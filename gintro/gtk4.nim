# dependencies:
# PangoCairo-1.0
# freetype2-2.0
# GLib-2.0
# GdkPixbuf-2.0
# HarfBuzz-0.0
# GModule-2.0
# cairo-1.0
# Graphene-1.0
# Gsk-4.0
# GObject-2.0
# Gdk-4.0
# Gio-2.0
# Pango-1.0
# immediate dependencies:
# Gsk-4.0
# Gdk-4.0
# libraries:
# libgtk-4.so.1
{.warning[UnusedImport]: off.}
import pangocairo, freetype2, glib, gdkpixbuf, harfbuzz, gmodule, cairo, graphene, gsk, gobject, gdk4, gio, pango
const Lib = "libgtk-4.so.1"
{.pragma: libprag, cdecl, dynlib: Lib.}

proc finalizeGObject*[T](o: ref T) =
  if not o.ignoreFinalizer:
    gobject.g_object_remove_toggle_ref(o.impl, gobject.toggleNotify, addr(o[]))

const ACCESSIBLE_ATTRIBUTE_BACKGROUND* = "bg-color"

const ACCESSIBLE_ATTRIBUTE_FAMILY* = "family-name"

const ACCESSIBLE_ATTRIBUTE_FOREGROUND* = "fg-color"

const ACCESSIBLE_ATTRIBUTE_OVERLINE* = "overline"

const ACCESSIBLE_ATTRIBUTE_OVERLINE_NONE* = "none"

const ACCESSIBLE_ATTRIBUTE_OVERLINE_SINGLE* = "single"

const ACCESSIBLE_ATTRIBUTE_SIZE* = "size"

const ACCESSIBLE_ATTRIBUTE_STRETCH* = "stretch"

const ACCESSIBLE_ATTRIBUTE_STRETCH_CONDENSED* = "condensed"

const ACCESSIBLE_ATTRIBUTE_STRETCH_EXPANDED* = "expanded"

const ACCESSIBLE_ATTRIBUTE_STRETCH_EXTRA_CONDENSED* = "extra_condensed"

const ACCESSIBLE_ATTRIBUTE_STRETCH_EXTRA_EXPANDED* = "extra_expanded"

const ACCESSIBLE_ATTRIBUTE_STRETCH_NORMAL* = "normal"

const ACCESSIBLE_ATTRIBUTE_STRETCH_SEMI_CONDENSED* = "semi_condensed"

const ACCESSIBLE_ATTRIBUTE_STRETCH_SEMI_EXPANDED* = "semi_expanded"

const ACCESSIBLE_ATTRIBUTE_STRETCH_ULTRA_CONDENSED* = "ultra_condensed"

const ACCESSIBLE_ATTRIBUTE_STRETCH_ULTRA_EXPANDED* = "ultra_expanded"

const ACCESSIBLE_ATTRIBUTE_STRIKETHROUGH* = "strikethrough"

const ACCESSIBLE_ATTRIBUTE_STYLE* = "style"

const ACCESSIBLE_ATTRIBUTE_STYLE_ITALIC* = "italic"

const ACCESSIBLE_ATTRIBUTE_STYLE_NORMAL* = "normal"

const ACCESSIBLE_ATTRIBUTE_STYLE_OBLIQUE* = "oblique"

const ACCESSIBLE_ATTRIBUTE_UNDERLINE* = "underline"

const ACCESSIBLE_ATTRIBUTE_UNDERLINE_DOUBLE* = "double"

const ACCESSIBLE_ATTRIBUTE_UNDERLINE_ERROR* = "error"

const ACCESSIBLE_ATTRIBUTE_UNDERLINE_NONE* = "none"

const ACCESSIBLE_ATTRIBUTE_UNDERLINE_SINGLE* = "single"

const ACCESSIBLE_ATTRIBUTE_VARIANT* = "variant"

const ACCESSIBLE_ATTRIBUTE_VARIANT_ALL_PETITE_CAPS* = "all-petite-caps"

const ACCESSIBLE_ATTRIBUTE_VARIANT_ALL_SMALL_CAPS* = "all-small-caps"

const ACCESSIBLE_ATTRIBUTE_VARIANT_PETITE_CAPS* = "petite-caps"

const ACCESSIBLE_ATTRIBUTE_VARIANT_SMALL_CAPS* = "small-caps"

const ACCESSIBLE_ATTRIBUTE_VARIANT_TITLE_CAPS* = "title-caps"

const ACCESSIBLE_ATTRIBUTE_VARIANT_UNICASE* = "unicase"

const ACCESSIBLE_ATTRIBUTE_WEIGHT* = "weight"

const ACCESSIBLE_VALUE_UNDEFINED* = -1'i32

type
  ATContext* = ref object of gobject.Object
  ATContext00* = object of gobject.Object00

proc gtk_at_context_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ATContext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scStateChange*(self: ATContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "state-change", cast[GCallback](p), xdata, nil, cf)

type
  Accessible00* = object of gobject.Object00
  Accessible* = ref object of gobject.Object

proc gtk_at_context_get_accessible(self: ptr ATContext00): ptr Accessible00 {.
    importc, libprag.}

proc getAccessible*(self: ATContext): Accessible =
  let gobj = gtk_at_context_get_accessible(cast[ptr ATContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accessible*(self: ATContext): Accessible =
  let gobj = gtk_at_context_get_accessible(cast[ptr ATContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  AccessibleAnnouncementPriority* {.size: sizeof(cint), pure.} = enum
    low = 0
    medium = 1
    high = 2

type
  AccessiblePlatformState* {.size: sizeof(cint), pure.} = enum
    focusable = 0
    focused = 1
    active = 2

type
  TextDirection* {.size: sizeof(cint), pure.} = enum
    none = 0
    ltr = 1
    rtl = 2

type
  DirectionType* {.size: sizeof(cint), pure.} = enum
    tabForward = 0
    tabBackward = 1
    up = 2
    down = 3
    left = 4
    right = 5

type
  Tooltip* = ref object of gobject.Object
  Tooltip00* = object of gobject.Object00

proc gtk_tooltip_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Tooltip()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tooltip_set_icon(self: ptr Tooltip00; paintable: ptr gdk4.Paintable00) {.
    importc, libprag.}

proc setIcon*(self: Tooltip; paintable: gdk4.Paintable = nil) =
  gtk_tooltip_set_icon(cast[ptr Tooltip00](self.impl), if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))

proc `icon=`*(self: Tooltip; paintable: gdk4.Paintable = nil) =
  gtk_tooltip_set_icon(cast[ptr Tooltip00](self.impl), if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))

proc gtk_tooltip_set_icon_from_gicon(self: ptr Tooltip00; gicon: ptr gio.Icon00) {.
    importc, libprag.}

proc setIconFromGicon*(self: Tooltip; gicon: gio.Icon = nil) =
  gtk_tooltip_set_icon_from_gicon(cast[ptr Tooltip00](self.impl), if gicon.isNil: nil else: cast[ptr gio.Icon00](gicon.impl))

proc `iconFromGicon=`*(self: Tooltip; gicon: gio.Icon = nil) =
  gtk_tooltip_set_icon_from_gicon(cast[ptr Tooltip00](self.impl), if gicon.isNil: nil else: cast[ptr gio.Icon00](gicon.impl))

proc gtk_tooltip_set_icon_from_icon_name(self: ptr Tooltip00; iconName: cstring) {.
    importc, libprag.}

proc setIconFromIconName*(self: Tooltip; iconName: cstring = nil) =
  gtk_tooltip_set_icon_from_icon_name(cast[ptr Tooltip00](self.impl), iconName)

proc `iconFromIconName=`*(self: Tooltip; iconName: cstring = nil) =
  gtk_tooltip_set_icon_from_icon_name(cast[ptr Tooltip00](self.impl), iconName)

proc gtk_tooltip_set_markup(self: ptr Tooltip00; markup: cstring) {.
    importc, libprag.}

proc setMarkup*(self: Tooltip; markup: cstring = nil) =
  gtk_tooltip_set_markup(cast[ptr Tooltip00](self.impl), markup)

proc `markup=`*(self: Tooltip; markup: cstring = nil) =
  gtk_tooltip_set_markup(cast[ptr Tooltip00](self.impl), markup)

proc gtk_tooltip_set_text(self: ptr Tooltip00; text: cstring) {.
    importc, libprag.}

proc setText*(self: Tooltip; text: cstring = nil) =
  gtk_tooltip_set_text(cast[ptr Tooltip00](self.impl), text)

proc `text=`*(self: Tooltip; text: cstring = nil) =
  gtk_tooltip_set_text(cast[ptr Tooltip00](self.impl), text)

proc gtk_tooltip_set_tip_area(self: ptr Tooltip00; rect: gdk4.Rectangle) {.
    importc, libprag.}

proc setTipArea*(self: Tooltip; rect: gdk4.Rectangle) =
  gtk_tooltip_set_tip_area(cast[ptr Tooltip00](self.impl), rect)

proc `tipArea=`*(self: Tooltip; rect: gdk4.Rectangle) =
  gtk_tooltip_set_tip_area(cast[ptr Tooltip00](self.impl), rect)

type
  StateFlag* {.size: sizeof(cint), pure.} = enum
    active = 0
    prelight = 1
    selected = 2
    insensitive = 3
    inconsistent = 4
    focused = 5
    backdrop = 6
    dirLtr = 7
    dirRtl = 8
    link = 9
    visited = 10
    checked = 11
    dropActive = 12
    focusVisible = 13
    focusWithin = 14

  StateFlags* = set[StateFlag]

const
  StateFlagsNormal* = StateFlags({})
proc normal*(t: typedesc[StateFlags]): StateFlags = StateFlags({})

type
  Widget* = ref object of gobject.InitiallyUnowned
  Widget00* = object of gobject.InitiallyUnowned00

proc gtk_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Widget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDestroy*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "destroy", cast[GCallback](p), xdata, nil, cf)

proc scDirectionChanged*(self: Widget;  p: proc (self: ptr Widget00; previousDirection: TextDirection; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "direction-changed", cast[GCallback](p), xdata, nil, cf)

proc scHide*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "hide", cast[GCallback](p), xdata, nil, cf)

proc scKeynavFailed*(self: Widget;  p: proc (self: ptr Widget00; direction: DirectionType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "keynav-failed", cast[GCallback](p), xdata, nil, cf)

proc scMap*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "map", cast[GCallback](p), xdata, nil, cf)

proc scMnemonicActivate*(self: Widget;  p: proc (self: ptr Widget00; groupCycling: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "mnemonic-activate", cast[GCallback](p), xdata, nil, cf)

proc scMoveFocus*(self: Widget;  p: proc (self: ptr Widget00; direction: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-focus", cast[GCallback](p), xdata, nil, cf)

proc scQueryTooltip*(self: Widget;  p: proc (self: ptr Widget00; x: int32; y: int32; keyboardMode: gboolean; tooltip: ptr Tooltip00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "query-tooltip", cast[GCallback](p), xdata, nil, cf)

proc scRealize*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "realize", cast[GCallback](p), xdata, nil, cf)

proc scShow*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show", cast[GCallback](p), xdata, nil, cf)

proc scStateFlagsChanged*(self: Widget;  p: proc (self: ptr Widget00; flags: StateFlags; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "state-flags-changed", cast[GCallback](p), xdata, nil, cf)

proc scUnmap*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unmap", cast[GCallback](p), xdata, nil, cf)

proc scUnrealize*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unrealize", cast[GCallback](p), xdata, nil, cf)

proc getDefaultDirection*(): TextDirection {.
    importc: "gtk_widget_get_default_direction", libprag.}

proc setDefaultDirection*(dir: TextDirection) {.
    importc: "gtk_widget_set_default_direction", libprag.}

proc gtk_widget_action_set_enabled(self: ptr Widget00; actionName: cstring;
    enabled: gboolean) {.
    importc, libprag.}

proc actionSetEnabled*(self: Widget; actionName: cstring; enabled: bool) =
  gtk_widget_action_set_enabled(cast[ptr Widget00](self.impl), actionName, gboolean(enabled))

proc gtk_widget_activate(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc activate*(self: Widget): bool =
  toBool(gtk_widget_activate(cast[ptr Widget00](self.impl)))

proc gtk_widget_activate_action_variant(self: ptr Widget00; name: cstring;
    args: ptr glib.Variant00): gboolean {.
    importc, libprag.}

proc activateAction*(self: Widget; name: cstring; args: glib.Variant = nil): bool =
  toBool(gtk_widget_activate_action_variant(cast[ptr Widget00](self.impl), name, if args.isNil: nil else: cast[ptr glib.Variant00](args.impl)))

proc gtk_widget_activate_default(self: ptr Widget00) {.
    importc, libprag.}

proc activateDefault*(self: Widget) =
  gtk_widget_activate_default(cast[ptr Widget00](self.impl))

proc gtk_widget_add_css_class(self: ptr Widget00; cssClass: cstring) {.
    importc, libprag.}

proc addCssClass*(self: Widget; cssClass: cstring) =
  gtk_widget_add_css_class(cast[ptr Widget00](self.impl), cssClass)

proc gtk_widget_add_mnemonic_label(self: ptr Widget00; label: ptr Widget00) {.
    importc, libprag.}

proc addMnemonicLabel*(self: Widget; label: Widget) =
  gtk_widget_add_mnemonic_label(cast[ptr Widget00](self.impl), cast[ptr Widget00](label.impl))

proc gtk_widget_allocate(self: ptr Widget00; width: int32; height: int32;
    baseline: int32; transform: ptr gsk.Transform00) {.
    importc, libprag.}

proc allocate*(self: Widget; width: int; height: int; baseline: int;
    transform: gsk.Transform = nil) =
  gtk_widget_allocate(cast[ptr Widget00](self.impl), int32(width), int32(height), int32(baseline), if transform.isNil: nil else: cast[ptr gsk.Transform00](g_boxed_copy(gsk_transform_get_type(), transform.impl)))

proc gtk_widget_child_focus(self: ptr Widget00; direction: DirectionType): gboolean {.
    importc, libprag.}

proc childFocus*(self: Widget; direction: DirectionType): bool =
  toBool(gtk_widget_child_focus(cast[ptr Widget00](self.impl), direction))

proc gtk_widget_compute_bounds(self: ptr Widget00; target: ptr Widget00;
    outBounds: var graphene.Rect): gboolean {.
    importc, libprag.}

proc computeBounds*(self: Widget; target: Widget; outBounds: var graphene.Rect): bool =
  toBool(gtk_widget_compute_bounds(cast[ptr Widget00](self.impl), cast[ptr Widget00](target.impl), outBounds))

proc gtk_widget_compute_point(self: ptr Widget00; target: ptr Widget00; point: graphene.Point;
    outPoint: var graphene.Point): gboolean {.
    importc, libprag.}

proc computePoint*(self: Widget; target: Widget; point: graphene.Point;
    outPoint: var graphene.Point): bool =
  toBool(gtk_widget_compute_point(cast[ptr Widget00](self.impl), cast[ptr Widget00](target.impl), point, outPoint))

proc gtk_widget_compute_transform(self: ptr Widget00; target: ptr Widget00;
    outTransform: var graphene.Matrix): gboolean {.
    importc, libprag.}

proc computeTransform*(self: Widget; target: Widget; outTransform: var graphene.Matrix): bool =
  toBool(gtk_widget_compute_transform(cast[ptr Widget00](self.impl), cast[ptr Widget00](target.impl), outTransform))

proc gtk_widget_contains(self: ptr Widget00; x: cdouble; y: cdouble): gboolean {.
    importc, libprag.}

proc contains*(self: Widget; x: cdouble; y: cdouble): bool =
  toBool(gtk_widget_contains(cast[ptr Widget00](self.impl), x, y))

proc gtk_widget_create_pango_context(self: ptr Widget00): ptr pango.Context00 {.
    importc, libprag.}

proc createPangoContext*(self: Widget): pango.Context =
  let gobj = gtk_widget_create_pango_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_create_pango_layout(self: ptr Widget00; text: cstring): ptr pango.Layout00 {.
    importc, libprag.}

proc createPangoLayout*(self: Widget; text: cstring = nil): pango.Layout =
  let gobj = gtk_widget_create_pango_layout(cast[ptr Widget00](self.impl), text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_dispose_template(self: ptr Widget00; widgetType: GType) {.
    importc, libprag.}

proc disposeTemplate*(self: Widget; widgetType: GType) =
  gtk_widget_dispose_template(cast[ptr Widget00](self.impl), widgetType)

proc gtk_drag_check_threshold(self: ptr Widget00; startX: int32; startY: int32;
    currentX: int32; currentY: int32): gboolean {.
    importc, libprag.}

proc dragCheckThreshold*(self: Widget; startX: int; startY: int; currentX: int;
    currentY: int): bool =
  toBool(gtk_drag_check_threshold(cast[ptr Widget00](self.impl), int32(startX), int32(startY), int32(currentX), int32(currentY)))

proc gtk_widget_error_bell(self: ptr Widget00) {.
    importc, libprag.}

proc errorBell*(self: Widget) =
  gtk_widget_error_bell(cast[ptr Widget00](self.impl))

proc gtk_widget_get_allocated_baseline(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getAllocatedBaseline*(self: Widget): int =
  int(gtk_widget_get_allocated_baseline(cast[ptr Widget00](self.impl)))

proc allocatedBaseline*(self: Widget): int =
  int(gtk_widget_get_allocated_baseline(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_allocated_height(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getAllocatedHeight*(self: Widget): int =
  int(gtk_widget_get_allocated_height(cast[ptr Widget00](self.impl)))

proc allocatedHeight*(self: Widget): int =
  int(gtk_widget_get_allocated_height(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_allocated_width(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getAllocatedWidth*(self: Widget): int =
  int(gtk_widget_get_allocated_width(cast[ptr Widget00](self.impl)))

proc allocatedWidth*(self: Widget): int =
  int(gtk_widget_get_allocated_width(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_allocation(self: ptr Widget00; allocation: var gdk4.Rectangle) {.
    importc, libprag.}

proc getAllocation*(self: Widget; allocation: var gdk4.Rectangle) =
  gtk_widget_get_allocation(cast[ptr Widget00](self.impl), allocation)

proc getAllocation*(self: Widget): gdk4.Rectangle =
  gtk_widget_get_allocation(cast[ptr Widget00](self.impl), result)

proc gtk_widget_get_ancestor(self: ptr Widget00; widgetType: GType): ptr Widget00 {.
    importc, libprag.}

proc getAncestor*(self: Widget; widgetType: GType): Widget =
  let gobj = gtk_widget_get_ancestor(cast[ptr Widget00](self.impl), widgetType)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_baseline(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getBaseline*(self: Widget): int =
  int(gtk_widget_get_baseline(cast[ptr Widget00](self.impl)))

proc baseline*(self: Widget): int =
  int(gtk_widget_get_baseline(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_can_focus(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getCanFocus*(self: Widget): bool =
  toBool(gtk_widget_get_can_focus(cast[ptr Widget00](self.impl)))

proc canFocus*(self: Widget): bool =
  toBool(gtk_widget_get_can_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_can_target(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getCanTarget*(self: Widget): bool =
  toBool(gtk_widget_get_can_target(cast[ptr Widget00](self.impl)))

proc canTarget*(self: Widget): bool =
  toBool(gtk_widget_get_can_target(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_child_visible(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getChildVisible*(self: Widget): bool =
  toBool(gtk_widget_get_child_visible(cast[ptr Widget00](self.impl)))

proc childVisible*(self: Widget): bool =
  toBool(gtk_widget_get_child_visible(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_clipboard(self: ptr Widget00): ptr gdk4.Clipboard00 {.
    importc, libprag.}

proc getClipboard*(self: Widget): gdk4.Clipboard =
  let gobj = gtk_widget_get_clipboard(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc clipboard*(self: Widget): gdk4.Clipboard =
  let gobj = gtk_widget_get_clipboard(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_color(self: ptr Widget00; color: var gdk4.RGBA) {.
    importc, libprag.}

proc getColor*(self: Widget; color: var gdk4.RGBA) =
  gtk_widget_get_color(cast[ptr Widget00](self.impl), color)

proc getColor*(self: Widget): gdk4.RGBA =
  gtk_widget_get_color(cast[ptr Widget00](self.impl), result)

proc gtk_widget_get_css_classes(self: ptr Widget00): ptr cstring {.
    importc, libprag.}

proc getCssClasses*(self: Widget): seq[string] =
  let resul0 = gtk_widget_get_css_classes(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc cssClasses*(self: Widget): seq[string] =
  let resul0 = gtk_widget_get_css_classes(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_widget_get_css_name(self: ptr Widget00): cstring {.
    importc, libprag.}

proc getCssName*(self: Widget): string =
  result = $gtk_widget_get_css_name(cast[ptr Widget00](self.impl))

proc cssName*(self: Widget): string =
  result = $gtk_widget_get_css_name(cast[ptr Widget00](self.impl))

proc gtk_widget_get_cursor(self: ptr Widget00): ptr gdk4.Cursor00 {.
    importc, libprag.}

proc getCursor*(self: Widget): gdk4.Cursor =
  let gobj = gtk_widget_get_cursor(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc cursor*(self: Widget): gdk4.Cursor =
  let gobj = gtk_widget_get_cursor(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_direction(self: ptr Widget00): TextDirection {.
    importc, libprag.}

proc getDirection*(self: Widget): TextDirection =
  gtk_widget_get_direction(cast[ptr Widget00](self.impl))

proc direction*(self: Widget): TextDirection =
  gtk_widget_get_direction(cast[ptr Widget00](self.impl))

proc gtk_widget_get_display(self: ptr Widget00): ptr gdk4.Display00 {.
    importc, libprag.}

proc getDisplay*(self: Widget): gdk4.Display =
  let gobj = gtk_widget_get_display(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: Widget): gdk4.Display =
  let gobj = gtk_widget_get_display(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_first_child(self: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getFirstChild*(self: Widget): Widget =
  let gobj = gtk_widget_get_first_child(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc firstChild*(self: Widget): Widget =
  let gobj = gtk_widget_get_first_child(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_focus_child(self: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getFocusChild*(self: Widget): Widget =
  let gobj = gtk_widget_get_focus_child(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusChild*(self: Widget): Widget =
  let gobj = gtk_widget_get_focus_child(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_focus_on_click(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getFocusOnClick*(self: Widget): bool =
  toBool(gtk_widget_get_focus_on_click(cast[ptr Widget00](self.impl)))

proc focusOnClick*(self: Widget): bool =
  toBool(gtk_widget_get_focus_on_click(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_focusable(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getFocusable*(self: Widget): bool =
  toBool(gtk_widget_get_focusable(cast[ptr Widget00](self.impl)))

proc focusable*(self: Widget): bool =
  toBool(gtk_widget_get_focusable(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_font_map(self: ptr Widget00): ptr pango.FontMap00 {.
    importc, libprag.}

proc getFontMap*(self: Widget): pango.FontMap =
  let gobj = gtk_widget_get_font_map(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontMap*(self: Widget): pango.FontMap =
  let gobj = gtk_widget_get_font_map(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_font_options(self: ptr Widget00): ptr cairo.FontOptions00 {.
    importc, libprag.}

proc getFontOptions*(self: Widget): cairo.FontOptions =
  let impl0 = gtk_widget_get_font_options(cast[ptr Widget00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeCairoFontOptions)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_font_options_get_type(), impl0))

proc fontOptions*(self: Widget): cairo.FontOptions =
  let impl0 = gtk_widget_get_font_options(cast[ptr Widget00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeCairoFontOptions)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_font_options_get_type(), impl0))

proc gtk_widget_get_frame_clock(self: ptr Widget00): ptr gdk4.FrameClock00 {.
    importc, libprag.}

proc getFrameClock*(self: Widget): gdk4.FrameClock =
  let gobj = gtk_widget_get_frame_clock(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc frameClock*(self: Widget): gdk4.FrameClock =
  let gobj = gtk_widget_get_frame_clock(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_has_tooltip(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getHasTooltip*(self: Widget): bool =
  toBool(gtk_widget_get_has_tooltip(cast[ptr Widget00](self.impl)))

proc hasTooltip*(self: Widget): bool =
  toBool(gtk_widget_get_has_tooltip(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_height(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getHeight*(self: Widget): int =
  int(gtk_widget_get_height(cast[ptr Widget00](self.impl)))

proc height*(self: Widget): int =
  int(gtk_widget_get_height(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_hexpand(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getHexpand*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand(cast[ptr Widget00](self.impl)))

proc hexpand*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_hexpand_set(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getHexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand_set(cast[ptr Widget00](self.impl)))

proc hexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand_set(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_last_child(self: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getLastChild*(self: Widget): Widget =
  let gobj = gtk_widget_get_last_child(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc lastChild*(self: Widget): Widget =
  let gobj = gtk_widget_get_last_child(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_mapped(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getMapped*(self: Widget): bool =
  toBool(gtk_widget_get_mapped(cast[ptr Widget00](self.impl)))

proc mapped*(self: Widget): bool =
  toBool(gtk_widget_get_mapped(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_bottom(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginBottom*(self: Widget): int =
  int(gtk_widget_get_margin_bottom(cast[ptr Widget00](self.impl)))

proc marginBottom*(self: Widget): int =
  int(gtk_widget_get_margin_bottom(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_end(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginEnd*(self: Widget): int =
  int(gtk_widget_get_margin_end(cast[ptr Widget00](self.impl)))

proc marginEnd*(self: Widget): int =
  int(gtk_widget_get_margin_end(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_start(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginStart*(self: Widget): int =
  int(gtk_widget_get_margin_start(cast[ptr Widget00](self.impl)))

proc marginStart*(self: Widget): int =
  int(gtk_widget_get_margin_start(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_top(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginTop*(self: Widget): int =
  int(gtk_widget_get_margin_top(cast[ptr Widget00](self.impl)))

proc marginTop*(self: Widget): int =
  int(gtk_widget_get_margin_top(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_name(self: ptr Widget00): cstring {.
    importc, libprag.}

proc getName*(self: Widget): string =
  result = $gtk_widget_get_name(cast[ptr Widget00](self.impl))

proc name*(self: Widget): string =
  result = $gtk_widget_get_name(cast[ptr Widget00](self.impl))

proc gtk_widget_get_next_sibling(self: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getNextSibling*(self: Widget): Widget =
  let gobj = gtk_widget_get_next_sibling(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc nextSibling*(self: Widget): Widget =
  let gobj = gtk_widget_get_next_sibling(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_opacity(self: ptr Widget00): cdouble {.
    importc, libprag.}

proc getOpacity*(self: Widget): cdouble =
  gtk_widget_get_opacity(cast[ptr Widget00](self.impl))

proc opacity*(self: Widget): cdouble =
  gtk_widget_get_opacity(cast[ptr Widget00](self.impl))

proc gtk_widget_get_pango_context(self: ptr Widget00): ptr pango.Context00 {.
    importc, libprag.}

proc getPangoContext*(self: Widget): pango.Context =
  let gobj = gtk_widget_get_pango_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pangoContext*(self: Widget): pango.Context =
  let gobj = gtk_widget_get_pango_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_parent(self: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getParent*(self: Widget): Widget =
  let gobj = gtk_widget_get_parent(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parent*(self: Widget): Widget =
  let gobj = gtk_widget_get_parent(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_prev_sibling(self: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getPrevSibling*(self: Widget): Widget =
  let gobj = gtk_widget_get_prev_sibling(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc prevSibling*(self: Widget): Widget =
  let gobj = gtk_widget_get_prev_sibling(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_primary_clipboard(self: ptr Widget00): ptr gdk4.Clipboard00 {.
    importc, libprag.}

proc getPrimaryClipboard*(self: Widget): gdk4.Clipboard =
  let gobj = gtk_widget_get_primary_clipboard(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc primaryClipboard*(self: Widget): gdk4.Clipboard =
  let gobj = gtk_widget_get_primary_clipboard(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_realized(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getRealized*(self: Widget): bool =
  toBool(gtk_widget_get_realized(cast[ptr Widget00](self.impl)))

proc realized*(self: Widget): bool =
  toBool(gtk_widget_get_realized(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_receives_default(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getReceivesDefault*(self: Widget): bool =
  toBool(gtk_widget_get_receives_default(cast[ptr Widget00](self.impl)))

proc receivesDefault*(self: Widget): bool =
  toBool(gtk_widget_get_receives_default(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_scale_factor(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getScaleFactor*(self: Widget): int =
  int(gtk_widget_get_scale_factor(cast[ptr Widget00](self.impl)))

proc scaleFactor*(self: Widget): int =
  int(gtk_widget_get_scale_factor(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_sensitive(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getSensitive*(self: Widget): bool =
  toBool(gtk_widget_get_sensitive(cast[ptr Widget00](self.impl)))

proc sensitive*(self: Widget): bool =
  toBool(gtk_widget_get_sensitive(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_size_request(self: ptr Widget00; width: var int32; height: var int32) {.
    importc, libprag.}

proc getSizeRequest*(self: Widget; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var height_00: int32
  var width_00: int32
  gtk_widget_get_size_request(cast[ptr Widget00](self.impl), width_00, height_00)
  if height.addr != nil:
    height = int(height_00)
  if width.addr != nil:
    width = int(width_00)

proc gtk_widget_get_state_flags(self: ptr Widget00): StateFlags {.
    importc, libprag.}

proc getStateFlags*(self: Widget): StateFlags =
  gtk_widget_get_state_flags(cast[ptr Widget00](self.impl))

proc stateFlags*(self: Widget): StateFlags =
  gtk_widget_get_state_flags(cast[ptr Widget00](self.impl))

proc gtk_widget_get_template_child(self: ptr Widget00; widgetType: GType;
    name: cstring): ptr gobject.Object00 {.
    importc, libprag.}

proc getTemplateChild*(self: Widget; widgetType: GType; name: cstring): gobject.Object =
  let gobj = gtk_widget_get_template_child(cast[ptr Widget00](self.impl), widgetType, name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_tooltip_markup(self: ptr Widget00): cstring {.
    importc, libprag.}

proc getTooltipMarkup*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_markup(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc tooltipMarkup*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_markup(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_widget_get_tooltip_text(self: ptr Widget00): cstring {.
    importc, libprag.}

proc getTooltipText*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_text(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc tooltipText*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_text(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_widget_get_vexpand(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getVexpand*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand(cast[ptr Widget00](self.impl)))

proc vexpand*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_vexpand_set(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getVexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand_set(cast[ptr Widget00](self.impl)))

proc vexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand_set(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_visible(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getVisible*(self: Widget): bool =
  toBool(gtk_widget_get_visible(cast[ptr Widget00](self.impl)))

proc visible*(self: Widget): bool =
  toBool(gtk_widget_get_visible(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_width(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getWidth*(self: Widget): int =
  int(gtk_widget_get_width(cast[ptr Widget00](self.impl)))

proc width*(self: Widget): int =
  int(gtk_widget_get_width(cast[ptr Widget00](self.impl)))

proc gtk_widget_grab_focus(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc grabFocus*(self: Widget): bool =
  toBool(gtk_widget_grab_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_css_class(self: ptr Widget00; cssClass: cstring): gboolean {.
    importc, libprag.}

proc hasCssClass*(self: Widget; cssClass: cstring): bool =
  toBool(gtk_widget_has_css_class(cast[ptr Widget00](self.impl), cssClass))

proc gtk_widget_has_default(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hasDefault*(self: Widget): bool =
  toBool(gtk_widget_has_default(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_focus(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hasFocus*(self: Widget): bool =
  toBool(gtk_widget_has_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_visible_focus(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hasVisibleFocus*(self: Widget): bool =
  toBool(gtk_widget_has_visible_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_hide(self: ptr Widget00) {.
    importc, libprag.}

proc hide*(self: Widget) =
  gtk_widget_hide(cast[ptr Widget00](self.impl))

proc gtk_widget_in_destruction(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc inDestruction*(self: Widget): bool =
  toBool(gtk_widget_in_destruction(cast[ptr Widget00](self.impl)))

proc gtk_widget_init_template(self: ptr Widget00) {.
    importc, libprag.}

proc initTemplate*(self: Widget) =
  gtk_widget_init_template(cast[ptr Widget00](self.impl))

proc gtk_widget_insert_action_group(self: ptr Widget00; name: cstring; group: ptr gio.ActionGroup00) {.
    importc, libprag.}

proc insertActionGroup*(self: Widget; name: cstring; group: gio.ActionGroup | gio.SimpleActionGroup = gio.ActionGroup(nil)) =
  gtk_widget_insert_action_group(cast[ptr Widget00](self.impl), name, if group.isNil: nil else: cast[ptr gio.ActionGroup00](group.impl))

proc gtk_widget_insert_after(self: ptr Widget00; parent: ptr Widget00; previousSibling: ptr Widget00) {.
    importc, libprag.}

proc insertAfter*(self: Widget; parent: Widget; previousSibling: Widget = nil) =
  gtk_widget_insert_after(cast[ptr Widget00](self.impl), cast[ptr Widget00](parent.impl), if previousSibling.isNil: nil else: cast[ptr Widget00](previousSibling.impl))

proc gtk_widget_insert_before(self: ptr Widget00; parent: ptr Widget00; nextSibling: ptr Widget00) {.
    importc, libprag.}

proc insertBefore*(self: Widget; parent: Widget; nextSibling: Widget = nil) =
  gtk_widget_insert_before(cast[ptr Widget00](self.impl), cast[ptr Widget00](parent.impl), if nextSibling.isNil: nil else: cast[ptr Widget00](nextSibling.impl))

proc gtk_widget_is_ancestor(self: ptr Widget00; ancestor: ptr Widget00): gboolean {.
    importc, libprag.}

proc isAncestor*(self: Widget; ancestor: Widget): bool =
  toBool(gtk_widget_is_ancestor(cast[ptr Widget00](self.impl), cast[ptr Widget00](ancestor.impl)))

proc gtk_widget_is_drawable(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isDrawable*(self: Widget): bool =
  toBool(gtk_widget_is_drawable(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_focus(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isFocus*(self: Widget): bool =
  toBool(gtk_widget_is_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_sensitive(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isSensitive*(self: Widget): bool =
  toBool(gtk_widget_is_sensitive(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_visible(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isVisible*(self: Widget): bool =
  toBool(gtk_widget_is_visible(cast[ptr Widget00](self.impl)))

proc gtk_widget_keynav_failed(self: ptr Widget00; direction: DirectionType): gboolean {.
    importc, libprag.}

proc keynavFailed*(self: Widget; direction: DirectionType): bool =
  toBool(gtk_widget_keynav_failed(cast[ptr Widget00](self.impl), direction))

proc gtk_widget_list_mnemonic_labels(self: ptr Widget00): ptr glib.List {.
    importc, libprag.}

proc listMnemonicLabels*(self: Widget): seq[Widget] =
  let resul0 = gtk_widget_list_mnemonic_labels(cast[ptr Widget00](self.impl))
  result = glistObjects2seq(Widget, resul0, false)
  g_list_free(resul0)

proc gtk_widget_map(self: ptr Widget00) {.
    importc, libprag.}

proc map*(self: Widget) =
  gtk_widget_map(cast[ptr Widget00](self.impl))

proc gtk_widget_mnemonic_activate(self: ptr Widget00; groupCycling: gboolean): gboolean {.
    importc, libprag.}

proc mnemonicActivate*(self: Widget; groupCycling: bool): bool =
  toBool(gtk_widget_mnemonic_activate(cast[ptr Widget00](self.impl), gboolean(groupCycling)))

proc gtk_widget_observe_children(self: ptr Widget00): ptr gio.ListModel00 {.
    importc, libprag.}

proc observeChildren*(self: Widget): gio.ListModel =
  let gobj = gtk_widget_observe_children(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_observe_controllers(self: ptr Widget00): ptr gio.ListModel00 {.
    importc, libprag.}

proc observeControllers*(self: Widget): gio.ListModel =
  let gobj = gtk_widget_observe_controllers(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_queue_allocate(self: ptr Widget00) {.
    importc, libprag.}

proc queueAllocate*(self: Widget) =
  gtk_widget_queue_allocate(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_draw(self: ptr Widget00) {.
    importc, libprag.}

proc queueDraw*(self: Widget) =
  gtk_widget_queue_draw(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_resize(self: ptr Widget00) {.
    importc, libprag.}

proc queueResize*(self: Widget) =
  gtk_widget_queue_resize(cast[ptr Widget00](self.impl))

proc gtk_widget_realize(self: ptr Widget00) {.
    importc, libprag.}

proc realize*(self: Widget) =
  gtk_widget_realize(cast[ptr Widget00](self.impl))

proc gtk_widget_remove_css_class(self: ptr Widget00; cssClass: cstring) {.
    importc, libprag.}

proc removeCssClass*(self: Widget; cssClass: cstring) =
  gtk_widget_remove_css_class(cast[ptr Widget00](self.impl), cssClass)

proc gtk_widget_remove_mnemonic_label(self: ptr Widget00; label: ptr Widget00) {.
    importc, libprag.}

proc removeMnemonicLabel*(self: Widget; label: Widget) =
  gtk_widget_remove_mnemonic_label(cast[ptr Widget00](self.impl), cast[ptr Widget00](label.impl))

proc gtk_widget_remove_tick_callback(self: ptr Widget00; id: uint32) {.
    importc, libprag.}

proc removeTickCallback*(self: Widget; id: int) =
  gtk_widget_remove_tick_callback(cast[ptr Widget00](self.impl), uint32(id))

proc gtk_widget_set_can_focus(self: ptr Widget00; canFocus: gboolean) {.
    importc, libprag.}

proc setCanFocus*(self: Widget; canFocus: bool = true) =
  gtk_widget_set_can_focus(cast[ptr Widget00](self.impl), gboolean(canFocus))

proc `canFocus=`*(self: Widget; canFocus: bool) =
  gtk_widget_set_can_focus(cast[ptr Widget00](self.impl), gboolean(canFocus))

proc gtk_widget_set_can_target(self: ptr Widget00; canTarget: gboolean) {.
    importc, libprag.}

proc setCanTarget*(self: Widget; canTarget: bool = true) =
  gtk_widget_set_can_target(cast[ptr Widget00](self.impl), gboolean(canTarget))

proc `canTarget=`*(self: Widget; canTarget: bool) =
  gtk_widget_set_can_target(cast[ptr Widget00](self.impl), gboolean(canTarget))

proc gtk_widget_set_child_visible(self: ptr Widget00; childVisible: gboolean) {.
    importc, libprag.}

proc setChildVisible*(self: Widget; childVisible: bool = true) =
  gtk_widget_set_child_visible(cast[ptr Widget00](self.impl), gboolean(childVisible))

proc `childVisible=`*(self: Widget; childVisible: bool) =
  gtk_widget_set_child_visible(cast[ptr Widget00](self.impl), gboolean(childVisible))

proc gtk_widget_set_css_classes(self: ptr Widget00; classes: ptr cstring) {.
    importc, libprag.}

proc setCssClasses*(self: Widget; classes: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_widget_set_css_classes(cast[ptr Widget00](self.impl), seq2CstringArray(classes, fs469n23))

proc `cssClasses=`*(self: Widget; classes: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_widget_set_css_classes(cast[ptr Widget00](self.impl), seq2CstringArray(classes, fs469n23))

proc gtk_widget_set_cursor(self: ptr Widget00; cursor: ptr gdk4.Cursor00) {.
    importc, libprag.}

proc setCursor*(self: Widget; cursor: gdk4.Cursor = nil) =
  gtk_widget_set_cursor(cast[ptr Widget00](self.impl), if cursor.isNil: nil else: cast[ptr gdk4.Cursor00](cursor.impl))

proc `cursor=`*(self: Widget; cursor: gdk4.Cursor = nil) =
  gtk_widget_set_cursor(cast[ptr Widget00](self.impl), if cursor.isNil: nil else: cast[ptr gdk4.Cursor00](cursor.impl))

proc gtk_widget_set_cursor_from_name(self: ptr Widget00; name: cstring) {.
    importc, libprag.}

proc setCursorFromName*(self: Widget; name: cstring = nil) =
  gtk_widget_set_cursor_from_name(cast[ptr Widget00](self.impl), name)

proc `cursorFromName=`*(self: Widget; name: cstring = nil) =
  gtk_widget_set_cursor_from_name(cast[ptr Widget00](self.impl), name)

proc gtk_widget_set_direction(self: ptr Widget00; dir: TextDirection) {.
    importc, libprag.}

proc setDirection*(self: Widget; dir: TextDirection) =
  gtk_widget_set_direction(cast[ptr Widget00](self.impl), dir)

proc `direction=`*(self: Widget; dir: TextDirection) =
  gtk_widget_set_direction(cast[ptr Widget00](self.impl), dir)

proc gtk_widget_set_focus_child(self: ptr Widget00; child: ptr Widget00) {.
    importc, libprag.}

proc setFocusChild*(self: Widget; child: Widget = nil) =
  gtk_widget_set_focus_child(cast[ptr Widget00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `focusChild=`*(self: Widget; child: Widget = nil) =
  gtk_widget_set_focus_child(cast[ptr Widget00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_widget_set_focus_on_click(self: ptr Widget00; focusOnClick: gboolean) {.
    importc, libprag.}

proc setFocusOnClick*(self: Widget; focusOnClick: bool = true) =
  gtk_widget_set_focus_on_click(cast[ptr Widget00](self.impl), gboolean(focusOnClick))

proc `focusOnClick=`*(self: Widget; focusOnClick: bool) =
  gtk_widget_set_focus_on_click(cast[ptr Widget00](self.impl), gboolean(focusOnClick))

proc gtk_widget_set_focusable(self: ptr Widget00; focusable: gboolean) {.
    importc, libprag.}

proc setFocusable*(self: Widget; focusable: bool = true) =
  gtk_widget_set_focusable(cast[ptr Widget00](self.impl), gboolean(focusable))

proc `focusable=`*(self: Widget; focusable: bool) =
  gtk_widget_set_focusable(cast[ptr Widget00](self.impl), gboolean(focusable))

proc gtk_widget_set_font_map(self: ptr Widget00; fontMap: ptr pango.FontMap00) {.
    importc, libprag.}

proc setFontMap*(self: Widget; fontMap: pango.FontMap = nil) =
  gtk_widget_set_font_map(cast[ptr Widget00](self.impl), if fontMap.isNil: nil else: cast[ptr pango.FontMap00](fontMap.impl))

proc `fontMap=`*(self: Widget; fontMap: pango.FontMap = nil) =
  gtk_widget_set_font_map(cast[ptr Widget00](self.impl), if fontMap.isNil: nil else: cast[ptr pango.FontMap00](fontMap.impl))

proc gtk_widget_set_font_options(self: ptr Widget00; options: ptr cairo.FontOptions00) {.
    importc, libprag.}

proc setFontOptions*(self: Widget; options: cairo.FontOptions = nil) =
  gtk_widget_set_font_options(cast[ptr Widget00](self.impl), if options.isNil: nil else: cast[ptr cairo.FontOptions00](options.impl))

proc `fontOptions=`*(self: Widget; options: cairo.FontOptions = nil) =
  gtk_widget_set_font_options(cast[ptr Widget00](self.impl), if options.isNil: nil else: cast[ptr cairo.FontOptions00](options.impl))

proc gtk_widget_set_has_tooltip(self: ptr Widget00; hasTooltip: gboolean) {.
    importc, libprag.}

proc setHasTooltip*(self: Widget; hasTooltip: bool = true) =
  gtk_widget_set_has_tooltip(cast[ptr Widget00](self.impl), gboolean(hasTooltip))

proc `hasTooltip=`*(self: Widget; hasTooltip: bool) =
  gtk_widget_set_has_tooltip(cast[ptr Widget00](self.impl), gboolean(hasTooltip))

proc gtk_widget_set_hexpand(self: ptr Widget00; expand: gboolean) {.
    importc, libprag.}

proc setHexpand*(self: Widget; expand: bool = true) =
  gtk_widget_set_hexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc `hexpand=`*(self: Widget; expand: bool) =
  gtk_widget_set_hexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc gtk_widget_set_hexpand_set(self: ptr Widget00; set: gboolean) {.
    importc, libprag.}

proc setHexpandSet*(self: Widget; set: bool = true) =
  gtk_widget_set_hexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc `hexpandSet=`*(self: Widget; set: bool) =
  gtk_widget_set_hexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc gtk_widget_set_margin_bottom(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginBottom*(self: Widget; margin: int) =
  gtk_widget_set_margin_bottom(cast[ptr Widget00](self.impl), int32(margin))

proc `marginBottom=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_bottom(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_end(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginEnd*(self: Widget; margin: int) =
  gtk_widget_set_margin_end(cast[ptr Widget00](self.impl), int32(margin))

proc `marginEnd=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_end(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_start(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginStart*(self: Widget; margin: int) =
  gtk_widget_set_margin_start(cast[ptr Widget00](self.impl), int32(margin))

proc `marginStart=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_start(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_top(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginTop*(self: Widget; margin: int) =
  gtk_widget_set_margin_top(cast[ptr Widget00](self.impl), int32(margin))

proc `marginTop=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_top(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_name(self: ptr Widget00; name: cstring) {.
    importc, libprag.}

proc setName*(self: Widget; name: cstring) =
  gtk_widget_set_name(cast[ptr Widget00](self.impl), name)

proc `name=`*(self: Widget; name: cstring) =
  gtk_widget_set_name(cast[ptr Widget00](self.impl), name)

proc gtk_widget_set_opacity(self: ptr Widget00; opacity: cdouble) {.
    importc, libprag.}

proc setOpacity*(self: Widget; opacity: cdouble) =
  gtk_widget_set_opacity(cast[ptr Widget00](self.impl), opacity)

proc `opacity=`*(self: Widget; opacity: cdouble) =
  gtk_widget_set_opacity(cast[ptr Widget00](self.impl), opacity)

proc gtk_widget_set_parent(self: ptr Widget00; parent: ptr Widget00) {.
    importc, libprag.}

proc setParent*(self: Widget; parent: Widget) =
  gtk_widget_set_parent(cast[ptr Widget00](self.impl), cast[ptr Widget00](parent.impl))

proc `parent=`*(self: Widget; parent: Widget) =
  gtk_widget_set_parent(cast[ptr Widget00](self.impl), cast[ptr Widget00](parent.impl))

proc gtk_widget_set_receives_default(self: ptr Widget00; receivesDefault: gboolean) {.
    importc, libprag.}

proc setReceivesDefault*(self: Widget; receivesDefault: bool = true) =
  gtk_widget_set_receives_default(cast[ptr Widget00](self.impl), gboolean(receivesDefault))

proc `receivesDefault=`*(self: Widget; receivesDefault: bool) =
  gtk_widget_set_receives_default(cast[ptr Widget00](self.impl), gboolean(receivesDefault))

proc gtk_widget_set_sensitive(self: ptr Widget00; sensitive: gboolean) {.
    importc, libprag.}

proc setSensitive*(self: Widget; sensitive: bool = true) =
  gtk_widget_set_sensitive(cast[ptr Widget00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: Widget; sensitive: bool) =
  gtk_widget_set_sensitive(cast[ptr Widget00](self.impl), gboolean(sensitive))

proc gtk_widget_set_size_request(self: ptr Widget00; width: int32; height: int32) {.
    importc, libprag.}

proc setSizeRequest*(self: Widget; width: int; height: int) =
  gtk_widget_set_size_request(cast[ptr Widget00](self.impl), int32(width), int32(height))

proc gtk_widget_set_state_flags(self: ptr Widget00; flags: StateFlags; clear: gboolean) {.
    importc, libprag.}

proc setStateFlags*(self: Widget; flags: StateFlags; clear: bool) =
  gtk_widget_set_state_flags(cast[ptr Widget00](self.impl), flags, gboolean(clear))

proc gtk_widget_set_tooltip_markup(self: ptr Widget00; markup: cstring) {.
    importc, libprag.}

proc setTooltipMarkup*(self: Widget; markup: cstring = nil) =
  gtk_widget_set_tooltip_markup(cast[ptr Widget00](self.impl), markup)

proc `tooltipMarkup=`*(self: Widget; markup: cstring = nil) =
  gtk_widget_set_tooltip_markup(cast[ptr Widget00](self.impl), markup)

proc gtk_widget_set_tooltip_text(self: ptr Widget00; text: cstring) {.
    importc, libprag.}

proc setTooltipText*(self: Widget; text: cstring = nil) =
  gtk_widget_set_tooltip_text(cast[ptr Widget00](self.impl), text)

proc `tooltipText=`*(self: Widget; text: cstring = nil) =
  gtk_widget_set_tooltip_text(cast[ptr Widget00](self.impl), text)

proc gtk_widget_set_vexpand(self: ptr Widget00; expand: gboolean) {.
    importc, libprag.}

proc setVexpand*(self: Widget; expand: bool = true) =
  gtk_widget_set_vexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc `vexpand=`*(self: Widget; expand: bool) =
  gtk_widget_set_vexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc gtk_widget_set_vexpand_set(self: ptr Widget00; set: gboolean) {.
    importc, libprag.}

proc setVexpandSet*(self: Widget; set: bool = true) =
  gtk_widget_set_vexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc `vexpandSet=`*(self: Widget; set: bool) =
  gtk_widget_set_vexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc gtk_widget_set_visible(self: ptr Widget00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: Widget; visible: bool = true) =
  gtk_widget_set_visible(cast[ptr Widget00](self.impl), gboolean(visible))

proc `visible=`*(self: Widget; visible: bool) =
  gtk_widget_set_visible(cast[ptr Widget00](self.impl), gboolean(visible))

proc gtk_widget_should_layout(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc shouldLayout*(self: Widget): bool =
  toBool(gtk_widget_should_layout(cast[ptr Widget00](self.impl)))

proc gtk_widget_show(self: ptr Widget00) {.
    importc, libprag.}

proc show*(self: Widget) =
  gtk_widget_show(cast[ptr Widget00](self.impl))

proc gtk_widget_size_allocate(self: ptr Widget00; allocation: gdk4.Rectangle;
    baseline: int32) {.
    importc, libprag.}

proc sizeAllocate*(self: Widget; allocation: gdk4.Rectangle; baseline: int) =
  gtk_widget_size_allocate(cast[ptr Widget00](self.impl), allocation, int32(baseline))

proc gtk_widget_translate_coordinates(self: ptr Widget00; destWidget: ptr Widget00;
    srcX: cdouble; srcY: cdouble; destX: var cdouble; destY: var cdouble): gboolean {.
    importc, libprag.}

proc translateCoordinates*(self: Widget; destWidget: Widget; srcX: cdouble;
    srcY: cdouble; destX: var cdouble = cast[var cdouble](nil); destY: var cdouble = cast[var cdouble](nil)): bool =
  toBool(gtk_widget_translate_coordinates(cast[ptr Widget00](self.impl), cast[ptr Widget00](destWidget.impl), srcX, srcY, destX, destY))

proc gtk_widget_trigger_tooltip_query(self: ptr Widget00) {.
    importc, libprag.}

proc triggerTooltipQuery*(self: Widget) =
  gtk_widget_trigger_tooltip_query(cast[ptr Widget00](self.impl))

proc gtk_widget_unmap(self: ptr Widget00) {.
    importc, libprag.}

proc unmap*(self: Widget) =
  gtk_widget_unmap(cast[ptr Widget00](self.impl))

proc gtk_widget_unparent(self: ptr Widget00) {.
    importc, libprag.}

proc unparent*(self: Widget) =
  gtk_widget_unparent(cast[ptr Widget00](self.impl))

proc gtk_widget_unrealize(self: ptr Widget00) {.
    importc, libprag.}

proc unrealize*(self: Widget) =
  gtk_widget_unrealize(cast[ptr Widget00](self.impl))

proc gtk_widget_unset_state_flags(self: ptr Widget00; flags: StateFlags) {.
    importc, libprag.}

proc unsetStateFlags*(self: Widget; flags: StateFlags) =
  gtk_widget_unset_state_flags(cast[ptr Widget00](self.impl), flags)

proc gtk_tooltip_set_custom(self: ptr Tooltip00; customWidget: ptr Widget00) {.
    importc, libprag.}

proc setCustom*(self: Tooltip; customWidget: Widget = nil) =
  gtk_tooltip_set_custom(cast[ptr Tooltip00](self.impl), if customWidget.isNil: nil else: cast[ptr Widget00](customWidget.impl))

proc `custom=`*(self: Tooltip; customWidget: Widget = nil) =
  gtk_tooltip_set_custom(cast[ptr Tooltip00](self.impl), if customWidget.isNil: nil else: cast[ptr Widget00](customWidget.impl))

type
  FlowBoxChild* = ref object of Widget
  FlowBoxChild00* = object of Widget00

proc gtk_flow_box_child_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FlowBoxChild()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: FlowBoxChild;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_flow_box_child_new(): ptr FlowBoxChild00 {.
    importc, libprag.}

proc newFlowBoxChild*(): FlowBoxChild =
  let gobj = gtk_flow_box_child_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFlowBoxChild*(tdesc: typedesc): tdesc =
  assert(result is FlowBoxChild)
  let gobj = gtk_flow_box_child_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFlowBoxChild*[T](result: var T) {.deprecated.} =
  assert(result is FlowBoxChild)
  let gobj = gtk_flow_box_child_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_child_changed(self: ptr FlowBoxChild00) {.
    importc, libprag.}

proc changed*(self: FlowBoxChild) =
  gtk_flow_box_child_changed(cast[ptr FlowBoxChild00](self.impl))

proc gtk_flow_box_child_get_child(self: ptr FlowBoxChild00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: FlowBoxChild): Widget =
  let gobj = gtk_flow_box_child_get_child(cast[ptr FlowBoxChild00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: FlowBoxChild): Widget =
  let gobj = gtk_flow_box_child_get_child(cast[ptr FlowBoxChild00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_child_get_index(self: ptr FlowBoxChild00): int32 {.
    importc, libprag.}

proc getIndex*(self: FlowBoxChild): int =
  int(gtk_flow_box_child_get_index(cast[ptr FlowBoxChild00](self.impl)))

proc index*(self: FlowBoxChild): int =
  int(gtk_flow_box_child_get_index(cast[ptr FlowBoxChild00](self.impl)))

proc gtk_flow_box_child_is_selected(self: ptr FlowBoxChild00): gboolean {.
    importc, libprag.}

proc isSelected*(self: FlowBoxChild): bool =
  toBool(gtk_flow_box_child_is_selected(cast[ptr FlowBoxChild00](self.impl)))

proc gtk_flow_box_child_set_child(self: ptr FlowBoxChild00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: FlowBoxChild; child: Widget = nil) =
  gtk_flow_box_child_set_child(cast[ptr FlowBoxChild00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: FlowBoxChild; child: Widget = nil) =
  gtk_flow_box_child_set_child(cast[ptr FlowBoxChild00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

type
  MovementStep* {.size: sizeof(cint), pure.} = enum
    logicalPositions = 0
    visualPositions = 1
    words = 2
    displayLines = 3
    displayLineEnds = 4
    paragraphs = 5
    paragraphEnds = 6
    pages = 7
    bufferEnds = 8
    horizontalPages = 9

type
  FlowBox* = ref object of Widget
  FlowBox00* = object of Widget00

proc gtk_flow_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FlowBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateCursorChild*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-cursor-child", cast[GCallback](p), xdata, nil, cf)

proc scChildActivated*(self: FlowBox;  p: proc (self: ptr FlowBox00; child: ptr FlowBoxChild00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "child-activated", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: FlowBox;  p: proc (self: ptr FlowBox00; step: MovementStep; count: int32; extend: gboolean; modify: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSelectedChildrenChanged*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selected-children-changed", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorChild*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-child", cast[GCallback](p), xdata, nil, cf)

proc scUnselectAll*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cf)

proc gtk_flow_box_new(): ptr FlowBox00 {.
    importc, libprag.}

proc newFlowBox*(): FlowBox =
  let gobj = gtk_flow_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFlowBox*(tdesc: typedesc): tdesc =
  assert(result is FlowBox)
  let gobj = gtk_flow_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFlowBox*[T](result: var T) {.deprecated.} =
  assert(result is FlowBox)
  let gobj = gtk_flow_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_append(self: ptr FlowBox00; child: ptr Widget00) {.
    importc, libprag.}

proc append*(self: FlowBox; child: Widget) =
  gtk_flow_box_append(cast[ptr FlowBox00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_flow_box_get_activate_on_single_click(self: ptr FlowBox00): gboolean {.
    importc, libprag.}

proc getActivateOnSingleClick*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_activate_on_single_click(cast[ptr FlowBox00](self.impl)))

proc activateOnSingleClick*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_activate_on_single_click(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_child_at_index(self: ptr FlowBox00; idx: int32): ptr FlowBoxChild00 {.
    importc, libprag.}

proc getChildAtIndex*(self: FlowBox; idx: int): FlowBoxChild =
  let gobj = gtk_flow_box_get_child_at_index(cast[ptr FlowBox00](self.impl), int32(idx))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_get_child_at_pos(self: ptr FlowBox00; x: int32; y: int32): ptr FlowBoxChild00 {.
    importc, libprag.}

proc getChildAtPos*(self: FlowBox; x: int; y: int): FlowBoxChild =
  let gobj = gtk_flow_box_get_child_at_pos(cast[ptr FlowBox00](self.impl), int32(x), int32(y))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_get_column_spacing(self: ptr FlowBox00): uint32 {.
    importc, libprag.}

proc getColumnSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_column_spacing(cast[ptr FlowBox00](self.impl)))

proc columnSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_column_spacing(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_homogeneous(self: ptr FlowBox00): gboolean {.
    importc, libprag.}

proc getHomogeneous*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_homogeneous(cast[ptr FlowBox00](self.impl)))

proc homogeneous*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_homogeneous(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_max_children_per_line(self: ptr FlowBox00): uint32 {.
    importc, libprag.}

proc getMaxChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_max_children_per_line(cast[ptr FlowBox00](self.impl)))

proc maxChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_max_children_per_line(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_min_children_per_line(self: ptr FlowBox00): uint32 {.
    importc, libprag.}

proc getMinChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_min_children_per_line(cast[ptr FlowBox00](self.impl)))

proc minChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_min_children_per_line(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_row_spacing(self: ptr FlowBox00): uint32 {.
    importc, libprag.}

proc getRowSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_row_spacing(cast[ptr FlowBox00](self.impl)))

proc rowSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_row_spacing(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_selected_children(self: ptr FlowBox00): ptr glib.List {.
    importc, libprag.}

proc getSelectedChildren*(self: FlowBox): seq[FlowBoxChild] =
  let resul0 = gtk_flow_box_get_selected_children(cast[ptr FlowBox00](self.impl))
  result = glistObjects2seq(FlowBoxChild, resul0, false)
  g_list_free(resul0)

proc selectedChildren*(self: FlowBox): seq[FlowBoxChild] =
  let resul0 = gtk_flow_box_get_selected_children(cast[ptr FlowBox00](self.impl))
  result = glistObjects2seq(FlowBoxChild, resul0, false)
  g_list_free(resul0)

proc gtk_flow_box_insert(self: ptr FlowBox00; widget: ptr Widget00; position: int32) {.
    importc, libprag.}

proc insert*(self: FlowBox; widget: Widget; position: int) =
  gtk_flow_box_insert(cast[ptr FlowBox00](self.impl), cast[ptr Widget00](widget.impl), int32(position))

proc gtk_flow_box_invalidate_filter(self: ptr FlowBox00) {.
    importc, libprag.}

proc invalidateFilter*(self: FlowBox) =
  gtk_flow_box_invalidate_filter(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_invalidate_sort(self: ptr FlowBox00) {.
    importc, libprag.}

proc invalidateSort*(self: FlowBox) =
  gtk_flow_box_invalidate_sort(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_prepend(self: ptr FlowBox00; child: ptr Widget00) {.
    importc, libprag.}

proc prepend*(self: FlowBox; child: Widget) =
  gtk_flow_box_prepend(cast[ptr FlowBox00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_flow_box_remove(self: ptr FlowBox00; widget: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: FlowBox; widget: Widget) =
  gtk_flow_box_remove(cast[ptr FlowBox00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_flow_box_remove_all(self: ptr FlowBox00) {.
    importc, libprag.}

proc removeAll*(self: FlowBox) =
  gtk_flow_box_remove_all(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_select_all(self: ptr FlowBox00) {.
    importc, libprag.}

proc selectAll*(self: FlowBox) =
  gtk_flow_box_select_all(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_select_child(self: ptr FlowBox00; child: ptr FlowBoxChild00) {.
    importc, libprag.}

proc selectChild*(self: FlowBox; child: FlowBoxChild) =
  gtk_flow_box_select_child(cast[ptr FlowBox00](self.impl), cast[ptr FlowBoxChild00](child.impl))

proc gtk_flow_box_set_activate_on_single_click(self: ptr FlowBox00; single: gboolean) {.
    importc, libprag.}

proc setActivateOnSingleClick*(self: FlowBox; single: bool = true) =
  gtk_flow_box_set_activate_on_single_click(cast[ptr FlowBox00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: FlowBox; single: bool) =
  gtk_flow_box_set_activate_on_single_click(cast[ptr FlowBox00](self.impl), gboolean(single))

proc gtk_flow_box_set_column_spacing(self: ptr FlowBox00; spacing: uint32) {.
    importc, libprag.}

proc setColumnSpacing*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_column_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc `columnSpacing=`*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_column_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc gtk_flow_box_set_homogeneous(self: ptr FlowBox00; homogeneous: gboolean) {.
    importc, libprag.}

proc setHomogeneous*(self: FlowBox; homogeneous: bool = true) =
  gtk_flow_box_set_homogeneous(cast[ptr FlowBox00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: FlowBox; homogeneous: bool) =
  gtk_flow_box_set_homogeneous(cast[ptr FlowBox00](self.impl), gboolean(homogeneous))

proc gtk_flow_box_set_max_children_per_line(self: ptr FlowBox00; nChildren: uint32) {.
    importc, libprag.}

proc setMaxChildrenPerLine*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_max_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc `maxChildrenPerLine=`*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_max_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc gtk_flow_box_set_min_children_per_line(self: ptr FlowBox00; nChildren: uint32) {.
    importc, libprag.}

proc setMinChildrenPerLine*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_min_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc `minChildrenPerLine=`*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_min_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc gtk_flow_box_set_row_spacing(self: ptr FlowBox00; spacing: uint32) {.
    importc, libprag.}

proc setRowSpacing*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_row_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc `rowSpacing=`*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_row_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc gtk_flow_box_unselect_all(self: ptr FlowBox00) {.
    importc, libprag.}

proc unselectAll*(self: FlowBox) =
  gtk_flow_box_unselect_all(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_unselect_child(self: ptr FlowBox00; child: ptr FlowBoxChild00) {.
    importc, libprag.}

proc unselectChild*(self: FlowBox; child: FlowBoxChild) =
  gtk_flow_box_unselect_child(cast[ptr FlowBox00](self.impl), cast[ptr FlowBoxChild00](child.impl))

type
  Popover* = ref object of Widget
  Popover00* = object of Widget00

proc gtk_popover_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Popover()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateDefault*(self: Popover;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-default", cast[GCallback](p), xdata, nil, cf)

proc scClosed*(self: Popover;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "closed", cast[GCallback](p), xdata, nil, cf)

proc gtk_popover_new(): ptr Popover00 {.
    importc, libprag.}

proc newPopover*(): Popover =
  let gobj = gtk_popover_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPopover*(tdesc: typedesc): tdesc =
  assert(result is Popover)
  let gobj = gtk_popover_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopover*[T](result: var T) {.deprecated.} =
  assert(result is Popover)
  let gobj = gtk_popover_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_get_autohide(self: ptr Popover00): gboolean {.
    importc, libprag.}

proc getAutohide*(self: Popover): bool =
  toBool(gtk_popover_get_autohide(cast[ptr Popover00](self.impl)))

proc autohide*(self: Popover): bool =
  toBool(gtk_popover_get_autohide(cast[ptr Popover00](self.impl)))

proc gtk_popover_get_cascade_popdown(self: ptr Popover00): gboolean {.
    importc, libprag.}

proc getCascadePopdown*(self: Popover): bool =
  toBool(gtk_popover_get_cascade_popdown(cast[ptr Popover00](self.impl)))

proc cascadePopdown*(self: Popover): bool =
  toBool(gtk_popover_get_cascade_popdown(cast[ptr Popover00](self.impl)))

proc gtk_popover_get_child(self: ptr Popover00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: Popover): Widget =
  let gobj = gtk_popover_get_child(cast[ptr Popover00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Popover): Widget =
  let gobj = gtk_popover_get_child(cast[ptr Popover00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_get_has_arrow(self: ptr Popover00): gboolean {.
    importc, libprag.}

proc getHasArrow*(self: Popover): bool =
  toBool(gtk_popover_get_has_arrow(cast[ptr Popover00](self.impl)))

proc hasArrow*(self: Popover): bool =
  toBool(gtk_popover_get_has_arrow(cast[ptr Popover00](self.impl)))

proc gtk_popover_get_mnemonics_visible(self: ptr Popover00): gboolean {.
    importc, libprag.}

proc getMnemonicsVisible*(self: Popover): bool =
  toBool(gtk_popover_get_mnemonics_visible(cast[ptr Popover00](self.impl)))

proc mnemonicsVisible*(self: Popover): bool =
  toBool(gtk_popover_get_mnemonics_visible(cast[ptr Popover00](self.impl)))

proc gtk_popover_get_offset(self: ptr Popover00; xOffset: var int32; yOffset: var int32) {.
    importc, libprag.}

proc getOffset*(self: Popover; xOffset: var int = cast[var int](nil);
    yOffset: var int = cast[var int](nil)) =
  var yOffset_00: int32
  var xOffset_00: int32
  gtk_popover_get_offset(cast[ptr Popover00](self.impl), xOffset_00, yOffset_00)
  if yOffset.addr != nil:
    yOffset = int(yOffset_00)
  if xOffset.addr != nil:
    xOffset = int(xOffset_00)

proc gtk_popover_get_pointing_to(self: ptr Popover00; rect: var gdk4.Rectangle): gboolean {.
    importc, libprag.}

proc getPointingTo*(self: Popover; rect: var gdk4.Rectangle): bool =
  toBool(gtk_popover_get_pointing_to(cast[ptr Popover00](self.impl), rect))

proc gtk_popover_popdown(self: ptr Popover00) {.
    importc, libprag.}

proc popdown*(self: Popover) =
  gtk_popover_popdown(cast[ptr Popover00](self.impl))

proc gtk_popover_popup(self: ptr Popover00) {.
    importc, libprag.}

proc popup*(self: Popover) =
  gtk_popover_popup(cast[ptr Popover00](self.impl))

proc gtk_popover_present(self: ptr Popover00) {.
    importc, libprag.}

proc present*(self: Popover) =
  gtk_popover_present(cast[ptr Popover00](self.impl))

proc gtk_popover_set_autohide(self: ptr Popover00; autohide: gboolean) {.
    importc, libprag.}

proc setAutohide*(self: Popover; autohide: bool = true) =
  gtk_popover_set_autohide(cast[ptr Popover00](self.impl), gboolean(autohide))

proc `autohide=`*(self: Popover; autohide: bool) =
  gtk_popover_set_autohide(cast[ptr Popover00](self.impl), gboolean(autohide))

proc gtk_popover_set_cascade_popdown(self: ptr Popover00; cascadePopdown: gboolean) {.
    importc, libprag.}

proc setCascadePopdown*(self: Popover; cascadePopdown: bool = true) =
  gtk_popover_set_cascade_popdown(cast[ptr Popover00](self.impl), gboolean(cascadePopdown))

proc `cascadePopdown=`*(self: Popover; cascadePopdown: bool) =
  gtk_popover_set_cascade_popdown(cast[ptr Popover00](self.impl), gboolean(cascadePopdown))

proc gtk_popover_set_child(self: ptr Popover00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: Popover; child: Widget = nil) =
  gtk_popover_set_child(cast[ptr Popover00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: Popover; child: Widget = nil) =
  gtk_popover_set_child(cast[ptr Popover00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_popover_set_default_widget(self: ptr Popover00; widget: ptr Widget00) {.
    importc, libprag.}

proc setDefaultWidget*(self: Popover; widget: Widget = nil) =
  gtk_popover_set_default_widget(cast[ptr Popover00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `defaultWidget=`*(self: Popover; widget: Widget = nil) =
  gtk_popover_set_default_widget(cast[ptr Popover00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_popover_set_has_arrow(self: ptr Popover00; hasArrow: gboolean) {.
    importc, libprag.}

proc setHasArrow*(self: Popover; hasArrow: bool = true) =
  gtk_popover_set_has_arrow(cast[ptr Popover00](self.impl), gboolean(hasArrow))

proc `hasArrow=`*(self: Popover; hasArrow: bool) =
  gtk_popover_set_has_arrow(cast[ptr Popover00](self.impl), gboolean(hasArrow))

proc gtk_popover_set_mnemonics_visible(self: ptr Popover00; mnemonicsVisible: gboolean) {.
    importc, libprag.}

proc setMnemonicsVisible*(self: Popover; mnemonicsVisible: bool = true) =
  gtk_popover_set_mnemonics_visible(cast[ptr Popover00](self.impl), gboolean(mnemonicsVisible))

proc `mnemonicsVisible=`*(self: Popover; mnemonicsVisible: bool) =
  gtk_popover_set_mnemonics_visible(cast[ptr Popover00](self.impl), gboolean(mnemonicsVisible))

proc gtk_popover_set_offset(self: ptr Popover00; xOffset: int32; yOffset: int32) {.
    importc, libprag.}

proc setOffset*(self: Popover; xOffset: int; yOffset: int) =
  gtk_popover_set_offset(cast[ptr Popover00](self.impl), int32(xOffset), int32(yOffset))

proc gtk_popover_set_pointing_to(self: ptr Popover00; rect: gdk4.Rectangle) {.
    importc, libprag.}

proc setPointingTo*(self: Popover; rect: gdk4.Rectangle = cast[var gdk4.Rectangle](nil)) =
  gtk_popover_set_pointing_to(cast[ptr Popover00](self.impl), rect)

proc `pointingTo=`*(self: Popover; rect: gdk4.Rectangle = cast[var gdk4.Rectangle](nil)) =
  gtk_popover_set_pointing_to(cast[ptr Popover00](self.impl), rect)

type
  EmojiChooser* = ref object of Popover
  EmojiChooser00* = object of Popover00

proc gtk_emoji_chooser_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EmojiChooser()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEmojiPicked*(self: EmojiChooser;  p: proc (self: ptr EmojiChooser00; text: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "emoji-picked", cast[GCallback](p), xdata, nil, cf)

proc gtk_emoji_chooser_new(): ptr EmojiChooser00 {.
    importc, libprag.}

proc newEmojiChooser*(): EmojiChooser =
  let gobj = gtk_emoji_chooser_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEmojiChooser*(tdesc: typedesc): tdesc =
  assert(result is EmojiChooser)
  let gobj = gtk_emoji_chooser_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEmojiChooser*[T](result: var T) {.deprecated.} =
  assert(result is EmojiChooser)
  let gobj = gtk_emoji_chooser_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Window* = ref object of Widget
  Window00* = object of Widget00

proc gtk_window_get_type*(): GType {.importc, libprag.}

proc scActivateDefault*(self: Window;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-default", cast[GCallback](p), xdata, nil, cf)

proc scActivateFocus*(self: Window;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-focus", cast[GCallback](p), xdata, nil, cf)

proc scCloseRequest*(self: Window;  p: proc (self: ptr Window00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "close-request", cast[GCallback](p), xdata, nil, cf)

proc scEnableDebugging*(self: Window;  p: proc (self: ptr Window00; toggle: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "enable-debugging", cast[GCallback](p), xdata, nil, cf)

proc scKeysChanged*(self: Window;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "keys-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_window_new(): ptr Window00 {.
    importc, libprag.}

proc newWindow*(): Window =
  let gobj = gtk_window_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newWindow*(tdesc: typedesc): tdesc =
  assert(result is Window)
  let gobj = gtk_window_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initWindow*[T](result: var T) {.deprecated.} =
  assert(result is Window)
  let gobj = gtk_window_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_default_icon_name(): cstring {.
    importc, libprag.}

proc getDefaultIconName*(): string =
  let resul0 = gtk_window_get_default_icon_name()
  if resul0.isNil:
    return
  result = $resul0

proc gtk_window_get_toplevels(): ptr gio.ListModel00 {.
    importc, libprag.}

proc getToplevels*(): gio.ListModel =
  let gobj = gtk_window_get_toplevels()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_list_toplevels(): ptr glib.List {.
    importc, libprag.}

proc listToplevels*(): seq[Widget] =
  let resul0 = gtk_window_list_toplevels()
  result = glistObjects2seq(Widget, resul0, false)
  g_list_free(resul0)

proc gtk_window_set_auto_startup_notification(setting: gboolean) {.
    importc, libprag.}

proc setAutoStartupNotification*(setting: bool = true) =
  gtk_window_set_auto_startup_notification(gboolean(setting))

proc setDefaultIconName*(name: cstring) {.
    importc: "gtk_window_set_default_icon_name", libprag.}

proc gtk_window_set_interactive_debugging(enable: gboolean) {.
    importc, libprag.}

proc setInteractiveDebugging*(enable: bool = true) =
  gtk_window_set_interactive_debugging(gboolean(enable))

proc gtk_window_close(self: ptr Window00) {.
    importc, libprag.}

proc close*(self: Window) =
  gtk_window_close(cast[ptr Window00](self.impl))

proc gtk_window_destroy(self: ptr Window00) {.
    importc, libprag.}

proc destroy*(self: Window) =
  gtk_window_destroy(cast[ptr Window00](self.impl))

proc gtk_window_fullscreen(self: ptr Window00) {.
    importc, libprag.}

proc fullscreen*(self: Window) =
  gtk_window_fullscreen(cast[ptr Window00](self.impl))

proc gtk_window_fullscreen_on_monitor(self: ptr Window00; monitor: ptr gdk4.Monitor00) {.
    importc, libprag.}

proc fullscreenOnMonitor*(self: Window; monitor: gdk4.Monitor) =
  gtk_window_fullscreen_on_monitor(cast[ptr Window00](self.impl), cast[ptr gdk4.Monitor00](monitor.impl))

proc gtk_window_get_child(self: ptr Window00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: Window): Widget =
  let gobj = gtk_window_get_child(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Window): Widget =
  let gobj = gtk_window_get_child(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_decorated(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getDecorated*(self: Window): bool =
  toBool(gtk_window_get_decorated(cast[ptr Window00](self.impl)))

proc decorated*(self: Window): bool =
  toBool(gtk_window_get_decorated(cast[ptr Window00](self.impl)))

proc gtk_window_get_default_size(self: ptr Window00; width: var int32; height: var int32) {.
    importc, libprag.}

proc getDefaultSize*(self: Window; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var height_00: int32
  var width_00: int32
  gtk_window_get_default_size(cast[ptr Window00](self.impl), width_00, height_00)
  if height.addr != nil:
    height = int(height_00)
  if width.addr != nil:
    width = int(width_00)

proc gtk_window_get_default_widget(self: ptr Window00): ptr Widget00 {.
    importc, libprag.}

proc getDefaultWidget*(self: Window): Widget =
  let gobj = gtk_window_get_default_widget(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultWidget*(self: Window): Widget =
  let gobj = gtk_window_get_default_widget(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_deletable(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getDeletable*(self: Window): bool =
  toBool(gtk_window_get_deletable(cast[ptr Window00](self.impl)))

proc deletable*(self: Window): bool =
  toBool(gtk_window_get_deletable(cast[ptr Window00](self.impl)))

proc gtk_window_get_destroy_with_parent(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getDestroyWithParent*(self: Window): bool =
  toBool(gtk_window_get_destroy_with_parent(cast[ptr Window00](self.impl)))

proc destroyWithParent*(self: Window): bool =
  toBool(gtk_window_get_destroy_with_parent(cast[ptr Window00](self.impl)))

proc gtk_window_get_focus(self: ptr Window00): ptr Widget00 {.
    importc, libprag.}

proc getFocus*(self: Window): Widget =
  let gobj = gtk_window_get_focus(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focus*(self: Window): Widget =
  let gobj = gtk_window_get_focus(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_focus_visible(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getFocusVisible*(self: Window): bool =
  toBool(gtk_window_get_focus_visible(cast[ptr Window00](self.impl)))

proc focusVisible*(self: Window): bool =
  toBool(gtk_window_get_focus_visible(cast[ptr Window00](self.impl)))

proc gtk_window_get_handle_menubar_accel(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getHandleMenubarAccel*(self: Window): bool =
  toBool(gtk_window_get_handle_menubar_accel(cast[ptr Window00](self.impl)))

proc handleMenubarAccel*(self: Window): bool =
  toBool(gtk_window_get_handle_menubar_accel(cast[ptr Window00](self.impl)))

proc gtk_window_get_hide_on_close(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getHideOnClose*(self: Window): bool =
  toBool(gtk_window_get_hide_on_close(cast[ptr Window00](self.impl)))

proc hideOnClose*(self: Window): bool =
  toBool(gtk_window_get_hide_on_close(cast[ptr Window00](self.impl)))

proc gtk_window_get_icon_name(self: ptr Window00): cstring {.
    importc, libprag.}

proc getIconName*(self: Window): string =
  let resul0 = gtk_window_get_icon_name(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc iconName*(self: Window): string =
  let resul0 = gtk_window_get_icon_name(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_window_get_mnemonics_visible(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getMnemonicsVisible*(self: Window): bool =
  toBool(gtk_window_get_mnemonics_visible(cast[ptr Window00](self.impl)))

proc mnemonicsVisible*(self: Window): bool =
  toBool(gtk_window_get_mnemonics_visible(cast[ptr Window00](self.impl)))

proc gtk_window_get_modal(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getModal*(self: Window): bool =
  toBool(gtk_window_get_modal(cast[ptr Window00](self.impl)))

proc modal*(self: Window): bool =
  toBool(gtk_window_get_modal(cast[ptr Window00](self.impl)))

proc gtk_window_get_resizable(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getResizable*(self: Window): bool =
  toBool(gtk_window_get_resizable(cast[ptr Window00](self.impl)))

proc resizable*(self: Window): bool =
  toBool(gtk_window_get_resizable(cast[ptr Window00](self.impl)))

proc gtk_window_get_title(self: ptr Window00): cstring {.
    importc, libprag.}

proc getTitle*(self: Window): string =
  let resul0 = gtk_window_get_title(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc title*(self: Window): string =
  let resul0 = gtk_window_get_title(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_window_get_titlebar(self: ptr Window00): ptr Widget00 {.
    importc, libprag.}

proc getTitlebar*(self: Window): Widget =
  let gobj = gtk_window_get_titlebar(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc titlebar*(self: Window): Widget =
  let gobj = gtk_window_get_titlebar(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_transient_for(self: ptr Window00): ptr Window00 {.
    importc, libprag.}

proc getTransientFor*(self: Window): Window =
  let gobj = gtk_window_get_transient_for(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc transientFor*(self: Window): Window =
  let gobj = gtk_window_get_transient_for(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_has_group(self: ptr Window00): gboolean {.
    importc, libprag.}

proc hasGroup*(self: Window): bool =
  toBool(gtk_window_has_group(cast[ptr Window00](self.impl)))

proc gtk_window_is_active(self: ptr Window00): gboolean {.
    importc, libprag.}

proc isActive*(self: Window): bool =
  toBool(gtk_window_is_active(cast[ptr Window00](self.impl)))

proc gtk_window_is_fullscreen(self: ptr Window00): gboolean {.
    importc, libprag.}

proc isFullscreen*(self: Window): bool =
  toBool(gtk_window_is_fullscreen(cast[ptr Window00](self.impl)))

proc gtk_window_is_maximized(self: ptr Window00): gboolean {.
    importc, libprag.}

proc isMaximized*(self: Window): bool =
  toBool(gtk_window_is_maximized(cast[ptr Window00](self.impl)))

proc gtk_window_is_suspended(self: ptr Window00): gboolean {.
    importc, libprag.}

proc isSuspended*(self: Window): bool =
  toBool(gtk_window_is_suspended(cast[ptr Window00](self.impl)))

proc gtk_window_maximize(self: ptr Window00) {.
    importc, libprag.}

proc maximize*(self: Window) =
  gtk_window_maximize(cast[ptr Window00](self.impl))

proc gtk_window_minimize(self: ptr Window00) {.
    importc, libprag.}

proc minimize*(self: Window) =
  gtk_window_minimize(cast[ptr Window00](self.impl))

proc gtk_window_present(self: ptr Window00) {.
    importc, libprag.}

proc present*(self: Window) =
  gtk_window_present(cast[ptr Window00](self.impl))

proc gtk_window_present_with_time(self: ptr Window00; timestamp: uint32) {.
    importc, libprag.}

proc presentWithTime*(self: Window; timestamp: int) =
  gtk_window_present_with_time(cast[ptr Window00](self.impl), uint32(timestamp))

proc gtk_window_set_child(self: ptr Window00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: Window; child: Widget = nil) =
  gtk_window_set_child(cast[ptr Window00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: Window; child: Widget = nil) =
  gtk_window_set_child(cast[ptr Window00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_window_set_decorated(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setDecorated*(self: Window; setting: bool = true) =
  gtk_window_set_decorated(cast[ptr Window00](self.impl), gboolean(setting))

proc `decorated=`*(self: Window; setting: bool) =
  gtk_window_set_decorated(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_default_size(self: ptr Window00; width: int32; height: int32) {.
    importc, libprag.}

proc setDefaultSize*(self: Window; width: int; height: int) =
  gtk_window_set_default_size(cast[ptr Window00](self.impl), int32(width), int32(height))

proc `defaultSize=`*(self: Window; dim: tuple[width: int; height: int]) =
  gtk_window_set_default_size(cast[ptr Window00](self.impl), int32(dim[0]), int32(dim[1]))

proc gtk_window_set_default_widget(self: ptr Window00; defaultWidget: ptr Widget00) {.
    importc, libprag.}

proc setDefaultWidget*(self: Window; defaultWidget: Widget = nil) =
  gtk_window_set_default_widget(cast[ptr Window00](self.impl), if defaultWidget.isNil: nil else: cast[ptr Widget00](defaultWidget.impl))

proc `defaultWidget=`*(self: Window; defaultWidget: Widget = nil) =
  gtk_window_set_default_widget(cast[ptr Window00](self.impl), if defaultWidget.isNil: nil else: cast[ptr Widget00](defaultWidget.impl))

proc gtk_window_set_deletable(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setDeletable*(self: Window; setting: bool = true) =
  gtk_window_set_deletable(cast[ptr Window00](self.impl), gboolean(setting))

proc `deletable=`*(self: Window; setting: bool) =
  gtk_window_set_deletable(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_destroy_with_parent(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setDestroyWithParent*(self: Window; setting: bool = true) =
  gtk_window_set_destroy_with_parent(cast[ptr Window00](self.impl), gboolean(setting))

proc `destroyWithParent=`*(self: Window; setting: bool) =
  gtk_window_set_destroy_with_parent(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_display(self: ptr Window00; display: ptr gdk4.Display00) {.
    importc, libprag.}

proc setDisplay*(self: Window; display: gdk4.Display) =
  gtk_window_set_display(cast[ptr Window00](self.impl), cast[ptr gdk4.Display00](display.impl))

proc `display=`*(self: Window; display: gdk4.Display) =
  gtk_window_set_display(cast[ptr Window00](self.impl), cast[ptr gdk4.Display00](display.impl))

proc gtk_window_set_focus(self: ptr Window00; focus: ptr Widget00) {.
    importc, libprag.}

proc setFocus*(self: Window; focus: Widget = nil) =
  gtk_window_set_focus(cast[ptr Window00](self.impl), if focus.isNil: nil else: cast[ptr Widget00](focus.impl))

proc `focus=`*(self: Window; focus: Widget = nil) =
  gtk_window_set_focus(cast[ptr Window00](self.impl), if focus.isNil: nil else: cast[ptr Widget00](focus.impl))

proc gtk_window_set_focus_visible(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setFocusVisible*(self: Window; setting: bool = true) =
  gtk_window_set_focus_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc `focusVisible=`*(self: Window; setting: bool) =
  gtk_window_set_focus_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_handle_menubar_accel(self: ptr Window00; handleMenubarAccel: gboolean) {.
    importc, libprag.}

proc setHandleMenubarAccel*(self: Window; handleMenubarAccel: bool = true) =
  gtk_window_set_handle_menubar_accel(cast[ptr Window00](self.impl), gboolean(handleMenubarAccel))

proc `handleMenubarAccel=`*(self: Window; handleMenubarAccel: bool) =
  gtk_window_set_handle_menubar_accel(cast[ptr Window00](self.impl), gboolean(handleMenubarAccel))

proc gtk_window_set_hide_on_close(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setHideOnClose*(self: Window; setting: bool = true) =
  gtk_window_set_hide_on_close(cast[ptr Window00](self.impl), gboolean(setting))

proc `hideOnClose=`*(self: Window; setting: bool) =
  gtk_window_set_hide_on_close(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_icon_name(self: ptr Window00; name: cstring) {.
    importc, libprag.}

proc setIconName*(self: Window; name: cstring = nil) =
  gtk_window_set_icon_name(cast[ptr Window00](self.impl), name)

proc `iconName=`*(self: Window; name: cstring = nil) =
  gtk_window_set_icon_name(cast[ptr Window00](self.impl), name)

proc gtk_window_set_mnemonics_visible(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setMnemonicsVisible*(self: Window; setting: bool = true) =
  gtk_window_set_mnemonics_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc `mnemonicsVisible=`*(self: Window; setting: bool) =
  gtk_window_set_mnemonics_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_modal(self: ptr Window00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: Window; modal: bool = true) =
  gtk_window_set_modal(cast[ptr Window00](self.impl), gboolean(modal))

proc `modal=`*(self: Window; modal: bool) =
  gtk_window_set_modal(cast[ptr Window00](self.impl), gboolean(modal))

proc gtk_window_set_resizable(self: ptr Window00; resizable: gboolean) {.
    importc, libprag.}

proc setResizable*(self: Window; resizable: bool = true) =
  gtk_window_set_resizable(cast[ptr Window00](self.impl), gboolean(resizable))

proc `resizable=`*(self: Window; resizable: bool) =
  gtk_window_set_resizable(cast[ptr Window00](self.impl), gboolean(resizable))

proc gtk_window_set_startup_id(self: ptr Window00; startupId: cstring) {.
    importc, libprag.}

proc setStartupId*(self: Window; startupId: cstring) =
  gtk_window_set_startup_id(cast[ptr Window00](self.impl), startupId)

proc `startupId=`*(self: Window; startupId: cstring) =
  gtk_window_set_startup_id(cast[ptr Window00](self.impl), startupId)

proc gtk_window_set_title(self: ptr Window00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: Window; title: cstring = nil) =
  gtk_window_set_title(cast[ptr Window00](self.impl), title)

proc `title=`*(self: Window; title: cstring = nil) =
  gtk_window_set_title(cast[ptr Window00](self.impl), title)

proc gtk_window_set_titlebar(self: ptr Window00; titlebar: ptr Widget00) {.
    importc, libprag.}

proc setTitlebar*(self: Window; titlebar: Widget = nil) =
  gtk_window_set_titlebar(cast[ptr Window00](self.impl), if titlebar.isNil: nil else: cast[ptr Widget00](titlebar.impl))

proc `titlebar=`*(self: Window; titlebar: Widget = nil) =
  gtk_window_set_titlebar(cast[ptr Window00](self.impl), if titlebar.isNil: nil else: cast[ptr Widget00](titlebar.impl))

proc gtk_window_set_transient_for(self: ptr Window00; parent: ptr Window00) {.
    importc, libprag.}

proc setTransientFor*(self: Window; parent: Window = nil) =
  gtk_window_set_transient_for(cast[ptr Window00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc `transientFor=`*(self: Window; parent: Window = nil) =
  gtk_window_set_transient_for(cast[ptr Window00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc gtk_window_unfullscreen(self: ptr Window00) {.
    importc, libprag.}

proc unfullscreen*(self: Window) =
  gtk_window_unfullscreen(cast[ptr Window00](self.impl))

proc gtk_window_unmaximize(self: ptr Window00) {.
    importc, libprag.}

proc unmaximize*(self: Window) =
  gtk_window_unmaximize(cast[ptr Window00](self.impl))

proc gtk_window_unminimize(self: ptr Window00) {.
    importc, libprag.}

proc unminimize*(self: Window) =
  gtk_window_unminimize(cast[ptr Window00](self.impl))

type
  Dialog* = ref object of Window
  Dialog00* = object of Window00

proc gtk_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Dialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClose*(self: Dialog;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cf)

proc scResponse*(self: Dialog;  p: proc (self: ptr Dialog00; responseId: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "response", cast[GCallback](p), xdata, nil, cf)

proc gtk_dialog_new(): ptr Dialog00 {.
    importc, libprag.}

proc newDialog*(): Dialog {.deprecated.}  =
  let gobj = gtk_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDialog*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is Dialog)
  let gobj = gtk_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDialog*[T](result: var T) {.deprecated.} =
  assert(result is Dialog)
  let gobj = gtk_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_add_action_widget(self: ptr Dialog00; child: ptr Widget00;
    responseId: int32) {.
    importc, libprag.}

proc addActionWidget*(self: Dialog; child: Widget; responseId: int) =
  gtk_dialog_add_action_widget(cast[ptr Dialog00](self.impl), cast[ptr Widget00](child.impl), int32(responseId))

proc gtk_dialog_add_button(self: ptr Dialog00; buttonText: cstring; responseId: int32): ptr Widget00 {.
    importc, libprag.}

proc addButton*(self: Dialog; buttonText: cstring; responseId: int): Widget =
  let gobj = gtk_dialog_add_button(cast[ptr Dialog00](self.impl), buttonText, int32(responseId))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_get_response_for_widget(self: ptr Dialog00; widget: ptr Widget00): int32 {.
    importc, libprag.}

proc getResponseForWidget*(self: Dialog; widget: Widget): int =
  int(gtk_dialog_get_response_for_widget(cast[ptr Dialog00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_dialog_get_widget_for_response(self: ptr Dialog00; responseId: int32): ptr Widget00 {.
    importc, libprag.}

proc getWidgetForResponse*(self: Dialog; responseId: int): Widget =
  let gobj = gtk_dialog_get_widget_for_response(cast[ptr Dialog00](self.impl), int32(responseId))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_response(self: ptr Dialog00; responseId: int32) {.
    importc, libprag.}

proc response*(self: Dialog; responseId: int) =
  gtk_dialog_response(cast[ptr Dialog00](self.impl), int32(responseId))

proc gtk_dialog_set_default_response(self: ptr Dialog00; responseId: int32) {.
    importc, libprag.}

proc setDefaultResponse*(self: Dialog; responseId: int) =
  gtk_dialog_set_default_response(cast[ptr Dialog00](self.impl), int32(responseId))

proc `defaultResponse=`*(self: Dialog; responseId: int) =
  gtk_dialog_set_default_response(cast[ptr Dialog00](self.impl), int32(responseId))

proc gtk_dialog_set_response_sensitive(self: ptr Dialog00; responseId: int32;
    setting: gboolean) {.
    importc, libprag.}

proc setResponseSensitive*(self: Dialog; responseId: int; setting: bool) =
  gtk_dialog_set_response_sensitive(cast[ptr Dialog00](self.impl), int32(responseId), gboolean(setting))

type
  FontChooserDialog* = ref object of Dialog
  FontChooserDialog00* = object of Dialog00

proc gtk_font_chooser_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontChooserDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_font_chooser_dialog_new(title: cstring; parent: ptr Window00): ptr FontChooserDialog00 {.
    importc, libprag.}

proc newFontChooserDialog*(title: cstring = nil; parent: Window = nil): FontChooserDialog {.deprecated.}  =
  let gobj = gtk_font_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontChooserDialog*(tdesc: typedesc; title: cstring = nil; parent: Window = nil): tdesc {.deprecated.}  =
  assert(result is FontChooserDialog)
  let gobj = gtk_font_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontChooserDialog*[T](result: var T; title: cstring = nil; parent: Window = nil) {.deprecated.} =
  assert(result is FontChooserDialog)
  let gobj = gtk_font_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ShortcutsWindow* = ref object of Window
  ShortcutsWindow00* = object of Window00

proc gtk_shortcuts_window_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutsWindow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClose*(self: ShortcutsWindow;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cf)

proc scSearch*(self: ShortcutsWindow;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "search", cast[GCallback](p), xdata, nil, cf)

type
  Viewport* = ref object of Widget
  Viewport00* = object of Widget00

proc gtk_viewport_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Viewport()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_viewport_get_child(self: ptr Viewport00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: Viewport): Widget =
  let gobj = gtk_viewport_get_child(cast[ptr Viewport00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Viewport): Widget =
  let gobj = gtk_viewport_get_child(cast[ptr Viewport00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_get_scroll_to_focus(self: ptr Viewport00): gboolean {.
    importc, libprag.}

proc getScrollToFocus*(self: Viewport): bool =
  toBool(gtk_viewport_get_scroll_to_focus(cast[ptr Viewport00](self.impl)))

proc scrollToFocus*(self: Viewport): bool =
  toBool(gtk_viewport_get_scroll_to_focus(cast[ptr Viewport00](self.impl)))

proc gtk_viewport_set_child(self: ptr Viewport00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: Viewport; child: Widget = nil) =
  gtk_viewport_set_child(cast[ptr Viewport00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: Viewport; child: Widget = nil) =
  gtk_viewport_set_child(cast[ptr Viewport00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_viewport_set_scroll_to_focus(self: ptr Viewport00; scrollToFocus: gboolean) {.
    importc, libprag.}

proc setScrollToFocus*(self: Viewport; scrollToFocus: bool = true) =
  gtk_viewport_set_scroll_to_focus(cast[ptr Viewport00](self.impl), gboolean(scrollToFocus))

proc `scrollToFocus=`*(self: Viewport; scrollToFocus: bool) =
  gtk_viewport_set_scroll_to_focus(cast[ptr Viewport00](self.impl), gboolean(scrollToFocus))

type
  TreeExpander* = ref object of Widget
  TreeExpander00* = object of Widget00

proc gtk_tree_expander_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeExpander()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_expander_new(): ptr TreeExpander00 {.
    importc, libprag.}

proc newTreeExpander*(): TreeExpander =
  let gobj = gtk_tree_expander_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeExpander*(tdesc: typedesc): tdesc =
  assert(result is TreeExpander)
  let gobj = gtk_tree_expander_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeExpander*[T](result: var T) {.deprecated.} =
  assert(result is TreeExpander)
  let gobj = gtk_tree_expander_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_expander_get_child(self: ptr TreeExpander00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: TreeExpander): Widget =
  let gobj = gtk_tree_expander_get_child(cast[ptr TreeExpander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: TreeExpander): Widget =
  let gobj = gtk_tree_expander_get_child(cast[ptr TreeExpander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_expander_get_hide_expander(self: ptr TreeExpander00): gboolean {.
    importc, libprag.}

proc getHideExpander*(self: TreeExpander): bool =
  toBool(gtk_tree_expander_get_hide_expander(cast[ptr TreeExpander00](self.impl)))

proc hideExpander*(self: TreeExpander): bool =
  toBool(gtk_tree_expander_get_hide_expander(cast[ptr TreeExpander00](self.impl)))

proc gtk_tree_expander_get_indent_for_depth(self: ptr TreeExpander00): gboolean {.
    importc, libprag.}

proc getIndentForDepth*(self: TreeExpander): bool =
  toBool(gtk_tree_expander_get_indent_for_depth(cast[ptr TreeExpander00](self.impl)))

proc indentForDepth*(self: TreeExpander): bool =
  toBool(gtk_tree_expander_get_indent_for_depth(cast[ptr TreeExpander00](self.impl)))

proc gtk_tree_expander_get_indent_for_icon(self: ptr TreeExpander00): gboolean {.
    importc, libprag.}

proc getIndentForIcon*(self: TreeExpander): bool =
  toBool(gtk_tree_expander_get_indent_for_icon(cast[ptr TreeExpander00](self.impl)))

proc indentForIcon*(self: TreeExpander): bool =
  toBool(gtk_tree_expander_get_indent_for_icon(cast[ptr TreeExpander00](self.impl)))

proc gtk_tree_expander_get_item(self: ptr TreeExpander00): ptr gobject.Object00 {.
    importc, libprag.}

proc getItem*(self: TreeExpander): gobject.Object =
  let gobj = gtk_tree_expander_get_item(cast[ptr TreeExpander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc item*(self: TreeExpander): gobject.Object =
  let gobj = gtk_tree_expander_get_item(cast[ptr TreeExpander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_expander_set_child(self: ptr TreeExpander00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: TreeExpander; child: Widget = nil) =
  gtk_tree_expander_set_child(cast[ptr TreeExpander00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: TreeExpander; child: Widget = nil) =
  gtk_tree_expander_set_child(cast[ptr TreeExpander00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_tree_expander_set_hide_expander(self: ptr TreeExpander00; hideExpander: gboolean) {.
    importc, libprag.}

proc setHideExpander*(self: TreeExpander; hideExpander: bool = true) =
  gtk_tree_expander_set_hide_expander(cast[ptr TreeExpander00](self.impl), gboolean(hideExpander))

proc `hideExpander=`*(self: TreeExpander; hideExpander: bool) =
  gtk_tree_expander_set_hide_expander(cast[ptr TreeExpander00](self.impl), gboolean(hideExpander))

proc gtk_tree_expander_set_indent_for_depth(self: ptr TreeExpander00; indentForDepth: gboolean) {.
    importc, libprag.}

proc setIndentForDepth*(self: TreeExpander; indentForDepth: bool = true) =
  gtk_tree_expander_set_indent_for_depth(cast[ptr TreeExpander00](self.impl), gboolean(indentForDepth))

proc `indentForDepth=`*(self: TreeExpander; indentForDepth: bool) =
  gtk_tree_expander_set_indent_for_depth(cast[ptr TreeExpander00](self.impl), gboolean(indentForDepth))

proc gtk_tree_expander_set_indent_for_icon(self: ptr TreeExpander00; indentForIcon: gboolean) {.
    importc, libprag.}

proc setIndentForIcon*(self: TreeExpander; indentForIcon: bool = true) =
  gtk_tree_expander_set_indent_for_icon(cast[ptr TreeExpander00](self.impl), gboolean(indentForIcon))

proc `indentForIcon=`*(self: TreeExpander; indentForIcon: bool) =
  gtk_tree_expander_set_indent_for_icon(cast[ptr TreeExpander00](self.impl), gboolean(indentForIcon))

type
  ScrollType* {.size: sizeof(cint), pure.} = enum
    none = 0
    jump = 1
    stepBackward = 2
    stepForward = 3
    pageBackward = 4
    pageForward = 5
    stepUp = 6
    stepDown = 7
    pageUp = 8
    pageDown = 9
    stepLeft = 10
    stepRight = 11
    pageLeft = 12
    pageRight = 13
    start = 14
    `end` = 15

type
  Range* = ref object of Widget
  Range00* = object of Widget00

proc gtk_range_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Range()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAdjustBounds*(self: Range;  p: proc (self: ptr Range00; value: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "adjust-bounds", cast[GCallback](p), xdata, nil, cf)

proc scChangeValue*(self: Range;  p: proc (self: ptr Range00; scroll: ScrollType; value: cdouble; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "change-value", cast[GCallback](p), xdata, nil, cf)

proc scMoveSlider*(self: Range;  p: proc (self: ptr Range00; step: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-slider", cast[GCallback](p), xdata, nil, cf)

proc scValueChanged*(self: Range;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_range_get_fill_level(self: ptr Range00): cdouble {.
    importc, libprag.}

proc getFillLevel*(self: Range): cdouble =
  gtk_range_get_fill_level(cast[ptr Range00](self.impl))

proc fillLevel*(self: Range): cdouble =
  gtk_range_get_fill_level(cast[ptr Range00](self.impl))

proc gtk_range_get_flippable(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getFlippable*(self: Range): bool =
  toBool(gtk_range_get_flippable(cast[ptr Range00](self.impl)))

proc flippable*(self: Range): bool =
  toBool(gtk_range_get_flippable(cast[ptr Range00](self.impl)))

proc gtk_range_get_inverted(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getInverted*(self: Range): bool =
  toBool(gtk_range_get_inverted(cast[ptr Range00](self.impl)))

proc inverted*(self: Range): bool =
  toBool(gtk_range_get_inverted(cast[ptr Range00](self.impl)))

proc gtk_range_get_range_rect(self: ptr Range00; rangeRect: var gdk4.Rectangle) {.
    importc, libprag.}

proc getRangeRect*(self: Range; rangeRect: var gdk4.Rectangle) =
  gtk_range_get_range_rect(cast[ptr Range00](self.impl), rangeRect)

proc getRangeRect*(self: Range): gdk4.Rectangle =
  gtk_range_get_range_rect(cast[ptr Range00](self.impl), result)

proc gtk_range_get_restrict_to_fill_level(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getRestrictToFillLevel*(self: Range): bool =
  toBool(gtk_range_get_restrict_to_fill_level(cast[ptr Range00](self.impl)))

proc restrictToFillLevel*(self: Range): bool =
  toBool(gtk_range_get_restrict_to_fill_level(cast[ptr Range00](self.impl)))

proc gtk_range_get_round_digits(self: ptr Range00): int32 {.
    importc, libprag.}

proc getRoundDigits*(self: Range): int =
  int(gtk_range_get_round_digits(cast[ptr Range00](self.impl)))

proc roundDigits*(self: Range): int =
  int(gtk_range_get_round_digits(cast[ptr Range00](self.impl)))

proc gtk_range_get_show_fill_level(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getShowFillLevel*(self: Range): bool =
  toBool(gtk_range_get_show_fill_level(cast[ptr Range00](self.impl)))

proc showFillLevel*(self: Range): bool =
  toBool(gtk_range_get_show_fill_level(cast[ptr Range00](self.impl)))

proc gtk_range_get_slider_range(self: ptr Range00; sliderStart: var int32;
    sliderEnd: var int32) {.
    importc, libprag.}

proc getSliderRange*(self: Range; sliderStart: var int = cast[var int](nil);
    sliderEnd: var int = cast[var int](nil)) =
  var sliderEnd_00: int32
  var sliderStart_00: int32
  gtk_range_get_slider_range(cast[ptr Range00](self.impl), sliderStart_00, sliderEnd_00)
  if sliderEnd.addr != nil:
    sliderEnd = int(sliderEnd_00)
  if sliderStart.addr != nil:
    sliderStart = int(sliderStart_00)

proc gtk_range_get_slider_size_fixed(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getSliderSizeFixed*(self: Range): bool =
  toBool(gtk_range_get_slider_size_fixed(cast[ptr Range00](self.impl)))

proc sliderSizeFixed*(self: Range): bool =
  toBool(gtk_range_get_slider_size_fixed(cast[ptr Range00](self.impl)))

proc gtk_range_get_value(self: ptr Range00): cdouble {.
    importc, libprag.}

proc getValue*(self: Range): cdouble =
  gtk_range_get_value(cast[ptr Range00](self.impl))

proc value*(self: Range): cdouble =
  gtk_range_get_value(cast[ptr Range00](self.impl))

proc gtk_range_set_fill_level(self: ptr Range00; fillLevel: cdouble) {.
    importc, libprag.}

proc setFillLevel*(self: Range; fillLevel: cdouble) =
  gtk_range_set_fill_level(cast[ptr Range00](self.impl), fillLevel)

proc `fillLevel=`*(self: Range; fillLevel: cdouble) =
  gtk_range_set_fill_level(cast[ptr Range00](self.impl), fillLevel)

proc gtk_range_set_flippable(self: ptr Range00; flippable: gboolean) {.
    importc, libprag.}

proc setFlippable*(self: Range; flippable: bool = true) =
  gtk_range_set_flippable(cast[ptr Range00](self.impl), gboolean(flippable))

proc `flippable=`*(self: Range; flippable: bool) =
  gtk_range_set_flippable(cast[ptr Range00](self.impl), gboolean(flippable))

proc gtk_range_set_increments(self: ptr Range00; step: cdouble; page: cdouble) {.
    importc, libprag.}

proc setIncrements*(self: Range; step: cdouble; page: cdouble) =
  gtk_range_set_increments(cast[ptr Range00](self.impl), step, page)

proc gtk_range_set_inverted(self: ptr Range00; setting: gboolean) {.
    importc, libprag.}

proc setInverted*(self: Range; setting: bool = true) =
  gtk_range_set_inverted(cast[ptr Range00](self.impl), gboolean(setting))

proc `inverted=`*(self: Range; setting: bool) =
  gtk_range_set_inverted(cast[ptr Range00](self.impl), gboolean(setting))

proc gtk_range_set_range(self: ptr Range00; min: cdouble; max: cdouble) {.
    importc, libprag.}

proc setRange*(self: Range; min: cdouble; max: cdouble) =
  gtk_range_set_range(cast[ptr Range00](self.impl), min, max)

proc gtk_range_set_restrict_to_fill_level(self: ptr Range00; restrictToFillLevel: gboolean) {.
    importc, libprag.}

proc setRestrictToFillLevel*(self: Range; restrictToFillLevel: bool = true) =
  gtk_range_set_restrict_to_fill_level(cast[ptr Range00](self.impl), gboolean(restrictToFillLevel))

proc `restrictToFillLevel=`*(self: Range; restrictToFillLevel: bool) =
  gtk_range_set_restrict_to_fill_level(cast[ptr Range00](self.impl), gboolean(restrictToFillLevel))

proc gtk_range_set_round_digits(self: ptr Range00; roundDigits: int32) {.
    importc, libprag.}

proc setRoundDigits*(self: Range; roundDigits: int) =
  gtk_range_set_round_digits(cast[ptr Range00](self.impl), int32(roundDigits))

proc `roundDigits=`*(self: Range; roundDigits: int) =
  gtk_range_set_round_digits(cast[ptr Range00](self.impl), int32(roundDigits))

proc gtk_range_set_show_fill_level(self: ptr Range00; showFillLevel: gboolean) {.
    importc, libprag.}

proc setShowFillLevel*(self: Range; showFillLevel: bool = true) =
  gtk_range_set_show_fill_level(cast[ptr Range00](self.impl), gboolean(showFillLevel))

proc `showFillLevel=`*(self: Range; showFillLevel: bool) =
  gtk_range_set_show_fill_level(cast[ptr Range00](self.impl), gboolean(showFillLevel))

proc gtk_range_set_slider_size_fixed(self: ptr Range00; sizeFixed: gboolean) {.
    importc, libprag.}

proc setSliderSizeFixed*(self: Range; sizeFixed: bool = true) =
  gtk_range_set_slider_size_fixed(cast[ptr Range00](self.impl), gboolean(sizeFixed))

proc `sliderSizeFixed=`*(self: Range; sizeFixed: bool) =
  gtk_range_set_slider_size_fixed(cast[ptr Range00](self.impl), gboolean(sizeFixed))

proc gtk_range_set_value(self: ptr Range00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: Range; value: cdouble) =
  gtk_range_set_value(cast[ptr Range00](self.impl), value)

proc `value=`*(self: Range; value: cdouble) =
  gtk_range_set_value(cast[ptr Range00](self.impl), value)

type
  Scale* = ref object of Range
  Scale00* = object of Range00

proc gtk_scale_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Scale()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_scale_clear_marks(self: ptr Scale00) {.
    importc, libprag.}

proc clearMarks*(self: Scale) =
  gtk_scale_clear_marks(cast[ptr Scale00](self.impl))

proc gtk_scale_get_digits(self: ptr Scale00): int32 {.
    importc, libprag.}

proc getDigits*(self: Scale): int =
  int(gtk_scale_get_digits(cast[ptr Scale00](self.impl)))

proc digits*(self: Scale): int =
  int(gtk_scale_get_digits(cast[ptr Scale00](self.impl)))

proc gtk_scale_get_draw_value(self: ptr Scale00): gboolean {.
    importc, libprag.}

proc getDrawValue*(self: Scale): bool =
  toBool(gtk_scale_get_draw_value(cast[ptr Scale00](self.impl)))

proc drawValue*(self: Scale): bool =
  toBool(gtk_scale_get_draw_value(cast[ptr Scale00](self.impl)))

proc gtk_scale_get_has_origin(self: ptr Scale00): gboolean {.
    importc, libprag.}

proc getHasOrigin*(self: Scale): bool =
  toBool(gtk_scale_get_has_origin(cast[ptr Scale00](self.impl)))

proc hasOrigin*(self: Scale): bool =
  toBool(gtk_scale_get_has_origin(cast[ptr Scale00](self.impl)))

proc gtk_scale_get_layout(self: ptr Scale00): ptr pango.Layout00 {.
    importc, libprag.}

proc getLayout*(self: Scale): pango.Layout =
  let gobj = gtk_scale_get_layout(cast[ptr Scale00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layout*(self: Scale): pango.Layout =
  let gobj = gtk_scale_get_layout(cast[ptr Scale00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_get_layout_offsets(self: ptr Scale00; x: var int32; y: var int32) {.
    importc, libprag.}

proc getLayoutOffsets*(self: Scale; x: var int = cast[var int](nil);
    y: var int = cast[var int](nil)) =
  var x_00: int32
  var y_00: int32
  gtk_scale_get_layout_offsets(cast[ptr Scale00](self.impl), x_00, y_00)
  if x.addr != nil:
    x = int(x_00)
  if y.addr != nil:
    y = int(y_00)

proc gtk_scale_set_digits(self: ptr Scale00; digits: int32) {.
    importc, libprag.}

proc setDigits*(self: Scale; digits: int) =
  gtk_scale_set_digits(cast[ptr Scale00](self.impl), int32(digits))

proc `digits=`*(self: Scale; digits: int) =
  gtk_scale_set_digits(cast[ptr Scale00](self.impl), int32(digits))

proc gtk_scale_set_draw_value(self: ptr Scale00; drawValue: gboolean) {.
    importc, libprag.}

proc setDrawValue*(self: Scale; drawValue: bool = true) =
  gtk_scale_set_draw_value(cast[ptr Scale00](self.impl), gboolean(drawValue))

proc `drawValue=`*(self: Scale; drawValue: bool) =
  gtk_scale_set_draw_value(cast[ptr Scale00](self.impl), gboolean(drawValue))

proc gtk_scale_set_has_origin(self: ptr Scale00; hasOrigin: gboolean) {.
    importc, libprag.}

proc setHasOrigin*(self: Scale; hasOrigin: bool = true) =
  gtk_scale_set_has_origin(cast[ptr Scale00](self.impl), gboolean(hasOrigin))

proc `hasOrigin=`*(self: Scale; hasOrigin: bool) =
  gtk_scale_set_has_origin(cast[ptr Scale00](self.impl), gboolean(hasOrigin))

type
  Inscription* = ref object of Widget
  Inscription00* = object of Widget00

proc gtk_inscription_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Inscription()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_inscription_new(text: cstring): ptr Inscription00 {.
    importc, libprag.}

proc newInscription*(text: cstring = nil): Inscription =
  let gobj = gtk_inscription_new(text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newInscription*(tdesc: typedesc; text: cstring = nil): tdesc =
  assert(result is Inscription)
  let gobj = gtk_inscription_new(text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initInscription*[T](result: var T; text: cstring = nil) {.deprecated.} =
  assert(result is Inscription)
  let gobj = gtk_inscription_new(text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_inscription_get_attributes(self: ptr Inscription00): ptr pango.AttrList00 {.
    importc, libprag.}

proc getAttributes*(self: Inscription): pango.AttrList =
  let impl0 = gtk_inscription_get_attributes(cast[ptr Inscription00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc attributes*(self: Inscription): pango.AttrList =
  let impl0 = gtk_inscription_get_attributes(cast[ptr Inscription00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc gtk_inscription_get_min_chars(self: ptr Inscription00): uint32 {.
    importc, libprag.}

proc getMinChars*(self: Inscription): int =
  int(gtk_inscription_get_min_chars(cast[ptr Inscription00](self.impl)))

proc minChars*(self: Inscription): int =
  int(gtk_inscription_get_min_chars(cast[ptr Inscription00](self.impl)))

proc gtk_inscription_get_min_lines(self: ptr Inscription00): uint32 {.
    importc, libprag.}

proc getMinLines*(self: Inscription): int =
  int(gtk_inscription_get_min_lines(cast[ptr Inscription00](self.impl)))

proc minLines*(self: Inscription): int =
  int(gtk_inscription_get_min_lines(cast[ptr Inscription00](self.impl)))

proc gtk_inscription_get_nat_chars(self: ptr Inscription00): uint32 {.
    importc, libprag.}

proc getNatChars*(self: Inscription): int =
  int(gtk_inscription_get_nat_chars(cast[ptr Inscription00](self.impl)))

proc natChars*(self: Inscription): int =
  int(gtk_inscription_get_nat_chars(cast[ptr Inscription00](self.impl)))

proc gtk_inscription_get_nat_lines(self: ptr Inscription00): uint32 {.
    importc, libprag.}

proc getNatLines*(self: Inscription): int =
  int(gtk_inscription_get_nat_lines(cast[ptr Inscription00](self.impl)))

proc natLines*(self: Inscription): int =
  int(gtk_inscription_get_nat_lines(cast[ptr Inscription00](self.impl)))

proc gtk_inscription_get_text(self: ptr Inscription00): cstring {.
    importc, libprag.}

proc getText*(self: Inscription): string =
  let resul0 = gtk_inscription_get_text(cast[ptr Inscription00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc text*(self: Inscription): string =
  let resul0 = gtk_inscription_get_text(cast[ptr Inscription00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_inscription_get_wrap_mode(self: ptr Inscription00): pango.WrapMode {.
    importc, libprag.}

proc getWrapMode*(self: Inscription): pango.WrapMode =
  gtk_inscription_get_wrap_mode(cast[ptr Inscription00](self.impl))

proc wrapMode*(self: Inscription): pango.WrapMode =
  gtk_inscription_get_wrap_mode(cast[ptr Inscription00](self.impl))

proc gtk_inscription_get_xalign(self: ptr Inscription00): cfloat {.
    importc, libprag.}

proc getXalign*(self: Inscription): cfloat =
  gtk_inscription_get_xalign(cast[ptr Inscription00](self.impl))

proc xalign*(self: Inscription): cfloat =
  gtk_inscription_get_xalign(cast[ptr Inscription00](self.impl))

proc gtk_inscription_get_yalign(self: ptr Inscription00): cfloat {.
    importc, libprag.}

proc getYalign*(self: Inscription): cfloat =
  gtk_inscription_get_yalign(cast[ptr Inscription00](self.impl))

proc yalign*(self: Inscription): cfloat =
  gtk_inscription_get_yalign(cast[ptr Inscription00](self.impl))

proc gtk_inscription_set_attributes(self: ptr Inscription00; attrs: ptr pango.AttrList00) {.
    importc, libprag.}

proc setAttributes*(self: Inscription; attrs: pango.AttrList = nil) =
  gtk_inscription_set_attributes(cast[ptr Inscription00](self.impl), if attrs.isNil: nil else: cast[ptr pango.AttrList00](attrs.impl))

proc `attributes=`*(self: Inscription; attrs: pango.AttrList = nil) =
  gtk_inscription_set_attributes(cast[ptr Inscription00](self.impl), if attrs.isNil: nil else: cast[ptr pango.AttrList00](attrs.impl))

proc gtk_inscription_set_markup(self: ptr Inscription00; markup: cstring) {.
    importc, libprag.}

proc setMarkup*(self: Inscription; markup: cstring = nil) =
  gtk_inscription_set_markup(cast[ptr Inscription00](self.impl), markup)

proc `markup=`*(self: Inscription; markup: cstring = nil) =
  gtk_inscription_set_markup(cast[ptr Inscription00](self.impl), markup)

proc gtk_inscription_set_min_chars(self: ptr Inscription00; minChars: uint32) {.
    importc, libprag.}

proc setMinChars*(self: Inscription; minChars: int) =
  gtk_inscription_set_min_chars(cast[ptr Inscription00](self.impl), uint32(minChars))

proc `minChars=`*(self: Inscription; minChars: int) =
  gtk_inscription_set_min_chars(cast[ptr Inscription00](self.impl), uint32(minChars))

proc gtk_inscription_set_min_lines(self: ptr Inscription00; minLines: uint32) {.
    importc, libprag.}

proc setMinLines*(self: Inscription; minLines: int) =
  gtk_inscription_set_min_lines(cast[ptr Inscription00](self.impl), uint32(minLines))

proc `minLines=`*(self: Inscription; minLines: int) =
  gtk_inscription_set_min_lines(cast[ptr Inscription00](self.impl), uint32(minLines))

proc gtk_inscription_set_nat_chars(self: ptr Inscription00; natChars: uint32) {.
    importc, libprag.}

proc setNatChars*(self: Inscription; natChars: int) =
  gtk_inscription_set_nat_chars(cast[ptr Inscription00](self.impl), uint32(natChars))

proc `natChars=`*(self: Inscription; natChars: int) =
  gtk_inscription_set_nat_chars(cast[ptr Inscription00](self.impl), uint32(natChars))

proc gtk_inscription_set_nat_lines(self: ptr Inscription00; natLines: uint32) {.
    importc, libprag.}

proc setNatLines*(self: Inscription; natLines: int) =
  gtk_inscription_set_nat_lines(cast[ptr Inscription00](self.impl), uint32(natLines))

proc `natLines=`*(self: Inscription; natLines: int) =
  gtk_inscription_set_nat_lines(cast[ptr Inscription00](self.impl), uint32(natLines))

proc gtk_inscription_set_text(self: ptr Inscription00; text: cstring) {.
    importc, libprag.}

proc setText*(self: Inscription; text: cstring = nil) =
  gtk_inscription_set_text(cast[ptr Inscription00](self.impl), text)

proc `text=`*(self: Inscription; text: cstring = nil) =
  gtk_inscription_set_text(cast[ptr Inscription00](self.impl), text)

proc gtk_inscription_set_wrap_mode(self: ptr Inscription00; wrapMode: pango.WrapMode) {.
    importc, libprag.}

proc setWrapMode*(self: Inscription; wrapMode: pango.WrapMode) =
  gtk_inscription_set_wrap_mode(cast[ptr Inscription00](self.impl), wrapMode)

proc `wrapMode=`*(self: Inscription; wrapMode: pango.WrapMode) =
  gtk_inscription_set_wrap_mode(cast[ptr Inscription00](self.impl), wrapMode)

proc gtk_inscription_set_xalign(self: ptr Inscription00; xalign: cfloat) {.
    importc, libprag.}

proc setXalign*(self: Inscription; xalign: cfloat) =
  gtk_inscription_set_xalign(cast[ptr Inscription00](self.impl), xalign)

proc `xalign=`*(self: Inscription; xalign: cfloat) =
  gtk_inscription_set_xalign(cast[ptr Inscription00](self.impl), xalign)

proc gtk_inscription_set_yalign(self: ptr Inscription00; yalign: cfloat) {.
    importc, libprag.}

proc setYalign*(self: Inscription; yalign: cfloat) =
  gtk_inscription_set_yalign(cast[ptr Inscription00](self.impl), yalign)

proc `yalign=`*(self: Inscription; yalign: cfloat) =
  gtk_inscription_set_yalign(cast[ptr Inscription00](self.impl), yalign)

type
  GLArea* = ref object of Widget
  GLArea00* = object of Widget00

proc gtk_gl_area_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GLArea()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scCreateContext*(self: GLArea;  p: proc (self: ptr GLArea00; xdata: pointer): ptr gdk4.GLContext00 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "create-context", cast[GCallback](p), xdata, nil, cf)

proc scRender*(self: GLArea;  p: proc (self: ptr GLArea00; context: ptr gdk4.GLContext00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "render", cast[GCallback](p), xdata, nil, cf)

proc scResize*(self: GLArea;  p: proc (self: ptr GLArea00; width: int32; height: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "resize", cast[GCallback](p), xdata, nil, cf)

proc gtk_gl_area_new(): ptr GLArea00 {.
    importc, libprag.}

proc newGLArea*(): GLArea =
  let gobj = gtk_gl_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGLArea*(tdesc: typedesc): tdesc =
  assert(result is GLArea)
  let gobj = gtk_gl_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGLArea*[T](result: var T) {.deprecated.} =
  assert(result is GLArea)
  let gobj = gtk_gl_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gl_area_attach_buffers(self: ptr GLArea00) {.
    importc, libprag.}

proc attachBuffers*(self: GLArea) =
  gtk_gl_area_attach_buffers(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_get_allowed_apis(self: ptr GLArea00): gdk4.GLAPI {.
    importc, libprag.}

proc getAllowedApis*(self: GLArea): gdk4.GLAPI =
  gtk_gl_area_get_allowed_apis(cast[ptr GLArea00](self.impl))

proc allowedApis*(self: GLArea): gdk4.GLAPI =
  gtk_gl_area_get_allowed_apis(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_get_api(self: ptr GLArea00): gdk4.GLAPI {.
    importc, libprag.}

proc getApi*(self: GLArea): gdk4.GLAPI =
  gtk_gl_area_get_api(cast[ptr GLArea00](self.impl))

proc api*(self: GLArea): gdk4.GLAPI =
  gtk_gl_area_get_api(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_get_auto_render(self: ptr GLArea00): gboolean {.
    importc, libprag.}

proc getAutoRender*(self: GLArea): bool =
  toBool(gtk_gl_area_get_auto_render(cast[ptr GLArea00](self.impl)))

proc autoRender*(self: GLArea): bool =
  toBool(gtk_gl_area_get_auto_render(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_context(self: ptr GLArea00): ptr gdk4.GLContext00 {.
    importc, libprag.}

proc getContext*(self: GLArea): gdk4.GLContext =
  let gobj = gtk_gl_area_get_context(cast[ptr GLArea00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc context*(self: GLArea): gdk4.GLContext =
  let gobj = gtk_gl_area_get_context(cast[ptr GLArea00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gl_area_get_error(self: ptr GLArea00): ptr glib.Error {.
    importc, libprag.}

proc getError*(self: GLArea): ptr glib.Error =
  gtk_gl_area_get_error(cast[ptr GLArea00](self.impl))

proc error*(self: GLArea): ptr glib.Error =
  gtk_gl_area_get_error(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_get_has_depth_buffer(self: ptr GLArea00): gboolean {.
    importc, libprag.}

proc getHasDepthBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_depth_buffer(cast[ptr GLArea00](self.impl)))

proc hasDepthBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_depth_buffer(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_has_stencil_buffer(self: ptr GLArea00): gboolean {.
    importc, libprag.}

proc getHasStencilBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_stencil_buffer(cast[ptr GLArea00](self.impl)))

proc hasStencilBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_stencil_buffer(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_required_version(self: ptr GLArea00; major: var int32;
    minor: var int32) {.
    importc, libprag.}

proc getRequiredVersion*(self: GLArea; major: var int; minor: var int) =
  var major_00: int32
  var minor_00: int32
  gtk_gl_area_get_required_version(cast[ptr GLArea00](self.impl), major_00, minor_00)
  if major.addr != nil:
    major = int(major_00)
  if minor.addr != nil:
    minor = int(minor_00)

proc gtk_gl_area_get_use_es(self: ptr GLArea00): gboolean {.
    importc, libprag.}

proc getUseEs*(self: GLArea): bool =
  toBool(gtk_gl_area_get_use_es(cast[ptr GLArea00](self.impl)))

proc useEs*(self: GLArea): bool =
  toBool(gtk_gl_area_get_use_es(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_make_current(self: ptr GLArea00) {.
    importc, libprag.}

proc makeCurrent*(self: GLArea) =
  gtk_gl_area_make_current(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_queue_render(self: ptr GLArea00) {.
    importc, libprag.}

proc queueRender*(self: GLArea) =
  gtk_gl_area_queue_render(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_set_allowed_apis(self: ptr GLArea00; apis: gdk4.GLAPI) {.
    importc, libprag.}

proc setAllowedApis*(self: GLArea; apis: gdk4.GLAPI) =
  gtk_gl_area_set_allowed_apis(cast[ptr GLArea00](self.impl), apis)

proc `allowedApis=`*(self: GLArea; apis: gdk4.GLAPI) =
  gtk_gl_area_set_allowed_apis(cast[ptr GLArea00](self.impl), apis)

proc gtk_gl_area_set_auto_render(self: ptr GLArea00; autoRender: gboolean) {.
    importc, libprag.}

proc setAutoRender*(self: GLArea; autoRender: bool = true) =
  gtk_gl_area_set_auto_render(cast[ptr GLArea00](self.impl), gboolean(autoRender))

proc `autoRender=`*(self: GLArea; autoRender: bool) =
  gtk_gl_area_set_auto_render(cast[ptr GLArea00](self.impl), gboolean(autoRender))

proc gtk_gl_area_set_error(self: ptr GLArea00; error: ptr glib.Error) {.
    importc, libprag.}

proc setError*(self: GLArea; error: ptr glib.Error) =
  gtk_gl_area_set_error(cast[ptr GLArea00](self.impl), error)

proc `error=`*(self: GLArea; error: ptr glib.Error) =
  gtk_gl_area_set_error(cast[ptr GLArea00](self.impl), error)

proc gtk_gl_area_set_has_depth_buffer(self: ptr GLArea00; hasDepthBuffer: gboolean) {.
    importc, libprag.}

proc setHasDepthBuffer*(self: GLArea; hasDepthBuffer: bool = true) =
  gtk_gl_area_set_has_depth_buffer(cast[ptr GLArea00](self.impl), gboolean(hasDepthBuffer))

proc `hasDepthBuffer=`*(self: GLArea; hasDepthBuffer: bool) =
  gtk_gl_area_set_has_depth_buffer(cast[ptr GLArea00](self.impl), gboolean(hasDepthBuffer))

proc gtk_gl_area_set_has_stencil_buffer(self: ptr GLArea00; hasStencilBuffer: gboolean) {.
    importc, libprag.}

proc setHasStencilBuffer*(self: GLArea; hasStencilBuffer: bool = true) =
  gtk_gl_area_set_has_stencil_buffer(cast[ptr GLArea00](self.impl), gboolean(hasStencilBuffer))

proc `hasStencilBuffer=`*(self: GLArea; hasStencilBuffer: bool) =
  gtk_gl_area_set_has_stencil_buffer(cast[ptr GLArea00](self.impl), gboolean(hasStencilBuffer))

proc gtk_gl_area_set_required_version(self: ptr GLArea00; major: int32; minor: int32) {.
    importc, libprag.}

proc setRequiredVersion*(self: GLArea; major: int; minor: int) =
  gtk_gl_area_set_required_version(cast[ptr GLArea00](self.impl), int32(major), int32(minor))

proc gtk_gl_area_set_use_es(self: ptr GLArea00; useEs: gboolean) {.
    importc, libprag.}

proc setUseEs*(self: GLArea; useEs: bool = true) =
  gtk_gl_area_set_use_es(cast[ptr GLArea00](self.impl), gboolean(useEs))

proc `useEs=`*(self: GLArea; useEs: bool) =
  gtk_gl_area_set_use_es(cast[ptr GLArea00](self.impl), gboolean(useEs))

type
  MediaControls* = ref object of Widget
  MediaControls00* = object of Widget00

proc gtk_media_controls_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MediaControls()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  FileChooserDialog* = ref object of Dialog
  FileChooserDialog00* = object of Dialog00

proc gtk_file_chooser_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileChooserDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  FontButton* = ref object of Widget
  FontButton00* = object of Widget00

proc gtk_font_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: FontButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scFontSet*(self: FontButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "font-set", cast[GCallback](p), xdata, nil, cf)

proc gtk_font_button_new(): ptr FontButton00 {.
    importc, libprag.}

proc newFontButton*(): FontButton {.deprecated.}  =
  let gobj = gtk_font_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontButton*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is FontButton)
  let gobj = gtk_font_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontButton*[T](result: var T) {.deprecated.} =
  assert(result is FontButton)
  let gobj = gtk_font_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_button_new_with_font(fontname: cstring): ptr FontButton00 {.
    importc, libprag.}

proc newFontButtonWithFont*(fontname: cstring): FontButton {.deprecated.}  =
  let gobj = gtk_font_button_new_with_font(fontname)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontButtonWithFont*(tdesc: typedesc; fontname: cstring): tdesc {.deprecated.}  =
  assert(result is FontButton)
  let gobj = gtk_font_button_new_with_font(fontname)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontButtonWithFont*[T](result: var T; fontname: cstring) {.deprecated.} =
  assert(result is FontButton)
  let gobj = gtk_font_button_new_with_font(fontname)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_button_get_modal(self: ptr FontButton00): gboolean {.
    importc, libprag.}

proc getModal*(self: FontButton): bool =
  toBool(gtk_font_button_get_modal(cast[ptr FontButton00](self.impl)))

proc modal*(self: FontButton): bool =
  toBool(gtk_font_button_get_modal(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_get_title(self: ptr FontButton00): cstring {.
    importc, libprag.}

proc getTitle*(self: FontButton): string =
  result = $gtk_font_button_get_title(cast[ptr FontButton00](self.impl))

proc title*(self: FontButton): string =
  result = $gtk_font_button_get_title(cast[ptr FontButton00](self.impl))

proc gtk_font_button_get_use_font(self: ptr FontButton00): gboolean {.
    importc, libprag.}

proc getUseFont*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_font(cast[ptr FontButton00](self.impl)))

proc useFont*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_font(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_get_use_size(self: ptr FontButton00): gboolean {.
    importc, libprag.}

proc getUseSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_size(cast[ptr FontButton00](self.impl)))

proc useSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_size(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_set_modal(self: ptr FontButton00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: FontButton; modal: bool = true) =
  gtk_font_button_set_modal(cast[ptr FontButton00](self.impl), gboolean(modal))

proc `modal=`*(self: FontButton; modal: bool) =
  gtk_font_button_set_modal(cast[ptr FontButton00](self.impl), gboolean(modal))

proc gtk_font_button_set_title(self: ptr FontButton00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: FontButton; title: cstring) =
  gtk_font_button_set_title(cast[ptr FontButton00](self.impl), title)

proc `title=`*(self: FontButton; title: cstring) =
  gtk_font_button_set_title(cast[ptr FontButton00](self.impl), title)

proc gtk_font_button_set_use_font(self: ptr FontButton00; useFont: gboolean) {.
    importc, libprag.}

proc setUseFont*(self: FontButton; useFont: bool = true) =
  gtk_font_button_set_use_font(cast[ptr FontButton00](self.impl), gboolean(useFont))

proc `useFont=`*(self: FontButton; useFont: bool) =
  gtk_font_button_set_use_font(cast[ptr FontButton00](self.impl), gboolean(useFont))

proc gtk_font_button_set_use_size(self: ptr FontButton00; useSize: gboolean) {.
    importc, libprag.}

proc setUseSize*(self: FontButton; useSize: bool = true) =
  gtk_font_button_set_use_size(cast[ptr FontButton00](self.impl), gboolean(useSize))

proc `useSize=`*(self: FontButton; useSize: bool) =
  gtk_font_button_set_use_size(cast[ptr FontButton00](self.impl), gboolean(useSize))

type
  MediaStream* = ref object of gobject.Object
  MediaStream00* = object of gobject.Object00

proc gtk_media_stream_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MediaStream()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_media_stream_gerror(self: ptr MediaStream00; error: ptr glib.Error) {.
    importc, libprag.}

proc gerror*(self: MediaStream; error: ptr glib.Error) =
  gtk_media_stream_gerror(cast[ptr MediaStream00](self.impl), error)

proc gtk_media_stream_get_duration(self: ptr MediaStream00): int64 {.
    importc, libprag.}

proc getDuration*(self: MediaStream): int64 =
  gtk_media_stream_get_duration(cast[ptr MediaStream00](self.impl))

proc duration*(self: MediaStream): int64 =
  gtk_media_stream_get_duration(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_get_ended(self: ptr MediaStream00): gboolean {.
    importc, libprag.}

proc getEnded*(self: MediaStream): bool =
  toBool(gtk_media_stream_get_ended(cast[ptr MediaStream00](self.impl)))

proc ended*(self: MediaStream): bool =
  toBool(gtk_media_stream_get_ended(cast[ptr MediaStream00](self.impl)))

proc gtk_media_stream_get_error(self: ptr MediaStream00): ptr glib.Error {.
    importc, libprag.}

proc getError*(self: MediaStream): ptr glib.Error =
  gtk_media_stream_get_error(cast[ptr MediaStream00](self.impl))

proc error*(self: MediaStream): ptr glib.Error =
  gtk_media_stream_get_error(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_get_loop(self: ptr MediaStream00): gboolean {.
    importc, libprag.}

proc getLoop*(self: MediaStream): bool =
  toBool(gtk_media_stream_get_loop(cast[ptr MediaStream00](self.impl)))

proc loop*(self: MediaStream): bool =
  toBool(gtk_media_stream_get_loop(cast[ptr MediaStream00](self.impl)))

proc gtk_media_stream_get_muted(self: ptr MediaStream00): gboolean {.
    importc, libprag.}

proc getMuted*(self: MediaStream): bool =
  toBool(gtk_media_stream_get_muted(cast[ptr MediaStream00](self.impl)))

proc muted*(self: MediaStream): bool =
  toBool(gtk_media_stream_get_muted(cast[ptr MediaStream00](self.impl)))

proc gtk_media_stream_get_playing(self: ptr MediaStream00): gboolean {.
    importc, libprag.}

proc getPlaying*(self: MediaStream): bool =
  toBool(gtk_media_stream_get_playing(cast[ptr MediaStream00](self.impl)))

proc playing*(self: MediaStream): bool =
  toBool(gtk_media_stream_get_playing(cast[ptr MediaStream00](self.impl)))

proc gtk_media_stream_get_timestamp(self: ptr MediaStream00): int64 {.
    importc, libprag.}

proc getTimestamp*(self: MediaStream): int64 =
  gtk_media_stream_get_timestamp(cast[ptr MediaStream00](self.impl))

proc timestamp*(self: MediaStream): int64 =
  gtk_media_stream_get_timestamp(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_get_volume(self: ptr MediaStream00): cdouble {.
    importc, libprag.}

proc getVolume*(self: MediaStream): cdouble =
  gtk_media_stream_get_volume(cast[ptr MediaStream00](self.impl))

proc volume*(self: MediaStream): cdouble =
  gtk_media_stream_get_volume(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_has_audio(self: ptr MediaStream00): gboolean {.
    importc, libprag.}

proc hasAudio*(self: MediaStream): bool =
  toBool(gtk_media_stream_has_audio(cast[ptr MediaStream00](self.impl)))

proc gtk_media_stream_has_video(self: ptr MediaStream00): gboolean {.
    importc, libprag.}

proc hasVideo*(self: MediaStream): bool =
  toBool(gtk_media_stream_has_video(cast[ptr MediaStream00](self.impl)))

proc gtk_media_stream_is_prepared(self: ptr MediaStream00): gboolean {.
    importc, libprag.}

proc isPrepared*(self: MediaStream): bool =
  toBool(gtk_media_stream_is_prepared(cast[ptr MediaStream00](self.impl)))

proc gtk_media_stream_is_seekable(self: ptr MediaStream00): gboolean {.
    importc, libprag.}

proc isSeekable*(self: MediaStream): bool =
  toBool(gtk_media_stream_is_seekable(cast[ptr MediaStream00](self.impl)))

proc gtk_media_stream_is_seeking(self: ptr MediaStream00): gboolean {.
    importc, libprag.}

proc isSeeking*(self: MediaStream): bool =
  toBool(gtk_media_stream_is_seeking(cast[ptr MediaStream00](self.impl)))

proc gtk_media_stream_pause(self: ptr MediaStream00) {.
    importc, libprag.}

proc pause*(self: MediaStream) =
  gtk_media_stream_pause(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_play(self: ptr MediaStream00) {.
    importc, libprag.}

proc play*(self: MediaStream) =
  gtk_media_stream_play(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_realize(self: ptr MediaStream00; surface: ptr gdk4.Surface00) {.
    importc, libprag.}

proc realize*(self: MediaStream; surface: gdk4.Surface) =
  gtk_media_stream_realize(cast[ptr MediaStream00](self.impl), cast[ptr gdk4.Surface00](surface.impl))

proc gtk_media_stream_seek(self: ptr MediaStream00; timestamp: int64) {.
    importc, libprag.}

proc seek*(self: MediaStream; timestamp: int64) =
  gtk_media_stream_seek(cast[ptr MediaStream00](self.impl), timestamp)

proc gtk_media_stream_seek_failed(self: ptr MediaStream00) {.
    importc, libprag.}

proc seekFailed*(self: MediaStream) =
  gtk_media_stream_seek_failed(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_seek_success(self: ptr MediaStream00) {.
    importc, libprag.}

proc seekSuccess*(self: MediaStream) =
  gtk_media_stream_seek_success(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_set_loop(self: ptr MediaStream00; loop: gboolean) {.
    importc, libprag.}

proc setLoop*(self: MediaStream; loop: bool = true) =
  gtk_media_stream_set_loop(cast[ptr MediaStream00](self.impl), gboolean(loop))

proc `loop=`*(self: MediaStream; loop: bool) =
  gtk_media_stream_set_loop(cast[ptr MediaStream00](self.impl), gboolean(loop))

proc gtk_media_stream_set_muted(self: ptr MediaStream00; muted: gboolean) {.
    importc, libprag.}

proc setMuted*(self: MediaStream; muted: bool = true) =
  gtk_media_stream_set_muted(cast[ptr MediaStream00](self.impl), gboolean(muted))

proc `muted=`*(self: MediaStream; muted: bool) =
  gtk_media_stream_set_muted(cast[ptr MediaStream00](self.impl), gboolean(muted))

proc gtk_media_stream_set_playing(self: ptr MediaStream00; playing: gboolean) {.
    importc, libprag.}

proc setPlaying*(self: MediaStream; playing: bool = true) =
  gtk_media_stream_set_playing(cast[ptr MediaStream00](self.impl), gboolean(playing))

proc `playing=`*(self: MediaStream; playing: bool) =
  gtk_media_stream_set_playing(cast[ptr MediaStream00](self.impl), gboolean(playing))

proc gtk_media_stream_set_volume(self: ptr MediaStream00; volume: cdouble) {.
    importc, libprag.}

proc setVolume*(self: MediaStream; volume: cdouble) =
  gtk_media_stream_set_volume(cast[ptr MediaStream00](self.impl), volume)

proc `volume=`*(self: MediaStream; volume: cdouble) =
  gtk_media_stream_set_volume(cast[ptr MediaStream00](self.impl), volume)

proc gtk_media_stream_stream_ended(self: ptr MediaStream00) {.
    importc, libprag.}

proc streamEnded*(self: MediaStream) =
  gtk_media_stream_stream_ended(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_stream_prepared(self: ptr MediaStream00; hasAudio: gboolean;
    hasVideo: gboolean; seekable: gboolean; duration: int64) {.
    importc, libprag.}

proc streamPrepared*(self: MediaStream; hasAudio: bool;
    hasVideo: bool; seekable: bool; duration: int64) =
  gtk_media_stream_stream_prepared(cast[ptr MediaStream00](self.impl), gboolean(hasAudio), gboolean(hasVideo), gboolean(seekable), duration)

proc gtk_media_stream_stream_unprepared(self: ptr MediaStream00) {.
    importc, libprag.}

proc streamUnprepared*(self: MediaStream) =
  gtk_media_stream_stream_unprepared(cast[ptr MediaStream00](self.impl))

proc gtk_media_stream_unrealize(self: ptr MediaStream00; surface: ptr gdk4.Surface00) {.
    importc, libprag.}

proc unrealize*(self: MediaStream; surface: gdk4.Surface) =
  gtk_media_stream_unrealize(cast[ptr MediaStream00](self.impl), cast[ptr gdk4.Surface00](surface.impl))

proc gtk_media_stream_update(self: ptr MediaStream00; timestamp: int64) {.
    importc, libprag.}

proc update*(self: MediaStream; timestamp: int64) =
  gtk_media_stream_update(cast[ptr MediaStream00](self.impl), timestamp)

proc gtk_media_controls_new(stream: ptr MediaStream00): ptr MediaControls00 {.
    importc, libprag.}

proc newMediaControls*(stream: MediaStream = nil): MediaControls =
  let gobj = gtk_media_controls_new(if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMediaControls*(tdesc: typedesc; stream: MediaStream = nil): tdesc =
  assert(result is MediaControls)
  let gobj = gtk_media_controls_new(if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMediaControls*[T](result: var T; stream: MediaStream = nil) {.deprecated.} =
  assert(result is MediaControls)
  let gobj = gtk_media_controls_new(if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_media_controls_get_media_stream(self: ptr MediaControls00): ptr MediaStream00 {.
    importc, libprag.}

proc getMediaStream*(self: MediaControls): MediaStream =
  let gobj = gtk_media_controls_get_media_stream(cast[ptr MediaControls00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc mediaStream*(self: MediaControls): MediaStream =
  let gobj = gtk_media_controls_get_media_stream(cast[ptr MediaControls00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_media_controls_set_media_stream(self: ptr MediaControls00; stream: ptr MediaStream00) {.
    importc, libprag.}

proc setMediaStream*(self: MediaControls; stream: MediaStream = nil) =
  gtk_media_controls_set_media_stream(cast[ptr MediaControls00](self.impl), if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))

proc `mediaStream=`*(self: MediaControls; stream: MediaStream = nil) =
  gtk_media_controls_set_media_stream(cast[ptr MediaControls00](self.impl), if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))

type
  InscriptionOverflow* {.size: sizeof(cint), pure.} = enum
    clip = 0
    ellipsizeStart = 1
    ellipsizeMiddle = 2
    ellipsizeEnd = 3

proc gtk_inscription_get_text_overflow(self: ptr Inscription00): InscriptionOverflow {.
    importc, libprag.}

proc getTextOverflow*(self: Inscription): InscriptionOverflow =
  gtk_inscription_get_text_overflow(cast[ptr Inscription00](self.impl))

proc textOverflow*(self: Inscription): InscriptionOverflow =
  gtk_inscription_get_text_overflow(cast[ptr Inscription00](self.impl))

proc gtk_inscription_set_text_overflow(self: ptr Inscription00; overflow: InscriptionOverflow) {.
    importc, libprag.}

proc setTextOverflow*(self: Inscription; overflow: InscriptionOverflow) =
  gtk_inscription_set_text_overflow(cast[ptr Inscription00](self.impl), overflow)

proc `textOverflow=`*(self: Inscription; overflow: InscriptionOverflow) =
  gtk_inscription_set_text_overflow(cast[ptr Inscription00](self.impl), overflow)

type
  TreeListRow* = ref object of gobject.Object
  TreeListRow00* = object of gobject.Object00

proc gtk_tree_list_row_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeListRow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_list_row_get_child_row(self: ptr TreeListRow00; position: uint32): ptr TreeListRow00 {.
    importc, libprag.}

proc getChildRow*(self: TreeListRow; position: int): TreeListRow =
  let gobj = gtk_tree_list_row_get_child_row(cast[ptr TreeListRow00](self.impl), uint32(position))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_list_row_get_children(self: ptr TreeListRow00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getChildren*(self: TreeListRow): gio.ListModel =
  let gobj = gtk_tree_list_row_get_children(cast[ptr TreeListRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc children*(self: TreeListRow): gio.ListModel =
  let gobj = gtk_tree_list_row_get_children(cast[ptr TreeListRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_list_row_get_depth(self: ptr TreeListRow00): uint32 {.
    importc, libprag.}

proc getDepth*(self: TreeListRow): int =
  int(gtk_tree_list_row_get_depth(cast[ptr TreeListRow00](self.impl)))

proc depth*(self: TreeListRow): int =
  int(gtk_tree_list_row_get_depth(cast[ptr TreeListRow00](self.impl)))

proc gtk_tree_list_row_get_expanded(self: ptr TreeListRow00): gboolean {.
    importc, libprag.}

proc getExpanded*(self: TreeListRow): bool =
  toBool(gtk_tree_list_row_get_expanded(cast[ptr TreeListRow00](self.impl)))

proc expanded*(self: TreeListRow): bool =
  toBool(gtk_tree_list_row_get_expanded(cast[ptr TreeListRow00](self.impl)))

proc gtk_tree_list_row_get_item(self: ptr TreeListRow00): ptr gobject.Object00 {.
    importc, libprag.}

proc getItem*(self: TreeListRow): gobject.Object =
  let gobj = gtk_tree_list_row_get_item(cast[ptr TreeListRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc item*(self: TreeListRow): gobject.Object =
  let gobj = gtk_tree_list_row_get_item(cast[ptr TreeListRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_list_row_get_parent(self: ptr TreeListRow00): ptr TreeListRow00 {.
    importc, libprag.}

proc getParent*(self: TreeListRow): TreeListRow =
  let gobj = gtk_tree_list_row_get_parent(cast[ptr TreeListRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parent*(self: TreeListRow): TreeListRow =
  let gobj = gtk_tree_list_row_get_parent(cast[ptr TreeListRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_list_row_get_position(self: ptr TreeListRow00): uint32 {.
    importc, libprag.}

proc getPosition*(self: TreeListRow): int =
  int(gtk_tree_list_row_get_position(cast[ptr TreeListRow00](self.impl)))

proc position*(self: TreeListRow): int =
  int(gtk_tree_list_row_get_position(cast[ptr TreeListRow00](self.impl)))

proc gtk_tree_list_row_is_expandable(self: ptr TreeListRow00): gboolean {.
    importc, libprag.}

proc isExpandable*(self: TreeListRow): bool =
  toBool(gtk_tree_list_row_is_expandable(cast[ptr TreeListRow00](self.impl)))

proc gtk_tree_list_row_set_expanded(self: ptr TreeListRow00; expanded: gboolean) {.
    importc, libprag.}

proc setExpanded*(self: TreeListRow; expanded: bool = true) =
  gtk_tree_list_row_set_expanded(cast[ptr TreeListRow00](self.impl), gboolean(expanded))

proc `expanded=`*(self: TreeListRow; expanded: bool) =
  gtk_tree_list_row_set_expanded(cast[ptr TreeListRow00](self.impl), gboolean(expanded))

proc gtk_tree_expander_get_list_row(self: ptr TreeExpander00): ptr TreeListRow00 {.
    importc, libprag.}

proc getListRow*(self: TreeExpander): TreeListRow =
  let gobj = gtk_tree_expander_get_list_row(cast[ptr TreeExpander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc listRow*(self: TreeExpander): TreeListRow =
  let gobj = gtk_tree_expander_get_list_row(cast[ptr TreeExpander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_expander_set_list_row(self: ptr TreeExpander00; listRow: ptr TreeListRow00) {.
    importc, libprag.}

proc setListRow*(self: TreeExpander; listRow: TreeListRow = nil) =
  gtk_tree_expander_set_list_row(cast[ptr TreeExpander00](self.impl), if listRow.isNil: nil else: cast[ptr TreeListRow00](listRow.impl))

proc `listRow=`*(self: TreeExpander; listRow: TreeListRow = nil) =
  gtk_tree_expander_set_list_row(cast[ptr TreeExpander00](self.impl), if listRow.isNil: nil else: cast[ptr TreeListRow00](listRow.impl))

type
  ScrollInfo00* {.pure.} = object
  ScrollInfo* = ref object
    impl*: ptr ScrollInfo00
    ignoreFinalizer*: bool

proc gtk_scroll_info_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkScrollInfo*(self: ScrollInfo) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_scroll_info_get_type(), cast[ptr ScrollInfo00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ScrollInfo()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_scroll_info_get_type(), cast[ptr ScrollInfo00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var ScrollInfo) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkScrollInfo)

proc gtk_scroll_info_unref(self: ptr ScrollInfo00) {.
    importc, libprag.}

proc unref*(self: ScrollInfo) =
  gtk_scroll_info_unref(cast[ptr ScrollInfo00](self.impl))

proc finalizerunref*(self: ScrollInfo) =
  if not self.ignoreFinalizer:
    gtk_scroll_info_unref(cast[ptr ScrollInfo00](self.impl))

proc gtk_scroll_info_get_enable_horizontal(self: ptr ScrollInfo00): gboolean {.
    importc, libprag.}

proc getEnableHorizontal*(self: ScrollInfo): bool =
  toBool(gtk_scroll_info_get_enable_horizontal(cast[ptr ScrollInfo00](self.impl)))

proc enableHorizontal*(self: ScrollInfo): bool =
  toBool(gtk_scroll_info_get_enable_horizontal(cast[ptr ScrollInfo00](self.impl)))

proc gtk_scroll_info_get_enable_vertical(self: ptr ScrollInfo00): gboolean {.
    importc, libprag.}

proc getEnableVertical*(self: ScrollInfo): bool =
  toBool(gtk_scroll_info_get_enable_vertical(cast[ptr ScrollInfo00](self.impl)))

proc enableVertical*(self: ScrollInfo): bool =
  toBool(gtk_scroll_info_get_enable_vertical(cast[ptr ScrollInfo00](self.impl)))

proc gtk_scroll_info_ref(self: ptr ScrollInfo00): ptr ScrollInfo00 {.
    importc, libprag.}

proc `ref`*(self: ScrollInfo): ScrollInfo =
  fnew(result, gBoxedFreeGtkScrollInfo)
  result.impl = gtk_scroll_info_ref(cast[ptr ScrollInfo00](self.impl))

proc gtk_scroll_info_set_enable_horizontal(self: ptr ScrollInfo00; horizontal: gboolean) {.
    importc, libprag.}

proc setEnableHorizontal*(self: ScrollInfo; horizontal: bool = true) =
  gtk_scroll_info_set_enable_horizontal(cast[ptr ScrollInfo00](self.impl), gboolean(horizontal))

proc `enableHorizontal=`*(self: ScrollInfo; horizontal: bool) =
  gtk_scroll_info_set_enable_horizontal(cast[ptr ScrollInfo00](self.impl), gboolean(horizontal))

proc gtk_scroll_info_set_enable_vertical(self: ptr ScrollInfo00; vertical: gboolean) {.
    importc, libprag.}

proc setEnableVertical*(self: ScrollInfo; vertical: bool = true) =
  gtk_scroll_info_set_enable_vertical(cast[ptr ScrollInfo00](self.impl), gboolean(vertical))

proc `enableVertical=`*(self: ScrollInfo; vertical: bool) =
  gtk_scroll_info_set_enable_vertical(cast[ptr ScrollInfo00](self.impl), gboolean(vertical))

proc gtk_scroll_info_new(): ptr ScrollInfo00 {.
    importc, libprag.}

proc newScrollInfo*(): ScrollInfo =
  fnew(result, gBoxedFreeGtkScrollInfo)
  result.impl = gtk_scroll_info_new()

proc newScrollInfo*(tdesc: typedesc): tdesc =
  assert(result is ScrollInfo)
  fnew(result, gBoxedFreeGtkScrollInfo)
  result.impl = gtk_scroll_info_new()

proc initScrollInfo*[T](result: var T) {.deprecated.} =
  assert(result is ScrollInfo)
  fnew(result, gBoxedFreeGtkScrollInfo)
  result.impl = gtk_scroll_info_new()

proc gtk_viewport_scroll_to(self: ptr Viewport00; descendant: ptr Widget00;
    scroll: ptr ScrollInfo00) {.
    importc, libprag.}

proc scrollTo*(self: Viewport; descendant: Widget; scroll: ScrollInfo = nil) =
  gtk_viewport_scroll_to(cast[ptr Viewport00](self.impl), cast[ptr Widget00](descendant.impl), if scroll.isNil: nil else: cast[ptr ScrollInfo00](g_boxed_copy(gtk_scroll_info_get_type(), scroll.impl)))

type
  WindowGroup* = ref object of gobject.Object
  WindowGroup00* = object of gobject.Object00

proc gtk_window_group_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(WindowGroup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_window_group_new(): ptr WindowGroup00 {.
    importc, libprag.}

proc newWindowGroup*(): WindowGroup =
  let gobj = gtk_window_group_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newWindowGroup*(tdesc: typedesc): tdesc =
  assert(result is WindowGroup)
  let gobj = gtk_window_group_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initWindowGroup*[T](result: var T) {.deprecated.} =
  assert(result is WindowGroup)
  let gobj = gtk_window_group_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_group_add_window(self: ptr WindowGroup00; window: ptr Window00) {.
    importc, libprag.}

proc addWindow*(self: WindowGroup; window: Window) =
  gtk_window_group_add_window(cast[ptr WindowGroup00](self.impl), cast[ptr Window00](window.impl))

proc gtk_window_group_list_windows(self: ptr WindowGroup00): ptr glib.List {.
    importc, libprag.}

proc listWindows*(self: WindowGroup): seq[Window] =
  let resul0 = gtk_window_group_list_windows(cast[ptr WindowGroup00](self.impl))
  result = glistObjects2seq(Window, resul0, false)
  g_list_free(resul0)

proc gtk_window_group_remove_window(self: ptr WindowGroup00; window: ptr Window00) {.
    importc, libprag.}

proc removeWindow*(self: WindowGroup; window: Window) =
  gtk_window_group_remove_window(cast[ptr WindowGroup00](self.impl), cast[ptr Window00](window.impl))

proc gtk_window_get_group(self: ptr Window00): ptr WindowGroup00 {.
    importc, libprag.}

proc getGroup*(self: Window): WindowGroup =
  let gobj = gtk_window_get_group(cast[ptr Window00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc group*(self: Window): WindowGroup =
  let gobj = gtk_window_get_group(cast[ptr Window00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Application* = ref object of gio.GApplication
  Application00* = object of gio.GApplication00

proc gtk_application_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Application()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scQueryEnd*(self: Application;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "query-end", cast[GCallback](p), xdata, nil, cf)

proc scWindowAdded*(self: Application;  p: proc (self: ptr Application00; window: ptr Window00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "window-added", cast[GCallback](p), xdata, nil, cf)

proc scWindowRemoved*(self: Application;  p: proc (self: ptr Application00; window: ptr Window00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "window-removed", cast[GCallback](p), xdata, nil, cf)

proc gtk_application_new(applicationId: cstring; flags: gio.ApplicationFlags): ptr Application00 {.
    importc, libprag.}

proc newApplication*(applicationId: cstring = nil; flags: gio.ApplicationFlags = {}): Application =
  let gobj = gtk_application_new(applicationId, flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newApplication*(tdesc: typedesc; applicationId: cstring = nil; flags: gio.ApplicationFlags = {}): tdesc =
  assert(result is Application)
  let gobj = gtk_application_new(applicationId, flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initApplication*[T](result: var T; applicationId: cstring = nil; flags: gio.ApplicationFlags = {}) {.deprecated.} =
  assert(result is Application)
  let gobj = gtk_application_new(applicationId, flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_add_window(self: ptr Application00; window: ptr Window00) {.
    importc, libprag.}

proc addWindow*(self: Application; window: Window) =
  gtk_application_add_window(cast[ptr Application00](self.impl), cast[ptr Window00](window.impl))

proc gtk_application_get_accels_for_action(self: ptr Application00; detailedActionName: cstring): ptr cstring {.
    importc, libprag.}

proc getAccelsForAction*(self: Application; detailedActionName: cstring): seq[string] =
  let resul0 = gtk_application_get_accels_for_action(cast[ptr Application00](self.impl), detailedActionName)
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_application_get_actions_for_accel(self: ptr Application00; accel: cstring): ptr cstring {.
    importc, libprag.}

proc getActionsForAccel*(self: Application; accel: cstring): seq[string] =
  let resul0 = gtk_application_get_actions_for_accel(cast[ptr Application00](self.impl), accel)
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_application_get_active_window(self: ptr Application00): ptr Window00 {.
    importc, libprag.}

proc getActiveWindow*(self: Application): Window =
  let gobj = gtk_application_get_active_window(cast[ptr Application00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc activeWindow*(self: Application): Window =
  let gobj = gtk_application_get_active_window(cast[ptr Application00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_menu_by_id(self: ptr Application00; id: cstring): ptr gio.Menu00 {.
    importc, libprag.}

proc getMenuById*(self: Application; id: cstring): gio.Menu =
  let gobj = gtk_application_get_menu_by_id(cast[ptr Application00](self.impl), id)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_menubar(self: ptr Application00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getMenubar*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_menubar(cast[ptr Application00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menubar*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_menubar(cast[ptr Application00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_window_by_id(self: ptr Application00; id: uint32): ptr Window00 {.
    importc, libprag.}

proc getWindowById*(self: Application; id: int): Window =
  let gobj = gtk_application_get_window_by_id(cast[ptr Application00](self.impl), uint32(id))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_windows(self: ptr Application00): ptr glib.List {.
    importc, libprag.}

proc getWindows*(self: Application): seq[Window] =
  result = glistObjects2seq(Window, gtk_application_get_windows(cast[ptr Application00](self.impl)), false)

proc windows*(self: Application): seq[Window] =
  result = glistObjects2seq(Window, gtk_application_get_windows(cast[ptr Application00](self.impl)), false)

proc gtk_application_list_action_descriptions(self: ptr Application00): ptr cstring {.
    importc, libprag.}

proc listActionDescriptions*(self: Application): seq[string] =
  let resul0 = gtk_application_list_action_descriptions(cast[ptr Application00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_application_remove_window(self: ptr Application00; window: ptr Window00) {.
    importc, libprag.}

proc removeWindow*(self: Application; window: Window) =
  gtk_application_remove_window(cast[ptr Application00](self.impl), cast[ptr Window00](window.impl))

proc gtk_application_set_accels_for_action(self: ptr Application00; detailedActionName: cstring;
    accels: ptr cstring) {.
    importc, libprag.}

proc setAccelsForAction*(self: Application; detailedActionName: cstring;
    accels: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_application_set_accels_for_action(cast[ptr Application00](self.impl), detailedActionName, seq2CstringArray(accels, fs469n23))

proc gtk_application_set_menubar(self: ptr Application00; menubar: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setMenubar*(self: Application; menubar: gio.MenuModel = nil) =
  gtk_application_set_menubar(cast[ptr Application00](self.impl), if menubar.isNil: nil else: cast[ptr gio.MenuModel00](menubar.impl))

proc `menubar=`*(self: Application; menubar: gio.MenuModel = nil) =
  gtk_application_set_menubar(cast[ptr Application00](self.impl), if menubar.isNil: nil else: cast[ptr gio.MenuModel00](menubar.impl))

proc gtk_application_uninhibit(self: ptr Application00; cookie: uint32) {.
    importc, libprag.}

proc uninhibit*(self: Application; cookie: int) =
  gtk_application_uninhibit(cast[ptr Application00](self.impl), uint32(cookie))

proc gtk_window_get_application(self: ptr Window00): ptr Application00 {.
    importc, libprag.}

proc getApplication*(self: Window): Application =
  let gobj = gtk_window_get_application(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc application*(self: Window): Application =
  let gobj = gtk_window_get_application(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_set_application(self: ptr Window00; application: ptr Application00) {.
    importc, libprag.}

proc setApplication*(self: Window; application: Application = nil) =
  gtk_window_set_application(cast[ptr Window00](self.impl), if application.isNil: nil else: cast[ptr Application00](application.impl))

proc `application=`*(self: Window; application: Application = nil) =
  gtk_window_set_application(cast[ptr Window00](self.impl), if application.isNil: nil else: cast[ptr Application00](application.impl))

type
  ApplicationInhibitFlag* {.size: sizeof(cint), pure.} = enum
    logout = 0
    switch = 1
    suspend = 2
    idle = 3

  ApplicationInhibitFlags* = set[ApplicationInhibitFlag]

proc gtk_application_inhibit(self: ptr Application00; window: ptr Window00;
    flags: ApplicationInhibitFlags; reason: cstring): uint32 {.
    importc, libprag.}

proc inhibit*(self: Application; window: Window = nil; flags: ApplicationInhibitFlags;
    reason: cstring = nil): int =
  int(gtk_application_inhibit(cast[ptr Application00](self.impl), if window.isNil: nil else: cast[ptr Window00](window.impl), flags, reason))

type
  Box* = ref object of Widget
  Box00* = object of Widget00

proc gtk_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Box()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_box_append(self: ptr Box00; child: ptr Widget00) {.
    importc, libprag.}

proc append*(self: Box; child: Widget) =
  gtk_box_append(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_box_get_baseline_child(self: ptr Box00): int32 {.
    importc, libprag.}

proc getBaselineChild*(self: Box): int =
  int(gtk_box_get_baseline_child(cast[ptr Box00](self.impl)))

proc baselineChild*(self: Box): int =
  int(gtk_box_get_baseline_child(cast[ptr Box00](self.impl)))

proc gtk_box_get_homogeneous(self: ptr Box00): gboolean {.
    importc, libprag.}

proc getHomogeneous*(self: Box): bool =
  toBool(gtk_box_get_homogeneous(cast[ptr Box00](self.impl)))

proc homogeneous*(self: Box): bool =
  toBool(gtk_box_get_homogeneous(cast[ptr Box00](self.impl)))

proc gtk_box_get_spacing(self: ptr Box00): int32 {.
    importc, libprag.}

proc getSpacing*(self: Box): int =
  int(gtk_box_get_spacing(cast[ptr Box00](self.impl)))

proc spacing*(self: Box): int =
  int(gtk_box_get_spacing(cast[ptr Box00](self.impl)))

proc gtk_box_insert_child_after(self: ptr Box00; child: ptr Widget00; sibling: ptr Widget00) {.
    importc, libprag.}

proc insertChildAfter*(self: Box; child: Widget; sibling: Widget = nil) =
  gtk_box_insert_child_after(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), if sibling.isNil: nil else: cast[ptr Widget00](sibling.impl))

proc gtk_box_prepend(self: ptr Box00; child: ptr Widget00) {.
    importc, libprag.}

proc prepend*(self: Box; child: Widget) =
  gtk_box_prepend(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_box_remove(self: ptr Box00; child: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: Box; child: Widget) =
  gtk_box_remove(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_box_reorder_child_after(self: ptr Box00; child: ptr Widget00; sibling: ptr Widget00) {.
    importc, libprag.}

proc reorderChildAfter*(self: Box; child: Widget; sibling: Widget = nil) =
  gtk_box_reorder_child_after(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), if sibling.isNil: nil else: cast[ptr Widget00](sibling.impl))

proc gtk_box_set_baseline_child(self: ptr Box00; child: int32) {.
    importc, libprag.}

proc setBaselineChild*(self: Box; child: int) =
  gtk_box_set_baseline_child(cast[ptr Box00](self.impl), int32(child))

proc `baselineChild=`*(self: Box; child: int) =
  gtk_box_set_baseline_child(cast[ptr Box00](self.impl), int32(child))

proc gtk_box_set_homogeneous(self: ptr Box00; homogeneous: gboolean) {.
    importc, libprag.}

proc setHomogeneous*(self: Box; homogeneous: bool = true) =
  gtk_box_set_homogeneous(cast[ptr Box00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: Box; homogeneous: bool) =
  gtk_box_set_homogeneous(cast[ptr Box00](self.impl), gboolean(homogeneous))

proc gtk_box_set_spacing(self: ptr Box00; spacing: int32) {.
    importc, libprag.}

proc setSpacing*(self: Box; spacing: int) =
  gtk_box_set_spacing(cast[ptr Box00](self.impl), int32(spacing))

proc `spacing=`*(self: Box; spacing: int) =
  gtk_box_set_spacing(cast[ptr Box00](self.impl), int32(spacing))

type
  ShortcutsSection* = ref object of Box
  ShortcutsSection00* = object of Box00

proc gtk_shortcuts_section_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutsSection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChangeCurrentPage*(self: ShortcutsSection;  p: proc (self: ptr ShortcutsSection00; obj: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "change-current-page", cast[GCallback](p), xdata, nil, cf)

type
  ShortcutsGroup* = ref object of Box
  ShortcutsGroup00* = object of Box00

proc gtk_shortcuts_group_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutsGroup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_dialog_get_content_area(self: ptr Dialog00): ptr Box00 {.
    importc, libprag.}

proc getContentArea*(self: Dialog): Box =
  let gobj = gtk_dialog_get_content_area(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc contentArea*(self: Dialog): Box =
  let gobj = gtk_dialog_get_content_area(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcuts_window_add_section(self: ptr ShortcutsWindow00; section: ptr ShortcutsSection00) {.
    importc, libprag.}

proc addSection*(self: ShortcutsWindow; section: ShortcutsSection) =
  gtk_shortcuts_window_add_section(cast[ptr ShortcutsWindow00](self.impl), cast[ptr ShortcutsSection00](section.impl))

proc gtk_shortcuts_section_add_group(self: ptr ShortcutsSection00; group: ptr ShortcutsGroup00) {.
    importc, libprag.}

proc addGroup*(self: ShortcutsSection; group: ShortcutsGroup) =
  gtk_shortcuts_section_add_group(cast[ptr ShortcutsSection00](self.impl), cast[ptr ShortcutsGroup00](group.impl))

type
  ColorChooserWidget* = ref object of Widget
  ColorChooserWidget00* = object of Widget00

proc gtk_color_chooser_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorChooserWidget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_color_chooser_widget_new(): ptr ColorChooserWidget00 {.
    importc, libprag.}

proc newColorChooserWidget*(): ColorChooserWidget =
  let gobj = gtk_color_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorChooserWidget*(tdesc: typedesc): tdesc =
  assert(result is ColorChooserWidget)
  let gobj = gtk_color_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorChooserWidget*[T](result: var T) {.deprecated.} =
  assert(result is ColorChooserWidget)
  let gobj = gtk_color_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Button* = ref object of Widget
  Button00* = object of Widget00

proc gtk_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Button()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scClicked*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "clicked", cast[GCallback](p), xdata, nil, cf)

proc gtk_button_new(): ptr Button00 {.
    importc, libprag.}

proc newButton*(): Button =
  let gobj = gtk_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButton*(tdesc: typedesc): tdesc =
  assert(result is Button)
  let gobj = gtk_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButton*[T](result: var T) {.deprecated.} =
  assert(result is Button)
  let gobj = gtk_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_from_icon_name(iconName: cstring): ptr Button00 {.
    importc, libprag.}

proc newButtonFromIconName*(iconName: cstring): Button =
  let gobj = gtk_button_new_from_icon_name(iconName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButtonFromIconName*(tdesc: typedesc; iconName: cstring): tdesc =
  assert(result is Button)
  let gobj = gtk_button_new_from_icon_name(iconName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonFromIconName*[T](result: var T; iconName: cstring) {.deprecated.} =
  assert(result is Button)
  let gobj = gtk_button_new_from_icon_name(iconName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_with_label(label: cstring): ptr Button00 {.
    importc, libprag.}

proc newButton*(label: cstring): Button =
  let gobj = gtk_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButton*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is Button)
  let gobj = gtk_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButton*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is Button)
  let gobj = gtk_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_with_mnemonic(label: cstring): ptr Button00 {.
    importc, libprag.}

proc newButtonWithMnemonic*(label: cstring): Button =
  let gobj = gtk_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButtonWithMnemonic*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is Button)
  let gobj = gtk_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonWithMnemonic*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is Button)
  let gobj = gtk_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_get_can_shrink(self: ptr Button00): gboolean {.
    importc, libprag.}

proc getCanShrink*(self: Button): bool =
  toBool(gtk_button_get_can_shrink(cast[ptr Button00](self.impl)))

proc canShrink*(self: Button): bool =
  toBool(gtk_button_get_can_shrink(cast[ptr Button00](self.impl)))

proc gtk_button_get_child(self: ptr Button00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: Button): Widget =
  let gobj = gtk_button_get_child(cast[ptr Button00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Button): Widget =
  let gobj = gtk_button_get_child(cast[ptr Button00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_get_has_frame(self: ptr Button00): gboolean {.
    importc, libprag.}

proc getHasFrame*(self: Button): bool =
  toBool(gtk_button_get_has_frame(cast[ptr Button00](self.impl)))

proc hasFrame*(self: Button): bool =
  toBool(gtk_button_get_has_frame(cast[ptr Button00](self.impl)))

proc gtk_button_get_icon_name(self: ptr Button00): cstring {.
    importc, libprag.}

proc getIconName*(self: Button): string =
  let resul0 = gtk_button_get_icon_name(cast[ptr Button00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc iconName*(self: Button): string =
  let resul0 = gtk_button_get_icon_name(cast[ptr Button00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_button_get_label(self: ptr Button00): cstring {.
    importc, libprag.}

proc getLabel*(self: Button): string =
  let resul0 = gtk_button_get_label(cast[ptr Button00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc label*(self: Button): string =
  let resul0 = gtk_button_get_label(cast[ptr Button00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_button_get_use_underline(self: ptr Button00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: Button): bool =
  toBool(gtk_button_get_use_underline(cast[ptr Button00](self.impl)))

proc useUnderline*(self: Button): bool =
  toBool(gtk_button_get_use_underline(cast[ptr Button00](self.impl)))

proc gtk_button_set_can_shrink(self: ptr Button00; canShrink: gboolean) {.
    importc, libprag.}

proc setCanShrink*(self: Button; canShrink: bool = true) =
  gtk_button_set_can_shrink(cast[ptr Button00](self.impl), gboolean(canShrink))

proc `canShrink=`*(self: Button; canShrink: bool) =
  gtk_button_set_can_shrink(cast[ptr Button00](self.impl), gboolean(canShrink))

proc gtk_button_set_child(self: ptr Button00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: Button; child: Widget = nil) =
  gtk_button_set_child(cast[ptr Button00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: Button; child: Widget = nil) =
  gtk_button_set_child(cast[ptr Button00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_button_set_has_frame(self: ptr Button00; hasFrame: gboolean) {.
    importc, libprag.}

proc setHasFrame*(self: Button; hasFrame: bool = true) =
  gtk_button_set_has_frame(cast[ptr Button00](self.impl), gboolean(hasFrame))

proc `hasFrame=`*(self: Button; hasFrame: bool) =
  gtk_button_set_has_frame(cast[ptr Button00](self.impl), gboolean(hasFrame))

proc gtk_button_set_icon_name(self: ptr Button00; iconName: cstring) {.
    importc, libprag.}

proc setIconName*(self: Button; iconName: cstring) =
  gtk_button_set_icon_name(cast[ptr Button00](self.impl), iconName)

proc `iconName=`*(self: Button; iconName: cstring) =
  gtk_button_set_icon_name(cast[ptr Button00](self.impl), iconName)

proc gtk_button_set_label(self: ptr Button00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: Button; label: cstring) =
  gtk_button_set_label(cast[ptr Button00](self.impl), label)

proc `label=`*(self: Button; label: cstring) =
  gtk_button_set_label(cast[ptr Button00](self.impl), label)

proc gtk_button_set_use_underline(self: ptr Button00; useUnderline: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: Button; useUnderline: bool = true) =
  gtk_button_set_use_underline(cast[ptr Button00](self.impl), gboolean(useUnderline))

proc `useUnderline=`*(self: Button; useUnderline: bool) =
  gtk_button_set_use_underline(cast[ptr Button00](self.impl), gboolean(useUnderline))

type
  LinkButton* = ref object of Button
  LinkButton00* = object of Button00

proc gtk_link_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LinkButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateLink*(self: LinkButton;  p: proc (self: ptr LinkButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-link", cast[GCallback](p), xdata, nil, cf)

proc gtk_link_button_new(uri: cstring): ptr LinkButton00 {.
    importc, libprag.}

proc newLinkButton*(uri: cstring): LinkButton =
  let gobj = gtk_link_button_new(uri)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLinkButton*(tdesc: typedesc; uri: cstring): tdesc =
  assert(result is LinkButton)
  let gobj = gtk_link_button_new(uri)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLinkButton*[T](result: var T; uri: cstring) {.deprecated.} =
  assert(result is LinkButton)
  let gobj = gtk_link_button_new(uri)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_link_button_new_with_label(uri: cstring; label: cstring): ptr LinkButton00 {.
    importc, libprag.}

proc newLinkButton*(uri: cstring; label: cstring): LinkButton =
  let gobj = gtk_link_button_new_with_label(uri, label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLinkButton*(tdesc: typedesc; uri: cstring; label: cstring): tdesc =
  assert(result is LinkButton)
  let gobj = gtk_link_button_new_with_label(uri, label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLinkButton*[T](result: var T; uri: cstring; label: cstring) {.deprecated.} =
  assert(result is LinkButton)
  let gobj = gtk_link_button_new_with_label(uri, label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_link_button_get_uri(self: ptr LinkButton00): cstring {.
    importc, libprag.}

proc getUri*(self: LinkButton): string =
  result = $gtk_link_button_get_uri(cast[ptr LinkButton00](self.impl))

proc uri*(self: LinkButton): string =
  result = $gtk_link_button_get_uri(cast[ptr LinkButton00](self.impl))

proc gtk_link_button_get_visited(self: ptr LinkButton00): gboolean {.
    importc, libprag.}

proc getVisited*(self: LinkButton): bool =
  toBool(gtk_link_button_get_visited(cast[ptr LinkButton00](self.impl)))

proc visited*(self: LinkButton): bool =
  toBool(gtk_link_button_get_visited(cast[ptr LinkButton00](self.impl)))

proc gtk_link_button_set_uri(self: ptr LinkButton00; uri: cstring) {.
    importc, libprag.}

proc setUri*(self: LinkButton; uri: cstring) =
  gtk_link_button_set_uri(cast[ptr LinkButton00](self.impl), uri)

proc `uri=`*(self: LinkButton; uri: cstring) =
  gtk_link_button_set_uri(cast[ptr LinkButton00](self.impl), uri)

proc gtk_link_button_set_visited(self: ptr LinkButton00; visited: gboolean) {.
    importc, libprag.}

proc setVisited*(self: LinkButton; visited: bool = true) =
  gtk_link_button_set_visited(cast[ptr LinkButton00](self.impl), gboolean(visited))

proc `visited=`*(self: LinkButton; visited: bool) =
  gtk_link_button_set_visited(cast[ptr LinkButton00](self.impl), gboolean(visited))

type
  Stack* = ref object of Widget
  Stack00* = object of Widget00

proc gtk_stack_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Stack()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_stack_new(): ptr Stack00 {.
    importc, libprag.}

proc newStack*(): Stack =
  let gobj = gtk_stack_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStack*(tdesc: typedesc): tdesc =
  assert(result is Stack)
  let gobj = gtk_stack_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStack*[T](result: var T) {.deprecated.} =
  assert(result is Stack)
  let gobj = gtk_stack_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_get_child_by_name(self: ptr Stack00; name: cstring): ptr Widget00 {.
    importc, libprag.}

proc getChildByName*(self: Stack; name: cstring): Widget =
  let gobj = gtk_stack_get_child_by_name(cast[ptr Stack00](self.impl), name)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_get_hhomogeneous(self: ptr Stack00): gboolean {.
    importc, libprag.}

proc getHhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_hhomogeneous(cast[ptr Stack00](self.impl)))

proc hhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_hhomogeneous(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_interpolate_size(self: ptr Stack00): gboolean {.
    importc, libprag.}

proc getInterpolateSize*(self: Stack): bool =
  toBool(gtk_stack_get_interpolate_size(cast[ptr Stack00](self.impl)))

proc interpolateSize*(self: Stack): bool =
  toBool(gtk_stack_get_interpolate_size(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_transition_duration(self: ptr Stack00): uint32 {.
    importc, libprag.}

proc getTransitionDuration*(self: Stack): int =
  int(gtk_stack_get_transition_duration(cast[ptr Stack00](self.impl)))

proc transitionDuration*(self: Stack): int =
  int(gtk_stack_get_transition_duration(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_transition_running(self: ptr Stack00): gboolean {.
    importc, libprag.}

proc getTransitionRunning*(self: Stack): bool =
  toBool(gtk_stack_get_transition_running(cast[ptr Stack00](self.impl)))

proc transitionRunning*(self: Stack): bool =
  toBool(gtk_stack_get_transition_running(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_vhomogeneous(self: ptr Stack00): gboolean {.
    importc, libprag.}

proc getVhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_vhomogeneous(cast[ptr Stack00](self.impl)))

proc vhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_vhomogeneous(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_visible_child(self: ptr Stack00): ptr Widget00 {.
    importc, libprag.}

proc getVisibleChild*(self: Stack): Widget =
  let gobj = gtk_stack_get_visible_child(cast[ptr Stack00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc visibleChild*(self: Stack): Widget =
  let gobj = gtk_stack_get_visible_child(cast[ptr Stack00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_get_visible_child_name(self: ptr Stack00): cstring {.
    importc, libprag.}

proc getVisibleChildName*(self: Stack): string =
  let resul0 = gtk_stack_get_visible_child_name(cast[ptr Stack00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc visibleChildName*(self: Stack): string =
  let resul0 = gtk_stack_get_visible_child_name(cast[ptr Stack00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_stack_remove(self: ptr Stack00; child: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: Stack; child: Widget) =
  gtk_stack_remove(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_stack_set_hhomogeneous(self: ptr Stack00; hhomogeneous: gboolean) {.
    importc, libprag.}

proc setHhomogeneous*(self: Stack; hhomogeneous: bool = true) =
  gtk_stack_set_hhomogeneous(cast[ptr Stack00](self.impl), gboolean(hhomogeneous))

proc `hhomogeneous=`*(self: Stack; hhomogeneous: bool) =
  gtk_stack_set_hhomogeneous(cast[ptr Stack00](self.impl), gboolean(hhomogeneous))

proc gtk_stack_set_interpolate_size(self: ptr Stack00; interpolateSize: gboolean) {.
    importc, libprag.}

proc setInterpolateSize*(self: Stack; interpolateSize: bool = true) =
  gtk_stack_set_interpolate_size(cast[ptr Stack00](self.impl), gboolean(interpolateSize))

proc `interpolateSize=`*(self: Stack; interpolateSize: bool) =
  gtk_stack_set_interpolate_size(cast[ptr Stack00](self.impl), gboolean(interpolateSize))

proc gtk_stack_set_transition_duration(self: ptr Stack00; duration: uint32) {.
    importc, libprag.}

proc setTransitionDuration*(self: Stack; duration: int) =
  gtk_stack_set_transition_duration(cast[ptr Stack00](self.impl), uint32(duration))

proc `transitionDuration=`*(self: Stack; duration: int) =
  gtk_stack_set_transition_duration(cast[ptr Stack00](self.impl), uint32(duration))

proc gtk_stack_set_vhomogeneous(self: ptr Stack00; vhomogeneous: gboolean) {.
    importc, libprag.}

proc setVhomogeneous*(self: Stack; vhomogeneous: bool = true) =
  gtk_stack_set_vhomogeneous(cast[ptr Stack00](self.impl), gboolean(vhomogeneous))

proc `vhomogeneous=`*(self: Stack; vhomogeneous: bool) =
  gtk_stack_set_vhomogeneous(cast[ptr Stack00](self.impl), gboolean(vhomogeneous))

proc gtk_stack_set_visible_child(self: ptr Stack00; child: ptr Widget00) {.
    importc, libprag.}

proc setVisibleChild*(self: Stack; child: Widget) =
  gtk_stack_set_visible_child(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl))

proc `visibleChild=`*(self: Stack; child: Widget) =
  gtk_stack_set_visible_child(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_stack_set_visible_child_name(self: ptr Stack00; name: cstring) {.
    importc, libprag.}

proc setVisibleChildName*(self: Stack; name: cstring) =
  gtk_stack_set_visible_child_name(cast[ptr Stack00](self.impl), name)

proc `visibleChildName=`*(self: Stack; name: cstring) =
  gtk_stack_set_visible_child_name(cast[ptr Stack00](self.impl), name)

type
  ComboBox* = ref object of Widget
  ComboBox00* = object of Widget00

proc gtk_combo_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ComboBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scChanged*(self: ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scFormatEntryText*(self: ComboBox;  p: proc (self: ptr ComboBox00; path: cstring; xdata: pointer): cstring {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "format-entry-text", cast[GCallback](p), xdata, nil, cf)

proc scMoveActive*(self: ComboBox;  p: proc (self: ptr ComboBox00; scrollType: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-active", cast[GCallback](p), xdata, nil, cf)

proc scPopdown*(self: ComboBox;  p: proc (self: ptr ComboBox00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popdown", cast[GCallback](p), xdata, nil, cf)

proc scPopup*(self: ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popup", cast[GCallback](p), xdata, nil, cf)

proc gtk_combo_box_new(): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBox*(): ComboBox {.deprecated.}  =
  let gobj = gtk_combo_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBox*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBox*[T](result: var T) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_entry(): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBoxWithEntry*(): ComboBox {.deprecated.}  =
  let gobj = gtk_combo_box_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxWithEntry*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithEntry*[T](result: var T) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_get_active(self: ptr ComboBox00): int32 {.
    importc, libprag.}

proc getActive*(self: ComboBox): int =
  int(gtk_combo_box_get_active(cast[ptr ComboBox00](self.impl)))

proc active*(self: ComboBox): int =
  int(gtk_combo_box_get_active(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_active_id(self: ptr ComboBox00): cstring {.
    importc, libprag.}

proc getActiveId*(self: ComboBox): string =
  let resul0 = gtk_combo_box_get_active_id(cast[ptr ComboBox00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc activeId*(self: ComboBox): string =
  let resul0 = gtk_combo_box_get_active_id(cast[ptr ComboBox00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_combo_box_get_child(self: ptr ComboBox00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: ComboBox): Widget =
  let gobj = gtk_combo_box_get_child(cast[ptr ComboBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: ComboBox): Widget =
  let gobj = gtk_combo_box_get_child(cast[ptr ComboBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_get_entry_text_column(self: ptr ComboBox00): int32 {.
    importc, libprag.}

proc getEntryTextColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_entry_text_column(cast[ptr ComboBox00](self.impl)))

proc entryTextColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_entry_text_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_has_entry(self: ptr ComboBox00): gboolean {.
    importc, libprag.}

proc getHasEntry*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_has_entry(cast[ptr ComboBox00](self.impl)))

proc hasEntry*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_has_entry(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_id_column(self: ptr ComboBox00): int32 {.
    importc, libprag.}

proc getIdColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_id_column(cast[ptr ComboBox00](self.impl)))

proc idColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_id_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_popup_fixed_width(self: ptr ComboBox00): gboolean {.
    importc, libprag.}

proc getPopupFixedWidth*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_popup_fixed_width(cast[ptr ComboBox00](self.impl)))

proc popupFixedWidth*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_popup_fixed_width(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_popdown(self: ptr ComboBox00) {.
    importc, libprag.}

proc popdown*(self: ComboBox) =
  gtk_combo_box_popdown(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_popup(self: ptr ComboBox00) {.
    importc, libprag.}

proc popup*(self: ComboBox) =
  gtk_combo_box_popup(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_popup_for_device(self: ptr ComboBox00; device: ptr gdk4.Device00) {.
    importc, libprag.}

proc popupForDevice*(self: ComboBox; device: gdk4.Device) =
  gtk_combo_box_popup_for_device(cast[ptr ComboBox00](self.impl), cast[ptr gdk4.Device00](device.impl))

proc gtk_combo_box_set_active(self: ptr ComboBox00; index: int32) {.
    importc, libprag.}

proc setActive*(self: ComboBox; index: int) =
  gtk_combo_box_set_active(cast[ptr ComboBox00](self.impl), int32(index))

proc `active=`*(self: ComboBox; index: int) =
  gtk_combo_box_set_active(cast[ptr ComboBox00](self.impl), int32(index))

proc gtk_combo_box_set_active_id(self: ptr ComboBox00; activeId: cstring): gboolean {.
    importc, libprag.}

proc setActiveId*(self: ComboBox; activeId: cstring = nil): bool =
  toBool(gtk_combo_box_set_active_id(cast[ptr ComboBox00](self.impl), activeId))

proc gtk_combo_box_set_child(self: ptr ComboBox00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: ComboBox; child: Widget = nil) =
  gtk_combo_box_set_child(cast[ptr ComboBox00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: ComboBox; child: Widget = nil) =
  gtk_combo_box_set_child(cast[ptr ComboBox00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_combo_box_set_entry_text_column(self: ptr ComboBox00; textColumn: int32) {.
    importc, libprag.}

proc setEntryTextColumn*(self: ComboBox; textColumn: int) =
  gtk_combo_box_set_entry_text_column(cast[ptr ComboBox00](self.impl), int32(textColumn))

proc `entryTextColumn=`*(self: ComboBox; textColumn: int) =
  gtk_combo_box_set_entry_text_column(cast[ptr ComboBox00](self.impl), int32(textColumn))

proc gtk_combo_box_set_id_column(self: ptr ComboBox00; idColumn: int32) {.
    importc, libprag.}

proc setIdColumn*(self: ComboBox; idColumn: int) =
  gtk_combo_box_set_id_column(cast[ptr ComboBox00](self.impl), int32(idColumn))

proc `idColumn=`*(self: ComboBox; idColumn: int) =
  gtk_combo_box_set_id_column(cast[ptr ComboBox00](self.impl), int32(idColumn))

proc gtk_combo_box_set_popup_fixed_width(self: ptr ComboBox00; fixed: gboolean) {.
    importc, libprag.}

proc setPopupFixedWidth*(self: ComboBox; fixed: bool = true) =
  gtk_combo_box_set_popup_fixed_width(cast[ptr ComboBox00](self.impl), gboolean(fixed))

proc `popupFixedWidth=`*(self: ComboBox; fixed: bool) =
  gtk_combo_box_set_popup_fixed_width(cast[ptr ComboBox00](self.impl), gboolean(fixed))

type
  Image* = ref object of Widget
  Image00* = object of Widget00

proc gtk_image_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Image()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_image_new(): ptr Image00 {.
    importc, libprag.}

proc newImage*(): Image =
  let gobj = gtk_image_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImage*(tdesc: typedesc): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImage*[T](result: var T) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_file(filename: cstring): ptr Image00 {.
    importc, libprag.}

proc newImageFromFile*(filename: cstring): Image =
  let gobj = gtk_image_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromFile*(tdesc: typedesc; filename: cstring): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromFile*[T](result: var T; filename: cstring) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_gicon(icon: ptr gio.Icon00): ptr Image00 {.
    importc, libprag.}

proc newImageFromGicon*(icon: gio.Icon): Image =
  let gobj = gtk_image_new_from_gicon(cast[ptr gio.Icon00](icon.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromGicon*(tdesc: typedesc; icon: gio.Icon): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_gicon(cast[ptr gio.Icon00](icon.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromGicon*[T](result: var T; icon: gio.Icon) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_gicon(cast[ptr gio.Icon00](icon.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_icon_name(iconName: cstring): ptr Image00 {.
    importc, libprag.}

proc newImageFromIconName*(iconName: cstring = nil): Image =
  let gobj = gtk_image_new_from_icon_name(iconName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromIconName*(tdesc: typedesc; iconName: cstring = nil): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_icon_name(iconName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromIconName*[T](result: var T; iconName: cstring = nil) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_icon_name(iconName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_paintable(paintable: ptr gdk4.Paintable00): ptr Image00 {.
    importc, libprag.}

proc newImageFromPaintable*(paintable: gdk4.Paintable = nil): Image =
  let gobj = gtk_image_new_from_paintable(if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromPaintable*(tdesc: typedesc; paintable: gdk4.Paintable = nil): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_paintable(if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromPaintable*[T](result: var T; paintable: gdk4.Paintable = nil) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_paintable(if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_pixbuf(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr Image00 {.
    importc, libprag.}

proc newImageFromPixbuf*(pixbuf: gdkpixbuf.Pixbuf = nil): Image {.deprecated.}  =
  let gobj = gtk_image_new_from_pixbuf(if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromPixbuf*(tdesc: typedesc; pixbuf: gdkpixbuf.Pixbuf = nil): tdesc {.deprecated.}  =
  assert(result is Image)
  let gobj = gtk_image_new_from_pixbuf(if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf = nil) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_pixbuf(if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_resource(resourcePath: cstring): ptr Image00 {.
    importc, libprag.}

proc newImageFromResource*(resourcePath: cstring): Image =
  let gobj = gtk_image_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromResource*(tdesc: typedesc; resourcePath: cstring): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromResource*[T](result: var T; resourcePath: cstring) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_clear(self: ptr Image00) {.
    importc, libprag.}

proc clear*(self: Image) =
  gtk_image_clear(cast[ptr Image00](self.impl))

proc gtk_image_get_gicon(self: ptr Image00): ptr gio.Icon00 {.
    importc, libprag.}

proc getGicon*(self: Image): gio.Icon =
  let gobj = gtk_image_get_gicon(cast[ptr Image00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gicon*(self: Image): gio.Icon =
  let gobj = gtk_image_get_gicon(cast[ptr Image00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_get_icon_name(self: ptr Image00): cstring {.
    importc, libprag.}

proc getIconName*(self: Image): string =
  let resul0 = gtk_image_get_icon_name(cast[ptr Image00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc iconName*(self: Image): string =
  let resul0 = gtk_image_get_icon_name(cast[ptr Image00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_image_get_paintable(self: ptr Image00): ptr gdk4.Paintable00 {.
    importc, libprag.}

proc getPaintable*(self: Image): gdk4.Paintable =
  let gobj = gtk_image_get_paintable(cast[ptr Image00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc paintable*(self: Image): gdk4.Paintable =
  let gobj = gtk_image_get_paintable(cast[ptr Image00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_get_pixel_size(self: ptr Image00): int32 {.
    importc, libprag.}

proc getPixelSize*(self: Image): int =
  int(gtk_image_get_pixel_size(cast[ptr Image00](self.impl)))

proc pixelSize*(self: Image): int =
  int(gtk_image_get_pixel_size(cast[ptr Image00](self.impl)))

proc gtk_image_set_from_file(self: ptr Image00; filename: cstring) {.
    importc, libprag.}

proc setFromFile*(self: Image; filename: cstring = nil) =
  gtk_image_set_from_file(cast[ptr Image00](self.impl), filename)

proc `fromFile=`*(self: Image; filename: cstring = nil) =
  gtk_image_set_from_file(cast[ptr Image00](self.impl), filename)

proc gtk_image_set_from_gicon(self: ptr Image00; icon: ptr gio.Icon00) {.
    importc, libprag.}

proc setFromGicon*(self: Image; icon: gio.Icon) =
  gtk_image_set_from_gicon(cast[ptr Image00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc `fromGicon=`*(self: Image; icon: gio.Icon) =
  gtk_image_set_from_gicon(cast[ptr Image00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc gtk_image_set_from_icon_name(self: ptr Image00; iconName: cstring) {.
    importc, libprag.}

proc setFromIconName*(self: Image; iconName: cstring = nil) =
  gtk_image_set_from_icon_name(cast[ptr Image00](self.impl), iconName)

proc `fromIconName=`*(self: Image; iconName: cstring = nil) =
  gtk_image_set_from_icon_name(cast[ptr Image00](self.impl), iconName)

proc gtk_image_set_from_paintable(self: ptr Image00; paintable: ptr gdk4.Paintable00) {.
    importc, libprag.}

proc setFromPaintable*(self: Image; paintable: gdk4.Paintable = nil) =
  gtk_image_set_from_paintable(cast[ptr Image00](self.impl), if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))

proc `fromPaintable=`*(self: Image; paintable: gdk4.Paintable = nil) =
  gtk_image_set_from_paintable(cast[ptr Image00](self.impl), if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))

proc gtk_image_set_from_pixbuf(self: ptr Image00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setFromPixbuf*(self: Image; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_image_set_from_pixbuf(cast[ptr Image00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `fromPixbuf=`*(self: Image; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_image_set_from_pixbuf(cast[ptr Image00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_image_set_from_resource(self: ptr Image00; resourcePath: cstring) {.
    importc, libprag.}

proc setFromResource*(self: Image; resourcePath: cstring = nil) =
  gtk_image_set_from_resource(cast[ptr Image00](self.impl), resourcePath)

proc `fromResource=`*(self: Image; resourcePath: cstring = nil) =
  gtk_image_set_from_resource(cast[ptr Image00](self.impl), resourcePath)

proc gtk_image_set_pixel_size(self: ptr Image00; pixelSize: int32) {.
    importc, libprag.}

proc setPixelSize*(self: Image; pixelSize: int) =
  gtk_image_set_pixel_size(cast[ptr Image00](self.impl), int32(pixelSize))

proc `pixelSize=`*(self: Image; pixelSize: int) =
  gtk_image_set_pixel_size(cast[ptr Image00](self.impl), int32(pixelSize))

type
  AboutDialog* = ref object of Window
  AboutDialog00* = object of Window00

proc gtk_about_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AboutDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateLink*(self: AboutDialog;  p: proc (self: ptr AboutDialog00; uri: cstring; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-link", cast[GCallback](p), xdata, nil, cf)

proc gtk_about_dialog_new(): ptr AboutDialog00 {.
    importc, libprag.}

proc newAboutDialog*(): AboutDialog =
  let gobj = gtk_about_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAboutDialog*(tdesc: typedesc): tdesc =
  assert(result is AboutDialog)
  let gobj = gtk_about_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAboutDialog*[T](result: var T) {.deprecated.} =
  assert(result is AboutDialog)
  let gobj = gtk_about_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_about_dialog_add_credit_section(self: ptr AboutDialog00; sectionName: cstring;
    people: ptr cstring) {.
    importc, libprag.}

proc addCreditSection*(self: AboutDialog; sectionName: cstring;
    people: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_add_credit_section(cast[ptr AboutDialog00](self.impl), sectionName, seq2CstringArray(people, fs469n23))

proc gtk_about_dialog_get_artists(self: ptr AboutDialog00): ptr cstring {.
    importc, libprag.}

proc getArtists*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_artists(cast[ptr AboutDialog00](self.impl)))

proc artists*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_artists(cast[ptr AboutDialog00](self.impl)))

proc gtk_about_dialog_get_authors(self: ptr AboutDialog00): ptr cstring {.
    importc, libprag.}

proc getAuthors*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_authors(cast[ptr AboutDialog00](self.impl)))

proc authors*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_authors(cast[ptr AboutDialog00](self.impl)))

proc gtk_about_dialog_get_comments(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getComments*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_comments(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc comments*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_comments(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_copyright(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getCopyright*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_copyright(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc copyright*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_copyright(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_documenters(self: ptr AboutDialog00): ptr cstring {.
    importc, libprag.}

proc getDocumenters*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_documenters(cast[ptr AboutDialog00](self.impl)))

proc documenters*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_documenters(cast[ptr AboutDialog00](self.impl)))

proc gtk_about_dialog_get_license(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getLicense*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_license(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc license*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_license(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_logo(self: ptr AboutDialog00): ptr gdk4.Paintable00 {.
    importc, libprag.}

proc getLogo*(self: AboutDialog): gdk4.Paintable =
  let gobj = gtk_about_dialog_get_logo(cast[ptr AboutDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc logo*(self: AboutDialog): gdk4.Paintable =
  let gobj = gtk_about_dialog_get_logo(cast[ptr AboutDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_about_dialog_get_logo_icon_name(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getLogoIconName*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_logo_icon_name(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc logoIconName*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_logo_icon_name(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_program_name(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getProgramName*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_program_name(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc programName*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_program_name(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_system_information(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getSystemInformation*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_system_information(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc systemInformation*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_system_information(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_translator_credits(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getTranslatorCredits*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_translator_credits(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc translatorCredits*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_translator_credits(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_version(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getVersion*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_version(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc version*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_version(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_website(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getWebsite*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_website(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc website*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_website(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_website_label(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getWebsiteLabel*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_website_label(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc websiteLabel*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_website_label(cast[ptr AboutDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_about_dialog_get_wrap_license(self: ptr AboutDialog00): gboolean {.
    importc, libprag.}

proc getWrapLicense*(self: AboutDialog): bool =
  toBool(gtk_about_dialog_get_wrap_license(cast[ptr AboutDialog00](self.impl)))

proc wrapLicense*(self: AboutDialog): bool =
  toBool(gtk_about_dialog_get_wrap_license(cast[ptr AboutDialog00](self.impl)))

proc gtk_about_dialog_set_artists(self: ptr AboutDialog00; artists: ptr cstring) {.
    importc, libprag.}

proc setArtists*(self: AboutDialog; artists: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_artists(cast[ptr AboutDialog00](self.impl), seq2CstringArray(artists, fs469n23))

proc `artists=`*(self: AboutDialog; artists: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_artists(cast[ptr AboutDialog00](self.impl), seq2CstringArray(artists, fs469n23))

proc gtk_about_dialog_set_authors(self: ptr AboutDialog00; authors: ptr cstring) {.
    importc, libprag.}

proc setAuthors*(self: AboutDialog; authors: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_authors(cast[ptr AboutDialog00](self.impl), seq2CstringArray(authors, fs469n23))

proc `authors=`*(self: AboutDialog; authors: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_authors(cast[ptr AboutDialog00](self.impl), seq2CstringArray(authors, fs469n23))

proc gtk_about_dialog_set_comments(self: ptr AboutDialog00; comments: cstring) {.
    importc, libprag.}

proc setComments*(self: AboutDialog; comments: cstring = nil) =
  gtk_about_dialog_set_comments(cast[ptr AboutDialog00](self.impl), comments)

proc `comments=`*(self: AboutDialog; comments: cstring = nil) =
  gtk_about_dialog_set_comments(cast[ptr AboutDialog00](self.impl), comments)

proc gtk_about_dialog_set_copyright(self: ptr AboutDialog00; copyright: cstring) {.
    importc, libprag.}

proc setCopyright*(self: AboutDialog; copyright: cstring = nil) =
  gtk_about_dialog_set_copyright(cast[ptr AboutDialog00](self.impl), copyright)

proc `copyright=`*(self: AboutDialog; copyright: cstring = nil) =
  gtk_about_dialog_set_copyright(cast[ptr AboutDialog00](self.impl), copyright)

proc gtk_about_dialog_set_documenters(self: ptr AboutDialog00; documenters: ptr cstring) {.
    importc, libprag.}

proc setDocumenters*(self: AboutDialog; documenters: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_documenters(cast[ptr AboutDialog00](self.impl), seq2CstringArray(documenters, fs469n23))

proc `documenters=`*(self: AboutDialog; documenters: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_documenters(cast[ptr AboutDialog00](self.impl), seq2CstringArray(documenters, fs469n23))

proc gtk_about_dialog_set_license(self: ptr AboutDialog00; license: cstring) {.
    importc, libprag.}

proc setLicense*(self: AboutDialog; license: cstring = nil) =
  gtk_about_dialog_set_license(cast[ptr AboutDialog00](self.impl), license)

proc `license=`*(self: AboutDialog; license: cstring = nil) =
  gtk_about_dialog_set_license(cast[ptr AboutDialog00](self.impl), license)

proc gtk_about_dialog_set_logo(self: ptr AboutDialog00; logo: ptr gdk4.Paintable00) {.
    importc, libprag.}

proc setLogo*(self: AboutDialog; logo: gdk4.Paintable = nil) =
  gtk_about_dialog_set_logo(cast[ptr AboutDialog00](self.impl), if logo.isNil: nil else: cast[ptr gdk4.Paintable00](logo.impl))

proc `logo=`*(self: AboutDialog; logo: gdk4.Paintable = nil) =
  gtk_about_dialog_set_logo(cast[ptr AboutDialog00](self.impl), if logo.isNil: nil else: cast[ptr gdk4.Paintable00](logo.impl))

proc gtk_about_dialog_set_logo_icon_name(self: ptr AboutDialog00; iconName: cstring) {.
    importc, libprag.}

proc setLogoIconName*(self: AboutDialog; iconName: cstring = nil) =
  gtk_about_dialog_set_logo_icon_name(cast[ptr AboutDialog00](self.impl), iconName)

proc `logoIconName=`*(self: AboutDialog; iconName: cstring = nil) =
  gtk_about_dialog_set_logo_icon_name(cast[ptr AboutDialog00](self.impl), iconName)

proc gtk_about_dialog_set_program_name(self: ptr AboutDialog00; name: cstring) {.
    importc, libprag.}

proc setProgramName*(self: AboutDialog; name: cstring = nil) =
  gtk_about_dialog_set_program_name(cast[ptr AboutDialog00](self.impl), name)

proc `programName=`*(self: AboutDialog; name: cstring = nil) =
  gtk_about_dialog_set_program_name(cast[ptr AboutDialog00](self.impl), name)

proc gtk_about_dialog_set_system_information(self: ptr AboutDialog00; systemInformation: cstring) {.
    importc, libprag.}

proc setSystemInformation*(self: AboutDialog; systemInformation: cstring = nil) =
  gtk_about_dialog_set_system_information(cast[ptr AboutDialog00](self.impl), systemInformation)

proc `systemInformation=`*(self: AboutDialog; systemInformation: cstring = nil) =
  gtk_about_dialog_set_system_information(cast[ptr AboutDialog00](self.impl), systemInformation)

proc gtk_about_dialog_set_translator_credits(self: ptr AboutDialog00; translatorCredits: cstring) {.
    importc, libprag.}

proc setTranslatorCredits*(self: AboutDialog; translatorCredits: cstring = nil) =
  gtk_about_dialog_set_translator_credits(cast[ptr AboutDialog00](self.impl), translatorCredits)

proc `translatorCredits=`*(self: AboutDialog; translatorCredits: cstring = nil) =
  gtk_about_dialog_set_translator_credits(cast[ptr AboutDialog00](self.impl), translatorCredits)

proc gtk_about_dialog_set_version(self: ptr AboutDialog00; version: cstring) {.
    importc, libprag.}

proc setVersion*(self: AboutDialog; version: cstring = nil) =
  gtk_about_dialog_set_version(cast[ptr AboutDialog00](self.impl), version)

proc `version=`*(self: AboutDialog; version: cstring = nil) =
  gtk_about_dialog_set_version(cast[ptr AboutDialog00](self.impl), version)

proc gtk_about_dialog_set_website(self: ptr AboutDialog00; website: cstring) {.
    importc, libprag.}

proc setWebsite*(self: AboutDialog; website: cstring = nil) =
  gtk_about_dialog_set_website(cast[ptr AboutDialog00](self.impl), website)

proc `website=`*(self: AboutDialog; website: cstring = nil) =
  gtk_about_dialog_set_website(cast[ptr AboutDialog00](self.impl), website)

proc gtk_about_dialog_set_website_label(self: ptr AboutDialog00; websiteLabel: cstring) {.
    importc, libprag.}

proc setWebsiteLabel*(self: AboutDialog; websiteLabel: cstring) =
  gtk_about_dialog_set_website_label(cast[ptr AboutDialog00](self.impl), websiteLabel)

proc `websiteLabel=`*(self: AboutDialog; websiteLabel: cstring) =
  gtk_about_dialog_set_website_label(cast[ptr AboutDialog00](self.impl), websiteLabel)

proc gtk_about_dialog_set_wrap_license(self: ptr AboutDialog00; wrapLicense: gboolean) {.
    importc, libprag.}

proc setWrapLicense*(self: AboutDialog; wrapLicense: bool = true) =
  gtk_about_dialog_set_wrap_license(cast[ptr AboutDialog00](self.impl), gboolean(wrapLicense))

proc `wrapLicense=`*(self: AboutDialog; wrapLicense: bool) =
  gtk_about_dialog_set_wrap_license(cast[ptr AboutDialog00](self.impl), gboolean(wrapLicense))

type
  ListBoxRow* = ref object of Widget
  ListBoxRow00* = object of Widget00

proc gtk_list_box_row_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListBoxRow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: ListBoxRow;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_list_box_row_new(): ptr ListBoxRow00 {.
    importc, libprag.}

proc newListBoxRow*(): ListBoxRow =
  let gobj = gtk_list_box_row_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newListBoxRow*(tdesc: typedesc): tdesc =
  assert(result is ListBoxRow)
  let gobj = gtk_list_box_row_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListBoxRow*[T](result: var T) {.deprecated.} =
  assert(result is ListBoxRow)
  let gobj = gtk_list_box_row_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_row_changed(self: ptr ListBoxRow00) {.
    importc, libprag.}

proc changed*(self: ListBoxRow) =
  gtk_list_box_row_changed(cast[ptr ListBoxRow00](self.impl))

proc gtk_list_box_row_get_activatable(self: ptr ListBoxRow00): gboolean {.
    importc, libprag.}

proc getActivatable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_activatable(cast[ptr ListBoxRow00](self.impl)))

proc activatable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_activatable(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_get_child(self: ptr ListBoxRow00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: ListBoxRow): Widget =
  let gobj = gtk_list_box_row_get_child(cast[ptr ListBoxRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: ListBoxRow): Widget =
  let gobj = gtk_list_box_row_get_child(cast[ptr ListBoxRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_row_get_header(self: ptr ListBoxRow00): ptr Widget00 {.
    importc, libprag.}

proc getHeader*(self: ListBoxRow): Widget =
  let gobj = gtk_list_box_row_get_header(cast[ptr ListBoxRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc header*(self: ListBoxRow): Widget =
  let gobj = gtk_list_box_row_get_header(cast[ptr ListBoxRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_row_get_index(self: ptr ListBoxRow00): int32 {.
    importc, libprag.}

proc getIndex*(self: ListBoxRow): int =
  int(gtk_list_box_row_get_index(cast[ptr ListBoxRow00](self.impl)))

proc index*(self: ListBoxRow): int =
  int(gtk_list_box_row_get_index(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_get_selectable(self: ptr ListBoxRow00): gboolean {.
    importc, libprag.}

proc getSelectable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_selectable(cast[ptr ListBoxRow00](self.impl)))

proc selectable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_selectable(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_is_selected(self: ptr ListBoxRow00): gboolean {.
    importc, libprag.}

proc isSelected*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_is_selected(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_set_activatable(self: ptr ListBoxRow00; activatable: gboolean) {.
    importc, libprag.}

proc setActivatable*(self: ListBoxRow; activatable: bool = true) =
  gtk_list_box_row_set_activatable(cast[ptr ListBoxRow00](self.impl), gboolean(activatable))

proc `activatable=`*(self: ListBoxRow; activatable: bool) =
  gtk_list_box_row_set_activatable(cast[ptr ListBoxRow00](self.impl), gboolean(activatable))

proc gtk_list_box_row_set_child(self: ptr ListBoxRow00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: ListBoxRow; child: Widget = nil) =
  gtk_list_box_row_set_child(cast[ptr ListBoxRow00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: ListBoxRow; child: Widget = nil) =
  gtk_list_box_row_set_child(cast[ptr ListBoxRow00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_list_box_row_set_header(self: ptr ListBoxRow00; header: ptr Widget00) {.
    importc, libprag.}

proc setHeader*(self: ListBoxRow; header: Widget = nil) =
  gtk_list_box_row_set_header(cast[ptr ListBoxRow00](self.impl), if header.isNil: nil else: cast[ptr Widget00](header.impl))

proc `header=`*(self: ListBoxRow; header: Widget = nil) =
  gtk_list_box_row_set_header(cast[ptr ListBoxRow00](self.impl), if header.isNil: nil else: cast[ptr Widget00](header.impl))

proc gtk_list_box_row_set_selectable(self: ptr ListBoxRow00; selectable: gboolean) {.
    importc, libprag.}

proc setSelectable*(self: ListBoxRow; selectable: bool = true) =
  gtk_list_box_row_set_selectable(cast[ptr ListBoxRow00](self.impl), gboolean(selectable))

proc `selectable=`*(self: ListBoxRow; selectable: bool) =
  gtk_list_box_row_set_selectable(cast[ptr ListBoxRow00](self.impl), gboolean(selectable))

type
  ListBox* = ref object of Widget
  ListBox00* = object of Widget00

proc gtk_list_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateCursorRow*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: ListBox;  p: proc (self: ptr ListBox00; obj: MovementStep; p0: int32; p1: gboolean; p2: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scRowActivated*(self: ListBox;  p: proc (self: ptr ListBox00; row: ptr ListBoxRow00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-activated", cast[GCallback](p), xdata, nil, cf)

proc scRowSelected*(self: ListBox;  p: proc (self: ptr ListBox00; row: ptr ListBoxRow00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-selected", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSelectedRowsChanged*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selected-rows-changed", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorRow*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scUnselectAll*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cf)

proc gtk_list_box_new(): ptr ListBox00 {.
    importc, libprag.}

proc newListBox*(): ListBox =
  let gobj = gtk_list_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newListBox*(tdesc: typedesc): tdesc =
  assert(result is ListBox)
  let gobj = gtk_list_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListBox*[T](result: var T) {.deprecated.} =
  assert(result is ListBox)
  let gobj = gtk_list_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_append(self: ptr ListBox00; child: ptr Widget00) {.
    importc, libprag.}

proc append*(self: ListBox; child: Widget) =
  gtk_list_box_append(cast[ptr ListBox00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_list_box_drag_highlight_row(self: ptr ListBox00; row: ptr ListBoxRow00) {.
    importc, libprag.}

proc dragHighlightRow*(self: ListBox; row: ListBoxRow) =
  gtk_list_box_drag_highlight_row(cast[ptr ListBox00](self.impl), cast[ptr ListBoxRow00](row.impl))

proc gtk_list_box_drag_unhighlight_row(self: ptr ListBox00) {.
    importc, libprag.}

proc dragUnhighlightRow*(self: ListBox) =
  gtk_list_box_drag_unhighlight_row(cast[ptr ListBox00](self.impl))

proc gtk_list_box_get_activate_on_single_click(self: ptr ListBox00): gboolean {.
    importc, libprag.}

proc getActivateOnSingleClick*(self: ListBox): bool =
  toBool(gtk_list_box_get_activate_on_single_click(cast[ptr ListBox00](self.impl)))

proc activateOnSingleClick*(self: ListBox): bool =
  toBool(gtk_list_box_get_activate_on_single_click(cast[ptr ListBox00](self.impl)))

proc gtk_list_box_get_row_at_index(self: ptr ListBox00; index: int32): ptr ListBoxRow00 {.
    importc, libprag.}

proc getRowAtIndex*(self: ListBox; index: int): ListBoxRow =
  let gobj = gtk_list_box_get_row_at_index(cast[ptr ListBox00](self.impl), int32(index))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_row_at_y(self: ptr ListBox00; y: int32): ptr ListBoxRow00 {.
    importc, libprag.}

proc getRowAtY*(self: ListBox; y: int): ListBoxRow =
  let gobj = gtk_list_box_get_row_at_y(cast[ptr ListBox00](self.impl), int32(y))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_selected_row(self: ptr ListBox00): ptr ListBoxRow00 {.
    importc, libprag.}

proc getSelectedRow*(self: ListBox): ListBoxRow =
  let gobj = gtk_list_box_get_selected_row(cast[ptr ListBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectedRow*(self: ListBox): ListBoxRow =
  let gobj = gtk_list_box_get_selected_row(cast[ptr ListBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_selected_rows(self: ptr ListBox00): ptr glib.List {.
    importc, libprag.}

proc getSelectedRows*(self: ListBox): seq[ListBoxRow] =
  let resul0 = gtk_list_box_get_selected_rows(cast[ptr ListBox00](self.impl))
  result = glistObjects2seq(ListBoxRow, resul0, false)
  g_list_free(resul0)

proc selectedRows*(self: ListBox): seq[ListBoxRow] =
  let resul0 = gtk_list_box_get_selected_rows(cast[ptr ListBox00](self.impl))
  result = glistObjects2seq(ListBoxRow, resul0, false)
  g_list_free(resul0)

proc gtk_list_box_get_show_separators(self: ptr ListBox00): gboolean {.
    importc, libprag.}

proc getShowSeparators*(self: ListBox): bool =
  toBool(gtk_list_box_get_show_separators(cast[ptr ListBox00](self.impl)))

proc showSeparators*(self: ListBox): bool =
  toBool(gtk_list_box_get_show_separators(cast[ptr ListBox00](self.impl)))

proc gtk_list_box_insert(self: ptr ListBox00; child: ptr Widget00; position: int32) {.
    importc, libprag.}

proc insert*(self: ListBox; child: Widget; position: int) =
  gtk_list_box_insert(cast[ptr ListBox00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_list_box_invalidate_filter(self: ptr ListBox00) {.
    importc, libprag.}

proc invalidateFilter*(self: ListBox) =
  gtk_list_box_invalidate_filter(cast[ptr ListBox00](self.impl))

proc gtk_list_box_invalidate_headers(self: ptr ListBox00) {.
    importc, libprag.}

proc invalidateHeaders*(self: ListBox) =
  gtk_list_box_invalidate_headers(cast[ptr ListBox00](self.impl))

proc gtk_list_box_invalidate_sort(self: ptr ListBox00) {.
    importc, libprag.}

proc invalidateSort*(self: ListBox) =
  gtk_list_box_invalidate_sort(cast[ptr ListBox00](self.impl))

proc gtk_list_box_prepend(self: ptr ListBox00; child: ptr Widget00) {.
    importc, libprag.}

proc prepend*(self: ListBox; child: Widget) =
  gtk_list_box_prepend(cast[ptr ListBox00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_list_box_remove(self: ptr ListBox00; child: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: ListBox; child: Widget) =
  gtk_list_box_remove(cast[ptr ListBox00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_list_box_remove_all(self: ptr ListBox00) {.
    importc, libprag.}

proc removeAll*(self: ListBox) =
  gtk_list_box_remove_all(cast[ptr ListBox00](self.impl))

proc gtk_list_box_select_all(self: ptr ListBox00) {.
    importc, libprag.}

proc selectAll*(self: ListBox) =
  gtk_list_box_select_all(cast[ptr ListBox00](self.impl))

proc gtk_list_box_select_row(self: ptr ListBox00; row: ptr ListBoxRow00) {.
    importc, libprag.}

proc selectRow*(self: ListBox; row: ListBoxRow = nil) =
  gtk_list_box_select_row(cast[ptr ListBox00](self.impl), if row.isNil: nil else: cast[ptr ListBoxRow00](row.impl))

proc gtk_list_box_set_activate_on_single_click(self: ptr ListBox00; single: gboolean) {.
    importc, libprag.}

proc setActivateOnSingleClick*(self: ListBox; single: bool = true) =
  gtk_list_box_set_activate_on_single_click(cast[ptr ListBox00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: ListBox; single: bool) =
  gtk_list_box_set_activate_on_single_click(cast[ptr ListBox00](self.impl), gboolean(single))

proc gtk_list_box_set_placeholder(self: ptr ListBox00; placeholder: ptr Widget00) {.
    importc, libprag.}

proc setPlaceholder*(self: ListBox; placeholder: Widget = nil) =
  gtk_list_box_set_placeholder(cast[ptr ListBox00](self.impl), if placeholder.isNil: nil else: cast[ptr Widget00](placeholder.impl))

proc `placeholder=`*(self: ListBox; placeholder: Widget = nil) =
  gtk_list_box_set_placeholder(cast[ptr ListBox00](self.impl), if placeholder.isNil: nil else: cast[ptr Widget00](placeholder.impl))

proc gtk_list_box_set_show_separators(self: ptr ListBox00; showSeparators: gboolean) {.
    importc, libprag.}

proc setShowSeparators*(self: ListBox; showSeparators: bool = true) =
  gtk_list_box_set_show_separators(cast[ptr ListBox00](self.impl), gboolean(showSeparators))

proc `showSeparators=`*(self: ListBox; showSeparators: bool) =
  gtk_list_box_set_show_separators(cast[ptr ListBox00](self.impl), gboolean(showSeparators))

proc gtk_list_box_unselect_all(self: ptr ListBox00) {.
    importc, libprag.}

proc unselectAll*(self: ListBox) =
  gtk_list_box_unselect_all(cast[ptr ListBox00](self.impl))

proc gtk_list_box_unselect_row(self: ptr ListBox00; row: ptr ListBoxRow00) {.
    importc, libprag.}

proc unselectRow*(self: ListBox; row: ListBoxRow) =
  gtk_list_box_unselect_row(cast[ptr ListBox00](self.impl), cast[ptr ListBoxRow00](row.impl))

type
  License* {.size: sizeof(cint), pure.} = enum
    unknown = 0
    custom = 1
    gpl_2_0 = 2
    gpl_3_0 = 3
    lgpl_2_1 = 4
    lgpl_3_0 = 5
    bsd = 6
    mitX11 = 7
    artistic = 8
    gpl_2_0Only = 9
    gpl_3_0Only = 10
    lgpl_2_1Only = 11
    lgpl_3_0Only = 12
    agpl_3_0 = 13
    agpl_3_0Only = 14
    bsd_3 = 15
    apache_2_0 = 16
    mpl_2_0 = 17
    enum0bsd = 18

proc gtk_about_dialog_get_license_type(self: ptr AboutDialog00): License {.
    importc, libprag.}

proc getLicenseType*(self: AboutDialog): License =
  gtk_about_dialog_get_license_type(cast[ptr AboutDialog00](self.impl))

proc licenseType*(self: AboutDialog): License =
  gtk_about_dialog_get_license_type(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_set_license_type(self: ptr AboutDialog00; licenseType: License) {.
    importc, libprag.}

proc setLicenseType*(self: AboutDialog; licenseType: License) =
  gtk_about_dialog_set_license_type(cast[ptr AboutDialog00](self.impl), licenseType)

proc `licenseType=`*(self: AboutDialog; licenseType: License) =
  gtk_about_dialog_set_license_type(cast[ptr AboutDialog00](self.impl), licenseType)

type
  ImageType* {.size: sizeof(cint), pure.} = enum
    empty = 0
    iconName = 1
    gicon = 2
    paintable = 3

proc gtk_image_get_storage_type(self: ptr Image00): ImageType {.
    importc, libprag.}

proc getStorageType*(self: Image): ImageType =
  gtk_image_get_storage_type(cast[ptr Image00](self.impl))

proc storageType*(self: Image): ImageType =
  gtk_image_get_storage_type(cast[ptr Image00](self.impl))

type
  IconSize* {.size: sizeof(cint), pure.} = enum
    inherit = 0
    normal = 1
    large = 2

proc gtk_image_get_icon_size(self: ptr Image00): IconSize {.
    importc, libprag.}

proc getIconSize*(self: Image): IconSize =
  gtk_image_get_icon_size(cast[ptr Image00](self.impl))

proc iconSize*(self: Image): IconSize =
  gtk_image_get_icon_size(cast[ptr Image00](self.impl))

proc gtk_image_set_icon_size(self: ptr Image00; iconSize: IconSize) {.
    importc, libprag.}

proc setIconSize*(self: Image; iconSize: IconSize) =
  gtk_image_set_icon_size(cast[ptr Image00](self.impl), iconSize)

proc `iconSize=`*(self: Image; iconSize: IconSize) =
  gtk_image_set_icon_size(cast[ptr Image00](self.impl), iconSize)

type
  TreeIter* {.pure, byRef.} = object
    stamp*: int32
    userData*: pointer
    userData2*: pointer
    userData3*: pointer

proc gtk_tree_iter_get_type*(): GType {.importc, libprag.}

proc gtk_tree_iter_free(self: TreeIter) {.
    importc, libprag.}

proc free*(self: TreeIter) =
  gtk_tree_iter_free(self)

proc gtk_tree_iter_copy(self: TreeIter): ptr TreeIter {.
    importc, libprag.}

proc copy*(self: TreeIter): ptr TreeIter =
  gtk_tree_iter_copy(self)

proc gtk_combo_box_get_active_iter(self: ptr ComboBox00; iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getActiveIter*(self: ComboBox; iter: var TreeIter): bool =
  toBool(gtk_combo_box_get_active_iter(cast[ptr ComboBox00](self.impl), iter))

proc gtk_combo_box_set_active_iter(self: ptr ComboBox00; iter: TreeIter) {.
    importc, libprag.}

proc setActiveIter*(self: ComboBox; iter: TreeIter = cast[var TreeIter](nil)) =
  gtk_combo_box_set_active_iter(cast[ptr ComboBox00](self.impl), iter)

proc `activeIter=`*(self: ComboBox; iter: TreeIter = cast[var TreeIter](nil)) =
  gtk_combo_box_set_active_iter(cast[ptr ComboBox00](self.impl), iter)

type
  SensitivityType* {.size: sizeof(cint), pure.} = enum
    auto = 0
    on = 1
    off = 2

proc gtk_combo_box_get_button_sensitivity(self: ptr ComboBox00): SensitivityType {.
    importc, libprag.}

proc getButtonSensitivity*(self: ComboBox): SensitivityType =
  gtk_combo_box_get_button_sensitivity(cast[ptr ComboBox00](self.impl))

proc buttonSensitivity*(self: ComboBox): SensitivityType =
  gtk_combo_box_get_button_sensitivity(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_set_button_sensitivity(self: ptr ComboBox00; sensitivity: SensitivityType) {.
    importc, libprag.}

proc setButtonSensitivity*(self: ComboBox; sensitivity: SensitivityType) =
  gtk_combo_box_set_button_sensitivity(cast[ptr ComboBox00](self.impl), sensitivity)

proc `buttonSensitivity=`*(self: ComboBox; sensitivity: SensitivityType) =
  gtk_combo_box_set_button_sensitivity(cast[ptr ComboBox00](self.impl), sensitivity)

type
  TreePath00* {.pure.} = object
  TreePath* = ref object
    impl*: ptr TreePath00
    ignoreFinalizer*: bool

proc gtk_tree_path_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkTreePath*(self: TreePath) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_tree_path_get_type(), cast[ptr TreePath00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreePath()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_tree_path_get_type(), cast[ptr TreePath00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var TreePath) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkTreePath)

proc gtk_tree_path_free(self: ptr TreePath00) {.
    importc, libprag.}

proc free*(self: TreePath) =
  gtk_tree_path_free(cast[ptr TreePath00](self.impl))

proc finalizerfree*(self: TreePath) =
  if not self.ignoreFinalizer:
    gtk_tree_path_free(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_new_first(): ptr TreePath00 {.
    importc, libprag.}

proc newTreePathFirst*(): TreePath {.deprecated.}  =
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_first()

proc newTreePathFirst*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_first()

proc initTreePathFirst*[T](result: var T) {.deprecated.} =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_first()

proc gtk_tree_path_new_from_indicesv(indices: ptr int32; length: uint64): ptr TreePath00 {.
    importc, libprag.}

proc newTreePathFromIndices*(indices: seq[int32]): TreePath {.deprecated.}  =
  let length = uint64(indices.len)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_from_indicesv(cast[ptr int32](unsafeaddr(indices[0])), length)

proc newTreePathFromIndices*(tdesc: typedesc; indices: seq[int32]): tdesc {.deprecated.}  =
  let length = uint64(indices.len)
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_from_indicesv(cast[ptr int32](unsafeaddr(indices[0])), length)

proc initTreePathFromIndices*[T](result: var T; indices: seq[int32]) {.deprecated.} =
  let length = uint64(indices.len)
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_from_indicesv(cast[ptr int32](unsafeaddr(indices[0])), length)

proc gtk_tree_path_new_from_string(path: cstring): ptr TreePath00 {.
    importc, libprag.}

proc newTreePathFromString*(path: cstring): TreePath {.deprecated.}  =
  let impl0 = gtk_tree_path_new_from_string(path)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc newTreePathFromString*(tdesc: typedesc; path: cstring): tdesc {.deprecated.}  =
  assert(result is TreePath)
  let impl0 = gtk_tree_path_new_from_string(path)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc initTreePathFromString*[T](result: var T; path: cstring) {.deprecated.} =
  assert(result is TreePath)
  let impl0 = gtk_tree_path_new_from_string(path)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_path_append_index(self: ptr TreePath00; index: int32) {.
    importc, libprag.}

proc appendIndex*(self: TreePath; index: int) =
  gtk_tree_path_append_index(cast[ptr TreePath00](self.impl), int32(index))

proc gtk_tree_path_compare(self: ptr TreePath00; b: ptr TreePath00): int32 {.
    importc, libprag.}

proc compare*(self: TreePath; b: TreePath): int =
  int(gtk_tree_path_compare(cast[ptr TreePath00](self.impl), cast[ptr TreePath00](b.impl)))

proc gtk_tree_path_copy(self: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc copy*(self: TreePath): TreePath =
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_copy(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_down(self: ptr TreePath00) {.
    importc, libprag.}

proc down*(self: TreePath) =
  gtk_tree_path_down(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_new(): ptr TreePath00 {.
    importc, libprag.}

proc newTreePath*(): TreePath {.deprecated.}  =
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new()

proc newTreePath*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new()

proc initTreePath*[T](result: var T) {.deprecated.} =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new()

proc gtk_tree_path_get_depth(self: ptr TreePath00): int32 {.
    importc, libprag.}

proc getDepth*(self: TreePath): int =
  int(gtk_tree_path_get_depth(cast[ptr TreePath00](self.impl)))

proc depth*(self: TreePath): int =
  int(gtk_tree_path_get_depth(cast[ptr TreePath00](self.impl)))

proc gtk_tree_path_get_indices_with_depth(self: ptr TreePath00; depth: var int32): ptr int32 {.
    importc, libprag.}

proc getIndices*(self: TreePath; depth: var int = cast[var int](nil)): seq[int32] =
  var depth_00: int32
  let resul0 = gtk_tree_path_get_indices_with_depth(cast[ptr TreePath00](self.impl), depth_00)
  if resul0.isNil:
    return
  result = int32ArrayToSeq(resul0, depth.int)
  if depth.addr != nil:
    depth = int(depth_00)

proc gtk_tree_path_is_ancestor(self: ptr TreePath00; descendant: ptr TreePath00): gboolean {.
    importc, libprag.}

proc isAncestor*(self: TreePath; descendant: TreePath): bool =
  toBool(gtk_tree_path_is_ancestor(cast[ptr TreePath00](self.impl), cast[ptr TreePath00](descendant.impl)))

proc gtk_tree_path_is_descendant(self: ptr TreePath00; ancestor: ptr TreePath00): gboolean {.
    importc, libprag.}

proc isDescendant*(self: TreePath; ancestor: TreePath): bool =
  toBool(gtk_tree_path_is_descendant(cast[ptr TreePath00](self.impl), cast[ptr TreePath00](ancestor.impl)))

proc gtk_tree_path_next(self: ptr TreePath00) {.
    importc, libprag.}

proc next*(self: TreePath) =
  gtk_tree_path_next(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_prepend_index(self: ptr TreePath00; index: int32) {.
    importc, libprag.}

proc prependIndex*(self: TreePath; index: int) =
  gtk_tree_path_prepend_index(cast[ptr TreePath00](self.impl), int32(index))

proc gtk_tree_path_prev(self: ptr TreePath00): gboolean {.
    importc, libprag.}

proc prev*(self: TreePath): bool =
  toBool(gtk_tree_path_prev(cast[ptr TreePath00](self.impl)))

proc gtk_tree_path_to_string(self: ptr TreePath00): cstring {.
    importc, libprag.}

proc toString*(self: TreePath): string =
  let resul0 = gtk_tree_path_to_string(cast[ptr TreePath00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_tree_path_up(self: ptr TreePath00): gboolean {.
    importc, libprag.}

proc up*(self: TreePath): bool =
  toBool(gtk_tree_path_up(cast[ptr TreePath00](self.impl)))

type
  TreeModelFilter* = ref object of gobject.Object
  TreeModelFilter00* = object of gobject.Object00

proc gtk_tree_model_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeModelFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_model_filter_clear_cache(self: ptr TreeModelFilter00) {.
    importc, libprag.}

proc clearCache*(self: TreeModelFilter) =
  gtk_tree_model_filter_clear_cache(cast[ptr TreeModelFilter00](self.impl))

proc gtk_tree_model_filter_convert_child_iter_to_iter(self: ptr TreeModelFilter00;
    filterIter: var TreeIter; childIter: TreeIter): gboolean {.
    importc, libprag.}

proc convertChildIterToIter*(self: TreeModelFilter;
    filterIter: var TreeIter; childIter: TreeIter): bool =
  toBool(gtk_tree_model_filter_convert_child_iter_to_iter(cast[ptr TreeModelFilter00](self.impl), filterIter, childIter))

proc gtk_tree_model_filter_convert_child_path_to_path(self: ptr TreeModelFilter00;
    childPath: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc convertChildPathToPath*(self: TreeModelFilter;
    childPath: TreePath): TreePath =
  let impl0 = gtk_tree_model_filter_convert_child_path_to_path(cast[ptr TreeModelFilter00](self.impl), cast[ptr TreePath00](childPath.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_model_filter_convert_iter_to_child_iter(self: ptr TreeModelFilter00;
    childIter: var TreeIter; filterIter: TreeIter) {.
    importc, libprag.}

proc convertIterToChildIter*(self: TreeModelFilter;
    childIter: var TreeIter; filterIter: TreeIter) =
  gtk_tree_model_filter_convert_iter_to_child_iter(cast[ptr TreeModelFilter00](self.impl), childIter, filterIter)

proc gtk_tree_model_filter_convert_path_to_child_path(self: ptr TreeModelFilter00;
    filterPath: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc convertPathToChildPath*(self: TreeModelFilter;
    filterPath: TreePath): TreePath =
  let impl0 = gtk_tree_model_filter_convert_path_to_child_path(cast[ptr TreeModelFilter00](self.impl), cast[ptr TreePath00](filterPath.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_model_filter_refilter(self: ptr TreeModelFilter00) {.
    importc, libprag.}

proc refilter*(self: TreeModelFilter) =
  gtk_tree_model_filter_refilter(cast[ptr TreeModelFilter00](self.impl))

proc gtk_tree_model_filter_set_visible_column(self: ptr TreeModelFilter00;
    column: int32) {.
    importc, libprag.}

proc setVisibleColumn*(self: TreeModelFilter; column: int) =
  gtk_tree_model_filter_set_visible_column(cast[ptr TreeModelFilter00](self.impl), int32(column))

proc `visibleColumn=`*(self: TreeModelFilter; column: int) =
  gtk_tree_model_filter_set_visible_column(cast[ptr TreeModelFilter00](self.impl), int32(column))

type
  TreeModelSort* = ref object of gobject.Object
  TreeModelSort00* = object of gobject.Object00

proc gtk_tree_model_sort_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeModelSort()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_model_sort_clear_cache(self: ptr TreeModelSort00) {.
    importc, libprag.}

proc clearCache*(self: TreeModelSort) =
  gtk_tree_model_sort_clear_cache(cast[ptr TreeModelSort00](self.impl))

proc gtk_tree_model_sort_convert_child_iter_to_iter(self: ptr TreeModelSort00;
    sortIter: var TreeIter; childIter: TreeIter): gboolean {.
    importc, libprag.}

proc convertChildIterToIter*(self: TreeModelSort;
    sortIter: var TreeIter; childIter: TreeIter): bool =
  toBool(gtk_tree_model_sort_convert_child_iter_to_iter(cast[ptr TreeModelSort00](self.impl), sortIter, childIter))

proc gtk_tree_model_sort_convert_child_path_to_path(self: ptr TreeModelSort00;
    childPath: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc convertChildPathToPath*(self: TreeModelSort;
    childPath: TreePath): TreePath =
  let impl0 = gtk_tree_model_sort_convert_child_path_to_path(cast[ptr TreeModelSort00](self.impl), cast[ptr TreePath00](childPath.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_model_sort_convert_iter_to_child_iter(self: ptr TreeModelSort00;
    childIter: var TreeIter; sortedIter: TreeIter) {.
    importc, libprag.}

proc convertIterToChildIter*(self: TreeModelSort;
    childIter: var TreeIter; sortedIter: TreeIter) =
  gtk_tree_model_sort_convert_iter_to_child_iter(cast[ptr TreeModelSort00](self.impl), childIter, sortedIter)

proc gtk_tree_model_sort_convert_path_to_child_path(self: ptr TreeModelSort00;
    sortedPath: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc convertPathToChildPath*(self: TreeModelSort;
    sortedPath: TreePath): TreePath =
  let impl0 = gtk_tree_model_sort_convert_path_to_child_path(cast[ptr TreeModelSort00](self.impl), cast[ptr TreePath00](sortedPath.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_model_sort_iter_is_valid(self: ptr TreeModelSort00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterIsValid*(self: TreeModelSort; iter: TreeIter): bool =
  toBool(gtk_tree_model_sort_iter_is_valid(cast[ptr TreeModelSort00](self.impl), iter))

proc gtk_tree_model_sort_reset_default_sort_func(self: ptr TreeModelSort00) {.
    importc, libprag.}

proc resetDefaultSortFunc*(self: TreeModelSort) =
  gtk_tree_model_sort_reset_default_sort_func(cast[ptr TreeModelSort00](self.impl))

type
  TreeStore* = ref object of gobject.Object
  TreeStore00* = object of gobject.Object00

proc gtk_tree_store_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeStore()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_store_newv(nColumns: int32; types: ptr GType): ptr TreeStore00 {.
    importc, libprag.}

proc newTreeStore*(nColumns: int; types: ptr GType): TreeStore {.deprecated.}  =
  let gobj = gtk_tree_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeStore*(tdesc: typedesc; nColumns: int; types: ptr GType): tdesc {.deprecated.}  =
  assert(result is TreeStore)
  let gobj = gtk_tree_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeStore*[T](result: var T; nColumns: int; types: ptr GType) {.deprecated.} =
  assert(result is TreeStore)
  let gobj = gtk_tree_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_store_append(self: ptr TreeStore00; iter: var TreeIter; parent: TreeIter) {.
    importc, libprag.}

proc append*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_append(cast[ptr TreeStore00](self.impl), iter, parent)

proc gtk_tree_store_clear(self: ptr TreeStore00) {.
    importc, libprag.}

proc clear*(self: TreeStore) =
  gtk_tree_store_clear(cast[ptr TreeStore00](self.impl))

proc gtk_tree_store_insert(self: ptr TreeStore00; iter: var TreeIter; parent: TreeIter;
    position: int32) {.
    importc, libprag.}

proc insert*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil);
    position: int) =
  gtk_tree_store_insert(cast[ptr TreeStore00](self.impl), iter, parent, int32(position))

proc gtk_tree_store_insert_after(self: ptr TreeStore00; iter: var TreeIter;
    parent: TreeIter; sibling: TreeIter) {.
    importc, libprag.}

proc insertAfter*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil);
    sibling: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_insert_after(cast[ptr TreeStore00](self.impl), iter, parent, sibling)

proc gtk_tree_store_insert_before(self: ptr TreeStore00; iter: var TreeIter;
    parent: TreeIter; sibling: TreeIter) {.
    importc, libprag.}

proc insertBefore*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil);
    sibling: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_insert_before(cast[ptr TreeStore00](self.impl), iter, parent, sibling)

proc gtk_tree_store_is_ancestor(self: ptr TreeStore00; iter: TreeIter; descendant: TreeIter): gboolean {.
    importc, libprag.}

proc isAncestor*(self: TreeStore; iter: TreeIter; descendant: TreeIter): bool =
  toBool(gtk_tree_store_is_ancestor(cast[ptr TreeStore00](self.impl), iter, descendant))

proc gtk_tree_store_iter_depth(self: ptr TreeStore00; iter: TreeIter): int32 {.
    importc, libprag.}

proc iterDepth*(self: TreeStore; iter: TreeIter): int =
  int(gtk_tree_store_iter_depth(cast[ptr TreeStore00](self.impl), iter))

proc gtk_tree_store_iter_is_valid(self: ptr TreeStore00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterIsValid*(self: TreeStore; iter: TreeIter): bool =
  toBool(gtk_tree_store_iter_is_valid(cast[ptr TreeStore00](self.impl), iter))

proc gtk_tree_store_move_after(self: ptr TreeStore00; iter: TreeIter; position: TreeIter) {.
    importc, libprag.}

proc moveAfter*(self: TreeStore; iter: TreeIter; position: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_move_after(cast[ptr TreeStore00](self.impl), iter, position)

proc gtk_tree_store_move_before(self: ptr TreeStore00; iter: TreeIter; position: TreeIter) {.
    importc, libprag.}

proc moveBefore*(self: TreeStore; iter: TreeIter; position: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_move_before(cast[ptr TreeStore00](self.impl), iter, position)

proc gtk_tree_store_prepend(self: ptr TreeStore00; iter: var TreeIter; parent: TreeIter) {.
    importc, libprag.}

proc prepend*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_prepend(cast[ptr TreeStore00](self.impl), iter, parent)

proc gtk_tree_store_remove(self: ptr TreeStore00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc remove*(self: TreeStore; iter: TreeIter): bool =
  toBool(gtk_tree_store_remove(cast[ptr TreeStore00](self.impl), iter))

proc gtk_tree_store_set_column_types(self: ptr TreeStore00; nColumns: int32;
    types: ptr GType) {.
    importc, libprag.}

proc setColumnTypes*(self: TreeStore; nColumns: int; types: ptr GType) =
  gtk_tree_store_set_column_types(cast[ptr TreeStore00](self.impl), int32(nColumns), types)

proc gtk_tree_store_set_value(self: ptr TreeStore00; iter: TreeIter; column: int32;
    value: gobject.Value) {.
    importc, libprag.}

proc setValue*(self: TreeStore; iter: TreeIter; column: int;
    value: gobject.Value) =
  gtk_tree_store_set_value(cast[ptr TreeStore00](self.impl), iter, int32(column), value)

proc gtk_tree_store_swap(self: ptr TreeStore00; a: TreeIter; b: TreeIter) {.
    importc, libprag.}

proc swap*(self: TreeStore; a: TreeIter; b: TreeIter) =
  gtk_tree_store_swap(cast[ptr TreeStore00](self.impl), a, b)

type
  ListStore* = ref object of gobject.Object
  ListStore00* = object of gobject.Object00

proc gtk_list_store_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListStore()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_list_store_newv(nColumns: int32; types: ptr GType): ptr ListStore00 {.
    importc, libprag.}

proc newListStore*(nColumns: int; types: ptr GType): ListStore {.deprecated.}  =
  let gobj = gtk_list_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newListStore*(tdesc: typedesc; nColumns: int; types: ptr GType): tdesc {.deprecated.}  =
  assert(result is ListStore)
  let gobj = gtk_list_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListStore*[T](result: var T; nColumns: int; types: ptr GType) {.deprecated.} =
  assert(result is ListStore)
  let gobj = gtk_list_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_store_append(self: ptr ListStore00; iter: var TreeIter) {.
    importc, libprag.}

proc append*(self: ListStore; iter: var TreeIter) =
  gtk_list_store_append(cast[ptr ListStore00](self.impl), iter)

proc append*(self: ListStore): TreeIter =
  gtk_list_store_append(cast[ptr ListStore00](self.impl), result)

proc gtk_list_store_clear(self: ptr ListStore00) {.
    importc, libprag.}

proc clear*(self: ListStore) =
  gtk_list_store_clear(cast[ptr ListStore00](self.impl))

proc gtk_list_store_insert(self: ptr ListStore00; iter: var TreeIter; position: int32) {.
    importc, libprag.}

proc insert*(self: ListStore; iter: var TreeIter; position: int) =
  gtk_list_store_insert(cast[ptr ListStore00](self.impl), iter, int32(position))

proc gtk_list_store_insert_after(self: ptr ListStore00; iter: var TreeIter;
    sibling: TreeIter) {.
    importc, libprag.}

proc insertAfter*(self: ListStore; iter: var TreeIter; sibling: TreeIter = cast[var TreeIter](nil)) =
  gtk_list_store_insert_after(cast[ptr ListStore00](self.impl), iter, sibling)

proc gtk_list_store_insert_before(self: ptr ListStore00; iter: var TreeIter;
    sibling: TreeIter) {.
    importc, libprag.}

proc insertBefore*(self: ListStore; iter: var TreeIter; sibling: TreeIter = cast[var TreeIter](nil)) =
  gtk_list_store_insert_before(cast[ptr ListStore00](self.impl), iter, sibling)

proc gtk_list_store_iter_is_valid(self: ptr ListStore00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterIsValid*(self: ListStore; iter: TreeIter): bool =
  toBool(gtk_list_store_iter_is_valid(cast[ptr ListStore00](self.impl), iter))

proc gtk_list_store_move_after(self: ptr ListStore00; iter: TreeIter; position: TreeIter) {.
    importc, libprag.}

proc moveAfter*(self: ListStore; iter: TreeIter; position: TreeIter = cast[var TreeIter](nil)) =
  gtk_list_store_move_after(cast[ptr ListStore00](self.impl), iter, position)

proc gtk_list_store_move_before(self: ptr ListStore00; iter: TreeIter; position: TreeIter) {.
    importc, libprag.}

proc moveBefore*(self: ListStore; iter: TreeIter; position: TreeIter = cast[var TreeIter](nil)) =
  gtk_list_store_move_before(cast[ptr ListStore00](self.impl), iter, position)

proc gtk_list_store_prepend(self: ptr ListStore00; iter: var TreeIter) {.
    importc, libprag.}

proc prepend*(self: ListStore; iter: var TreeIter) =
  gtk_list_store_prepend(cast[ptr ListStore00](self.impl), iter)

proc prepend*(self: ListStore): TreeIter =
  gtk_list_store_prepend(cast[ptr ListStore00](self.impl), result)

proc gtk_list_store_remove(self: ptr ListStore00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc remove*(self: ListStore; iter: TreeIter): bool =
  toBool(gtk_list_store_remove(cast[ptr ListStore00](self.impl), iter))

proc gtk_list_store_reorder(self: ptr ListStore00; newOrder: ptr int32) {.
    importc, libprag.}

proc reorder*(self: ListStore; newOrder: seq[int32]) =
  gtk_list_store_reorder(cast[ptr ListStore00](self.impl), cast[ptr int32](unsafeaddr(newOrder[0])))

proc gtk_list_store_set_column_types(self: ptr ListStore00; nColumns: int32;
    types: ptr GType) {.
    importc, libprag.}

proc setColumnTypes*(self: ListStore; nColumns: int; types: ptr GType) =
  gtk_list_store_set_column_types(cast[ptr ListStore00](self.impl), int32(nColumns), types)

proc gtk_list_store_set_value(self: ptr ListStore00; iter: TreeIter; column: int32;
    value: gobject.Value) {.
    importc, libprag.}

proc setValue*(self: ListStore; iter: TreeIter; column: int;
    value: gobject.Value) =
  gtk_list_store_set_value(cast[ptr ListStore00](self.impl), iter, int32(column), value)

proc gtk_list_store_swap(self: ptr ListStore00; a: TreeIter; b: TreeIter) {.
    importc, libprag.}

proc swap*(self: ListStore; a: TreeIter; b: TreeIter) =
  gtk_list_store_swap(cast[ptr ListStore00](self.impl), a, b)

type
  TreeModel00* = object of gobject.Object00
  TreeModel* = ref object of gobject.Object

proc scRowChanged*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;  p: proc (self: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-changed", cast[GCallback](p), xdata, nil, cf)

proc scRowDeleted*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;  p: proc (self: ptr TreeModel00; path: ptr TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-deleted", cast[GCallback](p), xdata, nil, cf)

proc scRowHasChildToggled*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;  p: proc (self: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-has-child-toggled", cast[GCallback](p), xdata, nil, cf)

proc scRowInserted*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;  p: proc (self: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-inserted", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_model_filter_new(self: ptr TreeModel00; root: ptr TreePath00): ptr TreeModel00 {.
    importc, libprag.}

proc filterNew*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    root: TreePath = nil): TreeModel =
  let gobj = gtk_tree_model_filter_new(cast[ptr TreeModel00](self.impl), if root.isNil: nil else: cast[ptr TreePath00](root.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_model_get_column_type(self: ptr TreeModel00; index: int32): GType {.
    importc, libprag.}

proc getColumnType*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    index: int): GType =
  gtk_tree_model_get_column_type(cast[ptr TreeModel00](self.impl), int32(index))

proc gtk_tree_model_get_iter(self: ptr TreeModel00; iter: var TreeIter; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc getIter*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: var TreeIter; path: TreePath): bool =
  toBool(gtk_tree_model_get_iter(cast[ptr TreeModel00](self.impl), iter, cast[ptr TreePath00](path.impl)))

proc gtk_tree_model_get_iter_first(self: ptr TreeModel00; iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getIterFirst*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: var TreeIter): bool =
  toBool(gtk_tree_model_get_iter_first(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_get_iter_from_string(self: ptr TreeModel00; iter: var TreeIter;
    pathString: cstring): gboolean {.
    importc, libprag.}

proc getIterFromString*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: var TreeIter; pathString: cstring): bool =
  toBool(gtk_tree_model_get_iter_from_string(cast[ptr TreeModel00](self.impl), iter, pathString))

proc gtk_tree_model_get_n_columns(self: ptr TreeModel00): int32 {.
    importc, libprag.}

proc getNColumns*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): int =
  int(gtk_tree_model_get_n_columns(cast[ptr TreeModel00](self.impl)))

proc nColumns*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): int =
  int(gtk_tree_model_get_n_columns(cast[ptr TreeModel00](self.impl)))

proc gtk_tree_model_get_path(self: ptr TreeModel00; iter: TreeIter): ptr TreePath00 {.
    importc, libprag.}

proc getPath*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter): TreePath =
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_model_get_path(cast[ptr TreeModel00](self.impl), iter)

proc gtk_tree_model_get_string_from_iter(self: ptr TreeModel00; iter: TreeIter): cstring {.
    importc, libprag.}

proc getStringFromIter*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter): string =
  let resul0 = gtk_tree_model_get_string_from_iter(cast[ptr TreeModel00](self.impl), iter)
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_tree_model_get_value(self: ptr TreeModel00; iter: TreeIter; column: int32;
    value: var gobject.Value) {.
    importc, libprag.}

proc getValue*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter; column: int; value: var gobject.Value) =
  gtk_tree_model_get_value(cast[ptr TreeModel00](self.impl), iter, int32(column), value)

proc gtk_tree_model_iter_children(self: ptr TreeModel00; iter: var TreeIter;
    parent: TreeIter): gboolean {.
    importc, libprag.}

proc iterChildren*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil)): bool =
  toBool(gtk_tree_model_iter_children(cast[ptr TreeModel00](self.impl), iter, parent))

proc gtk_tree_model_iter_has_child(self: ptr TreeModel00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterHasChild*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter): bool =
  toBool(gtk_tree_model_iter_has_child(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_iter_n_children(self: ptr TreeModel00; iter: TreeIter): int32 {.
    importc, libprag.}

proc iterNChildren*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter = cast[var TreeIter](nil)): int =
  int(gtk_tree_model_iter_n_children(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_iter_next(self: ptr TreeModel00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterNext*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter): bool =
  toBool(gtk_tree_model_iter_next(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_iter_nth_child(self: ptr TreeModel00; iter: var TreeIter;
    parent: TreeIter; n: int32): gboolean {.
    importc, libprag.}

proc iterNthChild*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil); n: int): bool =
  toBool(gtk_tree_model_iter_nth_child(cast[ptr TreeModel00](self.impl), iter, parent, int32(n)))

proc gtk_tree_model_iter_parent(self: ptr TreeModel00; iter: var TreeIter;
    child: TreeIter): gboolean {.
    importc, libprag.}

proc iterParent*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: var TreeIter; child: TreeIter): bool =
  toBool(gtk_tree_model_iter_parent(cast[ptr TreeModel00](self.impl), iter, child))

proc gtk_tree_model_iter_previous(self: ptr TreeModel00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterPrevious*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter): bool =
  toBool(gtk_tree_model_iter_previous(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_ref_node(self: ptr TreeModel00; iter: TreeIter) {.
    importc, libprag.}

proc refNode*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter) =
  gtk_tree_model_ref_node(cast[ptr TreeModel00](self.impl), iter)

proc gtk_tree_model_row_changed(self: ptr TreeModel00; path: ptr TreePath00;
    iter: TreeIter) {.
    importc, libprag.}

proc rowChanged*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath; iter: TreeIter) =
  gtk_tree_model_row_changed(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), iter)

proc gtk_tree_model_row_deleted(self: ptr TreeModel00; path: ptr TreePath00) {.
    importc, libprag.}

proc rowDeleted*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath) =
  gtk_tree_model_row_deleted(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_model_row_has_child_toggled(self: ptr TreeModel00; path: ptr TreePath00;
    iter: TreeIter) {.
    importc, libprag.}

proc rowHasChildToggled*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath; iter: TreeIter) =
  gtk_tree_model_row_has_child_toggled(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), iter)

proc gtk_tree_model_row_inserted(self: ptr TreeModel00; path: ptr TreePath00;
    iter: TreeIter) {.
    importc, libprag.}

proc rowInserted*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath; iter: TreeIter) =
  gtk_tree_model_row_inserted(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), iter)

proc gtk_tree_model_rows_reordered_with_length(self: ptr TreeModel00; path: ptr TreePath00;
    iter: TreeIter; newOrder: ptr int32; length: int32) {.
    importc, libprag.}

proc rowsReordered*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath; iter: TreeIter = cast[var TreeIter](nil); newOrder: seq[int32]) =
  let length = int(newOrder.len)
  gtk_tree_model_rows_reordered_with_length(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), iter, cast[ptr int32](unsafeaddr(newOrder[0])), int32(length))

proc gtk_tree_model_unref_node(self: ptr TreeModel00; iter: TreeIter) {.
    importc, libprag.}

proc unrefNode*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter) =
  gtk_tree_model_unref_node(cast[ptr TreeModel00](self.impl), iter)

proc gtk_combo_box_new_with_model(model: ptr TreeModel00): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBoxWithModel*(model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): ComboBox {.deprecated.}  =
  let gobj = gtk_combo_box_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxWithModel*(tdesc: typedesc; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): tdesc {.deprecated.}  =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithModel*[T](result: var T; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_model_and_entry(model: ptr TreeModel00): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBoxWithModelAndEntry*(model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): ComboBox {.deprecated.}  =
  let gobj = gtk_combo_box_new_with_model_and_entry(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxWithModelAndEntry*(tdesc: typedesc; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): tdesc {.deprecated.}  =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_model_and_entry(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithModelAndEntry*[T](result: var T; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_model_and_entry(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_get_model(self: ptr ComboBox00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: ComboBox): TreeModel =
  let gobj = gtk_combo_box_get_model(cast[ptr ComboBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: ComboBox): TreeModel =
  let gobj = gtk_combo_box_get_model(cast[ptr ComboBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_set_model(self: ptr ComboBox00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: ComboBox; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_combo_box_set_model(cast[ptr ComboBox00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: ComboBox; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_combo_box_set_model(cast[ptr ComboBox00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc gtk_tree_model_filter_get_model(self: ptr TreeModelFilter00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: TreeModelFilter): TreeModel =
  let gobj = gtk_tree_model_filter_get_model(cast[ptr TreeModelFilter00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: TreeModelFilter): TreeModel =
  let gobj = gtk_tree_model_filter_get_model(cast[ptr TreeModelFilter00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_model_sort_new_with_model(childModel: ptr TreeModel00): ptr TreeModelSort00 {.
    importc, libprag.}

proc newTreeModelSortWithModel*(childModel: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): TreeModelSort =
  let gobj = gtk_tree_model_sort_new_with_model(cast[ptr TreeModel00](childModel.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeModelSortWithModel*(tdesc: typedesc; childModel: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): tdesc =
  assert(result is TreeModelSort)
  let gobj = gtk_tree_model_sort_new_with_model(cast[ptr TreeModel00](childModel.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeModelSortWithModel*[T](result: var T; childModel: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) {.deprecated.} =
  assert(result is TreeModelSort)
  let gobj = gtk_tree_model_sort_new_with_model(cast[ptr TreeModel00](childModel.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_model_sort_get_model(self: ptr TreeModelSort00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: TreeModelSort): TreeModel =
  let gobj = gtk_tree_model_sort_get_model(cast[ptr TreeModelSort00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: TreeModelSort): TreeModel =
  let gobj = gtk_tree_model_sort_get_model(cast[ptr TreeModelSort00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TreeModelFlag* {.size: sizeof(cint), pure.} = enum
    itersPersist = 0
    listOnly = 1

  TreeModelFlags* = set[TreeModelFlag]

proc gtk_tree_model_get_flags(self: ptr TreeModel00): TreeModelFlags {.
    importc, libprag.}

proc getFlags*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): TreeModelFlags =
  gtk_tree_model_get_flags(cast[ptr TreeModel00](self.impl))

proc flags*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): TreeModelFlags =
  gtk_tree_model_get_flags(cast[ptr TreeModel00](self.impl))

type
  StackPage* = ref object of gobject.Object
  StackPage00* = object of gobject.Object00

proc gtk_stack_page_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StackPage()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_stack_page_get_child(self: ptr StackPage00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: StackPage): Widget =
  let gobj = gtk_stack_page_get_child(cast[ptr StackPage00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: StackPage): Widget =
  let gobj = gtk_stack_page_get_child(cast[ptr StackPage00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_page_get_icon_name(self: ptr StackPage00): cstring {.
    importc, libprag.}

proc getIconName*(self: StackPage): string =
  let resul0 = gtk_stack_page_get_icon_name(cast[ptr StackPage00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc iconName*(self: StackPage): string =
  let resul0 = gtk_stack_page_get_icon_name(cast[ptr StackPage00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_stack_page_get_name(self: ptr StackPage00): cstring {.
    importc, libprag.}

proc getName*(self: StackPage): string =
  let resul0 = gtk_stack_page_get_name(cast[ptr StackPage00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc name*(self: StackPage): string =
  let resul0 = gtk_stack_page_get_name(cast[ptr StackPage00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_stack_page_get_needs_attention(self: ptr StackPage00): gboolean {.
    importc, libprag.}

proc getNeedsAttention*(self: StackPage): bool =
  toBool(gtk_stack_page_get_needs_attention(cast[ptr StackPage00](self.impl)))

proc needsAttention*(self: StackPage): bool =
  toBool(gtk_stack_page_get_needs_attention(cast[ptr StackPage00](self.impl)))

proc gtk_stack_page_get_title(self: ptr StackPage00): cstring {.
    importc, libprag.}

proc getTitle*(self: StackPage): string =
  let resul0 = gtk_stack_page_get_title(cast[ptr StackPage00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc title*(self: StackPage): string =
  let resul0 = gtk_stack_page_get_title(cast[ptr StackPage00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_stack_page_get_use_underline(self: ptr StackPage00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: StackPage): bool =
  toBool(gtk_stack_page_get_use_underline(cast[ptr StackPage00](self.impl)))

proc useUnderline*(self: StackPage): bool =
  toBool(gtk_stack_page_get_use_underline(cast[ptr StackPage00](self.impl)))

proc gtk_stack_page_get_visible(self: ptr StackPage00): gboolean {.
    importc, libprag.}

proc getVisible*(self: StackPage): bool =
  toBool(gtk_stack_page_get_visible(cast[ptr StackPage00](self.impl)))

proc visible*(self: StackPage): bool =
  toBool(gtk_stack_page_get_visible(cast[ptr StackPage00](self.impl)))

proc gtk_stack_page_set_icon_name(self: ptr StackPage00; setting: cstring) {.
    importc, libprag.}

proc setIconName*(self: StackPage; setting: cstring) =
  gtk_stack_page_set_icon_name(cast[ptr StackPage00](self.impl), setting)

proc `iconName=`*(self: StackPage; setting: cstring) =
  gtk_stack_page_set_icon_name(cast[ptr StackPage00](self.impl), setting)

proc gtk_stack_page_set_name(self: ptr StackPage00; setting: cstring) {.
    importc, libprag.}

proc setName*(self: StackPage; setting: cstring) =
  gtk_stack_page_set_name(cast[ptr StackPage00](self.impl), setting)

proc `name=`*(self: StackPage; setting: cstring) =
  gtk_stack_page_set_name(cast[ptr StackPage00](self.impl), setting)

proc gtk_stack_page_set_needs_attention(self: ptr StackPage00; setting: gboolean) {.
    importc, libprag.}

proc setNeedsAttention*(self: StackPage; setting: bool = true) =
  gtk_stack_page_set_needs_attention(cast[ptr StackPage00](self.impl), gboolean(setting))

proc `needsAttention=`*(self: StackPage; setting: bool) =
  gtk_stack_page_set_needs_attention(cast[ptr StackPage00](self.impl), gboolean(setting))

proc gtk_stack_page_set_title(self: ptr StackPage00; setting: cstring) {.
    importc, libprag.}

proc setTitle*(self: StackPage; setting: cstring) =
  gtk_stack_page_set_title(cast[ptr StackPage00](self.impl), setting)

proc `title=`*(self: StackPage; setting: cstring) =
  gtk_stack_page_set_title(cast[ptr StackPage00](self.impl), setting)

proc gtk_stack_page_set_use_underline(self: ptr StackPage00; setting: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: StackPage; setting: bool = true) =
  gtk_stack_page_set_use_underline(cast[ptr StackPage00](self.impl), gboolean(setting))

proc `useUnderline=`*(self: StackPage; setting: bool) =
  gtk_stack_page_set_use_underline(cast[ptr StackPage00](self.impl), gboolean(setting))

proc gtk_stack_page_set_visible(self: ptr StackPage00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: StackPage; visible: bool = true) =
  gtk_stack_page_set_visible(cast[ptr StackPage00](self.impl), gboolean(visible))

proc `visible=`*(self: StackPage; visible: bool) =
  gtk_stack_page_set_visible(cast[ptr StackPage00](self.impl), gboolean(visible))

proc gtk_stack_add_child(self: ptr Stack00; child: ptr Widget00): ptr StackPage00 {.
    importc, libprag.}

proc addChild*(self: Stack; child: Widget): StackPage =
  let gobj = gtk_stack_add_child(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_add_named(self: ptr Stack00; child: ptr Widget00; name: cstring): ptr StackPage00 {.
    importc, libprag.}

proc addNamed*(self: Stack; child: Widget; name: cstring = nil): StackPage =
  let gobj = gtk_stack_add_named(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl), name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_add_titled(self: ptr Stack00; child: ptr Widget00; name: cstring;
    title: cstring): ptr StackPage00 {.
    importc, libprag.}

proc addTitled*(self: Stack; child: Widget; name: cstring = nil;
    title: cstring): StackPage =
  let gobj = gtk_stack_add_titled(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl), name, title)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_get_page(self: ptr Stack00; child: ptr Widget00): ptr StackPage00 {.
    importc, libprag.}

proc getPage*(self: Stack; child: Widget): StackPage =
  let gobj = gtk_stack_get_page(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SingleSelection* = ref object of gobject.Object
  SingleSelection00* = object of gobject.Object00

proc gtk_single_selection_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SingleSelection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_single_selection_new(model: ptr gio.ListModel00): ptr SingleSelection00 {.
    importc, libprag.}

proc newSingleSelection*(model: gio.ListModel = nil): SingleSelection =
  let gobj = gtk_single_selection_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSingleSelection*(tdesc: typedesc; model: gio.ListModel = nil): tdesc =
  assert(result is SingleSelection)
  let gobj = gtk_single_selection_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSingleSelection*[T](result: var T; model: gio.ListModel = nil) {.deprecated.} =
  assert(result is SingleSelection)
  let gobj = gtk_single_selection_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_single_selection_get_autoselect(self: ptr SingleSelection00): gboolean {.
    importc, libprag.}

proc getAutoselect*(self: SingleSelection): bool =
  toBool(gtk_single_selection_get_autoselect(cast[ptr SingleSelection00](self.impl)))

proc autoselect*(self: SingleSelection): bool =
  toBool(gtk_single_selection_get_autoselect(cast[ptr SingleSelection00](self.impl)))

proc gtk_single_selection_get_can_unselect(self: ptr SingleSelection00): gboolean {.
    importc, libprag.}

proc getCanUnselect*(self: SingleSelection): bool =
  toBool(gtk_single_selection_get_can_unselect(cast[ptr SingleSelection00](self.impl)))

proc canUnselect*(self: SingleSelection): bool =
  toBool(gtk_single_selection_get_can_unselect(cast[ptr SingleSelection00](self.impl)))

proc gtk_single_selection_get_model(self: ptr SingleSelection00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: SingleSelection): gio.ListModel =
  let gobj = gtk_single_selection_get_model(cast[ptr SingleSelection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: SingleSelection): gio.ListModel =
  let gobj = gtk_single_selection_get_model(cast[ptr SingleSelection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_single_selection_get_selected(self: ptr SingleSelection00): uint32 {.
    importc, libprag.}

proc getSelected*(self: SingleSelection): int =
  int(gtk_single_selection_get_selected(cast[ptr SingleSelection00](self.impl)))

proc selected*(self: SingleSelection): int =
  int(gtk_single_selection_get_selected(cast[ptr SingleSelection00](self.impl)))

proc gtk_single_selection_get_selected_item(self: ptr SingleSelection00): ptr gobject.Object00 {.
    importc, libprag.}

proc getSelectedItem*(self: SingleSelection): gobject.Object =
  let gobj = gtk_single_selection_get_selected_item(cast[ptr SingleSelection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectedItem*(self: SingleSelection): gobject.Object =
  let gobj = gtk_single_selection_get_selected_item(cast[ptr SingleSelection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_single_selection_set_autoselect(self: ptr SingleSelection00; autoselect: gboolean) {.
    importc, libprag.}

proc setAutoselect*(self: SingleSelection; autoselect: bool = true) =
  gtk_single_selection_set_autoselect(cast[ptr SingleSelection00](self.impl), gboolean(autoselect))

proc `autoselect=`*(self: SingleSelection; autoselect: bool) =
  gtk_single_selection_set_autoselect(cast[ptr SingleSelection00](self.impl), gboolean(autoselect))

proc gtk_single_selection_set_can_unselect(self: ptr SingleSelection00; canUnselect: gboolean) {.
    importc, libprag.}

proc setCanUnselect*(self: SingleSelection; canUnselect: bool = true) =
  gtk_single_selection_set_can_unselect(cast[ptr SingleSelection00](self.impl), gboolean(canUnselect))

proc `canUnselect=`*(self: SingleSelection; canUnselect: bool) =
  gtk_single_selection_set_can_unselect(cast[ptr SingleSelection00](self.impl), gboolean(canUnselect))

proc gtk_single_selection_set_model(self: ptr SingleSelection00; model: ptr gio.ListModel00) {.
    importc, libprag.}

proc setModel*(self: SingleSelection; model: gio.ListModel = nil) =
  gtk_single_selection_set_model(cast[ptr SingleSelection00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc `model=`*(self: SingleSelection; model: gio.ListModel = nil) =
  gtk_single_selection_set_model(cast[ptr SingleSelection00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc gtk_single_selection_set_selected(self: ptr SingleSelection00; position: uint32) {.
    importc, libprag.}

proc setSelected*(self: SingleSelection; position: int) =
  gtk_single_selection_set_selected(cast[ptr SingleSelection00](self.impl), uint32(position))

proc `selected=`*(self: SingleSelection; position: int) =
  gtk_single_selection_set_selected(cast[ptr SingleSelection00](self.impl), uint32(position))

type
  MultiSelection* = ref object of gobject.Object
  MultiSelection00* = object of gobject.Object00

proc gtk_multi_selection_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MultiSelection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_multi_selection_new(model: ptr gio.ListModel00): ptr MultiSelection00 {.
    importc, libprag.}

proc newMultiSelection*(model: gio.ListModel = nil): MultiSelection =
  let gobj = gtk_multi_selection_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMultiSelection*(tdesc: typedesc; model: gio.ListModel = nil): tdesc =
  assert(result is MultiSelection)
  let gobj = gtk_multi_selection_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMultiSelection*[T](result: var T; model: gio.ListModel = nil) {.deprecated.} =
  assert(result is MultiSelection)
  let gobj = gtk_multi_selection_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_multi_selection_get_model(self: ptr MultiSelection00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: MultiSelection): gio.ListModel =
  let gobj = gtk_multi_selection_get_model(cast[ptr MultiSelection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: MultiSelection): gio.ListModel =
  let gobj = gtk_multi_selection_get_model(cast[ptr MultiSelection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_multi_selection_set_model(self: ptr MultiSelection00; model: ptr gio.ListModel00) {.
    importc, libprag.}

proc setModel*(self: MultiSelection; model: gio.ListModel = nil) =
  gtk_multi_selection_set_model(cast[ptr MultiSelection00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc `model=`*(self: MultiSelection; model: gio.ListModel = nil) =
  gtk_multi_selection_set_model(cast[ptr MultiSelection00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

type
  NoSelection* = ref object of gobject.Object
  NoSelection00* = object of gobject.Object00

proc gtk_no_selection_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NoSelection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_no_selection_new(model: ptr gio.ListModel00): ptr NoSelection00 {.
    importc, libprag.}

proc newNoSelection*(model: gio.ListModel = nil): NoSelection =
  let gobj = gtk_no_selection_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newNoSelection*(tdesc: typedesc; model: gio.ListModel = nil): tdesc =
  assert(result is NoSelection)
  let gobj = gtk_no_selection_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initNoSelection*[T](result: var T; model: gio.ListModel = nil) {.deprecated.} =
  assert(result is NoSelection)
  let gobj = gtk_no_selection_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_no_selection_get_model(self: ptr NoSelection00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: NoSelection): gio.ListModel =
  let gobj = gtk_no_selection_get_model(cast[ptr NoSelection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: NoSelection): gio.ListModel =
  let gobj = gtk_no_selection_get_model(cast[ptr NoSelection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_no_selection_set_model(self: ptr NoSelection00; model: ptr gio.ListModel00) {.
    importc, libprag.}

proc setModel*(self: NoSelection; model: gio.ListModel = nil) =
  gtk_no_selection_set_model(cast[ptr NoSelection00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc `model=`*(self: NoSelection; model: gio.ListModel = nil) =
  gtk_no_selection_set_model(cast[ptr NoSelection00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

type
  SelectionModel00* = object of gobject.Object00
  SelectionModel* = ref object of gobject.Object

proc scSelectionChanged*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection;  p: proc (self: ptr SelectionModel00; position: uint32; nItems: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_selection_model_is_selected(self: ptr SelectionModel00; position: uint32): gboolean {.
    importc, libprag.}

proc isSelected*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection;
    position: int): bool =
  toBool(gtk_selection_model_is_selected(cast[ptr SelectionModel00](self.impl), uint32(position)))

proc gtk_selection_model_select_all(self: ptr SelectionModel00): gboolean {.
    importc, libprag.}

proc selectAll*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection): bool =
  toBool(gtk_selection_model_select_all(cast[ptr SelectionModel00](self.impl)))

proc gtk_selection_model_select_item(self: ptr SelectionModel00; position: uint32;
    unselectRest: gboolean): gboolean {.
    importc, libprag.}

proc selectItem*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection;
    position: int; unselectRest: bool): bool =
  toBool(gtk_selection_model_select_item(cast[ptr SelectionModel00](self.impl), uint32(position), gboolean(unselectRest)))

proc gtk_selection_model_select_range(self: ptr SelectionModel00; position: uint32;
    nItems: uint32; unselectRest: gboolean): gboolean {.
    importc, libprag.}

proc selectRange*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection;
    position: int; nItems: int; unselectRest: bool): bool =
  toBool(gtk_selection_model_select_range(cast[ptr SelectionModel00](self.impl), uint32(position), uint32(nItems), gboolean(unselectRest)))

proc gtk_selection_model_selection_changed(self: ptr SelectionModel00; position: uint32;
    nItems: uint32) {.
    importc, libprag.}

proc selectionChanged*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection;
    position: int; nItems: int) =
  gtk_selection_model_selection_changed(cast[ptr SelectionModel00](self.impl), uint32(position), uint32(nItems))

proc gtk_selection_model_unselect_all(self: ptr SelectionModel00): gboolean {.
    importc, libprag.}

proc unselectAll*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection): bool =
  toBool(gtk_selection_model_unselect_all(cast[ptr SelectionModel00](self.impl)))

proc gtk_selection_model_unselect_item(self: ptr SelectionModel00; position: uint32): gboolean {.
    importc, libprag.}

proc unselectItem*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection;
    position: int): bool =
  toBool(gtk_selection_model_unselect_item(cast[ptr SelectionModel00](self.impl), uint32(position)))

proc gtk_selection_model_unselect_range(self: ptr SelectionModel00; position: uint32;
    nItems: uint32): gboolean {.
    importc, libprag.}

proc unselectRange*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection;
    position: int; nItems: int): bool =
  toBool(gtk_selection_model_unselect_range(cast[ptr SelectionModel00](self.impl), uint32(position), uint32(nItems)))

proc gtk_stack_get_pages(self: ptr Stack00): ptr SelectionModel00 {.
    importc, libprag.}

proc getPages*(self: Stack): SelectionModel =
  let gobj = gtk_stack_get_pages(cast[ptr Stack00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pages*(self: Stack): SelectionModel =
  let gobj = gtk_stack_get_pages(cast[ptr Stack00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Bitset00* {.pure.} = object
  Bitset* = ref object
    impl*: ptr Bitset00
    ignoreFinalizer*: bool

proc gtk_bitset_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkBitset*(self: Bitset) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_bitset_get_type(), cast[ptr Bitset00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Bitset()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_bitset_get_type(), cast[ptr Bitset00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var Bitset) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkBitset)

proc gtk_bitset_unref(self: ptr Bitset00) {.
    importc, libprag.}

proc unref*(self: Bitset) =
  gtk_bitset_unref(cast[ptr Bitset00](self.impl))

proc finalizerunref*(self: Bitset) =
  if not self.ignoreFinalizer:
    gtk_bitset_unref(cast[ptr Bitset00](self.impl))

proc gtk_bitset_new_range(start: uint32; nItems: uint32): ptr Bitset00 {.
    importc, libprag.}

proc newBitsetRange*(start: int; nItems: int): Bitset =
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_bitset_new_range(uint32(start), uint32(nItems))

proc newBitsetRange*(tdesc: typedesc; start: int; nItems: int): tdesc =
  assert(result is Bitset)
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_bitset_new_range(uint32(start), uint32(nItems))

proc initBitsetRange*[T](result: var T; start: int; nItems: int) {.deprecated.} =
  assert(result is Bitset)
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_bitset_new_range(uint32(start), uint32(nItems))

proc gtk_bitset_add(self: ptr Bitset00; value: uint32): gboolean {.
    importc, libprag.}

proc add*(self: Bitset; value: int): bool =
  toBool(gtk_bitset_add(cast[ptr Bitset00](self.impl), uint32(value)))

proc gtk_bitset_add_range(self: ptr Bitset00; start: uint32; nItems: uint32) {.
    importc, libprag.}

proc addRange*(self: Bitset; start: int; nItems: int) =
  gtk_bitset_add_range(cast[ptr Bitset00](self.impl), uint32(start), uint32(nItems))

proc gtk_bitset_add_range_closed(self: ptr Bitset00; first: uint32; last: uint32) {.
    importc, libprag.}

proc addRangeClosed*(self: Bitset; first: int; last: int) =
  gtk_bitset_add_range_closed(cast[ptr Bitset00](self.impl), uint32(first), uint32(last))

proc gtk_bitset_add_rectangle(self: ptr Bitset00; start: uint32; width: uint32;
    height: uint32; stride: uint32) {.
    importc, libprag.}

proc addRectangle*(self: Bitset; start: int; width: int; height: int;
    stride: int) =
  gtk_bitset_add_rectangle(cast[ptr Bitset00](self.impl), uint32(start), uint32(width), uint32(height), uint32(stride))

proc gtk_bitset_contains(self: ptr Bitset00; value: uint32): gboolean {.
    importc, libprag.}

proc contains*(self: Bitset; value: int): bool =
  toBool(gtk_bitset_contains(cast[ptr Bitset00](self.impl), uint32(value)))

proc gtk_bitset_copy(self: ptr Bitset00): ptr Bitset00 {.
    importc, libprag.}

proc copy*(self: Bitset): Bitset =
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_bitset_copy(cast[ptr Bitset00](self.impl))

proc gtk_bitset_difference(self: ptr Bitset00; other: ptr Bitset00) {.
    importc, libprag.}

proc difference*(self: Bitset; other: Bitset) =
  gtk_bitset_difference(cast[ptr Bitset00](self.impl), cast[ptr Bitset00](other.impl))

proc gtk_bitset_equals(self: ptr Bitset00; other: ptr Bitset00): gboolean {.
    importc, libprag.}

proc equals*(self: Bitset; other: Bitset): bool =
  toBool(gtk_bitset_equals(cast[ptr Bitset00](self.impl), cast[ptr Bitset00](other.impl)))

proc gtk_bitset_get_maximum(self: ptr Bitset00): uint32 {.
    importc, libprag.}

proc getMaximum*(self: Bitset): int =
  int(gtk_bitset_get_maximum(cast[ptr Bitset00](self.impl)))

proc maximum*(self: Bitset): int =
  int(gtk_bitset_get_maximum(cast[ptr Bitset00](self.impl)))

proc gtk_bitset_get_minimum(self: ptr Bitset00): uint32 {.
    importc, libprag.}

proc getMinimum*(self: Bitset): int =
  int(gtk_bitset_get_minimum(cast[ptr Bitset00](self.impl)))

proc minimum*(self: Bitset): int =
  int(gtk_bitset_get_minimum(cast[ptr Bitset00](self.impl)))

proc gtk_bitset_get_nth(self: ptr Bitset00; nth: uint32): uint32 {.
    importc, libprag.}

proc getNth*(self: Bitset; nth: int): int =
  int(gtk_bitset_get_nth(cast[ptr Bitset00](self.impl), uint32(nth)))

proc gtk_bitset_get_size(self: ptr Bitset00): uint64 {.
    importc, libprag.}

proc getSize*(self: Bitset): uint64 =
  gtk_bitset_get_size(cast[ptr Bitset00](self.impl))

proc size*(self: Bitset): uint64 =
  gtk_bitset_get_size(cast[ptr Bitset00](self.impl))

proc gtk_bitset_get_size_in_range(self: ptr Bitset00; first: uint32; last: uint32): uint64 {.
    importc, libprag.}

proc getSizeInRange*(self: Bitset; first: int; last: int): uint64 =
  gtk_bitset_get_size_in_range(cast[ptr Bitset00](self.impl), uint32(first), uint32(last))

proc gtk_bitset_intersect(self: ptr Bitset00; other: ptr Bitset00) {.
    importc, libprag.}

proc intersect*(self: Bitset; other: Bitset) =
  gtk_bitset_intersect(cast[ptr Bitset00](self.impl), cast[ptr Bitset00](other.impl))

proc gtk_bitset_is_empty(self: ptr Bitset00): gboolean {.
    importc, libprag.}

proc isEmpty*(self: Bitset): bool =
  toBool(gtk_bitset_is_empty(cast[ptr Bitset00](self.impl)))

proc gtk_bitset_ref(self: ptr Bitset00): ptr Bitset00 {.
    importc, libprag.}

proc `ref`*(self: Bitset): Bitset =
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_bitset_ref(cast[ptr Bitset00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_bitset_get_type(), result.impl))

proc gtk_bitset_remove(self: ptr Bitset00; value: uint32): gboolean {.
    importc, libprag.}

proc remove*(self: Bitset; value: int): bool =
  toBool(gtk_bitset_remove(cast[ptr Bitset00](self.impl), uint32(value)))

proc gtk_bitset_remove_all(self: ptr Bitset00) {.
    importc, libprag.}

proc removeAll*(self: Bitset) =
  gtk_bitset_remove_all(cast[ptr Bitset00](self.impl))

proc gtk_bitset_remove_range(self: ptr Bitset00; start: uint32; nItems: uint32) {.
    importc, libprag.}

proc removeRange*(self: Bitset; start: int; nItems: int) =
  gtk_bitset_remove_range(cast[ptr Bitset00](self.impl), uint32(start), uint32(nItems))

proc gtk_bitset_remove_range_closed(self: ptr Bitset00; first: uint32; last: uint32) {.
    importc, libprag.}

proc removeRangeClosed*(self: Bitset; first: int; last: int) =
  gtk_bitset_remove_range_closed(cast[ptr Bitset00](self.impl), uint32(first), uint32(last))

proc gtk_bitset_remove_rectangle(self: ptr Bitset00; start: uint32; width: uint32;
    height: uint32; stride: uint32) {.
    importc, libprag.}

proc removeRectangle*(self: Bitset; start: int; width: int; height: int;
    stride: int) =
  gtk_bitset_remove_rectangle(cast[ptr Bitset00](self.impl), uint32(start), uint32(width), uint32(height), uint32(stride))

proc gtk_bitset_shift_left(self: ptr Bitset00; amount: uint32) {.
    importc, libprag.}

proc shiftLeft*(self: Bitset; amount: int) =
  gtk_bitset_shift_left(cast[ptr Bitset00](self.impl), uint32(amount))

proc gtk_bitset_shift_right(self: ptr Bitset00; amount: uint32) {.
    importc, libprag.}

proc shiftRight*(self: Bitset; amount: int) =
  gtk_bitset_shift_right(cast[ptr Bitset00](self.impl), uint32(amount))

proc gtk_bitset_splice(self: ptr Bitset00; position: uint32; removed: uint32;
    added: uint32) {.
    importc, libprag.}

proc splice*(self: Bitset; position: int; removed: int; added: int) =
  gtk_bitset_splice(cast[ptr Bitset00](self.impl), uint32(position), uint32(removed), uint32(added))

proc gtk_bitset_subtract(self: ptr Bitset00; other: ptr Bitset00) {.
    importc, libprag.}

proc subtract*(self: Bitset; other: Bitset) =
  gtk_bitset_subtract(cast[ptr Bitset00](self.impl), cast[ptr Bitset00](other.impl))

proc gtk_bitset_union(self: ptr Bitset00; other: ptr Bitset00) {.
    importc, libprag.}

proc union*(self: Bitset; other: Bitset) =
  gtk_bitset_union(cast[ptr Bitset00](self.impl), cast[ptr Bitset00](other.impl))

proc gtk_bitset_new_empty(): ptr Bitset00 {.
    importc, libprag.}

proc newBitsetEmpty*(): Bitset =
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_bitset_new_empty()

proc newBitsetEmpty*(tdesc: typedesc): tdesc =
  assert(result is Bitset)
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_bitset_new_empty()

proc initBitsetEmpty*[T](result: var T) {.deprecated.} =
  assert(result is Bitset)
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_bitset_new_empty()

proc gtk_selection_model_get_selection(self: ptr SelectionModel00): ptr Bitset00 {.
    importc, libprag.}

proc getSelection*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection): Bitset =
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_selection_model_get_selection(cast[ptr SelectionModel00](self.impl))

proc selection*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection): Bitset =
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_selection_model_get_selection(cast[ptr SelectionModel00](self.impl))

proc gtk_selection_model_get_selection_in_range(self: ptr SelectionModel00;
    position: uint32; nItems: uint32): ptr Bitset00 {.
    importc, libprag.}

proc getSelectionInRange*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection;
    position: int; nItems: int): Bitset =
  fnew(result, gBoxedFreeGtkBitset)
  result.impl = gtk_selection_model_get_selection_in_range(cast[ptr SelectionModel00](self.impl), uint32(position), uint32(nItems))

proc gtk_selection_model_set_selection(self: ptr SelectionModel00; selected: ptr Bitset00;
    mask: ptr Bitset00): gboolean {.
    importc, libprag.}

proc setSelection*(self: SelectionModel | SingleSelection | MultiSelection | NoSelection;
    selected: Bitset; mask: Bitset): bool =
  toBool(gtk_selection_model_set_selection(cast[ptr SelectionModel00](self.impl), cast[ptr Bitset00](selected.impl), cast[ptr Bitset00](mask.impl)))

type
  StackTransitionType* {.size: sizeof(cint), pure.} = enum
    none = 0
    crossfade = 1
    slideRight = 2
    slideLeft = 3
    slideUp = 4
    slideDown = 5
    slideLeftRight = 6
    slideUpDown = 7
    overUp = 8
    overDown = 9
    overLeft = 10
    overRight = 11
    underUp = 12
    underDown = 13
    underLeft = 14
    underRight = 15
    overUpDown = 16
    overDownUp = 17
    overLeftRight = 18
    overRightLeft = 19
    rotateLeft = 20
    rotateRight = 21
    rotateLeftRight = 22

proc gtk_stack_get_transition_type(self: ptr Stack00): StackTransitionType {.
    importc, libprag.}

proc getTransitionType*(self: Stack): StackTransitionType =
  gtk_stack_get_transition_type(cast[ptr Stack00](self.impl))

proc transitionType*(self: Stack): StackTransitionType =
  gtk_stack_get_transition_type(cast[ptr Stack00](self.impl))

proc gtk_stack_set_transition_type(self: ptr Stack00; transition: StackTransitionType) {.
    importc, libprag.}

proc setTransitionType*(self: Stack; transition: StackTransitionType) =
  gtk_stack_set_transition_type(cast[ptr Stack00](self.impl), transition)

proc `transitionType=`*(self: Stack; transition: StackTransitionType) =
  gtk_stack_set_transition_type(cast[ptr Stack00](self.impl), transition)

proc gtk_stack_set_visible_child_full(self: ptr Stack00; name: cstring; transition: StackTransitionType) {.
    importc, libprag.}

proc setVisibleChildFull*(self: Stack; name: cstring; transition: StackTransitionType) =
  gtk_stack_set_visible_child_full(cast[ptr Stack00](self.impl), name, transition)

type
  BaselinePosition* {.size: sizeof(cint), pure.} = enum
    top = 0
    center = 1
    bottom = 2

proc gtk_box_get_baseline_position(self: ptr Box00): BaselinePosition {.
    importc, libprag.}

proc getBaselinePosition*(self: Box): BaselinePosition =
  gtk_box_get_baseline_position(cast[ptr Box00](self.impl))

proc baselinePosition*(self: Box): BaselinePosition =
  gtk_box_get_baseline_position(cast[ptr Box00](self.impl))

proc gtk_box_set_baseline_position(self: ptr Box00; position: BaselinePosition) {.
    importc, libprag.}

proc setBaselinePosition*(self: Box; position: BaselinePosition) =
  gtk_box_set_baseline_position(cast[ptr Box00](self.impl), position)

proc `baselinePosition=`*(self: Box; position: BaselinePosition) =
  gtk_box_set_baseline_position(cast[ptr Box00](self.impl), position)

type
  ShortcutsShortcut* = ref object of Widget
  ShortcutsShortcut00* = object of Widget00

proc gtk_shortcuts_shortcut_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutsShortcut()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_shortcuts_group_add_shortcut(self: ptr ShortcutsGroup00; shortcut: ptr ShortcutsShortcut00) {.
    importc, libprag.}

proc addShortcut*(self: ShortcutsGroup; shortcut: ShortcutsShortcut) =
  gtk_shortcuts_group_add_shortcut(cast[ptr ShortcutsGroup00](self.impl), cast[ptr ShortcutsShortcut00](shortcut.impl))

type
  HeaderBar* = ref object of Widget
  HeaderBar00* = object of Widget00

proc gtk_header_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HeaderBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_header_bar_new(): ptr HeaderBar00 {.
    importc, libprag.}

proc newHeaderBar*(): HeaderBar =
  let gobj = gtk_header_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHeaderBar*(tdesc: typedesc): tdesc =
  assert(result is HeaderBar)
  let gobj = gtk_header_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHeaderBar*[T](result: var T) {.deprecated.} =
  assert(result is HeaderBar)
  let gobj = gtk_header_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_header_bar_get_decoration_layout(self: ptr HeaderBar00): cstring {.
    importc, libprag.}

proc getDecorationLayout*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_decoration_layout(cast[ptr HeaderBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc decorationLayout*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_decoration_layout(cast[ptr HeaderBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_header_bar_get_show_title_buttons(self: ptr HeaderBar00): gboolean {.
    importc, libprag.}

proc getShowTitleButtons*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_show_title_buttons(cast[ptr HeaderBar00](self.impl)))

proc showTitleButtons*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_show_title_buttons(cast[ptr HeaderBar00](self.impl)))

proc gtk_header_bar_get_title_widget(self: ptr HeaderBar00): ptr Widget00 {.
    importc, libprag.}

proc getTitleWidget*(self: HeaderBar): Widget =
  let gobj = gtk_header_bar_get_title_widget(cast[ptr HeaderBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc titleWidget*(self: HeaderBar): Widget =
  let gobj = gtk_header_bar_get_title_widget(cast[ptr HeaderBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_header_bar_pack_end(self: ptr HeaderBar00; child: ptr Widget00) {.
    importc, libprag.}

proc packEnd*(self: HeaderBar; child: Widget) =
  gtk_header_bar_pack_end(cast[ptr HeaderBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_header_bar_pack_start(self: ptr HeaderBar00; child: ptr Widget00) {.
    importc, libprag.}

proc packStart*(self: HeaderBar; child: Widget) =
  gtk_header_bar_pack_start(cast[ptr HeaderBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_header_bar_remove(self: ptr HeaderBar00; child: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: HeaderBar; child: Widget) =
  gtk_header_bar_remove(cast[ptr HeaderBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_header_bar_set_decoration_layout(self: ptr HeaderBar00; layout: cstring) {.
    importc, libprag.}

proc setDecorationLayout*(self: HeaderBar; layout: cstring = nil) =
  gtk_header_bar_set_decoration_layout(cast[ptr HeaderBar00](self.impl), layout)

proc `decorationLayout=`*(self: HeaderBar; layout: cstring = nil) =
  gtk_header_bar_set_decoration_layout(cast[ptr HeaderBar00](self.impl), layout)

proc gtk_header_bar_set_show_title_buttons(self: ptr HeaderBar00; setting: gboolean) {.
    importc, libprag.}

proc setShowTitleButtons*(self: HeaderBar; setting: bool = true) =
  gtk_header_bar_set_show_title_buttons(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc `showTitleButtons=`*(self: HeaderBar; setting: bool) =
  gtk_header_bar_set_show_title_buttons(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc gtk_header_bar_set_title_widget(self: ptr HeaderBar00; titleWidget: ptr Widget00) {.
    importc, libprag.}

proc setTitleWidget*(self: HeaderBar; titleWidget: Widget = nil) =
  gtk_header_bar_set_title_widget(cast[ptr HeaderBar00](self.impl), if titleWidget.isNil: nil else: cast[ptr Widget00](titleWidget.impl))

proc `titleWidget=`*(self: HeaderBar; titleWidget: Widget = nil) =
  gtk_header_bar_set_title_widget(cast[ptr HeaderBar00](self.impl), if titleWidget.isNil: nil else: cast[ptr Widget00](titleWidget.impl))

proc gtk_dialog_get_header_bar(self: ptr Dialog00): ptr HeaderBar00 {.
    importc, libprag.}

proc getHeaderBar*(self: Dialog): HeaderBar =
  let gobj = gtk_dialog_get_header_bar(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc headerBar*(self: Dialog): HeaderBar =
  let gobj = gtk_dialog_get_header_bar(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  PositionType* {.size: sizeof(cint), pure.} = enum
    left = 0
    right = 1
    top = 2
    bottom = 3

type
  ScrolledWindow* = ref object of Widget
  ScrolledWindow00* = object of Widget00

proc gtk_scrolled_window_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ScrolledWindow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEdgeOvershot*(self: ScrolledWindow;  p: proc (self: ptr ScrolledWindow00; pos: PositionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "edge-overshot", cast[GCallback](p), xdata, nil, cf)

proc scEdgeReached*(self: ScrolledWindow;  p: proc (self: ptr ScrolledWindow00; pos: PositionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "edge-reached", cast[GCallback](p), xdata, nil, cf)

proc scMoveFocusOut*(self: ScrolledWindow;  p: proc (self: ptr ScrolledWindow00; directionType: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-focus-out", cast[GCallback](p), xdata, nil, cf)

proc scScrollChild*(self: ScrolledWindow;  p: proc (self: ptr ScrolledWindow00; scroll: ScrollType; horizontal: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll-child", cast[GCallback](p), xdata, nil, cf)

proc gtk_scrolled_window_new(): ptr ScrolledWindow00 {.
    importc, libprag.}

proc newScrolledWindow*(): ScrolledWindow =
  let gobj = gtk_scrolled_window_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScrolledWindow*(tdesc: typedesc): tdesc =
  assert(result is ScrolledWindow)
  let gobj = gtk_scrolled_window_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScrolledWindow*[T](result: var T) {.deprecated.} =
  assert(result is ScrolledWindow)
  let gobj = gtk_scrolled_window_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_child(self: ptr ScrolledWindow00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_child(cast[ptr ScrolledWindow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_child(cast[ptr ScrolledWindow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_has_frame(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getHasFrame*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_has_frame(cast[ptr ScrolledWindow00](self.impl)))

proc hasFrame*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_has_frame(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_hscrollbar(self: ptr ScrolledWindow00): ptr Widget00 {.
    importc, libprag.}

proc getHscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_hscrollbar(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_hscrollbar(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_kinetic_scrolling(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getKineticScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc kineticScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_max_content_height(self: ptr ScrolledWindow00): int32 {.
    importc, libprag.}

proc getMaxContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc maxContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_max_content_width(self: ptr ScrolledWindow00): int32 {.
    importc, libprag.}

proc getMaxContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc maxContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_min_content_height(self: ptr ScrolledWindow00): int32 {.
    importc, libprag.}

proc getMinContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc minContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_min_content_width(self: ptr ScrolledWindow00): int32 {.
    importc, libprag.}

proc getMinContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc minContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_overlay_scrolling(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getOverlayScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc overlayScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_propagate_natural_height(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getPropagateNaturalHeight*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl)))

proc propagateNaturalHeight*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_propagate_natural_width(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getPropagateNaturalWidth*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl)))

proc propagateNaturalWidth*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_vscrollbar(self: ptr ScrolledWindow00): ptr Widget00 {.
    importc, libprag.}

proc getVscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_vscrollbar(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_vscrollbar(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_set_child(self: ptr ScrolledWindow00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: ScrolledWindow; child: Widget = nil) =
  gtk_scrolled_window_set_child(cast[ptr ScrolledWindow00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: ScrolledWindow; child: Widget = nil) =
  gtk_scrolled_window_set_child(cast[ptr ScrolledWindow00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_scrolled_window_set_has_frame(self: ptr ScrolledWindow00; hasFrame: gboolean) {.
    importc, libprag.}

proc setHasFrame*(self: ScrolledWindow; hasFrame: bool = true) =
  gtk_scrolled_window_set_has_frame(cast[ptr ScrolledWindow00](self.impl), gboolean(hasFrame))

proc `hasFrame=`*(self: ScrolledWindow; hasFrame: bool) =
  gtk_scrolled_window_set_has_frame(cast[ptr ScrolledWindow00](self.impl), gboolean(hasFrame))

proc gtk_scrolled_window_set_kinetic_scrolling(self: ptr ScrolledWindow00;
    kineticScrolling: gboolean) {.
    importc, libprag.}

proc setKineticScrolling*(self: ScrolledWindow; kineticScrolling: bool = true) =
  gtk_scrolled_window_set_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(kineticScrolling))

proc `kineticScrolling=`*(self: ScrolledWindow; kineticScrolling: bool) =
  gtk_scrolled_window_set_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(kineticScrolling))

proc gtk_scrolled_window_set_max_content_height(self: ptr ScrolledWindow00;
    height: int32) {.
    importc, libprag.}

proc setMaxContentHeight*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_max_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc `maxContentHeight=`*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_max_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc gtk_scrolled_window_set_max_content_width(self: ptr ScrolledWindow00;
    width: int32) {.
    importc, libprag.}

proc setMaxContentWidth*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_max_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc `maxContentWidth=`*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_max_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc gtk_scrolled_window_set_min_content_height(self: ptr ScrolledWindow00;
    height: int32) {.
    importc, libprag.}

proc setMinContentHeight*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_min_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc `minContentHeight=`*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_min_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc gtk_scrolled_window_set_min_content_width(self: ptr ScrolledWindow00;
    width: int32) {.
    importc, libprag.}

proc setMinContentWidth*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_min_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc `minContentWidth=`*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_min_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc gtk_scrolled_window_set_overlay_scrolling(self: ptr ScrolledWindow00;
    overlayScrolling: gboolean) {.
    importc, libprag.}

proc setOverlayScrolling*(self: ScrolledWindow; overlayScrolling: bool = true) =
  gtk_scrolled_window_set_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(overlayScrolling))

proc `overlayScrolling=`*(self: ScrolledWindow; overlayScrolling: bool) =
  gtk_scrolled_window_set_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(overlayScrolling))

proc gtk_scrolled_window_set_propagate_natural_height(self: ptr ScrolledWindow00;
    propagate: gboolean) {.
    importc, libprag.}

proc setPropagateNaturalHeight*(self: ScrolledWindow;
    propagate: bool = true) =
  gtk_scrolled_window_set_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc `propagateNaturalHeight=`*(self: ScrolledWindow;
    propagate: bool) =
  gtk_scrolled_window_set_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc gtk_scrolled_window_set_propagate_natural_width(self: ptr ScrolledWindow00;
    propagate: gboolean) {.
    importc, libprag.}

proc setPropagateNaturalWidth*(self: ScrolledWindow;
    propagate: bool = true) =
  gtk_scrolled_window_set_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc `propagateNaturalWidth=`*(self: ScrolledWindow;
    propagate: bool) =
  gtk_scrolled_window_set_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc gtk_scrolled_window_unset_placement(self: ptr ScrolledWindow00) {.
    importc, libprag.}

proc unsetPlacement*(self: ScrolledWindow) =
  gtk_scrolled_window_unset_placement(cast[ptr ScrolledWindow00](self.impl))

proc gtk_popover_get_position(self: ptr Popover00): PositionType {.
    importc, libprag.}

proc getPosition*(self: Popover): PositionType =
  gtk_popover_get_position(cast[ptr Popover00](self.impl))

proc position*(self: Popover): PositionType =
  gtk_popover_get_position(cast[ptr Popover00](self.impl))

proc gtk_popover_set_position(self: ptr Popover00; position: PositionType) {.
    importc, libprag.}

proc setPosition*(self: Popover; position: PositionType) =
  gtk_popover_set_position(cast[ptr Popover00](self.impl), position)

proc `position=`*(self: Popover; position: PositionType) =
  gtk_popover_set_position(cast[ptr Popover00](self.impl), position)

proc gtk_scale_add_mark(self: ptr Scale00; value: cdouble; position: PositionType;
    markup: cstring) {.
    importc, libprag.}

proc addMark*(self: Scale; value: cdouble; position: PositionType;
    markup: cstring = nil) =
  gtk_scale_add_mark(cast[ptr Scale00](self.impl), value, position, markup)

proc gtk_scale_get_value_pos(self: ptr Scale00): PositionType {.
    importc, libprag.}

proc getValuePos*(self: Scale): PositionType =
  gtk_scale_get_value_pos(cast[ptr Scale00](self.impl))

proc valuePos*(self: Scale): PositionType =
  gtk_scale_get_value_pos(cast[ptr Scale00](self.impl))

proc gtk_scale_set_value_pos(self: ptr Scale00; pos: PositionType) {.
    importc, libprag.}

proc setValuePos*(self: Scale; pos: PositionType) =
  gtk_scale_set_value_pos(cast[ptr Scale00](self.impl), pos)

proc `valuePos=`*(self: Scale; pos: PositionType) =
  gtk_scale_set_value_pos(cast[ptr Scale00](self.impl), pos)

type
  Overlay* = ref object of Widget
  Overlay00* = object of Widget00

proc gtk_overlay_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Overlay()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scGetChildPosition*(self: Overlay;  p: proc (self: ptr Overlay00; widget: ptr Widget00; allocation: var gdk4.Rectangle; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "get-child-position", cast[GCallback](p), xdata, nil, cf)

proc gtk_overlay_new(): ptr Overlay00 {.
    importc, libprag.}

proc newOverlay*(): Overlay =
  let gobj = gtk_overlay_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newOverlay*(tdesc: typedesc): tdesc =
  assert(result is Overlay)
  let gobj = gtk_overlay_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initOverlay*[T](result: var T) {.deprecated.} =
  assert(result is Overlay)
  let gobj = gtk_overlay_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_overlay_add_overlay(self: ptr Overlay00; widget: ptr Widget00) {.
    importc, libprag.}

proc addOverlay*(self: Overlay; widget: Widget) =
  gtk_overlay_add_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_overlay_get_child(self: ptr Overlay00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: Overlay): Widget =
  let gobj = gtk_overlay_get_child(cast[ptr Overlay00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Overlay): Widget =
  let gobj = gtk_overlay_get_child(cast[ptr Overlay00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_overlay_get_clip_overlay(self: ptr Overlay00; widget: ptr Widget00): gboolean {.
    importc, libprag.}

proc getClipOverlay*(self: Overlay; widget: Widget): bool =
  toBool(gtk_overlay_get_clip_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_overlay_get_measure_overlay(self: ptr Overlay00; widget: ptr Widget00): gboolean {.
    importc, libprag.}

proc getMeasureOverlay*(self: Overlay; widget: Widget): bool =
  toBool(gtk_overlay_get_measure_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_overlay_remove_overlay(self: ptr Overlay00; widget: ptr Widget00) {.
    importc, libprag.}

proc removeOverlay*(self: Overlay; widget: Widget) =
  gtk_overlay_remove_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_overlay_set_child(self: ptr Overlay00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: Overlay; child: Widget = nil) =
  gtk_overlay_set_child(cast[ptr Overlay00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: Overlay; child: Widget = nil) =
  gtk_overlay_set_child(cast[ptr Overlay00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_overlay_set_clip_overlay(self: ptr Overlay00; widget: ptr Widget00;
    clipOverlay: gboolean) {.
    importc, libprag.}

proc setClipOverlay*(self: Overlay; widget: Widget; clipOverlay: bool) =
  gtk_overlay_set_clip_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl), gboolean(clipOverlay))

proc gtk_overlay_set_measure_overlay(self: ptr Overlay00; widget: ptr Widget00;
    measure: gboolean) {.
    importc, libprag.}

proc setMeasureOverlay*(self: Overlay; widget: Widget; measure: bool) =
  gtk_overlay_set_measure_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl), gboolean(measure))

type
  Frame* = ref object of Widget
  Frame00* = object of Widget00

proc gtk_frame_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Frame()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_frame_new(label: cstring): ptr Frame00 {.
    importc, libprag.}

proc newFrame*(label: cstring = nil): Frame =
  let gobj = gtk_frame_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFrame*(tdesc: typedesc; label: cstring = nil): tdesc =
  assert(result is Frame)
  let gobj = gtk_frame_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFrame*[T](result: var T; label: cstring = nil) {.deprecated.} =
  assert(result is Frame)
  let gobj = gtk_frame_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_frame_get_child(self: ptr Frame00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: Frame): Widget =
  let gobj = gtk_frame_get_child(cast[ptr Frame00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Frame): Widget =
  let gobj = gtk_frame_get_child(cast[ptr Frame00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_frame_get_label(self: ptr Frame00): cstring {.
    importc, libprag.}

proc getLabel*(self: Frame): string =
  let resul0 = gtk_frame_get_label(cast[ptr Frame00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc label*(self: Frame): string =
  let resul0 = gtk_frame_get_label(cast[ptr Frame00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_frame_get_label_align(self: ptr Frame00): cfloat {.
    importc, libprag.}

proc getLabelAlign*(self: Frame): cfloat =
  gtk_frame_get_label_align(cast[ptr Frame00](self.impl))

proc labelAlign*(self: Frame): cfloat =
  gtk_frame_get_label_align(cast[ptr Frame00](self.impl))

proc gtk_frame_get_label_widget(self: ptr Frame00): ptr Widget00 {.
    importc, libprag.}

proc getLabelWidget*(self: Frame): Widget =
  let gobj = gtk_frame_get_label_widget(cast[ptr Frame00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: Frame): Widget =
  let gobj = gtk_frame_get_label_widget(cast[ptr Frame00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_frame_set_child(self: ptr Frame00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: Frame; child: Widget = nil) =
  gtk_frame_set_child(cast[ptr Frame00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: Frame; child: Widget = nil) =
  gtk_frame_set_child(cast[ptr Frame00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_frame_set_label(self: ptr Frame00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: Frame; label: cstring = nil) =
  gtk_frame_set_label(cast[ptr Frame00](self.impl), label)

proc `label=`*(self: Frame; label: cstring = nil) =
  gtk_frame_set_label(cast[ptr Frame00](self.impl), label)

proc gtk_frame_set_label_align(self: ptr Frame00; xalign: cfloat) {.
    importc, libprag.}

proc setLabelAlign*(self: Frame; xalign: cfloat) =
  gtk_frame_set_label_align(cast[ptr Frame00](self.impl), xalign)

proc `labelAlign=`*(self: Frame; xalign: cfloat) =
  gtk_frame_set_label_align(cast[ptr Frame00](self.impl), xalign)

proc gtk_frame_set_label_widget(self: ptr Frame00; labelWidget: ptr Widget00) {.
    importc, libprag.}

proc setLabelWidget*(self: Frame; labelWidget: Widget = nil) =
  gtk_frame_set_label_widget(cast[ptr Frame00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: Frame; labelWidget: Widget = nil) =
  gtk_frame_set_label_widget(cast[ptr Frame00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

type
  DeleteType* {.size: sizeof(cint), pure.} = enum
    chars = 0
    wordEnds = 1
    words = 2
    displayLines = 3
    displayLineEnds = 4
    paragraphEnds = 5
    paragraphs = 6
    whitespace = 7

type
  TextExtendSelection* {.size: sizeof(cint), pure.} = enum
    word = 0
    line = 1

type
  TextIter* {.pure, byRef.} = object
    dummy1*: pointer
    dummy2*: pointer
    dummy3*: int32
    dummy4*: int32
    dummy5*: int32
    dummy6*: int32
    dummy7*: int32
    dummy8*: int32
    dummy9*: pointer
    dummy10*: pointer
    dummy11*: int32
    dummy12*: int32
    dummy13*: int32
    dummy14*: pointer

proc gtk_text_iter_get_type*(): GType {.importc, libprag.}

proc gtk_text_iter_free(self: TextIter) {.
    importc, libprag.}

proc free*(self: TextIter) =
  gtk_text_iter_free(self)

proc gtk_text_iter_backward_char(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardChar*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_char(self))

proc gtk_text_iter_backward_chars(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardChars*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_chars(self, int32(count)))

proc gtk_text_iter_backward_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_cursor_position(self))

proc gtk_text_iter_backward_cursor_positions(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_cursor_positions(self, int32(count)))

proc gtk_text_iter_backward_line(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardLine*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_line(self))

proc gtk_text_iter_backward_lines(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_lines(self, int32(count)))

proc gtk_text_iter_backward_sentence_start(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardSentenceStart*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_sentence_start(self))

proc gtk_text_iter_backward_sentence_starts(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardSentenceStarts*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_sentence_starts(self, int32(count)))

proc gtk_text_iter_backward_visible_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardVisibleCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_visible_cursor_position(self))

proc gtk_text_iter_backward_visible_cursor_positions(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardVisibleCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_visible_cursor_positions(self, int32(count)))

proc gtk_text_iter_backward_visible_line(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardVisibleLine*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_visible_line(self))

proc gtk_text_iter_backward_visible_lines(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardVisibleLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_visible_lines(self, int32(count)))

proc gtk_text_iter_backward_visible_word_start(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardVisibleWordStart*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_visible_word_start(self))

proc gtk_text_iter_backward_visible_word_starts(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardVisibleWordStarts*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_visible_word_starts(self, int32(count)))

proc gtk_text_iter_backward_word_start(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardWordStart*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_word_start(self))

proc gtk_text_iter_backward_word_starts(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardWordStarts*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_word_starts(self, int32(count)))

proc gtk_text_iter_can_insert(self: TextIter; defaultEditability: gboolean): gboolean {.
    importc, libprag.}

proc canInsert*(self: TextIter; defaultEditability: bool): bool =
  toBool(gtk_text_iter_can_insert(self, gboolean(defaultEditability)))

proc gtk_text_iter_compare(self: TextIter; rhs: TextIter): int32 {.
    importc, libprag.}

proc compare*(self: TextIter; rhs: TextIter): int =
  int(gtk_text_iter_compare(self, rhs))

proc gtk_text_iter_editable(self: TextIter; defaultSetting: gboolean): gboolean {.
    importc, libprag.}

proc editable*(self: TextIter; defaultSetting: bool): bool =
  toBool(gtk_text_iter_editable(self, gboolean(defaultSetting)))

proc gtk_text_iter_ends_line(self: TextIter): gboolean {.
    importc, libprag.}

proc endsLine*(self: TextIter): bool =
  toBool(gtk_text_iter_ends_line(self))

proc gtk_text_iter_ends_sentence(self: TextIter): gboolean {.
    importc, libprag.}

proc endsSentence*(self: TextIter): bool =
  toBool(gtk_text_iter_ends_sentence(self))

proc gtk_text_iter_ends_word(self: TextIter): gboolean {.
    importc, libprag.}

proc endsWord*(self: TextIter): bool =
  toBool(gtk_text_iter_ends_word(self))

proc gtk_text_iter_equal(self: TextIter; rhs: TextIter): gboolean {.
    importc, libprag.}

proc equal*(self: TextIter; rhs: TextIter): bool =
  toBool(gtk_text_iter_equal(self, rhs))

proc gtk_text_iter_forward_char(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardChar*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_char(self))

proc gtk_text_iter_forward_chars(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardChars*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_chars(self, int32(count)))

proc gtk_text_iter_forward_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_cursor_position(self))

proc gtk_text_iter_forward_cursor_positions(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_cursor_positions(self, int32(count)))

proc gtk_text_iter_forward_line(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardLine*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_line(self))

proc gtk_text_iter_forward_lines(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_lines(self, int32(count)))

proc gtk_text_iter_forward_sentence_end(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardSentenceEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_sentence_end(self))

proc gtk_text_iter_forward_sentence_ends(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardSentenceEnds*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_sentence_ends(self, int32(count)))

proc gtk_text_iter_forward_to_end(self: TextIter) {.
    importc, libprag.}

proc forwardToEnd*(self: TextIter) =
  gtk_text_iter_forward_to_end(self)

proc gtk_text_iter_forward_to_line_end(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardToLineEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_to_line_end(self))

proc gtk_text_iter_forward_visible_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardVisibleCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_visible_cursor_position(self))

proc gtk_text_iter_forward_visible_cursor_positions(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardVisibleCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_visible_cursor_positions(self, int32(count)))

proc gtk_text_iter_forward_visible_line(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardVisibleLine*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_visible_line(self))

proc gtk_text_iter_forward_visible_lines(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardVisibleLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_visible_lines(self, int32(count)))

proc gtk_text_iter_forward_visible_word_end(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardVisibleWordEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_visible_word_end(self))

proc gtk_text_iter_forward_visible_word_ends(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardVisibleWordEnds*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_visible_word_ends(self, int32(count)))

proc gtk_text_iter_forward_word_end(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardWordEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_word_end(self))

proc gtk_text_iter_forward_word_ends(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardWordEnds*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_word_ends(self, int32(count)))

proc gtk_text_iter_assign(self: TextIter; other: TextIter) {.
    importc, libprag.}

proc assign*(self: TextIter; other: TextIter) =
  gtk_text_iter_assign(self, other)

proc gtk_text_iter_get_bytes_in_line(self: TextIter): int32 {.
    importc, libprag.}

proc getBytesInLine*(self: TextIter): int =
  int(gtk_text_iter_get_bytes_in_line(self))

proc bytesInLine*(self: TextIter): int =
  int(gtk_text_iter_get_bytes_in_line(self))

proc gtk_text_iter_get_char(self: TextIter): gunichar {.
    importc, libprag.}

proc getChar*(self: TextIter): gunichar =
  gtk_text_iter_get_char(self)

proc gtk_text_iter_get_chars_in_line(self: TextIter): int32 {.
    importc, libprag.}

proc getCharsInLine*(self: TextIter): int =
  int(gtk_text_iter_get_chars_in_line(self))

proc charsInLine*(self: TextIter): int =
  int(gtk_text_iter_get_chars_in_line(self))

proc gtk_text_iter_get_language(self: TextIter): ptr pango.Language00 {.
    importc, libprag.}

proc getLanguage*(self: TextIter): pango.Language =
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = gtk_text_iter_get_language(self)

proc language*(self: TextIter): pango.Language =
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = gtk_text_iter_get_language(self)

proc gtk_text_iter_get_line(self: TextIter): int32 {.
    importc, libprag.}

proc getLine*(self: TextIter): int =
  int(gtk_text_iter_get_line(self))

proc line*(self: TextIter): int =
  int(gtk_text_iter_get_line(self))

proc gtk_text_iter_get_line_index(self: TextIter): int32 {.
    importc, libprag.}

proc getLineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_line_index(self))

proc lineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_line_index(self))

proc gtk_text_iter_get_line_offset(self: TextIter): int32 {.
    importc, libprag.}

proc getLineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_line_offset(self))

proc lineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_line_offset(self))

proc gtk_text_iter_get_offset(self: TextIter): int32 {.
    importc, libprag.}

proc getOffset*(self: TextIter): int =
  int(gtk_text_iter_get_offset(self))

proc offset*(self: TextIter): int =
  int(gtk_text_iter_get_offset(self))

proc gtk_text_iter_get_paintable(self: TextIter): ptr gdk4.Paintable00 {.
    importc, libprag.}

proc getPaintable*(self: TextIter): gdk4.Paintable =
  let gobj = gtk_text_iter_get_paintable(self)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc paintable*(self: TextIter): gdk4.Paintable =
  let gobj = gtk_text_iter_get_paintable(self)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_iter_get_slice(self: TextIter; `end`: TextIter): cstring {.
    importc, libprag.}

proc getSlice*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_slice(self, `end`)
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_get_text(self: TextIter; `end`: TextIter): cstring {.
    importc, libprag.}

proc getText*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_text(self, `end`)
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_get_visible_line_index(self: TextIter): int32 {.
    importc, libprag.}

proc getVisibleLineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_index(self))

proc visibleLineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_index(self))

proc gtk_text_iter_get_visible_line_offset(self: TextIter): int32 {.
    importc, libprag.}

proc getVisibleLineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_offset(self))

proc visibleLineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_offset(self))

proc gtk_text_iter_get_visible_slice(self: TextIter; `end`: TextIter): cstring {.
    importc, libprag.}

proc getVisibleSlice*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_visible_slice(self, `end`)
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_get_visible_text(self: TextIter; `end`: TextIter): cstring {.
    importc, libprag.}

proc getVisibleText*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_visible_text(self, `end`)
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_in_range(self: TextIter; start: TextIter; `end`: TextIter): gboolean {.
    importc, libprag.}

proc inRange*(self: TextIter; start: TextIter; `end`: TextIter): bool =
  toBool(gtk_text_iter_in_range(self, start, `end`))

proc gtk_text_iter_inside_sentence(self: TextIter): gboolean {.
    importc, libprag.}

proc insideSentence*(self: TextIter): bool =
  toBool(gtk_text_iter_inside_sentence(self))

proc gtk_text_iter_inside_word(self: TextIter): gboolean {.
    importc, libprag.}

proc insideWord*(self: TextIter): bool =
  toBool(gtk_text_iter_inside_word(self))

proc gtk_text_iter_is_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc isCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_is_cursor_position(self))

proc gtk_text_iter_is_end(self: TextIter): gboolean {.
    importc, libprag.}

proc isEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_is_end(self))

proc gtk_text_iter_is_start(self: TextIter): gboolean {.
    importc, libprag.}

proc isStart*(self: TextIter): bool =
  toBool(gtk_text_iter_is_start(self))

proc gtk_text_iter_order(self: TextIter; second: TextIter) {.
    importc, libprag.}

proc order*(self: TextIter; second: TextIter) =
  gtk_text_iter_order(self, second)

proc gtk_text_iter_set_line(self: TextIter; lineNumber: int32) {.
    importc, libprag.}

proc setLine*(self: TextIter; lineNumber: int) =
  gtk_text_iter_set_line(self, int32(lineNumber))

proc `line=`*(self: TextIter; lineNumber: int) =
  gtk_text_iter_set_line(self, int32(lineNumber))

proc gtk_text_iter_set_line_index(self: TextIter; byteOnLine: int32) {.
    importc, libprag.}

proc setLineIndex*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_line_index(self, int32(byteOnLine))

proc `lineIndex=`*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_line_index(self, int32(byteOnLine))

proc gtk_text_iter_set_line_offset(self: TextIter; charOnLine: int32) {.
    importc, libprag.}

proc setLineOffset*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_line_offset(self, int32(charOnLine))

proc `lineOffset=`*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_line_offset(self, int32(charOnLine))

proc gtk_text_iter_set_offset(self: TextIter; charOffset: int32) {.
    importc, libprag.}

proc setOffset*(self: TextIter; charOffset: int) =
  gtk_text_iter_set_offset(self, int32(charOffset))

proc `offset=`*(self: TextIter; charOffset: int) =
  gtk_text_iter_set_offset(self, int32(charOffset))

proc gtk_text_iter_set_visible_line_index(self: TextIter; byteOnLine: int32) {.
    importc, libprag.}

proc setVisibleLineIndex*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_visible_line_index(self, int32(byteOnLine))

proc `visibleLineIndex=`*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_visible_line_index(self, int32(byteOnLine))

proc gtk_text_iter_set_visible_line_offset(self: TextIter; charOnLine: int32) {.
    importc, libprag.}

proc setVisibleLineOffset*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_visible_line_offset(self, int32(charOnLine))

proc `visibleLineOffset=`*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_visible_line_offset(self, int32(charOnLine))

proc gtk_text_iter_starts_line(self: TextIter): gboolean {.
    importc, libprag.}

proc startsLine*(self: TextIter): bool =
  toBool(gtk_text_iter_starts_line(self))

proc gtk_text_iter_starts_sentence(self: TextIter): gboolean {.
    importc, libprag.}

proc startsSentence*(self: TextIter): bool =
  toBool(gtk_text_iter_starts_sentence(self))

proc gtk_text_iter_starts_word(self: TextIter): gboolean {.
    importc, libprag.}

proc startsWord*(self: TextIter): bool =
  toBool(gtk_text_iter_starts_word(self))

type
  ScrollStep* {.size: sizeof(cint), pure.} = enum
    steps = 0
    pages = 1
    ends = 2
    horizontalSteps = 3
    horizontalPages = 4
    horizontalEnds = 5

type
  TextView* = ref object of Widget
  TextView00* = object of Widget00

proc gtk_text_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scBackspace*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "backspace", cast[GCallback](p), xdata, nil, cf)

proc scCopyClipboard*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "copy-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scCutClipboard*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cut-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scDeleteFromCursor*(self: TextView;  p: proc (self: ptr TextView00; `type`: DeleteType; count: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-from-cursor", cast[GCallback](p), xdata, nil, cf)

proc scExtendSelection*(self: TextView;  p: proc (self: ptr TextView00; granularity: TextExtendSelection; location: TextIter; start: TextIter;
    `end`: TextIter; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "extend-selection", cast[GCallback](p), xdata, nil, cf)

proc scInsertAtCursor*(self: TextView;  p: proc (self: ptr TextView00; string: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-at-cursor", cast[GCallback](p), xdata, nil, cf)

proc scInsertEmoji*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-emoji", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: TextView;  p: proc (self: ptr TextView00; step: MovementStep; count: int32; extendSelection: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scMoveViewport*(self: TextView;  p: proc (self: ptr TextView00; step: ScrollStep; count: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-viewport", cast[GCallback](p), xdata, nil, cf)

proc scPasteClipboard*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "paste-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scPreeditChanged*(self: TextView;  p: proc (self: ptr TextView00; preedit: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-changed", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: TextView;  p: proc (self: ptr TextView00; select: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSetAnchor*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "set-anchor", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorVisible*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-visible", cast[GCallback](p), xdata, nil, cf)

proc scToggleOverwrite*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-overwrite", cast[GCallback](p), xdata, nil, cf)

proc gtk_text_view_new(): ptr TextView00 {.
    importc, libprag.}

proc newTextView*(): TextView =
  let gobj = gtk_text_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextView*(tdesc: typedesc): tdesc =
  assert(result is TextView)
  let gobj = gtk_text_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextView*[T](result: var T) {.deprecated.} =
  assert(result is TextView)
  let gobj = gtk_text_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_add_overlay(self: ptr TextView00; child: ptr Widget00;
    xpos: int32; ypos: int32) {.
    importc, libprag.}

proc addOverlay*(self: TextView; child: Widget; xpos: int;
    ypos: int) =
  gtk_text_view_add_overlay(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl), int32(xpos), int32(ypos))

proc gtk_text_view_backward_display_line(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc backwardDisplayLine*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_backward_display_line(cast[ptr TextView00](self.impl), iter))

proc gtk_text_view_backward_display_line_start(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc backwardDisplayLineStart*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_backward_display_line_start(cast[ptr TextView00](self.impl), iter))

proc gtk_text_view_forward_display_line(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc forwardDisplayLine*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_forward_display_line(cast[ptr TextView00](self.impl), iter))

proc gtk_text_view_forward_display_line_end(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc forwardDisplayLineEnd*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_forward_display_line_end(cast[ptr TextView00](self.impl), iter))

proc gtk_text_view_get_accepts_tab(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getAcceptsTab*(self: TextView): bool =
  toBool(gtk_text_view_get_accepts_tab(cast[ptr TextView00](self.impl)))

proc acceptsTab*(self: TextView): bool =
  toBool(gtk_text_view_get_accepts_tab(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_bottom_margin(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getBottomMargin*(self: TextView): int =
  int(gtk_text_view_get_bottom_margin(cast[ptr TextView00](self.impl)))

proc bottomMargin*(self: TextView): int =
  int(gtk_text_view_get_bottom_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_cursor_locations(self: ptr TextView00; iter: TextIter;
    strong: var gdk4.Rectangle; weak: var gdk4.Rectangle) {.
    importc, libprag.}

proc getCursorLocations*(self: TextView; iter: TextIter = cast[var TextIter](nil);
    strong: var gdk4.Rectangle = cast[var gdk4.Rectangle](nil); weak: var gdk4.Rectangle = cast[var gdk4.Rectangle](nil)) =
  gtk_text_view_get_cursor_locations(cast[ptr TextView00](self.impl), iter, strong, weak)

proc gtk_text_view_get_cursor_visible(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getCursorVisible*(self: TextView): bool =
  toBool(gtk_text_view_get_cursor_visible(cast[ptr TextView00](self.impl)))

proc cursorVisible*(self: TextView): bool =
  toBool(gtk_text_view_get_cursor_visible(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_editable(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getEditable*(self: TextView): bool =
  toBool(gtk_text_view_get_editable(cast[ptr TextView00](self.impl)))

proc editable*(self: TextView): bool =
  toBool(gtk_text_view_get_editable(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_extra_menu(self: ptr TextView00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getExtraMenu*(self: TextView): gio.MenuModel =
  let gobj = gtk_text_view_get_extra_menu(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc extraMenu*(self: TextView): gio.MenuModel =
  let gobj = gtk_text_view_get_extra_menu(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_indent(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getIndent*(self: TextView): int =
  int(gtk_text_view_get_indent(cast[ptr TextView00](self.impl)))

proc indent*(self: TextView): int =
  int(gtk_text_view_get_indent(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_iter_at_location(self: ptr TextView00; iter: var TextIter;
    x: int32; y: int32): gboolean {.
    importc, libprag.}

proc getIterAtLocation*(self: TextView; iter: var TextIter;
    x: int; y: int): bool =
  toBool(gtk_text_view_get_iter_at_location(cast[ptr TextView00](self.impl), iter, int32(x), int32(y)))

proc gtk_text_view_get_iter_at_position(self: ptr TextView00; iter: var TextIter;
    trailing: var int32; x: int32; y: int32): gboolean {.
    importc, libprag.}

proc getIterAtPosition*(self: TextView; iter: var TextIter;
    trailing: var int = cast[var int](nil); x: int; y: int): bool =
  var trailing_00: int32
  result = toBool(gtk_text_view_get_iter_at_position(cast[ptr TextView00](self.impl), iter, trailing_00, int32(x), int32(y)))
  if trailing.addr != nil:
    trailing = int(trailing_00)

proc gtk_text_view_get_iter_location(self: ptr TextView00; iter: TextIter;
    location: var gdk4.Rectangle) {.
    importc, libprag.}

proc getIterLocation*(self: TextView; iter: TextIter; location: var gdk4.Rectangle) =
  gtk_text_view_get_iter_location(cast[ptr TextView00](self.impl), iter, location)

proc gtk_text_view_get_left_margin(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getLeftMargin*(self: TextView): int =
  int(gtk_text_view_get_left_margin(cast[ptr TextView00](self.impl)))

proc leftMargin*(self: TextView): int =
  int(gtk_text_view_get_left_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_line_at_y(self: ptr TextView00; targetIter: var TextIter;
    y: int32; lineTop: var int32) {.
    importc, libprag.}

proc getLineAtY*(self: TextView; targetIter: var TextIter;
    y: int; lineTop: var int) =
  var lineTop_00: int32
  gtk_text_view_get_line_at_y(cast[ptr TextView00](self.impl), targetIter, int32(y), lineTop_00)
  if lineTop.addr != nil:
    lineTop = int(lineTop_00)

proc gtk_text_view_get_line_yrange(self: ptr TextView00; iter: TextIter;
    y: var int32; height: var int32) {.
    importc, libprag.}

proc getLineYrange*(self: TextView; iter: TextIter; y: var int;
    height: var int) =
  var height_00: int32
  var y_00: int32
  gtk_text_view_get_line_yrange(cast[ptr TextView00](self.impl), iter, y_00, height_00)
  if height.addr != nil:
    height = int(height_00)
  if y.addr != nil:
    y = int(y_00)

proc gtk_text_view_get_ltr_context(self: ptr TextView00): ptr pango.Context00 {.
    importc, libprag.}

proc getLtrContext*(self: TextView): pango.Context =
  let gobj = gtk_text_view_get_ltr_context(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc ltrContext*(self: TextView): pango.Context =
  let gobj = gtk_text_view_get_ltr_context(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_monospace(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getMonospace*(self: TextView): bool =
  toBool(gtk_text_view_get_monospace(cast[ptr TextView00](self.impl)))

proc monospace*(self: TextView): bool =
  toBool(gtk_text_view_get_monospace(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_overwrite(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getOverwrite*(self: TextView): bool =
  toBool(gtk_text_view_get_overwrite(cast[ptr TextView00](self.impl)))

proc overwrite*(self: TextView): bool =
  toBool(gtk_text_view_get_overwrite(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_pixels_above_lines(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getPixelsAboveLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_above_lines(cast[ptr TextView00](self.impl)))

proc pixelsAboveLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_above_lines(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_pixels_below_lines(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getPixelsBelowLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_below_lines(cast[ptr TextView00](self.impl)))

proc pixelsBelowLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_below_lines(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_pixels_inside_wrap(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getPixelsInsideWrap*(self: TextView): int =
  int(gtk_text_view_get_pixels_inside_wrap(cast[ptr TextView00](self.impl)))

proc pixelsInsideWrap*(self: TextView): int =
  int(gtk_text_view_get_pixels_inside_wrap(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_right_margin(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getRightMargin*(self: TextView): int =
  int(gtk_text_view_get_right_margin(cast[ptr TextView00](self.impl)))

proc rightMargin*(self: TextView): int =
  int(gtk_text_view_get_right_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_rtl_context(self: ptr TextView00): ptr pango.Context00 {.
    importc, libprag.}

proc getRtlContext*(self: TextView): pango.Context =
  let gobj = gtk_text_view_get_rtl_context(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc rtlContext*(self: TextView): pango.Context =
  let gobj = gtk_text_view_get_rtl_context(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_tabs(self: ptr TextView00): ptr pango.TabArray00 {.
    importc, libprag.}

proc getTabs*(self: TextView): pango.TabArray =
  let impl0 = gtk_text_view_get_tabs(cast[ptr TextView00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = impl0

proc tabs*(self: TextView): pango.TabArray =
  let impl0 = gtk_text_view_get_tabs(cast[ptr TextView00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = impl0

proc gtk_text_view_get_top_margin(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getTopMargin*(self: TextView): int =
  int(gtk_text_view_get_top_margin(cast[ptr TextView00](self.impl)))

proc topMargin*(self: TextView): int =
  int(gtk_text_view_get_top_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_visible_rect(self: ptr TextView00; visibleRect: var gdk4.Rectangle) {.
    importc, libprag.}

proc getVisibleRect*(self: TextView; visibleRect: var gdk4.Rectangle) =
  gtk_text_view_get_visible_rect(cast[ptr TextView00](self.impl), visibleRect)

proc getVisibleRect*(self: TextView): gdk4.Rectangle =
  gtk_text_view_get_visible_rect(cast[ptr TextView00](self.impl), result)

proc gtk_text_view_im_context_filter_keypress(self: ptr TextView00; event: ptr gdk4.Event00): gboolean {.
    importc, libprag.}

proc imContextFilterKeypress*(self: TextView; event: gdk4.Event): bool =
  toBool(gtk_text_view_im_context_filter_keypress(cast[ptr TextView00](self.impl), cast[ptr gdk4.Event00](event.impl)))

proc gtk_text_view_move_overlay(self: ptr TextView00; child: ptr Widget00;
    xpos: int32; ypos: int32) {.
    importc, libprag.}

proc moveOverlay*(self: TextView; child: Widget; xpos: int;
    ypos: int) =
  gtk_text_view_move_overlay(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl), int32(xpos), int32(ypos))

proc gtk_text_view_move_visually(self: ptr TextView00; iter: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc moveVisually*(self: TextView; iter: TextIter; count: int): bool =
  toBool(gtk_text_view_move_visually(cast[ptr TextView00](self.impl), iter, int32(count)))

proc gtk_text_view_place_cursor_onscreen(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc placeCursorOnscreen*(self: TextView): bool =
  toBool(gtk_text_view_place_cursor_onscreen(cast[ptr TextView00](self.impl)))

proc gtk_text_view_remove(self: ptr TextView00; child: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: TextView; child: Widget) =
  gtk_text_view_remove(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_text_view_reset_cursor_blink(self: ptr TextView00) {.
    importc, libprag.}

proc resetCursorBlink*(self: TextView) =
  gtk_text_view_reset_cursor_blink(cast[ptr TextView00](self.impl))

proc gtk_text_view_reset_im_context(self: ptr TextView00) {.
    importc, libprag.}

proc resetImContext*(self: TextView) =
  gtk_text_view_reset_im_context(cast[ptr TextView00](self.impl))

proc gtk_text_view_scroll_to_iter(self: ptr TextView00; iter: TextIter; withinMargin: cdouble;
    useAlign: gboolean; xalign: cdouble; yalign: cdouble): gboolean {.
    importc, libprag.}

proc scrollToIter*(self: TextView; iter: TextIter; withinMargin: cdouble;
    useAlign: bool; xalign: cdouble; yalign: cdouble): bool =
  toBool(gtk_text_view_scroll_to_iter(cast[ptr TextView00](self.impl), iter, withinMargin, gboolean(useAlign), xalign, yalign))

proc gtk_text_view_set_accepts_tab(self: ptr TextView00; acceptsTab: gboolean) {.
    importc, libprag.}

proc setAcceptsTab*(self: TextView; acceptsTab: bool = true) =
  gtk_text_view_set_accepts_tab(cast[ptr TextView00](self.impl), gboolean(acceptsTab))

proc `acceptsTab=`*(self: TextView; acceptsTab: bool) =
  gtk_text_view_set_accepts_tab(cast[ptr TextView00](self.impl), gboolean(acceptsTab))

proc gtk_text_view_set_bottom_margin(self: ptr TextView00; bottomMargin: int32) {.
    importc, libprag.}

proc setBottomMargin*(self: TextView; bottomMargin: int) =
  gtk_text_view_set_bottom_margin(cast[ptr TextView00](self.impl), int32(bottomMargin))

proc `bottomMargin=`*(self: TextView; bottomMargin: int) =
  gtk_text_view_set_bottom_margin(cast[ptr TextView00](self.impl), int32(bottomMargin))

proc gtk_text_view_set_cursor_visible(self: ptr TextView00; setting: gboolean) {.
    importc, libprag.}

proc setCursorVisible*(self: TextView; setting: bool = true) =
  gtk_text_view_set_cursor_visible(cast[ptr TextView00](self.impl), gboolean(setting))

proc `cursorVisible=`*(self: TextView; setting: bool) =
  gtk_text_view_set_cursor_visible(cast[ptr TextView00](self.impl), gboolean(setting))

proc gtk_text_view_set_editable(self: ptr TextView00; setting: gboolean) {.
    importc, libprag.}

proc setEditable*(self: TextView; setting: bool = true) =
  gtk_text_view_set_editable(cast[ptr TextView00](self.impl), gboolean(setting))

proc `editable=`*(self: TextView; setting: bool) =
  gtk_text_view_set_editable(cast[ptr TextView00](self.impl), gboolean(setting))

proc gtk_text_view_set_extra_menu(self: ptr TextView00; model: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setExtraMenu*(self: TextView; model: gio.MenuModel = nil) =
  gtk_text_view_set_extra_menu(cast[ptr TextView00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc `extraMenu=`*(self: TextView; model: gio.MenuModel = nil) =
  gtk_text_view_set_extra_menu(cast[ptr TextView00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc gtk_text_view_set_indent(self: ptr TextView00; indent: int32) {.
    importc, libprag.}

proc setIndent*(self: TextView; indent: int) =
  gtk_text_view_set_indent(cast[ptr TextView00](self.impl), int32(indent))

proc `indent=`*(self: TextView; indent: int) =
  gtk_text_view_set_indent(cast[ptr TextView00](self.impl), int32(indent))

proc gtk_text_view_set_left_margin(self: ptr TextView00; leftMargin: int32) {.
    importc, libprag.}

proc setLeftMargin*(self: TextView; leftMargin: int) =
  gtk_text_view_set_left_margin(cast[ptr TextView00](self.impl), int32(leftMargin))

proc `leftMargin=`*(self: TextView; leftMargin: int) =
  gtk_text_view_set_left_margin(cast[ptr TextView00](self.impl), int32(leftMargin))

proc gtk_text_view_set_monospace(self: ptr TextView00; monospace: gboolean) {.
    importc, libprag.}

proc setMonospace*(self: TextView; monospace: bool = true) =
  gtk_text_view_set_monospace(cast[ptr TextView00](self.impl), gboolean(monospace))

proc `monospace=`*(self: TextView; monospace: bool) =
  gtk_text_view_set_monospace(cast[ptr TextView00](self.impl), gboolean(monospace))

proc gtk_text_view_set_overwrite(self: ptr TextView00; overwrite: gboolean) {.
    importc, libprag.}

proc setOverwrite*(self: TextView; overwrite: bool = true) =
  gtk_text_view_set_overwrite(cast[ptr TextView00](self.impl), gboolean(overwrite))

proc `overwrite=`*(self: TextView; overwrite: bool) =
  gtk_text_view_set_overwrite(cast[ptr TextView00](self.impl), gboolean(overwrite))

proc gtk_text_view_set_pixels_above_lines(self: ptr TextView00; pixelsAboveLines: int32) {.
    importc, libprag.}

proc setPixelsAboveLines*(self: TextView; pixelsAboveLines: int) =
  gtk_text_view_set_pixels_above_lines(cast[ptr TextView00](self.impl), int32(pixelsAboveLines))

proc `pixelsAboveLines=`*(self: TextView; pixelsAboveLines: int) =
  gtk_text_view_set_pixels_above_lines(cast[ptr TextView00](self.impl), int32(pixelsAboveLines))

proc gtk_text_view_set_pixels_below_lines(self: ptr TextView00; pixelsBelowLines: int32) {.
    importc, libprag.}

proc setPixelsBelowLines*(self: TextView; pixelsBelowLines: int) =
  gtk_text_view_set_pixels_below_lines(cast[ptr TextView00](self.impl), int32(pixelsBelowLines))

proc `pixelsBelowLines=`*(self: TextView; pixelsBelowLines: int) =
  gtk_text_view_set_pixels_below_lines(cast[ptr TextView00](self.impl), int32(pixelsBelowLines))

proc gtk_text_view_set_pixels_inside_wrap(self: ptr TextView00; pixelsInsideWrap: int32) {.
    importc, libprag.}

proc setPixelsInsideWrap*(self: TextView; pixelsInsideWrap: int) =
  gtk_text_view_set_pixels_inside_wrap(cast[ptr TextView00](self.impl), int32(pixelsInsideWrap))

proc `pixelsInsideWrap=`*(self: TextView; pixelsInsideWrap: int) =
  gtk_text_view_set_pixels_inside_wrap(cast[ptr TextView00](self.impl), int32(pixelsInsideWrap))

proc gtk_text_view_set_right_margin(self: ptr TextView00; rightMargin: int32) {.
    importc, libprag.}

proc setRightMargin*(self: TextView; rightMargin: int) =
  gtk_text_view_set_right_margin(cast[ptr TextView00](self.impl), int32(rightMargin))

proc `rightMargin=`*(self: TextView; rightMargin: int) =
  gtk_text_view_set_right_margin(cast[ptr TextView00](self.impl), int32(rightMargin))

proc gtk_text_view_set_tabs(self: ptr TextView00; tabs: ptr pango.TabArray00) {.
    importc, libprag.}

proc setTabs*(self: TextView; tabs: pango.TabArray) =
  gtk_text_view_set_tabs(cast[ptr TextView00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc `tabs=`*(self: TextView; tabs: pango.TabArray) =
  gtk_text_view_set_tabs(cast[ptr TextView00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc gtk_text_view_set_top_margin(self: ptr TextView00; topMargin: int32) {.
    importc, libprag.}

proc setTopMargin*(self: TextView; topMargin: int) =
  gtk_text_view_set_top_margin(cast[ptr TextView00](self.impl), int32(topMargin))

proc `topMargin=`*(self: TextView; topMargin: int) =
  gtk_text_view_set_top_margin(cast[ptr TextView00](self.impl), int32(topMargin))

proc gtk_text_view_starts_display_line(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc startsDisplayLine*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_starts_display_line(cast[ptr TextView00](self.impl), iter))

type
  FileChooserWidget* = ref object of Widget
  FileChooserWidget00* = object of Widget00

proc gtk_file_chooser_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileChooserWidget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDesktopFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "desktop-folder", cast[GCallback](p), xdata, nil, cf)

proc scDownFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "down-folder", cast[GCallback](p), xdata, nil, cf)

proc scHomeFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "home-folder", cast[GCallback](p), xdata, nil, cf)

proc scLocationPopup*(self: FileChooserWidget;  p: proc (self: ptr FileChooserWidget00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "location-popup", cast[GCallback](p), xdata, nil, cf)

proc scLocationPopupOnPaste*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "location-popup-on-paste", cast[GCallback](p), xdata, nil, cf)

proc scLocationTogglePopup*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "location-toggle-popup", cast[GCallback](p), xdata, nil, cf)

proc scPlacesShortcut*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "places-shortcut", cast[GCallback](p), xdata, nil, cf)

proc scQuickBookmark*(self: FileChooserWidget;  p: proc (self: ptr FileChooserWidget00; bookmarkIndex: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "quick-bookmark", cast[GCallback](p), xdata, nil, cf)

proc scRecentShortcut*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "recent-shortcut", cast[GCallback](p), xdata, nil, cf)

proc scSearchShortcut*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "search-shortcut", cast[GCallback](p), xdata, nil, cf)

proc scShowHidden*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-hidden", cast[GCallback](p), xdata, nil, cf)

proc scUpFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "up-folder", cast[GCallback](p), xdata, nil, cf)

type
  ListBase* = ref object of Widget
  ListBase00* = object of Widget00

proc gtk_list_base_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListBase()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ScaleButton* = ref object of Widget
  ScaleButton00* = object of Widget00

proc gtk_scale_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ScaleButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scPopdown*(self: ScaleButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popdown", cast[GCallback](p), xdata, nil, cf)

proc scPopup*(self: ScaleButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popup", cast[GCallback](p), xdata, nil, cf)

proc scValueChanged*(self: ScaleButton;  p: proc (self: ptr ScaleButton00; value: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_scale_button_new(min: cdouble; max: cdouble; step: cdouble; icons: ptr cstring): ptr ScaleButton00 {.
    importc, libprag.}

proc newScaleButton*(min: cdouble; max: cdouble; step: cdouble; icons: varargs[string, `$`]): ScaleButton =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  let gobj = gtk_scale_button_new(min, max, step, seq2CstringArray(icons, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScaleButton*(tdesc: typedesc; min: cdouble; max: cdouble; step: cdouble; icons: varargs[string, `$`]): tdesc =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is ScaleButton)
  let gobj = gtk_scale_button_new(min, max, step, seq2CstringArray(icons, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScaleButton*[T](result: var T; min: cdouble; max: cdouble; step: cdouble; icons: varargs[string, `$`]) {.deprecated.} =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is ScaleButton)
  let gobj = gtk_scale_button_new(min, max, step, seq2CstringArray(icons, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_active(self: ptr ScaleButton00): gboolean {.
    importc, libprag.}

proc getActive*(self: ScaleButton): bool =
  toBool(gtk_scale_button_get_active(cast[ptr ScaleButton00](self.impl)))

proc active*(self: ScaleButton): bool =
  toBool(gtk_scale_button_get_active(cast[ptr ScaleButton00](self.impl)))

proc gtk_scale_button_get_has_frame(self: ptr ScaleButton00): gboolean {.
    importc, libprag.}

proc getHasFrame*(self: ScaleButton): bool =
  toBool(gtk_scale_button_get_has_frame(cast[ptr ScaleButton00](self.impl)))

proc hasFrame*(self: ScaleButton): bool =
  toBool(gtk_scale_button_get_has_frame(cast[ptr ScaleButton00](self.impl)))

proc gtk_scale_button_get_minus_button(self: ptr ScaleButton00): ptr Button00 {.
    importc, libprag.}

proc getMinusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_minus_button(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc minusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_minus_button(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_plus_button(self: ptr ScaleButton00): ptr Button00 {.
    importc, libprag.}

proc getPlusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_plus_button(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc plusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_plus_button(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_popup(self: ptr ScaleButton00): ptr Widget00 {.
    importc, libprag.}

proc getPopup*(self: ScaleButton): Widget =
  let gobj = gtk_scale_button_get_popup(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popup*(self: ScaleButton): Widget =
  let gobj = gtk_scale_button_get_popup(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_value(self: ptr ScaleButton00): cdouble {.
    importc, libprag.}

proc getValue*(self: ScaleButton): cdouble =
  gtk_scale_button_get_value(cast[ptr ScaleButton00](self.impl))

proc value*(self: ScaleButton): cdouble =
  gtk_scale_button_get_value(cast[ptr ScaleButton00](self.impl))

proc gtk_scale_button_set_has_frame(self: ptr ScaleButton00; hasFrame: gboolean) {.
    importc, libprag.}

proc setHasFrame*(self: ScaleButton; hasFrame: bool = true) =
  gtk_scale_button_set_has_frame(cast[ptr ScaleButton00](self.impl), gboolean(hasFrame))

proc `hasFrame=`*(self: ScaleButton; hasFrame: bool) =
  gtk_scale_button_set_has_frame(cast[ptr ScaleButton00](self.impl), gboolean(hasFrame))

proc gtk_scale_button_set_icons(self: ptr ScaleButton00; icons: ptr cstring) {.
    importc, libprag.}

proc setIcons*(self: ScaleButton; icons: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_scale_button_set_icons(cast[ptr ScaleButton00](self.impl), seq2CstringArray(icons, fs469n23))

proc `icons=`*(self: ScaleButton; icons: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_scale_button_set_icons(cast[ptr ScaleButton00](self.impl), seq2CstringArray(icons, fs469n23))

proc gtk_scale_button_set_value(self: ptr ScaleButton00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: ScaleButton; value: cdouble) =
  gtk_scale_button_set_value(cast[ptr ScaleButton00](self.impl), value)

proc `value=`*(self: ScaleButton; value: cdouble) =
  gtk_scale_button_set_value(cast[ptr ScaleButton00](self.impl), value)

type
  DrawingArea* = ref object of Widget
  DrawingArea00* = object of Widget00

proc gtk_drawing_area_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(DrawingArea()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scResize*(self: DrawingArea;  p: proc (self: ptr DrawingArea00; width: int32; height: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "resize", cast[GCallback](p), xdata, nil, cf)

proc gtk_drawing_area_new(): ptr DrawingArea00 {.
    importc, libprag.}

proc newDrawingArea*(): DrawingArea =
  let gobj = gtk_drawing_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDrawingArea*(tdesc: typedesc): tdesc =
  assert(result is DrawingArea)
  let gobj = gtk_drawing_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDrawingArea*[T](result: var T) {.deprecated.} =
  assert(result is DrawingArea)
  let gobj = gtk_drawing_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drawing_area_get_content_height(self: ptr DrawingArea00): int32 {.
    importc, libprag.}

proc getContentHeight*(self: DrawingArea): int =
  int(gtk_drawing_area_get_content_height(cast[ptr DrawingArea00](self.impl)))

proc contentHeight*(self: DrawingArea): int =
  int(gtk_drawing_area_get_content_height(cast[ptr DrawingArea00](self.impl)))

proc gtk_drawing_area_get_content_width(self: ptr DrawingArea00): int32 {.
    importc, libprag.}

proc getContentWidth*(self: DrawingArea): int =
  int(gtk_drawing_area_get_content_width(cast[ptr DrawingArea00](self.impl)))

proc contentWidth*(self: DrawingArea): int =
  int(gtk_drawing_area_get_content_width(cast[ptr DrawingArea00](self.impl)))

proc gtk_drawing_area_set_content_height(self: ptr DrawingArea00; height: int32) {.
    importc, libprag.}

proc setContentHeight*(self: DrawingArea; height: int) =
  gtk_drawing_area_set_content_height(cast[ptr DrawingArea00](self.impl), int32(height))

proc `contentHeight=`*(self: DrawingArea; height: int) =
  gtk_drawing_area_set_content_height(cast[ptr DrawingArea00](self.impl), int32(height))

proc gtk_drawing_area_set_content_width(self: ptr DrawingArea00; width: int32) {.
    importc, libprag.}

proc setContentWidth*(self: DrawingArea; width: int) =
  gtk_drawing_area_set_content_width(cast[ptr DrawingArea00](self.impl), int32(width))

proc `contentWidth=`*(self: DrawingArea; width: int) =
  gtk_drawing_area_set_content_width(cast[ptr DrawingArea00](self.impl), int32(width))

type
  ShortcutLabel* = ref object of Widget
  ShortcutLabel00* = object of Widget00

proc gtk_shortcut_label_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutLabel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_shortcut_label_new(accelerator: cstring): ptr ShortcutLabel00 {.
    importc, libprag.}

proc newShortcutLabel*(accelerator: cstring): ShortcutLabel =
  let gobj = gtk_shortcut_label_new(accelerator)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newShortcutLabel*(tdesc: typedesc; accelerator: cstring): tdesc =
  assert(result is ShortcutLabel)
  let gobj = gtk_shortcut_label_new(accelerator)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initShortcutLabel*[T](result: var T; accelerator: cstring) {.deprecated.} =
  assert(result is ShortcutLabel)
  let gobj = gtk_shortcut_label_new(accelerator)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_label_get_accelerator(self: ptr ShortcutLabel00): cstring {.
    importc, libprag.}

proc getAccelerator*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_accelerator(cast[ptr ShortcutLabel00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc accelerator*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_accelerator(cast[ptr ShortcutLabel00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_shortcut_label_get_disabled_text(self: ptr ShortcutLabel00): cstring {.
    importc, libprag.}

proc getDisabledText*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_disabled_text(cast[ptr ShortcutLabel00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc disabledText*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_disabled_text(cast[ptr ShortcutLabel00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_shortcut_label_set_accelerator(self: ptr ShortcutLabel00; accelerator: cstring) {.
    importc, libprag.}

proc setAccelerator*(self: ShortcutLabel; accelerator: cstring) =
  gtk_shortcut_label_set_accelerator(cast[ptr ShortcutLabel00](self.impl), accelerator)

proc `accelerator=`*(self: ShortcutLabel; accelerator: cstring) =
  gtk_shortcut_label_set_accelerator(cast[ptr ShortcutLabel00](self.impl), accelerator)

proc gtk_shortcut_label_set_disabled_text(self: ptr ShortcutLabel00; disabledText: cstring) {.
    importc, libprag.}

proc setDisabledText*(self: ShortcutLabel; disabledText: cstring) =
  gtk_shortcut_label_set_disabled_text(cast[ptr ShortcutLabel00](self.impl), disabledText)

proc `disabledText=`*(self: ShortcutLabel; disabledText: cstring) =
  gtk_shortcut_label_set_disabled_text(cast[ptr ShortcutLabel00](self.impl), disabledText)

type
  DropDown* = ref object of Widget
  DropDown00* = object of Widget00

proc gtk_drop_down_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(DropDown()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: DropDown;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_drop_down_new_from_strings(strings: ptr cstring): ptr DropDown00 {.
    importc, libprag.}

proc newDropDownFromStrings*(strings: varargs[string, `$`]): DropDown =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  let gobj = gtk_drop_down_new_from_strings(seq2CstringArray(strings, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDropDownFromStrings*(tdesc: typedesc; strings: varargs[string, `$`]): tdesc =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is DropDown)
  let gobj = gtk_drop_down_new_from_strings(seq2CstringArray(strings, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDropDownFromStrings*[T](result: var T; strings: varargs[string, `$`]) {.deprecated.} =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is DropDown)
  let gobj = gtk_drop_down_new_from_strings(seq2CstringArray(strings, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_down_get_enable_search(self: ptr DropDown00): gboolean {.
    importc, libprag.}

proc getEnableSearch*(self: DropDown): bool =
  toBool(gtk_drop_down_get_enable_search(cast[ptr DropDown00](self.impl)))

proc enableSearch*(self: DropDown): bool =
  toBool(gtk_drop_down_get_enable_search(cast[ptr DropDown00](self.impl)))

proc gtk_drop_down_get_model(self: ptr DropDown00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: DropDown): gio.ListModel =
  let gobj = gtk_drop_down_get_model(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: DropDown): gio.ListModel =
  let gobj = gtk_drop_down_get_model(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_down_get_selected(self: ptr DropDown00): uint32 {.
    importc, libprag.}

proc getSelected*(self: DropDown): int =
  int(gtk_drop_down_get_selected(cast[ptr DropDown00](self.impl)))

proc selected*(self: DropDown): int =
  int(gtk_drop_down_get_selected(cast[ptr DropDown00](self.impl)))

proc gtk_drop_down_get_selected_item(self: ptr DropDown00): ptr gobject.Object00 {.
    importc, libprag.}

proc getSelectedItem*(self: DropDown): gobject.Object =
  let gobj = gtk_drop_down_get_selected_item(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectedItem*(self: DropDown): gobject.Object =
  let gobj = gtk_drop_down_get_selected_item(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_down_get_show_arrow(self: ptr DropDown00): gboolean {.
    importc, libprag.}

proc getShowArrow*(self: DropDown): bool =
  toBool(gtk_drop_down_get_show_arrow(cast[ptr DropDown00](self.impl)))

proc showArrow*(self: DropDown): bool =
  toBool(gtk_drop_down_get_show_arrow(cast[ptr DropDown00](self.impl)))

proc gtk_drop_down_set_enable_search(self: ptr DropDown00; enableSearch: gboolean) {.
    importc, libprag.}

proc setEnableSearch*(self: DropDown; enableSearch: bool = true) =
  gtk_drop_down_set_enable_search(cast[ptr DropDown00](self.impl), gboolean(enableSearch))

proc `enableSearch=`*(self: DropDown; enableSearch: bool) =
  gtk_drop_down_set_enable_search(cast[ptr DropDown00](self.impl), gboolean(enableSearch))

proc gtk_drop_down_set_model(self: ptr DropDown00; model: ptr gio.ListModel00) {.
    importc, libprag.}

proc setModel*(self: DropDown; model: gio.ListModel = nil) =
  gtk_drop_down_set_model(cast[ptr DropDown00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc `model=`*(self: DropDown; model: gio.ListModel = nil) =
  gtk_drop_down_set_model(cast[ptr DropDown00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc gtk_drop_down_set_selected(self: ptr DropDown00; position: uint32) {.
    importc, libprag.}

proc setSelected*(self: DropDown; position: int) =
  gtk_drop_down_set_selected(cast[ptr DropDown00](self.impl), uint32(position))

proc `selected=`*(self: DropDown; position: int) =
  gtk_drop_down_set_selected(cast[ptr DropDown00](self.impl), uint32(position))

proc gtk_drop_down_set_show_arrow(self: ptr DropDown00; showArrow: gboolean) {.
    importc, libprag.}

proc setShowArrow*(self: DropDown; showArrow: bool = true) =
  gtk_drop_down_set_show_arrow(cast[ptr DropDown00](self.impl), gboolean(showArrow))

proc `showArrow=`*(self: DropDown; showArrow: bool) =
  gtk_drop_down_set_show_arrow(cast[ptr DropDown00](self.impl), gboolean(showArrow))

type
  LockButton* = ref object of Button
  LockButton00* = object of Button00

proc gtk_lock_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LockButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_lock_button_new(permission: ptr gio.Permission00): ptr LockButton00 {.
    importc, libprag.}

proc newLockButton*(permission: gio.Permission = nil): LockButton {.deprecated.}  =
  let gobj = gtk_lock_button_new(if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLockButton*(tdesc: typedesc; permission: gio.Permission = nil): tdesc {.deprecated.}  =
  assert(result is LockButton)
  let gobj = gtk_lock_button_new(if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLockButton*[T](result: var T; permission: gio.Permission = nil) {.deprecated.} =
  assert(result is LockButton)
  let gobj = gtk_lock_button_new(if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_lock_button_get_permission(self: ptr LockButton00): ptr gio.Permission00 {.
    importc, libprag.}

proc getPermission*(self: LockButton): gio.Permission =
  let gobj = gtk_lock_button_get_permission(cast[ptr LockButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc permission*(self: LockButton): gio.Permission =
  let gobj = gtk_lock_button_get_permission(cast[ptr LockButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_lock_button_set_permission(self: ptr LockButton00; permission: ptr gio.Permission00) {.
    importc, libprag.}

proc setPermission*(self: LockButton; permission: gio.Permission = nil) =
  gtk_lock_button_set_permission(cast[ptr LockButton00](self.impl), if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))

proc `permission=`*(self: LockButton; permission: gio.Permission = nil) =
  gtk_lock_button_set_permission(cast[ptr LockButton00](self.impl), if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))

type
  DragIcon* = ref object of Widget
  DragIcon00* = object of Widget00

proc gtk_drag_icon_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(DragIcon()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_drag_icon_create_widget_for_value(value: gobject.Value): ptr Widget00 {.
    importc, libprag.}

proc createWidgetForValue*(value: gobject.Value): Widget =
  let gobj = gtk_drag_icon_create_widget_for_value(value)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_icon_get_for_drag(drag: ptr gdk4.Drag00): ptr Widget00 {.
    importc, libprag.}

proc getForDrag*(drag: gdk4.Drag): Widget =
  let gobj = gtk_drag_icon_get_for_drag(cast[ptr gdk4.Drag00](drag.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc forDrag*(drag: gdk4.Drag): Widget =
  let gobj = gtk_drag_icon_get_for_drag(cast[ptr gdk4.Drag00](drag.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_icon_set_from_paintable(drag: ptr gdk4.Drag00; paintable: ptr gdk4.Paintable00;
    hotX: int32; hotY: int32) {.
    importc, libprag.}

proc setFromPaintable*(drag: gdk4.Drag; paintable: gdk4.Paintable;
    hotX: int; hotY: int) =
  gtk_drag_icon_set_from_paintable(cast[ptr gdk4.Drag00](drag.impl), cast[ptr gdk4.Paintable00](paintable.impl), int32(hotX), int32(hotY))

proc gtk_drag_icon_get_child(self: ptr DragIcon00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: DragIcon): Widget =
  let gobj = gtk_drag_icon_get_child(cast[ptr DragIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: DragIcon): Widget =
  let gobj = gtk_drag_icon_get_child(cast[ptr DragIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_icon_set_child(self: ptr DragIcon00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: DragIcon; child: Widget = nil) =
  gtk_drag_icon_set_child(cast[ptr DragIcon00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: DragIcon; child: Widget = nil) =
  gtk_drag_icon_set_child(cast[ptr DragIcon00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

type
  AppChooserDialog* = ref object of Dialog
  AppChooserDialog00* = object of Dialog00

proc gtk_app_chooser_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AppChooserDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_app_chooser_dialog_get_heading(self: ptr AppChooserDialog00): cstring {.
    importc, libprag.}

proc getHeading*(self: AppChooserDialog): string =
  let resul0 = gtk_app_chooser_dialog_get_heading(cast[ptr AppChooserDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc heading*(self: AppChooserDialog): string =
  let resul0 = gtk_app_chooser_dialog_get_heading(cast[ptr AppChooserDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_app_chooser_dialog_get_widget(self: ptr AppChooserDialog00): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: AppChooserDialog): Widget =
  let gobj = gtk_app_chooser_dialog_get_widget(cast[ptr AppChooserDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: AppChooserDialog): Widget =
  let gobj = gtk_app_chooser_dialog_get_widget(cast[ptr AppChooserDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_dialog_set_heading(self: ptr AppChooserDialog00; heading: cstring) {.
    importc, libprag.}

proc setHeading*(self: AppChooserDialog; heading: cstring) =
  gtk_app_chooser_dialog_set_heading(cast[ptr AppChooserDialog00](self.impl), heading)

proc `heading=`*(self: AppChooserDialog; heading: cstring) =
  gtk_app_chooser_dialog_set_heading(cast[ptr AppChooserDialog00](self.impl), heading)

type
  StackSwitcher* = ref object of Widget
  StackSwitcher00* = object of Widget00

proc gtk_stack_switcher_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StackSwitcher()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_stack_switcher_new(): ptr StackSwitcher00 {.
    importc, libprag.}

proc newStackSwitcher*(): StackSwitcher =
  let gobj = gtk_stack_switcher_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStackSwitcher*(tdesc: typedesc): tdesc =
  assert(result is StackSwitcher)
  let gobj = gtk_stack_switcher_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStackSwitcher*[T](result: var T) {.deprecated.} =
  assert(result is StackSwitcher)
  let gobj = gtk_stack_switcher_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_switcher_get_stack(self: ptr StackSwitcher00): ptr Stack00 {.
    importc, libprag.}

proc getStack*(self: StackSwitcher): Stack =
  let gobj = gtk_stack_switcher_get_stack(cast[ptr StackSwitcher00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc stack*(self: StackSwitcher): Stack =
  let gobj = gtk_stack_switcher_get_stack(cast[ptr StackSwitcher00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_switcher_set_stack(self: ptr StackSwitcher00; stack: ptr Stack00) {.
    importc, libprag.}

proc setStack*(self: StackSwitcher; stack: Stack = nil) =
  gtk_stack_switcher_set_stack(cast[ptr StackSwitcher00](self.impl), if stack.isNil: nil else: cast[ptr Stack00](stack.impl))

proc `stack=`*(self: StackSwitcher; stack: Stack = nil) =
  gtk_stack_switcher_set_stack(cast[ptr StackSwitcher00](self.impl), if stack.isNil: nil else: cast[ptr Stack00](stack.impl))

type
  ComboBoxText* = ref object of ComboBox
  ComboBoxText00* = object of ComboBox00

proc gtk_combo_box_text_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ComboBoxText()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_combo_box_text_new(): ptr ComboBoxText00 {.
    importc, libprag.}

proc newComboBoxText*(): ComboBoxText {.deprecated.}  =
  let gobj = gtk_combo_box_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxText*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is ComboBoxText)
  let gobj = gtk_combo_box_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxText*[T](result: var T) {.deprecated.} =
  assert(result is ComboBoxText)
  let gobj = gtk_combo_box_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_text_new_with_entry(): ptr ComboBoxText00 {.
    importc, libprag.}

proc newComboBoxTextWithEntry*(): ComboBoxText {.deprecated.}  =
  let gobj = gtk_combo_box_text_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxTextWithEntry*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is ComboBoxText)
  let gobj = gtk_combo_box_text_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxTextWithEntry*[T](result: var T) {.deprecated.} =
  assert(result is ComboBoxText)
  let gobj = gtk_combo_box_text_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_text_append(self: ptr ComboBoxText00; id: cstring; text: cstring) {.
    importc, libprag.}

proc append*(self: ComboBoxText; id: cstring = nil; text: cstring) =
  gtk_combo_box_text_append(cast[ptr ComboBoxText00](self.impl), id, text)

proc gtk_combo_box_text_append_text(self: ptr ComboBoxText00; text: cstring) {.
    importc, libprag.}

proc appendText*(self: ComboBoxText; text: cstring) =
  gtk_combo_box_text_append_text(cast[ptr ComboBoxText00](self.impl), text)

proc gtk_combo_box_text_get_active_text(self: ptr ComboBoxText00): cstring {.
    importc, libprag.}

proc getActiveText*(self: ComboBoxText): string =
  let resul0 = gtk_combo_box_text_get_active_text(cast[ptr ComboBoxText00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc activeText*(self: ComboBoxText): string =
  let resul0 = gtk_combo_box_text_get_active_text(cast[ptr ComboBoxText00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_combo_box_text_insert(self: ptr ComboBoxText00; position: int32;
    id: cstring; text: cstring) {.
    importc, libprag.}

proc insert*(self: ComboBoxText; position: int; id: cstring = nil;
    text: cstring) =
  gtk_combo_box_text_insert(cast[ptr ComboBoxText00](self.impl), int32(position), id, text)

proc gtk_combo_box_text_insert_text(self: ptr ComboBoxText00; position: int32;
    text: cstring) {.
    importc, libprag.}

proc insertText*(self: ComboBoxText; position: int; text: cstring) =
  gtk_combo_box_text_insert_text(cast[ptr ComboBoxText00](self.impl), int32(position), text)

proc gtk_combo_box_text_prepend(self: ptr ComboBoxText00; id: cstring; text: cstring) {.
    importc, libprag.}

proc prepend*(self: ComboBoxText; id: cstring = nil; text: cstring) =
  gtk_combo_box_text_prepend(cast[ptr ComboBoxText00](self.impl), id, text)

proc gtk_combo_box_text_prepend_text(self: ptr ComboBoxText00; text: cstring) {.
    importc, libprag.}

proc prependText*(self: ComboBoxText; text: cstring) =
  gtk_combo_box_text_prepend_text(cast[ptr ComboBoxText00](self.impl), text)

proc gtk_combo_box_text_remove(self: ptr ComboBoxText00; position: int32) {.
    importc, libprag.}

proc remove*(self: ComboBoxText; position: int) =
  gtk_combo_box_text_remove(cast[ptr ComboBoxText00](self.impl), int32(position))

proc gtk_combo_box_text_remove_all(self: ptr ComboBoxText00) {.
    importc, libprag.}

proc removeAll*(self: ComboBoxText) =
  gtk_combo_box_text_remove_all(cast[ptr ComboBoxText00](self.impl))

type
  Assistant* = ref object of Window
  Assistant00* = object of Window00

proc gtk_assistant_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Assistant()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scApply*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "apply", cast[GCallback](p), xdata, nil, cf)

proc scCancel*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cancel", cast[GCallback](p), xdata, nil, cf)

proc scClose*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cf)

proc scEscape*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "escape", cast[GCallback](p), xdata, nil, cf)

proc scPrepare*(self: Assistant;  p: proc (self: ptr Assistant00; page: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "prepare", cast[GCallback](p), xdata, nil, cf)

proc gtk_assistant_new(): ptr Assistant00 {.
    importc, libprag.}

proc newAssistant*(): Assistant {.deprecated.}  =
  let gobj = gtk_assistant_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAssistant*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is Assistant)
  let gobj = gtk_assistant_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAssistant*[T](result: var T) {.deprecated.} =
  assert(result is Assistant)
  let gobj = gtk_assistant_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_add_action_widget(self: ptr Assistant00; child: ptr Widget00) {.
    importc, libprag.}

proc addActionWidget*(self: Assistant; child: Widget) =
  gtk_assistant_add_action_widget(cast[ptr Assistant00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_assistant_append_page(self: ptr Assistant00; page: ptr Widget00): int32 {.
    importc, libprag.}

proc appendPage*(self: Assistant; page: Widget): int =
  int(gtk_assistant_append_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_commit(self: ptr Assistant00) {.
    importc, libprag.}

proc commit*(self: Assistant) =
  gtk_assistant_commit(cast[ptr Assistant00](self.impl))

proc gtk_assistant_get_current_page(self: ptr Assistant00): int32 {.
    importc, libprag.}

proc getCurrentPage*(self: Assistant): int =
  int(gtk_assistant_get_current_page(cast[ptr Assistant00](self.impl)))

proc currentPage*(self: Assistant): int =
  int(gtk_assistant_get_current_page(cast[ptr Assistant00](self.impl)))

proc gtk_assistant_get_n_pages(self: ptr Assistant00): int32 {.
    importc, libprag.}

proc getNPages*(self: Assistant): int =
  int(gtk_assistant_get_n_pages(cast[ptr Assistant00](self.impl)))

proc nPages*(self: Assistant): int =
  int(gtk_assistant_get_n_pages(cast[ptr Assistant00](self.impl)))

proc gtk_assistant_get_nth_page(self: ptr Assistant00; pageNum: int32): ptr Widget00 {.
    importc, libprag.}

proc getNthPage*(self: Assistant; pageNum: int): Widget =
  let gobj = gtk_assistant_get_nth_page(cast[ptr Assistant00](self.impl), int32(pageNum))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_get_page_complete(self: ptr Assistant00; page: ptr Widget00): gboolean {.
    importc, libprag.}

proc getPageComplete*(self: Assistant; page: Widget): bool =
  toBool(gtk_assistant_get_page_complete(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_get_page_title(self: ptr Assistant00; page: ptr Widget00): cstring {.
    importc, libprag.}

proc getPageTitle*(self: Assistant; page: Widget): string =
  result = $gtk_assistant_get_page_title(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))

proc gtk_assistant_get_pages(self: ptr Assistant00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getPages*(self: Assistant): gio.ListModel =
  let gobj = gtk_assistant_get_pages(cast[ptr Assistant00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pages*(self: Assistant): gio.ListModel =
  let gobj = gtk_assistant_get_pages(cast[ptr Assistant00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_insert_page(self: ptr Assistant00; page: ptr Widget00;
    position: int32): int32 {.
    importc, libprag.}

proc insertPage*(self: Assistant; page: Widget; position: int): int =
  int(gtk_assistant_insert_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), int32(position)))

proc gtk_assistant_next_page(self: ptr Assistant00) {.
    importc, libprag.}

proc nextPage*(self: Assistant) =
  gtk_assistant_next_page(cast[ptr Assistant00](self.impl))

proc gtk_assistant_prepend_page(self: ptr Assistant00; page: ptr Widget00): int32 {.
    importc, libprag.}

proc prependPage*(self: Assistant; page: Widget): int =
  int(gtk_assistant_prepend_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_previous_page(self: ptr Assistant00) {.
    importc, libprag.}

proc previousPage*(self: Assistant) =
  gtk_assistant_previous_page(cast[ptr Assistant00](self.impl))

proc gtk_assistant_remove_action_widget(self: ptr Assistant00; child: ptr Widget00) {.
    importc, libprag.}

proc removeActionWidget*(self: Assistant; child: Widget) =
  gtk_assistant_remove_action_widget(cast[ptr Assistant00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_assistant_remove_page(self: ptr Assistant00; pageNum: int32) {.
    importc, libprag.}

proc removePage*(self: Assistant; pageNum: int) =
  gtk_assistant_remove_page(cast[ptr Assistant00](self.impl), int32(pageNum))

proc gtk_assistant_set_current_page(self: ptr Assistant00; pageNum: int32) {.
    importc, libprag.}

proc setCurrentPage*(self: Assistant; pageNum: int) =
  gtk_assistant_set_current_page(cast[ptr Assistant00](self.impl), int32(pageNum))

proc `currentPage=`*(self: Assistant; pageNum: int) =
  gtk_assistant_set_current_page(cast[ptr Assistant00](self.impl), int32(pageNum))

proc gtk_assistant_set_page_complete(self: ptr Assistant00; page: ptr Widget00;
    complete: gboolean) {.
    importc, libprag.}

proc setPageComplete*(self: Assistant; page: Widget; complete: bool) =
  gtk_assistant_set_page_complete(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), gboolean(complete))

proc gtk_assistant_set_page_title(self: ptr Assistant00; page: ptr Widget00;
    title: cstring) {.
    importc, libprag.}

proc setPageTitle*(self: Assistant; page: Widget; title: cstring) =
  gtk_assistant_set_page_title(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), title)

proc gtk_assistant_update_buttons_state(self: ptr Assistant00) {.
    importc, libprag.}

proc updateButtonsState*(self: Assistant) =
  gtk_assistant_update_buttons_state(cast[ptr Assistant00](self.impl))

type
  MenuButton* = ref object of Widget
  MenuButton00* = object of Widget00

proc gtk_menu_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: MenuButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_menu_button_new(): ptr MenuButton00 {.
    importc, libprag.}

proc newMenuButton*(): MenuButton =
  let gobj = gtk_menu_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuButton*(tdesc: typedesc): tdesc =
  assert(result is MenuButton)
  let gobj = gtk_menu_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuButton*[T](result: var T) {.deprecated.} =
  assert(result is MenuButton)
  let gobj = gtk_menu_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_active(self: ptr MenuButton00): gboolean {.
    importc, libprag.}

proc getActive*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_active(cast[ptr MenuButton00](self.impl)))

proc active*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_active(cast[ptr MenuButton00](self.impl)))

proc gtk_menu_button_get_always_show_arrow(self: ptr MenuButton00): gboolean {.
    importc, libprag.}

proc getAlwaysShowArrow*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_always_show_arrow(cast[ptr MenuButton00](self.impl)))

proc alwaysShowArrow*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_always_show_arrow(cast[ptr MenuButton00](self.impl)))

proc gtk_menu_button_get_can_shrink(self: ptr MenuButton00): gboolean {.
    importc, libprag.}

proc getCanShrink*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_can_shrink(cast[ptr MenuButton00](self.impl)))

proc canShrink*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_can_shrink(cast[ptr MenuButton00](self.impl)))

proc gtk_menu_button_get_child(self: ptr MenuButton00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: MenuButton): Widget =
  let gobj = gtk_menu_button_get_child(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: MenuButton): Widget =
  let gobj = gtk_menu_button_get_child(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_has_frame(self: ptr MenuButton00): gboolean {.
    importc, libprag.}

proc getHasFrame*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_has_frame(cast[ptr MenuButton00](self.impl)))

proc hasFrame*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_has_frame(cast[ptr MenuButton00](self.impl)))

proc gtk_menu_button_get_icon_name(self: ptr MenuButton00): cstring {.
    importc, libprag.}

proc getIconName*(self: MenuButton): string =
  let resul0 = gtk_menu_button_get_icon_name(cast[ptr MenuButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc iconName*(self: MenuButton): string =
  let resul0 = gtk_menu_button_get_icon_name(cast[ptr MenuButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_menu_button_get_label(self: ptr MenuButton00): cstring {.
    importc, libprag.}

proc getLabel*(self: MenuButton): string =
  let resul0 = gtk_menu_button_get_label(cast[ptr MenuButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc label*(self: MenuButton): string =
  let resul0 = gtk_menu_button_get_label(cast[ptr MenuButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_menu_button_get_menu_model(self: ptr MenuButton00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getMenuModel*(self: MenuButton): gio.MenuModel =
  let gobj = gtk_menu_button_get_menu_model(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menuModel*(self: MenuButton): gio.MenuModel =
  let gobj = gtk_menu_button_get_menu_model(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_popover(self: ptr MenuButton00): ptr Popover00 {.
    importc, libprag.}

proc getPopover*(self: MenuButton): Popover =
  let gobj = gtk_menu_button_get_popover(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popover*(self: MenuButton): Popover =
  let gobj = gtk_menu_button_get_popover(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_primary(self: ptr MenuButton00): gboolean {.
    importc, libprag.}

proc getPrimary*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_primary(cast[ptr MenuButton00](self.impl)))

proc primary*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_primary(cast[ptr MenuButton00](self.impl)))

proc gtk_menu_button_get_use_underline(self: ptr MenuButton00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_use_underline(cast[ptr MenuButton00](self.impl)))

proc useUnderline*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_use_underline(cast[ptr MenuButton00](self.impl)))

proc gtk_menu_button_popdown(self: ptr MenuButton00) {.
    importc, libprag.}

proc popdown*(self: MenuButton) =
  gtk_menu_button_popdown(cast[ptr MenuButton00](self.impl))

proc gtk_menu_button_popup(self: ptr MenuButton00) {.
    importc, libprag.}

proc popup*(self: MenuButton) =
  gtk_menu_button_popup(cast[ptr MenuButton00](self.impl))

proc gtk_menu_button_set_active(self: ptr MenuButton00; active: gboolean) {.
    importc, libprag.}

proc setActive*(self: MenuButton; active: bool = true) =
  gtk_menu_button_set_active(cast[ptr MenuButton00](self.impl), gboolean(active))

proc `active=`*(self: MenuButton; active: bool) =
  gtk_menu_button_set_active(cast[ptr MenuButton00](self.impl), gboolean(active))

proc gtk_menu_button_set_always_show_arrow(self: ptr MenuButton00; alwaysShowArrow: gboolean) {.
    importc, libprag.}

proc setAlwaysShowArrow*(self: MenuButton; alwaysShowArrow: bool = true) =
  gtk_menu_button_set_always_show_arrow(cast[ptr MenuButton00](self.impl), gboolean(alwaysShowArrow))

proc `alwaysShowArrow=`*(self: MenuButton; alwaysShowArrow: bool) =
  gtk_menu_button_set_always_show_arrow(cast[ptr MenuButton00](self.impl), gboolean(alwaysShowArrow))

proc gtk_menu_button_set_can_shrink(self: ptr MenuButton00; canShrink: gboolean) {.
    importc, libprag.}

proc setCanShrink*(self: MenuButton; canShrink: bool = true) =
  gtk_menu_button_set_can_shrink(cast[ptr MenuButton00](self.impl), gboolean(canShrink))

proc `canShrink=`*(self: MenuButton; canShrink: bool) =
  gtk_menu_button_set_can_shrink(cast[ptr MenuButton00](self.impl), gboolean(canShrink))

proc gtk_menu_button_set_child(self: ptr MenuButton00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: MenuButton; child: Widget = nil) =
  gtk_menu_button_set_child(cast[ptr MenuButton00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: MenuButton; child: Widget = nil) =
  gtk_menu_button_set_child(cast[ptr MenuButton00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_menu_button_set_has_frame(self: ptr MenuButton00; hasFrame: gboolean) {.
    importc, libprag.}

proc setHasFrame*(self: MenuButton; hasFrame: bool = true) =
  gtk_menu_button_set_has_frame(cast[ptr MenuButton00](self.impl), gboolean(hasFrame))

proc `hasFrame=`*(self: MenuButton; hasFrame: bool) =
  gtk_menu_button_set_has_frame(cast[ptr MenuButton00](self.impl), gboolean(hasFrame))

proc gtk_menu_button_set_icon_name(self: ptr MenuButton00; iconName: cstring) {.
    importc, libprag.}

proc setIconName*(self: MenuButton; iconName: cstring) =
  gtk_menu_button_set_icon_name(cast[ptr MenuButton00](self.impl), iconName)

proc `iconName=`*(self: MenuButton; iconName: cstring) =
  gtk_menu_button_set_icon_name(cast[ptr MenuButton00](self.impl), iconName)

proc gtk_menu_button_set_label(self: ptr MenuButton00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: MenuButton; label: cstring) =
  gtk_menu_button_set_label(cast[ptr MenuButton00](self.impl), label)

proc `label=`*(self: MenuButton; label: cstring) =
  gtk_menu_button_set_label(cast[ptr MenuButton00](self.impl), label)

proc gtk_menu_button_set_menu_model(self: ptr MenuButton00; menuModel: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setMenuModel*(self: MenuButton; menuModel: gio.MenuModel = nil) =
  gtk_menu_button_set_menu_model(cast[ptr MenuButton00](self.impl), if menuModel.isNil: nil else: cast[ptr gio.MenuModel00](menuModel.impl))

proc `menuModel=`*(self: MenuButton; menuModel: gio.MenuModel = nil) =
  gtk_menu_button_set_menu_model(cast[ptr MenuButton00](self.impl), if menuModel.isNil: nil else: cast[ptr gio.MenuModel00](menuModel.impl))

proc gtk_menu_button_set_popover(self: ptr MenuButton00; popover: ptr Widget00) {.
    importc, libprag.}

proc setPopover*(self: MenuButton; popover: Widget = nil) =
  gtk_menu_button_set_popover(cast[ptr MenuButton00](self.impl), if popover.isNil: nil else: cast[ptr Widget00](popover.impl))

proc `popover=`*(self: MenuButton; popover: Widget = nil) =
  gtk_menu_button_set_popover(cast[ptr MenuButton00](self.impl), if popover.isNil: nil else: cast[ptr Widget00](popover.impl))

proc gtk_menu_button_set_primary(self: ptr MenuButton00; primary: gboolean) {.
    importc, libprag.}

proc setPrimary*(self: MenuButton; primary: bool = true) =
  gtk_menu_button_set_primary(cast[ptr MenuButton00](self.impl), gboolean(primary))

proc `primary=`*(self: MenuButton; primary: bool) =
  gtk_menu_button_set_primary(cast[ptr MenuButton00](self.impl), gboolean(primary))

proc gtk_menu_button_set_use_underline(self: ptr MenuButton00; useUnderline: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: MenuButton; useUnderline: bool = true) =
  gtk_menu_button_set_use_underline(cast[ptr MenuButton00](self.impl), gboolean(useUnderline))

proc `useUnderline=`*(self: MenuButton; useUnderline: bool) =
  gtk_menu_button_set_use_underline(cast[ptr MenuButton00](self.impl), gboolean(useUnderline))

type
  WindowControls* = ref object of Widget
  WindowControls00* = object of Widget00

proc gtk_window_controls_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(WindowControls()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_window_controls_get_decoration_layout(self: ptr WindowControls00): cstring {.
    importc, libprag.}

proc getDecorationLayout*(self: WindowControls): string =
  let resul0 = gtk_window_controls_get_decoration_layout(cast[ptr WindowControls00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc decorationLayout*(self: WindowControls): string =
  let resul0 = gtk_window_controls_get_decoration_layout(cast[ptr WindowControls00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_window_controls_get_empty(self: ptr WindowControls00): gboolean {.
    importc, libprag.}

proc getEmpty*(self: WindowControls): bool =
  toBool(gtk_window_controls_get_empty(cast[ptr WindowControls00](self.impl)))

proc empty*(self: WindowControls): bool =
  toBool(gtk_window_controls_get_empty(cast[ptr WindowControls00](self.impl)))

proc gtk_window_controls_set_decoration_layout(self: ptr WindowControls00;
    layout: cstring) {.
    importc, libprag.}

proc setDecorationLayout*(self: WindowControls; layout: cstring = nil) =
  gtk_window_controls_set_decoration_layout(cast[ptr WindowControls00](self.impl), layout)

proc `decorationLayout=`*(self: WindowControls; layout: cstring = nil) =
  gtk_window_controls_set_decoration_layout(cast[ptr WindowControls00](self.impl), layout)

type
  ColorChooserDialog* = ref object of Dialog
  ColorChooserDialog00* = object of Dialog00

proc gtk_color_chooser_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorChooserDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_color_chooser_dialog_new(title: cstring; parent: ptr Window00): ptr ColorChooserDialog00 {.
    importc, libprag.}

proc newColorChooserDialog*(title: cstring = nil; parent: Window = nil): ColorChooserDialog {.deprecated.}  =
  let gobj = gtk_color_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorChooserDialog*(tdesc: typedesc; title: cstring = nil; parent: Window = nil): tdesc {.deprecated.}  =
  assert(result is ColorChooserDialog)
  let gobj = gtk_color_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorChooserDialog*[T](result: var T; title: cstring = nil; parent: Window = nil) {.deprecated.} =
  assert(result is ColorChooserDialog)
  let gobj = gtk_color_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  AppChooserButton* = ref object of Widget
  AppChooserButton00* = object of Widget00

proc gtk_app_chooser_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AppChooserButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: AppChooserButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scChanged*(self: AppChooserButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scCustomItemActivated*(self: AppChooserButton;  p: proc (self: ptr AppChooserButton00; itemName: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "custom-item-activated", cast[GCallback](p), xdata, nil, cf)

proc gtk_app_chooser_button_new(contentType: cstring): ptr AppChooserButton00 {.
    importc, libprag.}

proc newAppChooserButton*(contentType: cstring): AppChooserButton {.deprecated.}  =
  let gobj = gtk_app_chooser_button_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAppChooserButton*(tdesc: typedesc; contentType: cstring): tdesc {.deprecated.}  =
  assert(result is AppChooserButton)
  let gobj = gtk_app_chooser_button_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserButton*[T](result: var T; contentType: cstring) {.deprecated.} =
  assert(result is AppChooserButton)
  let gobj = gtk_app_chooser_button_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_button_append_custom_item(self: ptr AppChooserButton00;
    name: cstring; label: cstring; icon: ptr gio.Icon00) {.
    importc, libprag.}

proc appendCustomItem*(self: AppChooserButton; name: cstring;
    label: cstring; icon: gio.Icon) =
  gtk_app_chooser_button_append_custom_item(cast[ptr AppChooserButton00](self.impl), name, label, cast[ptr gio.Icon00](icon.impl))

proc gtk_app_chooser_button_append_separator(self: ptr AppChooserButton00) {.
    importc, libprag.}

proc appendSeparator*(self: AppChooserButton) =
  gtk_app_chooser_button_append_separator(cast[ptr AppChooserButton00](self.impl))

proc gtk_app_chooser_button_get_heading(self: ptr AppChooserButton00): cstring {.
    importc, libprag.}

proc getHeading*(self: AppChooserButton): string =
  let resul0 = gtk_app_chooser_button_get_heading(cast[ptr AppChooserButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc heading*(self: AppChooserButton): string =
  let resul0 = gtk_app_chooser_button_get_heading(cast[ptr AppChooserButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_app_chooser_button_get_modal(self: ptr AppChooserButton00): gboolean {.
    importc, libprag.}

proc getModal*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_modal(cast[ptr AppChooserButton00](self.impl)))

proc modal*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_modal(cast[ptr AppChooserButton00](self.impl)))

proc gtk_app_chooser_button_get_show_default_item(self: ptr AppChooserButton00): gboolean {.
    importc, libprag.}

proc getShowDefaultItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_default_item(cast[ptr AppChooserButton00](self.impl)))

proc showDefaultItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_default_item(cast[ptr AppChooserButton00](self.impl)))

proc gtk_app_chooser_button_get_show_dialog_item(self: ptr AppChooserButton00): gboolean {.
    importc, libprag.}

proc getShowDialogItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_dialog_item(cast[ptr AppChooserButton00](self.impl)))

proc showDialogItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_dialog_item(cast[ptr AppChooserButton00](self.impl)))

proc gtk_app_chooser_button_set_active_custom_item(self: ptr AppChooserButton00;
    name: cstring) {.
    importc, libprag.}

proc setActiveCustomItem*(self: AppChooserButton;
    name: cstring) =
  gtk_app_chooser_button_set_active_custom_item(cast[ptr AppChooserButton00](self.impl), name)

proc `activeCustomItem=`*(self: AppChooserButton;
    name: cstring) =
  gtk_app_chooser_button_set_active_custom_item(cast[ptr AppChooserButton00](self.impl), name)

proc gtk_app_chooser_button_set_heading(self: ptr AppChooserButton00; heading: cstring) {.
    importc, libprag.}

proc setHeading*(self: AppChooserButton; heading: cstring) =
  gtk_app_chooser_button_set_heading(cast[ptr AppChooserButton00](self.impl), heading)

proc `heading=`*(self: AppChooserButton; heading: cstring) =
  gtk_app_chooser_button_set_heading(cast[ptr AppChooserButton00](self.impl), heading)

proc gtk_app_chooser_button_set_modal(self: ptr AppChooserButton00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: AppChooserButton; modal: bool = true) =
  gtk_app_chooser_button_set_modal(cast[ptr AppChooserButton00](self.impl), gboolean(modal))

proc `modal=`*(self: AppChooserButton; modal: bool) =
  gtk_app_chooser_button_set_modal(cast[ptr AppChooserButton00](self.impl), gboolean(modal))

proc gtk_app_chooser_button_set_show_default_item(self: ptr AppChooserButton00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowDefaultItem*(self: AppChooserButton;
    setting: bool = true) =
  gtk_app_chooser_button_set_show_default_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

proc `showDefaultItem=`*(self: AppChooserButton;
    setting: bool) =
  gtk_app_chooser_button_set_show_default_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

proc gtk_app_chooser_button_set_show_dialog_item(self: ptr AppChooserButton00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowDialogItem*(self: AppChooserButton;
    setting: bool = true) =
  gtk_app_chooser_button_set_show_dialog_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

proc `showDialogItem=`*(self: AppChooserButton;
    setting: bool) =
  gtk_app_chooser_button_set_show_dialog_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

type
  ColorDialogButton* = ref object of Widget
  ColorDialogButton00* = object of Widget00

proc gtk_color_dialog_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorDialogButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: ColorDialogButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_color_dialog_button_get_rgba(self: ptr ColorDialogButton00): ptr gdk4.RGBA {.
    importc, libprag.}

proc getRgba*(self: ColorDialogButton): ptr gdk4.RGBA =
  gtk_color_dialog_button_get_rgba(cast[ptr ColorDialogButton00](self.impl))

proc rgba*(self: ColorDialogButton): ptr gdk4.RGBA =
  gtk_color_dialog_button_get_rgba(cast[ptr ColorDialogButton00](self.impl))

proc gtk_color_dialog_button_set_rgba(self: ptr ColorDialogButton00; color: gdk4.RGBA) {.
    importc, libprag.}

proc setRgba*(self: ColorDialogButton; color: gdk4.RGBA) =
  gtk_color_dialog_button_set_rgba(cast[ptr ColorDialogButton00](self.impl), color)

proc `rgba=`*(self: ColorDialogButton; color: gdk4.RGBA) =
  gtk_color_dialog_button_set_rgba(cast[ptr ColorDialogButton00](self.impl), color)

type
  Calendar* = ref object of Widget
  Calendar00* = object of Widget00

proc gtk_calendar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Calendar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDaySelected*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "day-selected", cast[GCallback](p), xdata, nil, cf)

proc scNextMonth*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "next-month", cast[GCallback](p), xdata, nil, cf)

proc scNextYear*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "next-year", cast[GCallback](p), xdata, nil, cf)

proc scPrevMonth*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "prev-month", cast[GCallback](p), xdata, nil, cf)

proc scPrevYear*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "prev-year", cast[GCallback](p), xdata, nil, cf)

proc gtk_calendar_new(): ptr Calendar00 {.
    importc, libprag.}

proc newCalendar*(): Calendar =
  let gobj = gtk_calendar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCalendar*(tdesc: typedesc): tdesc =
  assert(result is Calendar)
  let gobj = gtk_calendar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCalendar*[T](result: var T) {.deprecated.} =
  assert(result is Calendar)
  let gobj = gtk_calendar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_calendar_clear_marks(self: ptr Calendar00) {.
    importc, libprag.}

proc clearMarks*(self: Calendar) =
  gtk_calendar_clear_marks(cast[ptr Calendar00](self.impl))

proc gtk_calendar_get_date(self: ptr Calendar00): ptr glib.DateTime00 {.
    importc, libprag.}

proc getDate*(self: Calendar): glib.DateTime =
  fnew(result, gBoxedFreeGDateTime)
  result.impl = gtk_calendar_get_date(cast[ptr Calendar00](self.impl))

proc date*(self: Calendar): glib.DateTime =
  fnew(result, gBoxedFreeGDateTime)
  result.impl = gtk_calendar_get_date(cast[ptr Calendar00](self.impl))

proc gtk_calendar_get_day(self: ptr Calendar00): int32 {.
    importc, libprag.}

proc getDay*(self: Calendar): int =
  int(gtk_calendar_get_day(cast[ptr Calendar00](self.impl)))

proc day*(self: Calendar): int =
  int(gtk_calendar_get_day(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_get_day_is_marked(self: ptr Calendar00; day: uint32): gboolean {.
    importc, libprag.}

proc getDayIsMarked*(self: Calendar; day: int): bool =
  toBool(gtk_calendar_get_day_is_marked(cast[ptr Calendar00](self.impl), uint32(day)))

proc gtk_calendar_get_month(self: ptr Calendar00): int32 {.
    importc, libprag.}

proc getMonth*(self: Calendar): int =
  int(gtk_calendar_get_month(cast[ptr Calendar00](self.impl)))

proc month*(self: Calendar): int =
  int(gtk_calendar_get_month(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_get_show_day_names(self: ptr Calendar00): gboolean {.
    importc, libprag.}

proc getShowDayNames*(self: Calendar): bool =
  toBool(gtk_calendar_get_show_day_names(cast[ptr Calendar00](self.impl)))

proc showDayNames*(self: Calendar): bool =
  toBool(gtk_calendar_get_show_day_names(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_get_show_heading(self: ptr Calendar00): gboolean {.
    importc, libprag.}

proc getShowHeading*(self: Calendar): bool =
  toBool(gtk_calendar_get_show_heading(cast[ptr Calendar00](self.impl)))

proc showHeading*(self: Calendar): bool =
  toBool(gtk_calendar_get_show_heading(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_get_show_week_numbers(self: ptr Calendar00): gboolean {.
    importc, libprag.}

proc getShowWeekNumbers*(self: Calendar): bool =
  toBool(gtk_calendar_get_show_week_numbers(cast[ptr Calendar00](self.impl)))

proc showWeekNumbers*(self: Calendar): bool =
  toBool(gtk_calendar_get_show_week_numbers(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_get_year(self: ptr Calendar00): int32 {.
    importc, libprag.}

proc getYear*(self: Calendar): int =
  int(gtk_calendar_get_year(cast[ptr Calendar00](self.impl)))

proc year*(self: Calendar): int =
  int(gtk_calendar_get_year(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_mark_day(self: ptr Calendar00; day: uint32) {.
    importc, libprag.}

proc markDay*(self: Calendar; day: int) =
  gtk_calendar_mark_day(cast[ptr Calendar00](self.impl), uint32(day))

proc gtk_calendar_select_day(self: ptr Calendar00; date: ptr glib.DateTime00) {.
    importc, libprag.}

proc selectDay*(self: Calendar; date: glib.DateTime) =
  gtk_calendar_select_day(cast[ptr Calendar00](self.impl), cast[ptr glib.DateTime00](date.impl))

proc gtk_calendar_set_day(self: ptr Calendar00; day: int32) {.
    importc, libprag.}

proc setDay*(self: Calendar; day: int) =
  gtk_calendar_set_day(cast[ptr Calendar00](self.impl), int32(day))

proc `day=`*(self: Calendar; day: int) =
  gtk_calendar_set_day(cast[ptr Calendar00](self.impl), int32(day))

proc gtk_calendar_set_month(self: ptr Calendar00; month: int32) {.
    importc, libprag.}

proc setMonth*(self: Calendar; month: int) =
  gtk_calendar_set_month(cast[ptr Calendar00](self.impl), int32(month))

proc `month=`*(self: Calendar; month: int) =
  gtk_calendar_set_month(cast[ptr Calendar00](self.impl), int32(month))

proc gtk_calendar_set_show_day_names(self: ptr Calendar00; value: gboolean) {.
    importc, libprag.}

proc setShowDayNames*(self: Calendar; value: bool = true) =
  gtk_calendar_set_show_day_names(cast[ptr Calendar00](self.impl), gboolean(value))

proc `showDayNames=`*(self: Calendar; value: bool) =
  gtk_calendar_set_show_day_names(cast[ptr Calendar00](self.impl), gboolean(value))

proc gtk_calendar_set_show_heading(self: ptr Calendar00; value: gboolean) {.
    importc, libprag.}

proc setShowHeading*(self: Calendar; value: bool = true) =
  gtk_calendar_set_show_heading(cast[ptr Calendar00](self.impl), gboolean(value))

proc `showHeading=`*(self: Calendar; value: bool) =
  gtk_calendar_set_show_heading(cast[ptr Calendar00](self.impl), gboolean(value))

proc gtk_calendar_set_show_week_numbers(self: ptr Calendar00; value: gboolean) {.
    importc, libprag.}

proc setShowWeekNumbers*(self: Calendar; value: bool = true) =
  gtk_calendar_set_show_week_numbers(cast[ptr Calendar00](self.impl), gboolean(value))

proc `showWeekNumbers=`*(self: Calendar; value: bool) =
  gtk_calendar_set_show_week_numbers(cast[ptr Calendar00](self.impl), gboolean(value))

proc gtk_calendar_set_year(self: ptr Calendar00; year: int32) {.
    importc, libprag.}

proc setYear*(self: Calendar; year: int) =
  gtk_calendar_set_year(cast[ptr Calendar00](self.impl), int32(year))

proc `year=`*(self: Calendar; year: int) =
  gtk_calendar_set_year(cast[ptr Calendar00](self.impl), int32(year))

proc gtk_calendar_unmark_day(self: ptr Calendar00; day: uint32) {.
    importc, libprag.}

proc unmarkDay*(self: Calendar; day: int) =
  gtk_calendar_unmark_day(cast[ptr Calendar00](self.impl), uint32(day))

type
  PopoverMenuBar* = ref object of Widget
  PopoverMenuBar00* = object of Widget00

proc gtk_popover_menu_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PopoverMenuBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_popover_menu_bar_new_from_model(model: ptr gio.MenuModel00): ptr PopoverMenuBar00 {.
    importc, libprag.}

proc newPopoverMenuBarFromModel*(model: gio.MenuModel = nil): PopoverMenuBar =
  let gobj = gtk_popover_menu_bar_new_from_model(if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPopoverMenuBarFromModel*(tdesc: typedesc; model: gio.MenuModel = nil): tdesc =
  assert(result is PopoverMenuBar)
  let gobj = gtk_popover_menu_bar_new_from_model(if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopoverMenuBarFromModel*[T](result: var T; model: gio.MenuModel = nil) {.deprecated.} =
  assert(result is PopoverMenuBar)
  let gobj = gtk_popover_menu_bar_new_from_model(if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_menu_bar_add_child(self: ptr PopoverMenuBar00; child: ptr Widget00;
    id: cstring): gboolean {.
    importc, libprag.}

proc addChild*(self: PopoverMenuBar; child: Widget;
    id: cstring): bool =
  toBool(gtk_popover_menu_bar_add_child(cast[ptr PopoverMenuBar00](self.impl), cast[ptr Widget00](child.impl), id))

proc gtk_popover_menu_bar_get_menu_model(self: ptr PopoverMenuBar00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getMenuModel*(self: PopoverMenuBar): gio.MenuModel =
  let gobj = gtk_popover_menu_bar_get_menu_model(cast[ptr PopoverMenuBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menuModel*(self: PopoverMenuBar): gio.MenuModel =
  let gobj = gtk_popover_menu_bar_get_menu_model(cast[ptr PopoverMenuBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_menu_bar_remove_child(self: ptr PopoverMenuBar00; child: ptr Widget00): gboolean {.
    importc, libprag.}

proc removeChild*(self: PopoverMenuBar; child: Widget): bool =
  toBool(gtk_popover_menu_bar_remove_child(cast[ptr PopoverMenuBar00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_popover_menu_bar_set_menu_model(self: ptr PopoverMenuBar00; model: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setMenuModel*(self: PopoverMenuBar; model: gio.MenuModel = nil) =
  gtk_popover_menu_bar_set_menu_model(cast[ptr PopoverMenuBar00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc `menuModel=`*(self: PopoverMenuBar; model: gio.MenuModel = nil) =
  gtk_popover_menu_bar_set_menu_model(cast[ptr PopoverMenuBar00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

type
  Expander* = ref object of Widget
  Expander00* = object of Widget00

proc gtk_expander_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Expander()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Expander;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_expander_new(label: cstring): ptr Expander00 {.
    importc, libprag.}

proc newExpander*(label: cstring = nil): Expander =
  let gobj = gtk_expander_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newExpander*(tdesc: typedesc; label: cstring = nil): tdesc =
  assert(result is Expander)
  let gobj = gtk_expander_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initExpander*[T](result: var T; label: cstring = nil) {.deprecated.} =
  assert(result is Expander)
  let gobj = gtk_expander_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_new_with_mnemonic(label: cstring): ptr Expander00 {.
    importc, libprag.}

proc newExpanderWithMnemonic*(label: cstring = nil): Expander =
  let gobj = gtk_expander_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newExpanderWithMnemonic*(tdesc: typedesc; label: cstring = nil): tdesc =
  assert(result is Expander)
  let gobj = gtk_expander_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initExpanderWithMnemonic*[T](result: var T; label: cstring = nil) {.deprecated.} =
  assert(result is Expander)
  let gobj = gtk_expander_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_get_child(self: ptr Expander00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: Expander): Widget =
  let gobj = gtk_expander_get_child(cast[ptr Expander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Expander): Widget =
  let gobj = gtk_expander_get_child(cast[ptr Expander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_get_expanded(self: ptr Expander00): gboolean {.
    importc, libprag.}

proc getExpanded*(self: Expander): bool =
  toBool(gtk_expander_get_expanded(cast[ptr Expander00](self.impl)))

proc expanded*(self: Expander): bool =
  toBool(gtk_expander_get_expanded(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_label(self: ptr Expander00): cstring {.
    importc, libprag.}

proc getLabel*(self: Expander): string =
  let resul0 = gtk_expander_get_label(cast[ptr Expander00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc label*(self: Expander): string =
  let resul0 = gtk_expander_get_label(cast[ptr Expander00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_expander_get_label_widget(self: ptr Expander00): ptr Widget00 {.
    importc, libprag.}

proc getLabelWidget*(self: Expander): Widget =
  let gobj = gtk_expander_get_label_widget(cast[ptr Expander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: Expander): Widget =
  let gobj = gtk_expander_get_label_widget(cast[ptr Expander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_get_resize_toplevel(self: ptr Expander00): gboolean {.
    importc, libprag.}

proc getResizeToplevel*(self: Expander): bool =
  toBool(gtk_expander_get_resize_toplevel(cast[ptr Expander00](self.impl)))

proc resizeToplevel*(self: Expander): bool =
  toBool(gtk_expander_get_resize_toplevel(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_use_markup(self: ptr Expander00): gboolean {.
    importc, libprag.}

proc getUseMarkup*(self: Expander): bool =
  toBool(gtk_expander_get_use_markup(cast[ptr Expander00](self.impl)))

proc useMarkup*(self: Expander): bool =
  toBool(gtk_expander_get_use_markup(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_use_underline(self: ptr Expander00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: Expander): bool =
  toBool(gtk_expander_get_use_underline(cast[ptr Expander00](self.impl)))

proc useUnderline*(self: Expander): bool =
  toBool(gtk_expander_get_use_underline(cast[ptr Expander00](self.impl)))

proc gtk_expander_set_child(self: ptr Expander00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: Expander; child: Widget = nil) =
  gtk_expander_set_child(cast[ptr Expander00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: Expander; child: Widget = nil) =
  gtk_expander_set_child(cast[ptr Expander00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_expander_set_expanded(self: ptr Expander00; expanded: gboolean) {.
    importc, libprag.}

proc setExpanded*(self: Expander; expanded: bool = true) =
  gtk_expander_set_expanded(cast[ptr Expander00](self.impl), gboolean(expanded))

proc `expanded=`*(self: Expander; expanded: bool) =
  gtk_expander_set_expanded(cast[ptr Expander00](self.impl), gboolean(expanded))

proc gtk_expander_set_label(self: ptr Expander00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: Expander; label: cstring = nil) =
  gtk_expander_set_label(cast[ptr Expander00](self.impl), label)

proc `label=`*(self: Expander; label: cstring = nil) =
  gtk_expander_set_label(cast[ptr Expander00](self.impl), label)

proc gtk_expander_set_label_widget(self: ptr Expander00; labelWidget: ptr Widget00) {.
    importc, libprag.}

proc setLabelWidget*(self: Expander; labelWidget: Widget = nil) =
  gtk_expander_set_label_widget(cast[ptr Expander00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: Expander; labelWidget: Widget = nil) =
  gtk_expander_set_label_widget(cast[ptr Expander00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

proc gtk_expander_set_resize_toplevel(self: ptr Expander00; resizeToplevel: gboolean) {.
    importc, libprag.}

proc setResizeToplevel*(self: Expander; resizeToplevel: bool = true) =
  gtk_expander_set_resize_toplevel(cast[ptr Expander00](self.impl), gboolean(resizeToplevel))

proc `resizeToplevel=`*(self: Expander; resizeToplevel: bool) =
  gtk_expander_set_resize_toplevel(cast[ptr Expander00](self.impl), gboolean(resizeToplevel))

proc gtk_expander_set_use_markup(self: ptr Expander00; useMarkup: gboolean) {.
    importc, libprag.}

proc setUseMarkup*(self: Expander; useMarkup: bool = true) =
  gtk_expander_set_use_markup(cast[ptr Expander00](self.impl), gboolean(useMarkup))

proc `useMarkup=`*(self: Expander; useMarkup: bool) =
  gtk_expander_set_use_markup(cast[ptr Expander00](self.impl), gboolean(useMarkup))

proc gtk_expander_set_use_underline(self: ptr Expander00; useUnderline: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: Expander; useUnderline: bool = true) =
  gtk_expander_set_use_underline(cast[ptr Expander00](self.impl), gboolean(useUnderline))

proc `useUnderline=`*(self: Expander; useUnderline: bool) =
  gtk_expander_set_use_underline(cast[ptr Expander00](self.impl), gboolean(useUnderline))

type
  ProgressBar* = ref object of Widget
  ProgressBar00* = object of Widget00

proc gtk_progress_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ProgressBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_progress_bar_new(): ptr ProgressBar00 {.
    importc, libprag.}

proc newProgressBar*(): ProgressBar =
  let gobj = gtk_progress_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newProgressBar*(tdesc: typedesc): tdesc =
  assert(result is ProgressBar)
  let gobj = gtk_progress_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initProgressBar*[T](result: var T) {.deprecated.} =
  assert(result is ProgressBar)
  let gobj = gtk_progress_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_progress_bar_get_ellipsize(self: ptr ProgressBar00): pango.EllipsizeMode {.
    importc, libprag.}

proc getEllipsize*(self: ProgressBar): pango.EllipsizeMode =
  gtk_progress_bar_get_ellipsize(cast[ptr ProgressBar00](self.impl))

proc ellipsize*(self: ProgressBar): pango.EllipsizeMode =
  gtk_progress_bar_get_ellipsize(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_get_fraction(self: ptr ProgressBar00): cdouble {.
    importc, libprag.}

proc getFraction*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_fraction(cast[ptr ProgressBar00](self.impl))

proc fraction*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_fraction(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_get_inverted(self: ptr ProgressBar00): gboolean {.
    importc, libprag.}

proc getInverted*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_inverted(cast[ptr ProgressBar00](self.impl)))

proc inverted*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_inverted(cast[ptr ProgressBar00](self.impl)))

proc gtk_progress_bar_get_pulse_step(self: ptr ProgressBar00): cdouble {.
    importc, libprag.}

proc getPulseStep*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_pulse_step(cast[ptr ProgressBar00](self.impl))

proc pulseStep*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_pulse_step(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_get_show_text(self: ptr ProgressBar00): gboolean {.
    importc, libprag.}

proc getShowText*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_show_text(cast[ptr ProgressBar00](self.impl)))

proc showText*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_show_text(cast[ptr ProgressBar00](self.impl)))

proc gtk_progress_bar_get_text(self: ptr ProgressBar00): cstring {.
    importc, libprag.}

proc getText*(self: ProgressBar): string =
  let resul0 = gtk_progress_bar_get_text(cast[ptr ProgressBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc text*(self: ProgressBar): string =
  let resul0 = gtk_progress_bar_get_text(cast[ptr ProgressBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_progress_bar_pulse(self: ptr ProgressBar00) {.
    importc, libprag.}

proc pulse*(self: ProgressBar) =
  gtk_progress_bar_pulse(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_set_ellipsize(self: ptr ProgressBar00; mode: pango.EllipsizeMode) {.
    importc, libprag.}

proc setEllipsize*(self: ProgressBar; mode: pango.EllipsizeMode) =
  gtk_progress_bar_set_ellipsize(cast[ptr ProgressBar00](self.impl), mode)

proc `ellipsize=`*(self: ProgressBar; mode: pango.EllipsizeMode) =
  gtk_progress_bar_set_ellipsize(cast[ptr ProgressBar00](self.impl), mode)

proc gtk_progress_bar_set_fraction(self: ptr ProgressBar00; fraction: cdouble) {.
    importc, libprag.}

proc setFraction*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_fraction(cast[ptr ProgressBar00](self.impl), fraction)

proc `fraction=`*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_fraction(cast[ptr ProgressBar00](self.impl), fraction)

proc gtk_progress_bar_set_inverted(self: ptr ProgressBar00; inverted: gboolean) {.
    importc, libprag.}

proc setInverted*(self: ProgressBar; inverted: bool = true) =
  gtk_progress_bar_set_inverted(cast[ptr ProgressBar00](self.impl), gboolean(inverted))

proc `inverted=`*(self: ProgressBar; inverted: bool) =
  gtk_progress_bar_set_inverted(cast[ptr ProgressBar00](self.impl), gboolean(inverted))

proc gtk_progress_bar_set_pulse_step(self: ptr ProgressBar00; fraction: cdouble) {.
    importc, libprag.}

proc setPulseStep*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_pulse_step(cast[ptr ProgressBar00](self.impl), fraction)

proc `pulseStep=`*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_pulse_step(cast[ptr ProgressBar00](self.impl), fraction)

proc gtk_progress_bar_set_show_text(self: ptr ProgressBar00; showText: gboolean) {.
    importc, libprag.}

proc setShowText*(self: ProgressBar; showText: bool = true) =
  gtk_progress_bar_set_show_text(cast[ptr ProgressBar00](self.impl), gboolean(showText))

proc `showText=`*(self: ProgressBar; showText: bool) =
  gtk_progress_bar_set_show_text(cast[ptr ProgressBar00](self.impl), gboolean(showText))

proc gtk_progress_bar_set_text(self: ptr ProgressBar00; text: cstring) {.
    importc, libprag.}

proc setText*(self: ProgressBar; text: cstring = nil) =
  gtk_progress_bar_set_text(cast[ptr ProgressBar00](self.impl), text)

proc `text=`*(self: ProgressBar; text: cstring = nil) =
  gtk_progress_bar_set_text(cast[ptr ProgressBar00](self.impl), text)

type
  StackSidebar* = ref object of Widget
  StackSidebar00* = object of Widget00

proc gtk_stack_sidebar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StackSidebar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_stack_sidebar_new(): ptr StackSidebar00 {.
    importc, libprag.}

proc newStackSidebar*(): StackSidebar =
  let gobj = gtk_stack_sidebar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStackSidebar*(tdesc: typedesc): tdesc =
  assert(result is StackSidebar)
  let gobj = gtk_stack_sidebar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStackSidebar*[T](result: var T) {.deprecated.} =
  assert(result is StackSidebar)
  let gobj = gtk_stack_sidebar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_sidebar_get_stack(self: ptr StackSidebar00): ptr Stack00 {.
    importc, libprag.}

proc getStack*(self: StackSidebar): Stack =
  let gobj = gtk_stack_sidebar_get_stack(cast[ptr StackSidebar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc stack*(self: StackSidebar): Stack =
  let gobj = gtk_stack_sidebar_get_stack(cast[ptr StackSidebar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_sidebar_set_stack(self: ptr StackSidebar00; stack: ptr Stack00) {.
    importc, libprag.}

proc setStack*(self: StackSidebar; stack: Stack) =
  gtk_stack_sidebar_set_stack(cast[ptr StackSidebar00](self.impl), cast[ptr Stack00](stack.impl))

proc `stack=`*(self: StackSidebar; stack: Stack) =
  gtk_stack_sidebar_set_stack(cast[ptr StackSidebar00](self.impl), cast[ptr Stack00](stack.impl))

type
  CellView* = ref object of Widget
  CellView00* = object of Widget00

proc gtk_cell_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_view_new(): ptr CellView00 {.
    importc, libprag.}

proc newCellView*(): CellView {.deprecated.}  =
  let gobj = gtk_cell_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellView*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellView)
  let gobj = gtk_cell_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellView*[T](result: var T) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_markup(markup: cstring): ptr CellView00 {.
    importc, libprag.}

proc newCellViewWithMarkup*(markup: cstring): CellView {.deprecated.}  =
  let gobj = gtk_cell_view_new_with_markup(markup)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellViewWithMarkup*(tdesc: typedesc; markup: cstring): tdesc {.deprecated.}  =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_markup(markup)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithMarkup*[T](result: var T; markup: cstring) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_markup(markup)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_text(text: cstring): ptr CellView00 {.
    importc, libprag.}

proc newCellViewWithText*(text: cstring): CellView {.deprecated.}  =
  let gobj = gtk_cell_view_new_with_text(text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellViewWithText*(tdesc: typedesc; text: cstring): tdesc {.deprecated.}  =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_text(text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithText*[T](result: var T; text: cstring) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_text(text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_texture(texture: ptr gdk4.Texture00): ptr CellView00 {.
    importc, libprag.}

proc newCellViewWithTexture*(texture: gdk4.Texture): CellView {.deprecated.}  =
  let gobj = gtk_cell_view_new_with_texture(cast[ptr gdk4.Texture00](texture.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellViewWithTexture*(tdesc: typedesc; texture: gdk4.Texture): tdesc {.deprecated.}  =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_texture(cast[ptr gdk4.Texture00](texture.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithTexture*[T](result: var T; texture: gdk4.Texture) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_texture(cast[ptr gdk4.Texture00](texture.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_get_displayed_row(self: ptr CellView00): ptr TreePath00 {.
    importc, libprag.}

proc getDisplayedRow*(self: CellView): TreePath =
  let impl0 = gtk_cell_view_get_displayed_row(cast[ptr CellView00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc displayedRow*(self: CellView): TreePath =
  let impl0 = gtk_cell_view_get_displayed_row(cast[ptr CellView00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_cell_view_get_draw_sensitive(self: ptr CellView00): gboolean {.
    importc, libprag.}

proc getDrawSensitive*(self: CellView): bool =
  toBool(gtk_cell_view_get_draw_sensitive(cast[ptr CellView00](self.impl)))

proc drawSensitive*(self: CellView): bool =
  toBool(gtk_cell_view_get_draw_sensitive(cast[ptr CellView00](self.impl)))

proc gtk_cell_view_get_fit_model(self: ptr CellView00): gboolean {.
    importc, libprag.}

proc getFitModel*(self: CellView): bool =
  toBool(gtk_cell_view_get_fit_model(cast[ptr CellView00](self.impl)))

proc fitModel*(self: CellView): bool =
  toBool(gtk_cell_view_get_fit_model(cast[ptr CellView00](self.impl)))

proc gtk_cell_view_get_model(self: ptr CellView00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: CellView): TreeModel =
  let gobj = gtk_cell_view_get_model(cast[ptr CellView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: CellView): TreeModel =
  let gobj = gtk_cell_view_get_model(cast[ptr CellView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_set_displayed_row(self: ptr CellView00; path: ptr TreePath00) {.
    importc, libprag.}

proc setDisplayedRow*(self: CellView; path: TreePath = nil) =
  gtk_cell_view_set_displayed_row(cast[ptr CellView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl))

proc `displayedRow=`*(self: CellView; path: TreePath = nil) =
  gtk_cell_view_set_displayed_row(cast[ptr CellView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl))

proc gtk_cell_view_set_draw_sensitive(self: ptr CellView00; drawSensitive: gboolean) {.
    importc, libprag.}

proc setDrawSensitive*(self: CellView; drawSensitive: bool = true) =
  gtk_cell_view_set_draw_sensitive(cast[ptr CellView00](self.impl), gboolean(drawSensitive))

proc `drawSensitive=`*(self: CellView; drawSensitive: bool) =
  gtk_cell_view_set_draw_sensitive(cast[ptr CellView00](self.impl), gboolean(drawSensitive))

proc gtk_cell_view_set_fit_model(self: ptr CellView00; fitModel: gboolean) {.
    importc, libprag.}

proc setFitModel*(self: CellView; fitModel: bool = true) =
  gtk_cell_view_set_fit_model(cast[ptr CellView00](self.impl), gboolean(fitModel))

proc `fitModel=`*(self: CellView; fitModel: bool) =
  gtk_cell_view_set_fit_model(cast[ptr CellView00](self.impl), gboolean(fitModel))

proc gtk_cell_view_set_model(self: ptr CellView00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: CellView; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_cell_view_set_model(cast[ptr CellView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: CellView; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_cell_view_set_model(cast[ptr CellView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

type
  PrintUnixDialog* = ref object of Dialog
  PrintUnixDialog00* = object of Dialog00

proc gtk_print_unix_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintUnixDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_print_unix_dialog_new(title: cstring; parent: ptr Window00): ptr PrintUnixDialog00 {.
    importc, libprag.}

proc newPrintUnixDialog*(title: cstring = nil; parent: Window = nil): PrintUnixDialog =
  let gobj = gtk_print_unix_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintUnixDialog*(tdesc: typedesc; title: cstring = nil; parent: Window = nil): tdesc =
  assert(result is PrintUnixDialog)
  let gobj = gtk_print_unix_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintUnixDialog*[T](result: var T; title: cstring = nil; parent: Window = nil) {.deprecated.} =
  assert(result is PrintUnixDialog)
  let gobj = gtk_print_unix_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_unix_dialog_add_custom_tab(self: ptr PrintUnixDialog00; child: ptr Widget00;
    tabLabel: ptr Widget00) {.
    importc, libprag.}

proc addCustomTab*(self: PrintUnixDialog; child: Widget;
    tabLabel: Widget) =
  gtk_print_unix_dialog_add_custom_tab(cast[ptr PrintUnixDialog00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](tabLabel.impl))

proc gtk_print_unix_dialog_get_current_page(self: ptr PrintUnixDialog00): int32 {.
    importc, libprag.}

proc getCurrentPage*(self: PrintUnixDialog): int =
  int(gtk_print_unix_dialog_get_current_page(cast[ptr PrintUnixDialog00](self.impl)))

proc currentPage*(self: PrintUnixDialog): int =
  int(gtk_print_unix_dialog_get_current_page(cast[ptr PrintUnixDialog00](self.impl)))

proc gtk_print_unix_dialog_get_embed_page_setup(self: ptr PrintUnixDialog00): gboolean {.
    importc, libprag.}

proc getEmbedPageSetup*(self: PrintUnixDialog): bool =
  toBool(gtk_print_unix_dialog_get_embed_page_setup(cast[ptr PrintUnixDialog00](self.impl)))

proc embedPageSetup*(self: PrintUnixDialog): bool =
  toBool(gtk_print_unix_dialog_get_embed_page_setup(cast[ptr PrintUnixDialog00](self.impl)))

proc gtk_print_unix_dialog_get_has_selection(self: ptr PrintUnixDialog00): gboolean {.
    importc, libprag.}

proc getHasSelection*(self: PrintUnixDialog): bool =
  toBool(gtk_print_unix_dialog_get_has_selection(cast[ptr PrintUnixDialog00](self.impl)))

proc hasSelection*(self: PrintUnixDialog): bool =
  toBool(gtk_print_unix_dialog_get_has_selection(cast[ptr PrintUnixDialog00](self.impl)))

proc gtk_print_unix_dialog_get_page_setup_set(self: ptr PrintUnixDialog00): gboolean {.
    importc, libprag.}

proc getPageSetupSet*(self: PrintUnixDialog): bool =
  toBool(gtk_print_unix_dialog_get_page_setup_set(cast[ptr PrintUnixDialog00](self.impl)))

proc pageSetupSet*(self: PrintUnixDialog): bool =
  toBool(gtk_print_unix_dialog_get_page_setup_set(cast[ptr PrintUnixDialog00](self.impl)))

proc gtk_print_unix_dialog_get_support_selection(self: ptr PrintUnixDialog00): gboolean {.
    importc, libprag.}

proc getSupportSelection*(self: PrintUnixDialog): bool =
  toBool(gtk_print_unix_dialog_get_support_selection(cast[ptr PrintUnixDialog00](self.impl)))

proc supportSelection*(self: PrintUnixDialog): bool =
  toBool(gtk_print_unix_dialog_get_support_selection(cast[ptr PrintUnixDialog00](self.impl)))

proc gtk_print_unix_dialog_set_current_page(self: ptr PrintUnixDialog00;
    currentPage: int32) {.
    importc, libprag.}

proc setCurrentPage*(self: PrintUnixDialog; currentPage: int) =
  gtk_print_unix_dialog_set_current_page(cast[ptr PrintUnixDialog00](self.impl), int32(currentPage))

proc `currentPage=`*(self: PrintUnixDialog; currentPage: int) =
  gtk_print_unix_dialog_set_current_page(cast[ptr PrintUnixDialog00](self.impl), int32(currentPage))

proc gtk_print_unix_dialog_set_embed_page_setup(self: ptr PrintUnixDialog00;
    embed: gboolean) {.
    importc, libprag.}

proc setEmbedPageSetup*(self: PrintUnixDialog; embed: bool = true) =
  gtk_print_unix_dialog_set_embed_page_setup(cast[ptr PrintUnixDialog00](self.impl), gboolean(embed))

proc `embedPageSetup=`*(self: PrintUnixDialog; embed: bool) =
  gtk_print_unix_dialog_set_embed_page_setup(cast[ptr PrintUnixDialog00](self.impl), gboolean(embed))

proc gtk_print_unix_dialog_set_has_selection(self: ptr PrintUnixDialog00;
    hasSelection: gboolean) {.
    importc, libprag.}

proc setHasSelection*(self: PrintUnixDialog; hasSelection: bool = true) =
  gtk_print_unix_dialog_set_has_selection(cast[ptr PrintUnixDialog00](self.impl), gboolean(hasSelection))

proc `hasSelection=`*(self: PrintUnixDialog; hasSelection: bool) =
  gtk_print_unix_dialog_set_has_selection(cast[ptr PrintUnixDialog00](self.impl), gboolean(hasSelection))

proc gtk_print_unix_dialog_set_support_selection(self: ptr PrintUnixDialog00;
    supportSelection: gboolean) {.
    importc, libprag.}

proc setSupportSelection*(self: PrintUnixDialog; supportSelection: bool = true) =
  gtk_print_unix_dialog_set_support_selection(cast[ptr PrintUnixDialog00](self.impl), gboolean(supportSelection))

proc `supportSelection=`*(self: PrintUnixDialog; supportSelection: bool) =
  gtk_print_unix_dialog_set_support_selection(cast[ptr PrintUnixDialog00](self.impl), gboolean(supportSelection))

type
  GridView* = ref object of ListBase
  GridView00* = object of ListBase00

proc gtk_grid_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GridView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: GridView;  p: proc (self: ptr GridView00; position: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_grid_view_get_enable_rubberband(self: ptr GridView00): gboolean {.
    importc, libprag.}

proc getEnableRubberband*(self: GridView): bool =
  toBool(gtk_grid_view_get_enable_rubberband(cast[ptr GridView00](self.impl)))

proc enableRubberband*(self: GridView): bool =
  toBool(gtk_grid_view_get_enable_rubberband(cast[ptr GridView00](self.impl)))

proc gtk_grid_view_get_max_columns(self: ptr GridView00): uint32 {.
    importc, libprag.}

proc getMaxColumns*(self: GridView): int =
  int(gtk_grid_view_get_max_columns(cast[ptr GridView00](self.impl)))

proc maxColumns*(self: GridView): int =
  int(gtk_grid_view_get_max_columns(cast[ptr GridView00](self.impl)))

proc gtk_grid_view_get_min_columns(self: ptr GridView00): uint32 {.
    importc, libprag.}

proc getMinColumns*(self: GridView): int =
  int(gtk_grid_view_get_min_columns(cast[ptr GridView00](self.impl)))

proc minColumns*(self: GridView): int =
  int(gtk_grid_view_get_min_columns(cast[ptr GridView00](self.impl)))

proc gtk_grid_view_get_model(self: ptr GridView00): ptr SelectionModel00 {.
    importc, libprag.}

proc getModel*(self: GridView): SelectionModel =
  let gobj = gtk_grid_view_get_model(cast[ptr GridView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: GridView): SelectionModel =
  let gobj = gtk_grid_view_get_model(cast[ptr GridView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_view_get_single_click_activate(self: ptr GridView00): gboolean {.
    importc, libprag.}

proc getSingleClickActivate*(self: GridView): bool =
  toBool(gtk_grid_view_get_single_click_activate(cast[ptr GridView00](self.impl)))

proc singleClickActivate*(self: GridView): bool =
  toBool(gtk_grid_view_get_single_click_activate(cast[ptr GridView00](self.impl)))

proc gtk_grid_view_set_enable_rubberband(self: ptr GridView00; enableRubberband: gboolean) {.
    importc, libprag.}

proc setEnableRubberband*(self: GridView; enableRubberband: bool = true) =
  gtk_grid_view_set_enable_rubberband(cast[ptr GridView00](self.impl), gboolean(enableRubberband))

proc `enableRubberband=`*(self: GridView; enableRubberband: bool) =
  gtk_grid_view_set_enable_rubberband(cast[ptr GridView00](self.impl), gboolean(enableRubberband))

proc gtk_grid_view_set_max_columns(self: ptr GridView00; maxColumns: uint32) {.
    importc, libprag.}

proc setMaxColumns*(self: GridView; maxColumns: int) =
  gtk_grid_view_set_max_columns(cast[ptr GridView00](self.impl), uint32(maxColumns))

proc `maxColumns=`*(self: GridView; maxColumns: int) =
  gtk_grid_view_set_max_columns(cast[ptr GridView00](self.impl), uint32(maxColumns))

proc gtk_grid_view_set_min_columns(self: ptr GridView00; minColumns: uint32) {.
    importc, libprag.}

proc setMinColumns*(self: GridView; minColumns: int) =
  gtk_grid_view_set_min_columns(cast[ptr GridView00](self.impl), uint32(minColumns))

proc `minColumns=`*(self: GridView; minColumns: int) =
  gtk_grid_view_set_min_columns(cast[ptr GridView00](self.impl), uint32(minColumns))

proc gtk_grid_view_set_model(self: ptr GridView00; model: ptr SelectionModel00) {.
    importc, libprag.}

proc setModel*(self: GridView; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) =
  gtk_grid_view_set_model(cast[ptr GridView00](self.impl), if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))

proc `model=`*(self: GridView; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) =
  gtk_grid_view_set_model(cast[ptr GridView00](self.impl), if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))

proc gtk_grid_view_set_single_click_activate(self: ptr GridView00; singleClickActivate: gboolean) {.
    importc, libprag.}

proc setSingleClickActivate*(self: GridView; singleClickActivate: bool = true) =
  gtk_grid_view_set_single_click_activate(cast[ptr GridView00](self.impl), gboolean(singleClickActivate))

proc `singleClickActivate=`*(self: GridView; singleClickActivate: bool) =
  gtk_grid_view_set_single_click_activate(cast[ptr GridView00](self.impl), gboolean(singleClickActivate))

type
  EditableLabel* = ref object of Widget
  EditableLabel00* = object of Widget00

proc gtk_editable_label_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EditableLabel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_editable_label_new(str: cstring): ptr EditableLabel00 {.
    importc, libprag.}

proc newEditableLabel*(str: cstring): EditableLabel =
  let gobj = gtk_editable_label_new(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEditableLabel*(tdesc: typedesc; str: cstring): tdesc =
  assert(result is EditableLabel)
  let gobj = gtk_editable_label_new(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEditableLabel*[T](result: var T; str: cstring) {.deprecated.} =
  assert(result is EditableLabel)
  let gobj = gtk_editable_label_new(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_editable_label_get_editing(self: ptr EditableLabel00): gboolean {.
    importc, libprag.}

proc getEditing*(self: EditableLabel): bool =
  toBool(gtk_editable_label_get_editing(cast[ptr EditableLabel00](self.impl)))

proc editing*(self: EditableLabel): bool =
  toBool(gtk_editable_label_get_editing(cast[ptr EditableLabel00](self.impl)))

proc gtk_editable_label_start_editing(self: ptr EditableLabel00) {.
    importc, libprag.}

proc startEditing*(self: EditableLabel) =
  gtk_editable_label_start_editing(cast[ptr EditableLabel00](self.impl))

proc gtk_editable_label_stop_editing(self: ptr EditableLabel00; commit: gboolean) {.
    importc, libprag.}

proc stopEditing*(self: EditableLabel; commit: bool) =
  gtk_editable_label_stop_editing(cast[ptr EditableLabel00](self.impl), gboolean(commit))

type
  Label* = ref object of Widget
  Label00* = object of Widget00

proc gtk_label_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Label()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateCurrentLink*(self: Label;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-current-link", cast[GCallback](p), xdata, nil, cf)

proc scActivateLink*(self: Label;  p: proc (self: ptr Label00; uri: cstring; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-link", cast[GCallback](p), xdata, nil, cf)

proc scCopyClipboard*(self: Label;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "copy-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: Label;  p: proc (self: ptr Label00; step: MovementStep; count: int32; extendSelection: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc gtk_label_new(str: cstring): ptr Label00 {.
    importc, libprag.}

proc newLabel*(str: cstring = nil): Label =
  let gobj = gtk_label_new(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLabel*(tdesc: typedesc; str: cstring = nil): tdesc =
  assert(result is Label)
  let gobj = gtk_label_new(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLabel*[T](result: var T; str: cstring = nil) {.deprecated.} =
  assert(result is Label)
  let gobj = gtk_label_new(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_new_with_mnemonic(str: cstring): ptr Label00 {.
    importc, libprag.}

proc newLabelWithMnemonic*(str: cstring = nil): Label =
  let gobj = gtk_label_new_with_mnemonic(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLabelWithMnemonic*(tdesc: typedesc; str: cstring = nil): tdesc =
  assert(result is Label)
  let gobj = gtk_label_new_with_mnemonic(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLabelWithMnemonic*[T](result: var T; str: cstring = nil) {.deprecated.} =
  assert(result is Label)
  let gobj = gtk_label_new_with_mnemonic(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_attributes(self: ptr Label00): ptr pango.AttrList00 {.
    importc, libprag.}

proc getAttributes*(self: Label): pango.AttrList =
  let impl0 = gtk_label_get_attributes(cast[ptr Label00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc attributes*(self: Label): pango.AttrList =
  let impl0 = gtk_label_get_attributes(cast[ptr Label00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc gtk_label_get_current_uri(self: ptr Label00): cstring {.
    importc, libprag.}

proc getCurrentUri*(self: Label): string =
  let resul0 = gtk_label_get_current_uri(cast[ptr Label00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc currentUri*(self: Label): string =
  let resul0 = gtk_label_get_current_uri(cast[ptr Label00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_label_get_ellipsize(self: ptr Label00): pango.EllipsizeMode {.
    importc, libprag.}

proc getEllipsize*(self: Label): pango.EllipsizeMode =
  gtk_label_get_ellipsize(cast[ptr Label00](self.impl))

proc ellipsize*(self: Label): pango.EllipsizeMode =
  gtk_label_get_ellipsize(cast[ptr Label00](self.impl))

proc gtk_label_get_extra_menu(self: ptr Label00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getExtraMenu*(self: Label): gio.MenuModel =
  let gobj = gtk_label_get_extra_menu(cast[ptr Label00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc extraMenu*(self: Label): gio.MenuModel =
  let gobj = gtk_label_get_extra_menu(cast[ptr Label00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_label(self: ptr Label00): cstring {.
    importc, libprag.}

proc getLabel*(self: Label): string =
  result = $gtk_label_get_label(cast[ptr Label00](self.impl))

proc label*(self: Label): string =
  result = $gtk_label_get_label(cast[ptr Label00](self.impl))

proc gtk_label_get_layout(self: ptr Label00): ptr pango.Layout00 {.
    importc, libprag.}

proc getLayout*(self: Label): pango.Layout =
  let gobj = gtk_label_get_layout(cast[ptr Label00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layout*(self: Label): pango.Layout =
  let gobj = gtk_label_get_layout(cast[ptr Label00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_layout_offsets(self: ptr Label00; x: var int32; y: var int32) {.
    importc, libprag.}

proc getLayoutOffsets*(self: Label; x: var int = cast[var int](nil);
    y: var int = cast[var int](nil)) =
  var x_00: int32
  var y_00: int32
  gtk_label_get_layout_offsets(cast[ptr Label00](self.impl), x_00, y_00)
  if x.addr != nil:
    x = int(x_00)
  if y.addr != nil:
    y = int(y_00)

proc gtk_label_get_lines(self: ptr Label00): int32 {.
    importc, libprag.}

proc getLines*(self: Label): int =
  int(gtk_label_get_lines(cast[ptr Label00](self.impl)))

proc lines*(self: Label): int =
  int(gtk_label_get_lines(cast[ptr Label00](self.impl)))

proc gtk_label_get_max_width_chars(self: ptr Label00): int32 {.
    importc, libprag.}

proc getMaxWidthChars*(self: Label): int =
  int(gtk_label_get_max_width_chars(cast[ptr Label00](self.impl)))

proc maxWidthChars*(self: Label): int =
  int(gtk_label_get_max_width_chars(cast[ptr Label00](self.impl)))

proc gtk_label_get_mnemonic_keyval(self: ptr Label00): uint32 {.
    importc, libprag.}

proc getMnemonicKeyval*(self: Label): int =
  int(gtk_label_get_mnemonic_keyval(cast[ptr Label00](self.impl)))

proc mnemonicKeyval*(self: Label): int =
  int(gtk_label_get_mnemonic_keyval(cast[ptr Label00](self.impl)))

proc gtk_label_get_mnemonic_widget(self: ptr Label00): ptr Widget00 {.
    importc, libprag.}

proc getMnemonicWidget*(self: Label): Widget =
  let gobj = gtk_label_get_mnemonic_widget(cast[ptr Label00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc mnemonicWidget*(self: Label): Widget =
  let gobj = gtk_label_get_mnemonic_widget(cast[ptr Label00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_selectable(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getSelectable*(self: Label): bool =
  toBool(gtk_label_get_selectable(cast[ptr Label00](self.impl)))

proc selectable*(self: Label): bool =
  toBool(gtk_label_get_selectable(cast[ptr Label00](self.impl)))

proc gtk_label_get_selection_bounds(self: ptr Label00; start: var int32;
    `end`: var int32): gboolean {.
    importc, libprag.}

proc getSelectionBounds*(self: Label; start: var int = cast[var int](nil);
    `end`: var int = cast[var int](nil)): bool =
  var end_00: int32
  var start_00: int32
  result = toBool(gtk_label_get_selection_bounds(cast[ptr Label00](self.impl), start_00, end_00))
  if `end`.addr != nil:
    `end` = int(end_00)
  if start.addr != nil:
    start = int(start_00)

proc gtk_label_get_single_line_mode(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getSingleLineMode*(self: Label): bool =
  toBool(gtk_label_get_single_line_mode(cast[ptr Label00](self.impl)))

proc singleLineMode*(self: Label): bool =
  toBool(gtk_label_get_single_line_mode(cast[ptr Label00](self.impl)))

proc gtk_label_get_tabs(self: ptr Label00): ptr pango.TabArray00 {.
    importc, libprag.}

proc getTabs*(self: Label): pango.TabArray =
  let impl0 = gtk_label_get_tabs(cast[ptr Label00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = impl0

proc tabs*(self: Label): pango.TabArray =
  let impl0 = gtk_label_get_tabs(cast[ptr Label00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = impl0

proc gtk_label_get_text(self: ptr Label00): cstring {.
    importc, libprag.}

proc getText*(self: Label): string =
  result = $gtk_label_get_text(cast[ptr Label00](self.impl))

proc text*(self: Label): string =
  result = $gtk_label_get_text(cast[ptr Label00](self.impl))

proc gtk_label_get_use_markup(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getUseMarkup*(self: Label): bool =
  toBool(gtk_label_get_use_markup(cast[ptr Label00](self.impl)))

proc useMarkup*(self: Label): bool =
  toBool(gtk_label_get_use_markup(cast[ptr Label00](self.impl)))

proc gtk_label_get_use_underline(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: Label): bool =
  toBool(gtk_label_get_use_underline(cast[ptr Label00](self.impl)))

proc useUnderline*(self: Label): bool =
  toBool(gtk_label_get_use_underline(cast[ptr Label00](self.impl)))

proc gtk_label_get_width_chars(self: ptr Label00): int32 {.
    importc, libprag.}

proc getWidthChars*(self: Label): int =
  int(gtk_label_get_width_chars(cast[ptr Label00](self.impl)))

proc widthChars*(self: Label): int =
  int(gtk_label_get_width_chars(cast[ptr Label00](self.impl)))

proc gtk_label_get_wrap(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getWrap*(self: Label): bool =
  toBool(gtk_label_get_wrap(cast[ptr Label00](self.impl)))

proc wrap*(self: Label): bool =
  toBool(gtk_label_get_wrap(cast[ptr Label00](self.impl)))

proc gtk_label_get_wrap_mode(self: ptr Label00): pango.WrapMode {.
    importc, libprag.}

proc getWrapMode*(self: Label): pango.WrapMode =
  gtk_label_get_wrap_mode(cast[ptr Label00](self.impl))

proc wrapMode*(self: Label): pango.WrapMode =
  gtk_label_get_wrap_mode(cast[ptr Label00](self.impl))

proc gtk_label_get_xalign(self: ptr Label00): cfloat {.
    importc, libprag.}

proc getXalign*(self: Label): cfloat =
  gtk_label_get_xalign(cast[ptr Label00](self.impl))

proc xalign*(self: Label): cfloat =
  gtk_label_get_xalign(cast[ptr Label00](self.impl))

proc gtk_label_get_yalign(self: ptr Label00): cfloat {.
    importc, libprag.}

proc getYalign*(self: Label): cfloat =
  gtk_label_get_yalign(cast[ptr Label00](self.impl))

proc yalign*(self: Label): cfloat =
  gtk_label_get_yalign(cast[ptr Label00](self.impl))

proc gtk_label_select_region(self: ptr Label00; startOffset: int32; endOffset: int32) {.
    importc, libprag.}

proc selectRegion*(self: Label; startOffset: int; endOffset: int) =
  gtk_label_select_region(cast[ptr Label00](self.impl), int32(startOffset), int32(endOffset))

proc gtk_label_set_attributes(self: ptr Label00; attrs: ptr pango.AttrList00) {.
    importc, libprag.}

proc setAttributes*(self: Label; attrs: pango.AttrList = nil) =
  gtk_label_set_attributes(cast[ptr Label00](self.impl), if attrs.isNil: nil else: cast[ptr pango.AttrList00](attrs.impl))

proc `attributes=`*(self: Label; attrs: pango.AttrList = nil) =
  gtk_label_set_attributes(cast[ptr Label00](self.impl), if attrs.isNil: nil else: cast[ptr pango.AttrList00](attrs.impl))

proc gtk_label_set_ellipsize(self: ptr Label00; mode: pango.EllipsizeMode) {.
    importc, libprag.}

proc setEllipsize*(self: Label; mode: pango.EllipsizeMode) =
  gtk_label_set_ellipsize(cast[ptr Label00](self.impl), mode)

proc `ellipsize=`*(self: Label; mode: pango.EllipsizeMode) =
  gtk_label_set_ellipsize(cast[ptr Label00](self.impl), mode)

proc gtk_label_set_extra_menu(self: ptr Label00; model: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setExtraMenu*(self: Label; model: gio.MenuModel = nil) =
  gtk_label_set_extra_menu(cast[ptr Label00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc `extraMenu=`*(self: Label; model: gio.MenuModel = nil) =
  gtk_label_set_extra_menu(cast[ptr Label00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc gtk_label_set_label(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setLabel*(self: Label; str: cstring) =
  gtk_label_set_label(cast[ptr Label00](self.impl), str)

proc `label=`*(self: Label; str: cstring) =
  gtk_label_set_label(cast[ptr Label00](self.impl), str)

proc gtk_label_set_lines(self: ptr Label00; lines: int32) {.
    importc, libprag.}

proc setLines*(self: Label; lines: int) =
  gtk_label_set_lines(cast[ptr Label00](self.impl), int32(lines))

proc `lines=`*(self: Label; lines: int) =
  gtk_label_set_lines(cast[ptr Label00](self.impl), int32(lines))

proc gtk_label_set_markup(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setMarkup*(self: Label; str: cstring) =
  gtk_label_set_markup(cast[ptr Label00](self.impl), str)

proc `markup=`*(self: Label; str: cstring) =
  gtk_label_set_markup(cast[ptr Label00](self.impl), str)

proc gtk_label_set_markup_with_mnemonic(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setMarkupWithMnemonic*(self: Label; str: cstring) =
  gtk_label_set_markup_with_mnemonic(cast[ptr Label00](self.impl), str)

proc `markupWithMnemonic=`*(self: Label; str: cstring) =
  gtk_label_set_markup_with_mnemonic(cast[ptr Label00](self.impl), str)

proc gtk_label_set_max_width_chars(self: ptr Label00; nChars: int32) {.
    importc, libprag.}

proc setMaxWidthChars*(self: Label; nChars: int) =
  gtk_label_set_max_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc `maxWidthChars=`*(self: Label; nChars: int) =
  gtk_label_set_max_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc gtk_label_set_mnemonic_widget(self: ptr Label00; widget: ptr Widget00) {.
    importc, libprag.}

proc setMnemonicWidget*(self: Label; widget: Widget = nil) =
  gtk_label_set_mnemonic_widget(cast[ptr Label00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `mnemonicWidget=`*(self: Label; widget: Widget = nil) =
  gtk_label_set_mnemonic_widget(cast[ptr Label00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_label_set_selectable(self: ptr Label00; setting: gboolean) {.
    importc, libprag.}

proc setSelectable*(self: Label; setting: bool = true) =
  gtk_label_set_selectable(cast[ptr Label00](self.impl), gboolean(setting))

proc `selectable=`*(self: Label; setting: bool) =
  gtk_label_set_selectable(cast[ptr Label00](self.impl), gboolean(setting))

proc gtk_label_set_single_line_mode(self: ptr Label00; singleLineMode: gboolean) {.
    importc, libprag.}

proc setSingleLineMode*(self: Label; singleLineMode: bool = true) =
  gtk_label_set_single_line_mode(cast[ptr Label00](self.impl), gboolean(singleLineMode))

proc `singleLineMode=`*(self: Label; singleLineMode: bool) =
  gtk_label_set_single_line_mode(cast[ptr Label00](self.impl), gboolean(singleLineMode))

proc gtk_label_set_tabs(self: ptr Label00; tabs: ptr pango.TabArray00) {.
    importc, libprag.}

proc setTabs*(self: Label; tabs: pango.TabArray = nil) =
  gtk_label_set_tabs(cast[ptr Label00](self.impl), if tabs.isNil: nil else: cast[ptr pango.TabArray00](tabs.impl))

proc `tabs=`*(self: Label; tabs: pango.TabArray = nil) =
  gtk_label_set_tabs(cast[ptr Label00](self.impl), if tabs.isNil: nil else: cast[ptr pango.TabArray00](tabs.impl))

proc gtk_label_set_text(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setText*(self: Label; str: cstring) =
  gtk_label_set_text(cast[ptr Label00](self.impl), str)

proc `text=`*(self: Label; str: cstring) =
  gtk_label_set_text(cast[ptr Label00](self.impl), str)

proc gtk_label_set_text_with_mnemonic(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setTextWithMnemonic*(self: Label; str: cstring) =
  gtk_label_set_text_with_mnemonic(cast[ptr Label00](self.impl), str)

proc `textWithMnemonic=`*(self: Label; str: cstring) =
  gtk_label_set_text_with_mnemonic(cast[ptr Label00](self.impl), str)

proc gtk_label_set_use_markup(self: ptr Label00; setting: gboolean) {.
    importc, libprag.}

proc setUseMarkup*(self: Label; setting: bool = true) =
  gtk_label_set_use_markup(cast[ptr Label00](self.impl), gboolean(setting))

proc `useMarkup=`*(self: Label; setting: bool) =
  gtk_label_set_use_markup(cast[ptr Label00](self.impl), gboolean(setting))

proc gtk_label_set_use_underline(self: ptr Label00; setting: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: Label; setting: bool = true) =
  gtk_label_set_use_underline(cast[ptr Label00](self.impl), gboolean(setting))

proc `useUnderline=`*(self: Label; setting: bool) =
  gtk_label_set_use_underline(cast[ptr Label00](self.impl), gboolean(setting))

proc gtk_label_set_width_chars(self: ptr Label00; nChars: int32) {.
    importc, libprag.}

proc setWidthChars*(self: Label; nChars: int) =
  gtk_label_set_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc `widthChars=`*(self: Label; nChars: int) =
  gtk_label_set_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc gtk_label_set_wrap(self: ptr Label00; wrap: gboolean) {.
    importc, libprag.}

proc setWrap*(self: Label; wrap: bool = true) =
  gtk_label_set_wrap(cast[ptr Label00](self.impl), gboolean(wrap))

proc `wrap=`*(self: Label; wrap: bool) =
  gtk_label_set_wrap(cast[ptr Label00](self.impl), gboolean(wrap))

proc gtk_label_set_wrap_mode(self: ptr Label00; wrapMode: pango.WrapMode) {.
    importc, libprag.}

proc setWrapMode*(self: Label; wrapMode: pango.WrapMode) =
  gtk_label_set_wrap_mode(cast[ptr Label00](self.impl), wrapMode)

proc `wrapMode=`*(self: Label; wrapMode: pango.WrapMode) =
  gtk_label_set_wrap_mode(cast[ptr Label00](self.impl), wrapMode)

proc gtk_label_set_xalign(self: ptr Label00; xalign: cfloat) {.
    importc, libprag.}

proc setXalign*(self: Label; xalign: cfloat) =
  gtk_label_set_xalign(cast[ptr Label00](self.impl), xalign)

proc `xalign=`*(self: Label; xalign: cfloat) =
  gtk_label_set_xalign(cast[ptr Label00](self.impl), xalign)

proc gtk_label_set_yalign(self: ptr Label00; yalign: cfloat) {.
    importc, libprag.}

proc setYalign*(self: Label; yalign: cfloat) =
  gtk_label_set_yalign(cast[ptr Label00](self.impl), yalign)

proc `yalign=`*(self: Label; yalign: cfloat) =
  gtk_label_set_yalign(cast[ptr Label00](self.impl), yalign)

type
  Spinner* = ref object of Widget
  Spinner00* = object of Widget00

proc gtk_spinner_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Spinner()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_spinner_new(): ptr Spinner00 {.
    importc, libprag.}

proc newSpinner*(): Spinner =
  let gobj = gtk_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSpinner*(tdesc: typedesc): tdesc =
  assert(result is Spinner)
  let gobj = gtk_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSpinner*[T](result: var T) {.deprecated.} =
  assert(result is Spinner)
  let gobj = gtk_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spinner_get_spinning(self: ptr Spinner00): gboolean {.
    importc, libprag.}

proc getSpinning*(self: Spinner): bool =
  toBool(gtk_spinner_get_spinning(cast[ptr Spinner00](self.impl)))

proc spinning*(self: Spinner): bool =
  toBool(gtk_spinner_get_spinning(cast[ptr Spinner00](self.impl)))

proc gtk_spinner_set_spinning(self: ptr Spinner00; spinning: gboolean) {.
    importc, libprag.}

proc setSpinning*(self: Spinner; spinning: bool = true) =
  gtk_spinner_set_spinning(cast[ptr Spinner00](self.impl), gboolean(spinning))

proc `spinning=`*(self: Spinner; spinning: bool) =
  gtk_spinner_set_spinning(cast[ptr Spinner00](self.impl), gboolean(spinning))

proc gtk_spinner_start(self: ptr Spinner00) {.
    importc, libprag.}

proc start*(self: Spinner) =
  gtk_spinner_start(cast[ptr Spinner00](self.impl))

proc gtk_spinner_stop(self: ptr Spinner00) {.
    importc, libprag.}

proc stop*(self: Spinner) =
  gtk_spinner_stop(cast[ptr Spinner00](self.impl))

type
  ToggleButton* = ref object of Button
  ToggleButton00* = object of Button00

proc gtk_toggle_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToggleButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scToggled*(self: ToggleButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cf)

proc gtk_toggle_button_new(): ptr ToggleButton00 {.
    importc, libprag.}

proc newToggleButton*(): ToggleButton =
  let gobj = gtk_toggle_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToggleButton*(tdesc: typedesc): tdesc =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleButton*[T](result: var T) {.deprecated.} =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_button_new_with_label(label: cstring): ptr ToggleButton00 {.
    importc, libprag.}

proc newToggleButton*(label: cstring): ToggleButton =
  let gobj = gtk_toggle_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToggleButton*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleButton*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_button_new_with_mnemonic(label: cstring): ptr ToggleButton00 {.
    importc, libprag.}

proc newToggleButtonWithMnemonic*(label: cstring): ToggleButton =
  let gobj = gtk_toggle_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToggleButtonWithMnemonic*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleButtonWithMnemonic*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_button_get_active(self: ptr ToggleButton00): gboolean {.
    importc, libprag.}

proc getActive*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_active(cast[ptr ToggleButton00](self.impl)))

proc active*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_active(cast[ptr ToggleButton00](self.impl)))

proc gtk_toggle_button_set_active(self: ptr ToggleButton00; isActive: gboolean) {.
    importc, libprag.}

proc setActive*(self: ToggleButton; isActive: bool = true) =
  gtk_toggle_button_set_active(cast[ptr ToggleButton00](self.impl), gboolean(isActive))

proc `active=`*(self: ToggleButton; isActive: bool) =
  gtk_toggle_button_set_active(cast[ptr ToggleButton00](self.impl), gboolean(isActive))

proc gtk_toggle_button_set_group(self: ptr ToggleButton00; group: ptr ToggleButton00) {.
    importc, libprag.}

proc setGroup*(self: ToggleButton; group: ToggleButton = nil) =
  gtk_toggle_button_set_group(cast[ptr ToggleButton00](self.impl), if group.isNil: nil else: cast[ptr ToggleButton00](group.impl))

proc `group=`*(self: ToggleButton; group: ToggleButton = nil) =
  gtk_toggle_button_set_group(cast[ptr ToggleButton00](self.impl), if group.isNil: nil else: cast[ptr ToggleButton00](group.impl))

proc gtk_toggle_button_toggled(self: ptr ToggleButton00) {.
    importc, libprag.}

proc toggled*(self: ToggleButton) =
  gtk_toggle_button_toggled(cast[ptr ToggleButton00](self.impl))

type
  SearchBar* = ref object of Widget
  SearchBar00* = object of Widget00

proc gtk_search_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SearchBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_search_bar_new(): ptr SearchBar00 {.
    importc, libprag.}

proc newSearchBar*(): SearchBar =
  let gobj = gtk_search_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSearchBar*(tdesc: typedesc): tdesc =
  assert(result is SearchBar)
  let gobj = gtk_search_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSearchBar*[T](result: var T) {.deprecated.} =
  assert(result is SearchBar)
  let gobj = gtk_search_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_search_bar_get_child(self: ptr SearchBar00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: SearchBar): Widget =
  let gobj = gtk_search_bar_get_child(cast[ptr SearchBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: SearchBar): Widget =
  let gobj = gtk_search_bar_get_child(cast[ptr SearchBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_search_bar_get_key_capture_widget(self: ptr SearchBar00): ptr Widget00 {.
    importc, libprag.}

proc getKeyCaptureWidget*(self: SearchBar): Widget =
  let gobj = gtk_search_bar_get_key_capture_widget(cast[ptr SearchBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc keyCaptureWidget*(self: SearchBar): Widget =
  let gobj = gtk_search_bar_get_key_capture_widget(cast[ptr SearchBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_search_bar_get_search_mode(self: ptr SearchBar00): gboolean {.
    importc, libprag.}

proc getSearchMode*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_search_mode(cast[ptr SearchBar00](self.impl)))

proc searchMode*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_search_mode(cast[ptr SearchBar00](self.impl)))

proc gtk_search_bar_get_show_close_button(self: ptr SearchBar00): gboolean {.
    importc, libprag.}

proc getShowCloseButton*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_show_close_button(cast[ptr SearchBar00](self.impl)))

proc showCloseButton*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_show_close_button(cast[ptr SearchBar00](self.impl)))

proc gtk_search_bar_set_child(self: ptr SearchBar00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: SearchBar; child: Widget = nil) =
  gtk_search_bar_set_child(cast[ptr SearchBar00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: SearchBar; child: Widget = nil) =
  gtk_search_bar_set_child(cast[ptr SearchBar00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_search_bar_set_key_capture_widget(self: ptr SearchBar00; widget: ptr Widget00) {.
    importc, libprag.}

proc setKeyCaptureWidget*(self: SearchBar; widget: Widget = nil) =
  gtk_search_bar_set_key_capture_widget(cast[ptr SearchBar00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `keyCaptureWidget=`*(self: SearchBar; widget: Widget = nil) =
  gtk_search_bar_set_key_capture_widget(cast[ptr SearchBar00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_search_bar_set_search_mode(self: ptr SearchBar00; searchMode: gboolean) {.
    importc, libprag.}

proc setSearchMode*(self: SearchBar; searchMode: bool = true) =
  gtk_search_bar_set_search_mode(cast[ptr SearchBar00](self.impl), gboolean(searchMode))

proc `searchMode=`*(self: SearchBar; searchMode: bool) =
  gtk_search_bar_set_search_mode(cast[ptr SearchBar00](self.impl), gboolean(searchMode))

proc gtk_search_bar_set_show_close_button(self: ptr SearchBar00; visible: gboolean) {.
    importc, libprag.}

proc setShowCloseButton*(self: SearchBar; visible: bool = true) =
  gtk_search_bar_set_show_close_button(cast[ptr SearchBar00](self.impl), gboolean(visible))

proc `showCloseButton=`*(self: SearchBar; visible: bool) =
  gtk_search_bar_set_show_close_button(cast[ptr SearchBar00](self.impl), gboolean(visible))

type
  ApplicationWindow* = ref object of Window
  ApplicationWindow00* = object of Window00

proc gtk_application_window_get_type*(): GType {.importc, libprag.}

proc gtk_application_window_new(application: ptr Application00): ptr ApplicationWindow00 {.
    importc, libprag.}

proc newApplicationWindow*(application: Application): ApplicationWindow =
  let gobj = gtk_application_window_new(cast[ptr Application00](application.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newApplicationWindow*(tdesc: typedesc; application: Application): tdesc =
  assert(result is ApplicationWindow)
  let gobj = gtk_application_window_new(cast[ptr Application00](application.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initApplicationWindow*[T](result: var T; application: Application) {.deprecated.} =
  assert(result is ApplicationWindow)
  let gobj = gtk_application_window_new(cast[ptr Application00](application.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_window_get_help_overlay(self: ptr ApplicationWindow00): ptr ShortcutsWindow00 {.
    importc, libprag.}

proc getHelpOverlay*(self: ApplicationWindow): ShortcutsWindow =
  let gobj = gtk_application_window_get_help_overlay(cast[ptr ApplicationWindow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc helpOverlay*(self: ApplicationWindow): ShortcutsWindow =
  let gobj = gtk_application_window_get_help_overlay(cast[ptr ApplicationWindow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_window_get_id(self: ptr ApplicationWindow00): uint32 {.
    importc, libprag.}

proc getId*(self: ApplicationWindow): int =
  int(gtk_application_window_get_id(cast[ptr ApplicationWindow00](self.impl)))

proc id*(self: ApplicationWindow): int =
  int(gtk_application_window_get_id(cast[ptr ApplicationWindow00](self.impl)))

proc gtk_application_window_get_show_menubar(self: ptr ApplicationWindow00): gboolean {.
    importc, libprag.}

proc getShowMenubar*(self: ApplicationWindow): bool =
  toBool(gtk_application_window_get_show_menubar(cast[ptr ApplicationWindow00](self.impl)))

proc showMenubar*(self: ApplicationWindow): bool =
  toBool(gtk_application_window_get_show_menubar(cast[ptr ApplicationWindow00](self.impl)))

proc gtk_application_window_set_help_overlay(self: ptr ApplicationWindow00;
    helpOverlay: ptr ShortcutsWindow00) {.
    importc, libprag.}

proc setHelpOverlay*(self: ApplicationWindow; helpOverlay: ShortcutsWindow = nil) =
  gtk_application_window_set_help_overlay(cast[ptr ApplicationWindow00](self.impl), if helpOverlay.isNil: nil else: cast[ptr ShortcutsWindow00](helpOverlay.impl))

proc `helpOverlay=`*(self: ApplicationWindow; helpOverlay: ShortcutsWindow = nil) =
  gtk_application_window_set_help_overlay(cast[ptr ApplicationWindow00](self.impl), if helpOverlay.isNil: nil else: cast[ptr ShortcutsWindow00](helpOverlay.impl))

proc gtk_application_window_set_show_menubar(self: ptr ApplicationWindow00;
    showMenubar: gboolean) {.
    importc, libprag.}

proc setShowMenubar*(self: ApplicationWindow; showMenubar: bool = true) =
  gtk_application_window_set_show_menubar(cast[ptr ApplicationWindow00](self.impl), gboolean(showMenubar))

proc `showMenubar=`*(self: ApplicationWindow; showMenubar: bool) =
  gtk_application_window_set_show_menubar(cast[ptr ApplicationWindow00](self.impl), gboolean(showMenubar))

type
  CheckButton* = ref object of Widget
  CheckButton00* = object of Widget00

proc gtk_check_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CheckButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: CheckButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scToggled*(self: CheckButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cf)

proc gtk_check_button_new(): ptr CheckButton00 {.
    importc, libprag.}

proc newCheckButton*(): CheckButton =
  let gobj = gtk_check_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCheckButton*(tdesc: typedesc): tdesc =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckButton*[T](result: var T) {.deprecated.} =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_button_new_with_label(label: cstring): ptr CheckButton00 {.
    importc, libprag.}

proc newCheckButton*(label: cstring): CheckButton =
  let gobj = gtk_check_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCheckButton*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckButton*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_button_new_with_mnemonic(label: cstring): ptr CheckButton00 {.
    importc, libprag.}

proc newCheckButtonWithMnemonic*(label: cstring = nil): CheckButton =
  let gobj = gtk_check_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCheckButtonWithMnemonic*(tdesc: typedesc; label: cstring = nil): tdesc =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckButtonWithMnemonic*[T](result: var T; label: cstring = nil) {.deprecated.} =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_button_get_active(self: ptr CheckButton00): gboolean {.
    importc, libprag.}

proc getActive*(self: CheckButton): bool =
  toBool(gtk_check_button_get_active(cast[ptr CheckButton00](self.impl)))

proc active*(self: CheckButton): bool =
  toBool(gtk_check_button_get_active(cast[ptr CheckButton00](self.impl)))

proc gtk_check_button_get_child(self: ptr CheckButton00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: CheckButton): Widget =
  let gobj = gtk_check_button_get_child(cast[ptr CheckButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: CheckButton): Widget =
  let gobj = gtk_check_button_get_child(cast[ptr CheckButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_button_get_inconsistent(self: ptr CheckButton00): gboolean {.
    importc, libprag.}

proc getInconsistent*(self: CheckButton): bool =
  toBool(gtk_check_button_get_inconsistent(cast[ptr CheckButton00](self.impl)))

proc inconsistent*(self: CheckButton): bool =
  toBool(gtk_check_button_get_inconsistent(cast[ptr CheckButton00](self.impl)))

proc gtk_check_button_get_label(self: ptr CheckButton00): cstring {.
    importc, libprag.}

proc getLabel*(self: CheckButton): string =
  let resul0 = gtk_check_button_get_label(cast[ptr CheckButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc label*(self: CheckButton): string =
  let resul0 = gtk_check_button_get_label(cast[ptr CheckButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_check_button_get_use_underline(self: ptr CheckButton00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: CheckButton): bool =
  toBool(gtk_check_button_get_use_underline(cast[ptr CheckButton00](self.impl)))

proc useUnderline*(self: CheckButton): bool =
  toBool(gtk_check_button_get_use_underline(cast[ptr CheckButton00](self.impl)))

proc gtk_check_button_set_active(self: ptr CheckButton00; setting: gboolean) {.
    importc, libprag.}

proc setActive*(self: CheckButton; setting: bool = true) =
  gtk_check_button_set_active(cast[ptr CheckButton00](self.impl), gboolean(setting))

proc `active=`*(self: CheckButton; setting: bool) =
  gtk_check_button_set_active(cast[ptr CheckButton00](self.impl), gboolean(setting))

proc gtk_check_button_set_child(self: ptr CheckButton00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: CheckButton; child: Widget = nil) =
  gtk_check_button_set_child(cast[ptr CheckButton00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: CheckButton; child: Widget = nil) =
  gtk_check_button_set_child(cast[ptr CheckButton00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_check_button_set_group(self: ptr CheckButton00; group: ptr CheckButton00) {.
    importc, libprag.}

proc setGroup*(self: CheckButton; group: CheckButton = nil) =
  gtk_check_button_set_group(cast[ptr CheckButton00](self.impl), if group.isNil: nil else: cast[ptr CheckButton00](group.impl))

proc `group=`*(self: CheckButton; group: CheckButton = nil) =
  gtk_check_button_set_group(cast[ptr CheckButton00](self.impl), if group.isNil: nil else: cast[ptr CheckButton00](group.impl))

proc gtk_check_button_set_inconsistent(self: ptr CheckButton00; inconsistent: gboolean) {.
    importc, libprag.}

proc setInconsistent*(self: CheckButton; inconsistent: bool = true) =
  gtk_check_button_set_inconsistent(cast[ptr CheckButton00](self.impl), gboolean(inconsistent))

proc `inconsistent=`*(self: CheckButton; inconsistent: bool) =
  gtk_check_button_set_inconsistent(cast[ptr CheckButton00](self.impl), gboolean(inconsistent))

proc gtk_check_button_set_label(self: ptr CheckButton00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: CheckButton; label: cstring = nil) =
  gtk_check_button_set_label(cast[ptr CheckButton00](self.impl), label)

proc `label=`*(self: CheckButton; label: cstring = nil) =
  gtk_check_button_set_label(cast[ptr CheckButton00](self.impl), label)

proc gtk_check_button_set_use_underline(self: ptr CheckButton00; setting: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: CheckButton; setting: bool = true) =
  gtk_check_button_set_use_underline(cast[ptr CheckButton00](self.impl), gboolean(setting))

proc `useUnderline=`*(self: CheckButton; setting: bool) =
  gtk_check_button_set_use_underline(cast[ptr CheckButton00](self.impl), gboolean(setting))

type
  FontDialogButton* = ref object of Widget
  FontDialogButton00* = object of Widget00

proc gtk_font_dialog_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontDialogButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: FontDialogButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_font_dialog_button_get_font_desc(self: ptr FontDialogButton00): ptr pango.FontDescription00 {.
    importc, libprag.}

proc getFontDesc*(self: FontDialogButton): pango.FontDescription =
  let impl0 = gtk_font_dialog_button_get_font_desc(cast[ptr FontDialogButton00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoFontDescription)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_font_description_get_type(), impl0))

proc fontDesc*(self: FontDialogButton): pango.FontDescription =
  let impl0 = gtk_font_dialog_button_get_font_desc(cast[ptr FontDialogButton00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoFontDescription)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_font_description_get_type(), impl0))

proc gtk_font_dialog_button_get_font_features(self: ptr FontDialogButton00): cstring {.
    importc, libprag.}

proc getFontFeatures*(self: FontDialogButton): string =
  let resul0 = gtk_font_dialog_button_get_font_features(cast[ptr FontDialogButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc fontFeatures*(self: FontDialogButton): string =
  let resul0 = gtk_font_dialog_button_get_font_features(cast[ptr FontDialogButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_font_dialog_button_get_language(self: ptr FontDialogButton00): ptr pango.Language00 {.
    importc, libprag.}

proc getLanguage*(self: FontDialogButton): pango.Language =
  let impl0 = gtk_font_dialog_button_get_language(cast[ptr FontDialogButton00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = impl0

proc language*(self: FontDialogButton): pango.Language =
  let impl0 = gtk_font_dialog_button_get_language(cast[ptr FontDialogButton00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = impl0

proc gtk_font_dialog_button_get_use_font(self: ptr FontDialogButton00): gboolean {.
    importc, libprag.}

proc getUseFont*(self: FontDialogButton): bool =
  toBool(gtk_font_dialog_button_get_use_font(cast[ptr FontDialogButton00](self.impl)))

proc useFont*(self: FontDialogButton): bool =
  toBool(gtk_font_dialog_button_get_use_font(cast[ptr FontDialogButton00](self.impl)))

proc gtk_font_dialog_button_get_use_size(self: ptr FontDialogButton00): gboolean {.
    importc, libprag.}

proc getUseSize*(self: FontDialogButton): bool =
  toBool(gtk_font_dialog_button_get_use_size(cast[ptr FontDialogButton00](self.impl)))

proc useSize*(self: FontDialogButton): bool =
  toBool(gtk_font_dialog_button_get_use_size(cast[ptr FontDialogButton00](self.impl)))

proc gtk_font_dialog_button_set_font_desc(self: ptr FontDialogButton00; fontDesc: ptr pango.FontDescription00) {.
    importc, libprag.}

proc setFontDesc*(self: FontDialogButton; fontDesc: pango.FontDescription) =
  gtk_font_dialog_button_set_font_desc(cast[ptr FontDialogButton00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc `fontDesc=`*(self: FontDialogButton; fontDesc: pango.FontDescription) =
  gtk_font_dialog_button_set_font_desc(cast[ptr FontDialogButton00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc gtk_font_dialog_button_set_font_features(self: ptr FontDialogButton00;
    fontFeatures: cstring) {.
    importc, libprag.}

proc setFontFeatures*(self: FontDialogButton; fontFeatures: cstring = nil) =
  gtk_font_dialog_button_set_font_features(cast[ptr FontDialogButton00](self.impl), fontFeatures)

proc `fontFeatures=`*(self: FontDialogButton; fontFeatures: cstring = nil) =
  gtk_font_dialog_button_set_font_features(cast[ptr FontDialogButton00](self.impl), fontFeatures)

proc gtk_font_dialog_button_set_language(self: ptr FontDialogButton00; language: ptr pango.Language00) {.
    importc, libprag.}

proc setLanguage*(self: FontDialogButton; language: pango.Language = nil) =
  gtk_font_dialog_button_set_language(cast[ptr FontDialogButton00](self.impl), if language.isNil: nil else: cast[ptr pango.Language00](language.impl))

proc `language=`*(self: FontDialogButton; language: pango.Language = nil) =
  gtk_font_dialog_button_set_language(cast[ptr FontDialogButton00](self.impl), if language.isNil: nil else: cast[ptr pango.Language00](language.impl))

proc gtk_font_dialog_button_set_use_font(self: ptr FontDialogButton00; useFont: gboolean) {.
    importc, libprag.}

proc setUseFont*(self: FontDialogButton; useFont: bool = true) =
  gtk_font_dialog_button_set_use_font(cast[ptr FontDialogButton00](self.impl), gboolean(useFont))

proc `useFont=`*(self: FontDialogButton; useFont: bool) =
  gtk_font_dialog_button_set_use_font(cast[ptr FontDialogButton00](self.impl), gboolean(useFont))

proc gtk_font_dialog_button_set_use_size(self: ptr FontDialogButton00; useSize: gboolean) {.
    importc, libprag.}

proc setUseSize*(self: FontDialogButton; useSize: bool = true) =
  gtk_font_dialog_button_set_use_size(cast[ptr FontDialogButton00](self.impl), gboolean(useSize))

proc `useSize=`*(self: FontDialogButton; useSize: bool) =
  gtk_font_dialog_button_set_use_size(cast[ptr FontDialogButton00](self.impl), gboolean(useSize))

type
  ColumnView* = ref object of Widget
  ColumnView00* = object of Widget00

proc gtk_column_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColumnView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: ColumnView;  p: proc (self: ptr ColumnView00; position: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_column_view_new(model: ptr SelectionModel00): ptr ColumnView00 {.
    importc, libprag.}

proc newColumnView*(model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)): ColumnView =
  let gobj = gtk_column_view_new(if model.isNil: nil else: cast[ptr SelectionModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColumnView*(tdesc: typedesc; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)): tdesc =
  assert(result is ColumnView)
  let gobj = gtk_column_view_new(if model.isNil: nil else: cast[ptr SelectionModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColumnView*[T](result: var T; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) {.deprecated.} =
  assert(result is ColumnView)
  let gobj = gtk_column_view_new(if model.isNil: nil else: cast[ptr SelectionModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_get_columns(self: ptr ColumnView00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getColumns*(self: ColumnView): gio.ListModel =
  let gobj = gtk_column_view_get_columns(cast[ptr ColumnView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc columns*(self: ColumnView): gio.ListModel =
  let gobj = gtk_column_view_get_columns(cast[ptr ColumnView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_get_enable_rubberband(self: ptr ColumnView00): gboolean {.
    importc, libprag.}

proc getEnableRubberband*(self: ColumnView): bool =
  toBool(gtk_column_view_get_enable_rubberband(cast[ptr ColumnView00](self.impl)))

proc enableRubberband*(self: ColumnView): bool =
  toBool(gtk_column_view_get_enable_rubberband(cast[ptr ColumnView00](self.impl)))

proc gtk_column_view_get_model(self: ptr ColumnView00): ptr SelectionModel00 {.
    importc, libprag.}

proc getModel*(self: ColumnView): SelectionModel =
  let gobj = gtk_column_view_get_model(cast[ptr ColumnView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: ColumnView): SelectionModel =
  let gobj = gtk_column_view_get_model(cast[ptr ColumnView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_get_reorderable(self: ptr ColumnView00): gboolean {.
    importc, libprag.}

proc getReorderable*(self: ColumnView): bool =
  toBool(gtk_column_view_get_reorderable(cast[ptr ColumnView00](self.impl)))

proc reorderable*(self: ColumnView): bool =
  toBool(gtk_column_view_get_reorderable(cast[ptr ColumnView00](self.impl)))

proc gtk_column_view_get_show_column_separators(self: ptr ColumnView00): gboolean {.
    importc, libprag.}

proc getShowColumnSeparators*(self: ColumnView): bool =
  toBool(gtk_column_view_get_show_column_separators(cast[ptr ColumnView00](self.impl)))

proc showColumnSeparators*(self: ColumnView): bool =
  toBool(gtk_column_view_get_show_column_separators(cast[ptr ColumnView00](self.impl)))

proc gtk_column_view_get_show_row_separators(self: ptr ColumnView00): gboolean {.
    importc, libprag.}

proc getShowRowSeparators*(self: ColumnView): bool =
  toBool(gtk_column_view_get_show_row_separators(cast[ptr ColumnView00](self.impl)))

proc showRowSeparators*(self: ColumnView): bool =
  toBool(gtk_column_view_get_show_row_separators(cast[ptr ColumnView00](self.impl)))

proc gtk_column_view_get_single_click_activate(self: ptr ColumnView00): gboolean {.
    importc, libprag.}

proc getSingleClickActivate*(self: ColumnView): bool =
  toBool(gtk_column_view_get_single_click_activate(cast[ptr ColumnView00](self.impl)))

proc singleClickActivate*(self: ColumnView): bool =
  toBool(gtk_column_view_get_single_click_activate(cast[ptr ColumnView00](self.impl)))

proc gtk_column_view_set_enable_rubberband(self: ptr ColumnView00; enableRubberband: gboolean) {.
    importc, libprag.}

proc setEnableRubberband*(self: ColumnView; enableRubberband: bool = true) =
  gtk_column_view_set_enable_rubberband(cast[ptr ColumnView00](self.impl), gboolean(enableRubberband))

proc `enableRubberband=`*(self: ColumnView; enableRubberband: bool) =
  gtk_column_view_set_enable_rubberband(cast[ptr ColumnView00](self.impl), gboolean(enableRubberband))

proc gtk_column_view_set_model(self: ptr ColumnView00; model: ptr SelectionModel00) {.
    importc, libprag.}

proc setModel*(self: ColumnView; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) =
  gtk_column_view_set_model(cast[ptr ColumnView00](self.impl), if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))

proc `model=`*(self: ColumnView; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) =
  gtk_column_view_set_model(cast[ptr ColumnView00](self.impl), if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))

proc gtk_column_view_set_reorderable(self: ptr ColumnView00; reorderable: gboolean) {.
    importc, libprag.}

proc setReorderable*(self: ColumnView; reorderable: bool = true) =
  gtk_column_view_set_reorderable(cast[ptr ColumnView00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: ColumnView; reorderable: bool) =
  gtk_column_view_set_reorderable(cast[ptr ColumnView00](self.impl), gboolean(reorderable))

proc gtk_column_view_set_show_column_separators(self: ptr ColumnView00; showColumnSeparators: gboolean) {.
    importc, libprag.}

proc setShowColumnSeparators*(self: ColumnView; showColumnSeparators: bool = true) =
  gtk_column_view_set_show_column_separators(cast[ptr ColumnView00](self.impl), gboolean(showColumnSeparators))

proc `showColumnSeparators=`*(self: ColumnView; showColumnSeparators: bool) =
  gtk_column_view_set_show_column_separators(cast[ptr ColumnView00](self.impl), gboolean(showColumnSeparators))

proc gtk_column_view_set_show_row_separators(self: ptr ColumnView00; showRowSeparators: gboolean) {.
    importc, libprag.}

proc setShowRowSeparators*(self: ColumnView; showRowSeparators: bool = true) =
  gtk_column_view_set_show_row_separators(cast[ptr ColumnView00](self.impl), gboolean(showRowSeparators))

proc `showRowSeparators=`*(self: ColumnView; showRowSeparators: bool) =
  gtk_column_view_set_show_row_separators(cast[ptr ColumnView00](self.impl), gboolean(showRowSeparators))

proc gtk_column_view_set_single_click_activate(self: ptr ColumnView00; singleClickActivate: gboolean) {.
    importc, libprag.}

proc setSingleClickActivate*(self: ColumnView; singleClickActivate: bool = true) =
  gtk_column_view_set_single_click_activate(cast[ptr ColumnView00](self.impl), gboolean(singleClickActivate))

proc `singleClickActivate=`*(self: ColumnView; singleClickActivate: bool) =
  gtk_column_view_set_single_click_activate(cast[ptr ColumnView00](self.impl), gboolean(singleClickActivate))

type
  VolumeButton* = ref object of ScaleButton
  VolumeButton00* = object of ScaleButton00

proc gtk_volume_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(VolumeButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_volume_button_new(): ptr VolumeButton00 {.
    importc, libprag.}

proc newVolumeButton*(): VolumeButton {.deprecated.}  =
  let gobj = gtk_volume_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVolumeButton*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is VolumeButton)
  let gobj = gtk_volume_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVolumeButton*[T](result: var T) {.deprecated.} =
  assert(result is VolumeButton)
  let gobj = gtk_volume_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  InfoBar* = ref object of Widget
  InfoBar00* = object of Widget00

proc gtk_info_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(InfoBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClose*(self: InfoBar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cf)

proc scResponse*(self: InfoBar;  p: proc (self: ptr InfoBar00; responseId: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "response", cast[GCallback](p), xdata, nil, cf)

proc gtk_info_bar_new(): ptr InfoBar00 {.
    importc, libprag.}

proc newInfoBar*(): InfoBar {.deprecated.}  =
  let gobj = gtk_info_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newInfoBar*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is InfoBar)
  let gobj = gtk_info_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initInfoBar*[T](result: var T) {.deprecated.} =
  assert(result is InfoBar)
  let gobj = gtk_info_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_add_action_widget(self: ptr InfoBar00; child: ptr Widget00;
    responseId: int32) {.
    importc, libprag.}

proc addActionWidget*(self: InfoBar; child: Widget; responseId: int) =
  gtk_info_bar_add_action_widget(cast[ptr InfoBar00](self.impl), cast[ptr Widget00](child.impl), int32(responseId))

proc gtk_info_bar_add_button(self: ptr InfoBar00; buttonText: cstring; responseId: int32): ptr Button00 {.
    importc, libprag.}

proc addButton*(self: InfoBar; buttonText: cstring; responseId: int): Button =
  let gobj = gtk_info_bar_add_button(cast[ptr InfoBar00](self.impl), buttonText, int32(responseId))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_add_child(self: ptr InfoBar00; widget: ptr Widget00) {.
    importc, libprag.}

proc addChild*(self: InfoBar; widget: Widget) =
  gtk_info_bar_add_child(cast[ptr InfoBar00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_info_bar_get_revealed(self: ptr InfoBar00): gboolean {.
    importc, libprag.}

proc getRevealed*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_revealed(cast[ptr InfoBar00](self.impl)))

proc revealed*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_revealed(cast[ptr InfoBar00](self.impl)))

proc gtk_info_bar_get_show_close_button(self: ptr InfoBar00): gboolean {.
    importc, libprag.}

proc getShowCloseButton*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_show_close_button(cast[ptr InfoBar00](self.impl)))

proc showCloseButton*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_show_close_button(cast[ptr InfoBar00](self.impl)))

proc gtk_info_bar_remove_action_widget(self: ptr InfoBar00; widget: ptr Widget00) {.
    importc, libprag.}

proc removeActionWidget*(self: InfoBar; widget: Widget) =
  gtk_info_bar_remove_action_widget(cast[ptr InfoBar00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_info_bar_remove_child(self: ptr InfoBar00; widget: ptr Widget00) {.
    importc, libprag.}

proc removeChild*(self: InfoBar; widget: Widget) =
  gtk_info_bar_remove_child(cast[ptr InfoBar00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_info_bar_response(self: ptr InfoBar00; responseId: int32) {.
    importc, libprag.}

proc response*(self: InfoBar; responseId: int) =
  gtk_info_bar_response(cast[ptr InfoBar00](self.impl), int32(responseId))

proc gtk_info_bar_set_default_response(self: ptr InfoBar00; responseId: int32) {.
    importc, libprag.}

proc setDefaultResponse*(self: InfoBar; responseId: int) =
  gtk_info_bar_set_default_response(cast[ptr InfoBar00](self.impl), int32(responseId))

proc `defaultResponse=`*(self: InfoBar; responseId: int) =
  gtk_info_bar_set_default_response(cast[ptr InfoBar00](self.impl), int32(responseId))

proc gtk_info_bar_set_response_sensitive(self: ptr InfoBar00; responseId: int32;
    setting: gboolean) {.
    importc, libprag.}

proc setResponseSensitive*(self: InfoBar; responseId: int;
    setting: bool) =
  gtk_info_bar_set_response_sensitive(cast[ptr InfoBar00](self.impl), int32(responseId), gboolean(setting))

proc gtk_info_bar_set_revealed(self: ptr InfoBar00; revealed: gboolean) {.
    importc, libprag.}

proc setRevealed*(self: InfoBar; revealed: bool = true) =
  gtk_info_bar_set_revealed(cast[ptr InfoBar00](self.impl), gboolean(revealed))

proc `revealed=`*(self: InfoBar; revealed: bool) =
  gtk_info_bar_set_revealed(cast[ptr InfoBar00](self.impl), gboolean(revealed))

proc gtk_info_bar_set_show_close_button(self: ptr InfoBar00; setting: gboolean) {.
    importc, libprag.}

proc setShowCloseButton*(self: InfoBar; setting: bool = true) =
  gtk_info_bar_set_show_close_button(cast[ptr InfoBar00](self.impl), gboolean(setting))

proc `showCloseButton=`*(self: InfoBar; setting: bool) =
  gtk_info_bar_set_show_close_button(cast[ptr InfoBar00](self.impl), gboolean(setting))

type
  IconView* = ref object of Widget
  IconView00* = object of Widget00

proc gtk_icon_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateCursorItem*(self: IconView;  p: proc (self: ptr IconView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-cursor-item", cast[GCallback](p), xdata, nil, cf)

proc scItemActivated*(self: IconView;  p: proc (self: ptr IconView00; path: ptr TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "item-activated", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: IconView;  p: proc (self: ptr IconView00; step: MovementStep; count: int32; extend: gboolean; modify: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSelectCursorItem*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-cursor-item", cast[GCallback](p), xdata, nil, cf)

proc scSelectionChanged*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-changed", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorItem*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-item", cast[GCallback](p), xdata, nil, cf)

proc scUnselectAll*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cf)

proc gtk_icon_view_new(): ptr IconView00 {.
    importc, libprag.}

proc newIconView*(): IconView {.deprecated.}  =
  let gobj = gtk_icon_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconView*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is IconView)
  let gobj = gtk_icon_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconView*[T](result: var T) {.deprecated.} =
  assert(result is IconView)
  let gobj = gtk_icon_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_new_with_model(model: ptr TreeModel00): ptr IconView00 {.
    importc, libprag.}

proc newIconViewWithModel*(model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): IconView {.deprecated.}  =
  let gobj = gtk_icon_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconViewWithModel*(tdesc: typedesc; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): tdesc {.deprecated.}  =
  assert(result is IconView)
  let gobj = gtk_icon_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconViewWithModel*[T](result: var T; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) {.deprecated.} =
  assert(result is IconView)
  let gobj = gtk_icon_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_create_drag_icon(self: ptr IconView00; path: ptr TreePath00): ptr gdk4.Paintable00 {.
    importc, libprag.}

proc createDragIcon*(self: IconView; path: TreePath): gdk4.Paintable =
  let gobj = gtk_icon_view_create_drag_icon(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_enable_model_drag_dest(self: ptr IconView00; formats: ptr gdk4.ContentFormats00;
    actions: gdk4.DragAction) {.
    importc, libprag.}

proc enableModelDragDest*(self: IconView; formats: gdk4.ContentFormats;
    actions: gdk4.DragAction) =
  gtk_icon_view_enable_model_drag_dest(cast[ptr IconView00](self.impl), cast[ptr gdk4.ContentFormats00](formats.impl), actions)

proc gtk_icon_view_enable_model_drag_source(self: ptr IconView00; startButtonMask: gdk4.ModifierType;
    formats: ptr gdk4.ContentFormats00; actions: gdk4.DragAction) {.
    importc, libprag.}

proc enableModelDragSource*(self: IconView; startButtonMask: gdk4.ModifierType;
    formats: gdk4.ContentFormats; actions: gdk4.DragAction) =
  gtk_icon_view_enable_model_drag_source(cast[ptr IconView00](self.impl), startButtonMask, cast[ptr gdk4.ContentFormats00](formats.impl), actions)

proc gtk_icon_view_get_activate_on_single_click(self: ptr IconView00): gboolean {.
    importc, libprag.}

proc getActivateOnSingleClick*(self: IconView): bool =
  toBool(gtk_icon_view_get_activate_on_single_click(cast[ptr IconView00](self.impl)))

proc activateOnSingleClick*(self: IconView): bool =
  toBool(gtk_icon_view_get_activate_on_single_click(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_column_spacing(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getColumnSpacing*(self: IconView): int =
  int(gtk_icon_view_get_column_spacing(cast[ptr IconView00](self.impl)))

proc columnSpacing*(self: IconView): int =
  int(gtk_icon_view_get_column_spacing(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_columns(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getColumns*(self: IconView): int =
  int(gtk_icon_view_get_columns(cast[ptr IconView00](self.impl)))

proc columns*(self: IconView): int =
  int(gtk_icon_view_get_columns(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_item_column(self: ptr IconView00; path: ptr TreePath00): int32 {.
    importc, libprag.}

proc getItemColumn*(self: IconView; path: TreePath): int =
  int(gtk_icon_view_get_item_column(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_icon_view_get_item_padding(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getItemPadding*(self: IconView): int =
  int(gtk_icon_view_get_item_padding(cast[ptr IconView00](self.impl)))

proc itemPadding*(self: IconView): int =
  int(gtk_icon_view_get_item_padding(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_item_row(self: ptr IconView00; path: ptr TreePath00): int32 {.
    importc, libprag.}

proc getItemRow*(self: IconView; path: TreePath): int =
  int(gtk_icon_view_get_item_row(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_icon_view_get_item_width(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getItemWidth*(self: IconView): int =
  int(gtk_icon_view_get_item_width(cast[ptr IconView00](self.impl)))

proc itemWidth*(self: IconView): int =
  int(gtk_icon_view_get_item_width(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_margin(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getMargin*(self: IconView): int =
  int(gtk_icon_view_get_margin(cast[ptr IconView00](self.impl)))

proc margin*(self: IconView): int =
  int(gtk_icon_view_get_margin(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_markup_column(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getMarkupColumn*(self: IconView): int =
  int(gtk_icon_view_get_markup_column(cast[ptr IconView00](self.impl)))

proc markupColumn*(self: IconView): int =
  int(gtk_icon_view_get_markup_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_model(self: ptr IconView00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: IconView): TreeModel =
  let gobj = gtk_icon_view_get_model(cast[ptr IconView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: IconView): TreeModel =
  let gobj = gtk_icon_view_get_model(cast[ptr IconView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_get_path_at_pos(self: ptr IconView00; x: int32; y: int32): ptr TreePath00 {.
    importc, libprag.}

proc getPathAtPos*(self: IconView; x: int; y: int): TreePath =
  let impl0 = gtk_icon_view_get_path_at_pos(cast[ptr IconView00](self.impl), int32(x), int32(y))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_icon_view_get_pixbuf_column(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getPixbufColumn*(self: IconView): int =
  int(gtk_icon_view_get_pixbuf_column(cast[ptr IconView00](self.impl)))

proc pixbufColumn*(self: IconView): int =
  int(gtk_icon_view_get_pixbuf_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_reorderable(self: ptr IconView00): gboolean {.
    importc, libprag.}

proc getReorderable*(self: IconView): bool =
  toBool(gtk_icon_view_get_reorderable(cast[ptr IconView00](self.impl)))

proc reorderable*(self: IconView): bool =
  toBool(gtk_icon_view_get_reorderable(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_row_spacing(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getRowSpacing*(self: IconView): int =
  int(gtk_icon_view_get_row_spacing(cast[ptr IconView00](self.impl)))

proc rowSpacing*(self: IconView): int =
  int(gtk_icon_view_get_row_spacing(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_selected_items(self: ptr IconView00): ptr glib.List {.
    importc, libprag.}

proc getSelectedItems*(self: IconView): seq[TreePath] =
  let resul0 = gtk_icon_view_get_selected_items(cast[ptr IconView00](self.impl))
  result = glistStructs2seq[TreePath](resul0, false)
  g_list_free(resul0)

proc selectedItems*(self: IconView): seq[TreePath] =
  let resul0 = gtk_icon_view_get_selected_items(cast[ptr IconView00](self.impl))
  result = glistStructs2seq[TreePath](resul0, false)
  g_list_free(resul0)

proc gtk_icon_view_get_spacing(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getSpacing*(self: IconView): int =
  int(gtk_icon_view_get_spacing(cast[ptr IconView00](self.impl)))

proc spacing*(self: IconView): int =
  int(gtk_icon_view_get_spacing(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_text_column(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getTextColumn*(self: IconView): int =
  int(gtk_icon_view_get_text_column(cast[ptr IconView00](self.impl)))

proc textColumn*(self: IconView): int =
  int(gtk_icon_view_get_text_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_tooltip_column(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getTooltipColumn*(self: IconView): int =
  int(gtk_icon_view_get_tooltip_column(cast[ptr IconView00](self.impl)))

proc tooltipColumn*(self: IconView): int =
  int(gtk_icon_view_get_tooltip_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_tooltip_context(self: ptr IconView00; x: int32; y: int32;
    keyboardTip: gboolean; model: var ptr TreeModel00; path: var ptr TreePath00;
    iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getTooltipContext*(self: IconView; x: int; y: int; keyboardTip: bool;
    model: var (TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) = cast[var TreeModel](nil);
    path: var TreePath = cast[var TreePath](nil); iter: var TreeIter = cast[var TreeIter](nil)): bool =
  var tmpoutgobjectarg: ptr TreeModel00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_icon_view_get_tooltip_context(cast[ptr IconView00](self.impl), int32(x), int32(y), gboolean(keyboardTip), cast[var ptr TreeModel00](if addr(model) == nil: nil else: addr tmpoutgobjectarg), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), iter))
#  dothemagic(model
  if addr(model) != nil:
    model = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      model = cast[type(model)](argqdata)
      assert(model.impl == tmpoutgobjectarg)
    else:
      fnew(model, gtk4.finalizeGObject)
      model.impl = tmpoutgobjectarg
      GC_ref(model)
      if g_object_is_floating(model.impl).int != 0:
        discard g_object_ref_sink(model.impl)
      g_object_add_toggle_ref(model.impl, toggleNotify, addr(model[]))
      g_object_unref(model.impl)
      assert(g_object_get_qdata(model.impl, Quark) == nil)
      g_object_set_qdata(model.impl, Quark, addr(model[]))


proc gtk_icon_view_get_visible_range(self: ptr IconView00; startPath: var ptr TreePath00;
    endPath: var ptr TreePath00): gboolean {.
    importc, libprag.}

proc getVisibleRange*(self: IconView; startPath: var TreePath = cast[var TreePath](nil);
    endPath: var TreePath = cast[var TreePath](nil)): bool =
  if addr(startPath) != nil:
    fnew(startPath, gBoxedFreeGtkTreePath)
  if addr(endPath) != nil:
    fnew(endPath, gBoxedFreeGtkTreePath)
  toBool(gtk_icon_view_get_visible_range(cast[ptr IconView00](self.impl), cast[var ptr TreePath00](if addr(startPath) == nil: nil else: addr startPath.impl), cast[var ptr TreePath00](if addr(endPath) == nil: nil else: addr endPath.impl)))

proc gtk_icon_view_item_activated(self: ptr IconView00; path: ptr TreePath00) {.
    importc, libprag.}

proc itemActivated*(self: IconView; path: TreePath) =
  gtk_icon_view_item_activated(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_path_is_selected(self: ptr IconView00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc pathIsSelected*(self: IconView; path: TreePath): bool =
  toBool(gtk_icon_view_path_is_selected(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_icon_view_scroll_to_path(self: ptr IconView00; path: ptr TreePath00;
    useAlign: gboolean; rowAlign: cfloat; colAlign: cfloat) {.
    importc, libprag.}

proc scrollToPath*(self: IconView; path: TreePath; useAlign: bool;
    rowAlign: cfloat; colAlign: cfloat) =
  gtk_icon_view_scroll_to_path(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl), gboolean(useAlign), rowAlign, colAlign)

proc gtk_icon_view_select_all(self: ptr IconView00) {.
    importc, libprag.}

proc selectAll*(self: IconView) =
  gtk_icon_view_select_all(cast[ptr IconView00](self.impl))

proc gtk_icon_view_select_path(self: ptr IconView00; path: ptr TreePath00) {.
    importc, libprag.}

proc selectPath*(self: IconView; path: TreePath) =
  gtk_icon_view_select_path(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_set_activate_on_single_click(self: ptr IconView00; single: gboolean) {.
    importc, libprag.}

proc setActivateOnSingleClick*(self: IconView; single: bool = true) =
  gtk_icon_view_set_activate_on_single_click(cast[ptr IconView00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: IconView; single: bool) =
  gtk_icon_view_set_activate_on_single_click(cast[ptr IconView00](self.impl), gboolean(single))

proc gtk_icon_view_set_column_spacing(self: ptr IconView00; columnSpacing: int32) {.
    importc, libprag.}

proc setColumnSpacing*(self: IconView; columnSpacing: int) =
  gtk_icon_view_set_column_spacing(cast[ptr IconView00](self.impl), int32(columnSpacing))

proc `columnSpacing=`*(self: IconView; columnSpacing: int) =
  gtk_icon_view_set_column_spacing(cast[ptr IconView00](self.impl), int32(columnSpacing))

proc gtk_icon_view_set_columns(self: ptr IconView00; columns: int32) {.
    importc, libprag.}

proc setColumns*(self: IconView; columns: int) =
  gtk_icon_view_set_columns(cast[ptr IconView00](self.impl), int32(columns))

proc `columns=`*(self: IconView; columns: int) =
  gtk_icon_view_set_columns(cast[ptr IconView00](self.impl), int32(columns))

proc gtk_icon_view_set_item_padding(self: ptr IconView00; itemPadding: int32) {.
    importc, libprag.}

proc setItemPadding*(self: IconView; itemPadding: int) =
  gtk_icon_view_set_item_padding(cast[ptr IconView00](self.impl), int32(itemPadding))

proc `itemPadding=`*(self: IconView; itemPadding: int) =
  gtk_icon_view_set_item_padding(cast[ptr IconView00](self.impl), int32(itemPadding))

proc gtk_icon_view_set_item_width(self: ptr IconView00; itemWidth: int32) {.
    importc, libprag.}

proc setItemWidth*(self: IconView; itemWidth: int) =
  gtk_icon_view_set_item_width(cast[ptr IconView00](self.impl), int32(itemWidth))

proc `itemWidth=`*(self: IconView; itemWidth: int) =
  gtk_icon_view_set_item_width(cast[ptr IconView00](self.impl), int32(itemWidth))

proc gtk_icon_view_set_margin(self: ptr IconView00; margin: int32) {.
    importc, libprag.}

proc setMargin*(self: IconView; margin: int) =
  gtk_icon_view_set_margin(cast[ptr IconView00](self.impl), int32(margin))

proc `margin=`*(self: IconView; margin: int) =
  gtk_icon_view_set_margin(cast[ptr IconView00](self.impl), int32(margin))

proc gtk_icon_view_set_markup_column(self: ptr IconView00; column: int32) {.
    importc, libprag.}

proc setMarkupColumn*(self: IconView; column: int) =
  gtk_icon_view_set_markup_column(cast[ptr IconView00](self.impl), int32(column))

proc `markupColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_markup_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_model(self: ptr IconView00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: IconView; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_icon_view_set_model(cast[ptr IconView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: IconView; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_icon_view_set_model(cast[ptr IconView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc gtk_icon_view_set_pixbuf_column(self: ptr IconView00; column: int32) {.
    importc, libprag.}

proc setPixbufColumn*(self: IconView; column: int) =
  gtk_icon_view_set_pixbuf_column(cast[ptr IconView00](self.impl), int32(column))

proc `pixbufColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_pixbuf_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_reorderable(self: ptr IconView00; reorderable: gboolean) {.
    importc, libprag.}

proc setReorderable*(self: IconView; reorderable: bool = true) =
  gtk_icon_view_set_reorderable(cast[ptr IconView00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: IconView; reorderable: bool) =
  gtk_icon_view_set_reorderable(cast[ptr IconView00](self.impl), gboolean(reorderable))

proc gtk_icon_view_set_row_spacing(self: ptr IconView00; rowSpacing: int32) {.
    importc, libprag.}

proc setRowSpacing*(self: IconView; rowSpacing: int) =
  gtk_icon_view_set_row_spacing(cast[ptr IconView00](self.impl), int32(rowSpacing))

proc `rowSpacing=`*(self: IconView; rowSpacing: int) =
  gtk_icon_view_set_row_spacing(cast[ptr IconView00](self.impl), int32(rowSpacing))

proc gtk_icon_view_set_spacing(self: ptr IconView00; spacing: int32) {.
    importc, libprag.}

proc setSpacing*(self: IconView; spacing: int) =
  gtk_icon_view_set_spacing(cast[ptr IconView00](self.impl), int32(spacing))

proc `spacing=`*(self: IconView; spacing: int) =
  gtk_icon_view_set_spacing(cast[ptr IconView00](self.impl), int32(spacing))

proc gtk_icon_view_set_text_column(self: ptr IconView00; column: int32) {.
    importc, libprag.}

proc setTextColumn*(self: IconView; column: int) =
  gtk_icon_view_set_text_column(cast[ptr IconView00](self.impl), int32(column))

proc `textColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_text_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_tooltip_column(self: ptr IconView00; column: int32) {.
    importc, libprag.}

proc setTooltipColumn*(self: IconView; column: int) =
  gtk_icon_view_set_tooltip_column(cast[ptr IconView00](self.impl), int32(column))

proc `tooltipColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_tooltip_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_tooltip_item(self: ptr IconView00; tooltip: ptr Tooltip00;
    path: ptr TreePath00) {.
    importc, libprag.}

proc setTooltipItem*(self: IconView; tooltip: Tooltip; path: TreePath) =
  gtk_icon_view_set_tooltip_item(cast[ptr IconView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_unselect_all(self: ptr IconView00) {.
    importc, libprag.}

proc unselectAll*(self: IconView) =
  gtk_icon_view_unselect_all(cast[ptr IconView00](self.impl))

proc gtk_icon_view_unselect_path(self: ptr IconView00; path: ptr TreePath00) {.
    importc, libprag.}

proc unselectPath*(self: IconView; path: TreePath) =
  gtk_icon_view_unselect_path(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_unset_model_drag_dest(self: ptr IconView00) {.
    importc, libprag.}

proc unsetModelDragDest*(self: IconView) =
  gtk_icon_view_unset_model_drag_dest(cast[ptr IconView00](self.impl))

proc gtk_icon_view_unset_model_drag_source(self: ptr IconView00) {.
    importc, libprag.}

proc unsetModelDragSource*(self: IconView) =
  gtk_icon_view_unset_model_drag_source(cast[ptr IconView00](self.impl))

type
  PageSetupUnixDialog* = ref object of Dialog
  PageSetupUnixDialog00* = object of Dialog00

proc gtk_page_setup_unix_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PageSetupUnixDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_page_setup_unix_dialog_new(title: cstring; parent: ptr Window00): ptr PageSetupUnixDialog00 {.
    importc, libprag.}

proc newPageSetupUnixDialog*(title: cstring = nil; parent: Window = nil): PageSetupUnixDialog =
  let gobj = gtk_page_setup_unix_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPageSetupUnixDialog*(tdesc: typedesc; title: cstring = nil; parent: Window = nil): tdesc =
  assert(result is PageSetupUnixDialog)
  let gobj = gtk_page_setup_unix_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupUnixDialog*[T](result: var T; title: cstring = nil; parent: Window = nil) {.deprecated.} =
  assert(result is PageSetupUnixDialog)
  let gobj = gtk_page_setup_unix_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  AppChooserWidget* = ref object of Widget
  AppChooserWidget00* = object of Widget00

proc gtk_app_chooser_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AppChooserWidget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scApplicationActivated*(self: AppChooserWidget;  p: proc (self: ptr AppChooserWidget00; application: ptr gio.AppInfo00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "application-activated", cast[GCallback](p), xdata, nil, cf)

proc scApplicationSelected*(self: AppChooserWidget;  p: proc (self: ptr AppChooserWidget00; application: ptr gio.AppInfo00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "application-selected", cast[GCallback](p), xdata, nil, cf)

proc gtk_app_chooser_widget_new(contentType: cstring): ptr AppChooserWidget00 {.
    importc, libprag.}

proc newAppChooserWidget*(contentType: cstring): AppChooserWidget {.deprecated.}  =
  let gobj = gtk_app_chooser_widget_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAppChooserWidget*(tdesc: typedesc; contentType: cstring): tdesc {.deprecated.}  =
  assert(result is AppChooserWidget)
  let gobj = gtk_app_chooser_widget_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserWidget*[T](result: var T; contentType: cstring) {.deprecated.} =
  assert(result is AppChooserWidget)
  let gobj = gtk_app_chooser_widget_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_widget_get_default_text(self: ptr AppChooserWidget00): cstring {.
    importc, libprag.}

proc getDefaultText*(self: AppChooserWidget): string =
  let resul0 = gtk_app_chooser_widget_get_default_text(cast[ptr AppChooserWidget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc defaultText*(self: AppChooserWidget): string =
  let resul0 = gtk_app_chooser_widget_get_default_text(cast[ptr AppChooserWidget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_app_chooser_widget_get_show_all(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowAll*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_all(cast[ptr AppChooserWidget00](self.impl)))

proc showAll*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_all(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_default(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowDefault*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_default(cast[ptr AppChooserWidget00](self.impl)))

proc showDefault*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_default(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_fallback(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowFallback*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_fallback(cast[ptr AppChooserWidget00](self.impl)))

proc showFallback*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_fallback(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_other(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowOther*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_other(cast[ptr AppChooserWidget00](self.impl)))

proc showOther*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_other(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_recommended(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowRecommended*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_recommended(cast[ptr AppChooserWidget00](self.impl)))

proc showRecommended*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_recommended(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_set_default_text(self: ptr AppChooserWidget00;
    text: cstring) {.
    importc, libprag.}

proc setDefaultText*(self: AppChooserWidget; text: cstring) =
  gtk_app_chooser_widget_set_default_text(cast[ptr AppChooserWidget00](self.impl), text)

proc `defaultText=`*(self: AppChooserWidget; text: cstring) =
  gtk_app_chooser_widget_set_default_text(cast[ptr AppChooserWidget00](self.impl), text)

proc gtk_app_chooser_widget_set_show_all(self: ptr AppChooserWidget00; setting: gboolean) {.
    importc, libprag.}

proc setShowAll*(self: AppChooserWidget; setting: bool = true) =
  gtk_app_chooser_widget_set_show_all(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showAll=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_all(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_default(self: ptr AppChooserWidget00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowDefault*(self: AppChooserWidget; setting: bool = true) =
  gtk_app_chooser_widget_set_show_default(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showDefault=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_default(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_fallback(self: ptr AppChooserWidget00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowFallback*(self: AppChooserWidget; setting: bool = true) =
  gtk_app_chooser_widget_set_show_fallback(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showFallback=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_fallback(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_other(self: ptr AppChooserWidget00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowOther*(self: AppChooserWidget; setting: bool = true) =
  gtk_app_chooser_widget_set_show_other(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showOther=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_other(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_recommended(self: ptr AppChooserWidget00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowRecommended*(self: AppChooserWidget;
    setting: bool = true) =
  gtk_app_chooser_widget_set_show_recommended(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showRecommended=`*(self: AppChooserWidget;
    setting: bool) =
  gtk_app_chooser_widget_set_show_recommended(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

type
  FontChooserWidget* = ref object of Widget
  FontChooserWidget00* = object of Widget00

proc gtk_font_chooser_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontChooserWidget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_font_chooser_widget_new(): ptr FontChooserWidget00 {.
    importc, libprag.}

proc newFontChooserWidget*(): FontChooserWidget {.deprecated.}  =
  let gobj = gtk_font_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontChooserWidget*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is FontChooserWidget)
  let gobj = gtk_font_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontChooserWidget*[T](result: var T) {.deprecated.} =
  assert(result is FontChooserWidget)
  let gobj = gtk_font_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  PasswordEntry* = ref object of Widget
  PasswordEntry00* = object of Widget00

proc gtk_password_entry_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PasswordEntry()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: PasswordEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_password_entry_new(): ptr PasswordEntry00 {.
    importc, libprag.}

proc newPasswordEntry*(): PasswordEntry =
  let gobj = gtk_password_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPasswordEntry*(tdesc: typedesc): tdesc =
  assert(result is PasswordEntry)
  let gobj = gtk_password_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPasswordEntry*[T](result: var T) {.deprecated.} =
  assert(result is PasswordEntry)
  let gobj = gtk_password_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_password_entry_get_extra_menu(self: ptr PasswordEntry00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getExtraMenu*(self: PasswordEntry): gio.MenuModel =
  let gobj = gtk_password_entry_get_extra_menu(cast[ptr PasswordEntry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc extraMenu*(self: PasswordEntry): gio.MenuModel =
  let gobj = gtk_password_entry_get_extra_menu(cast[ptr PasswordEntry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_password_entry_get_show_peek_icon(self: ptr PasswordEntry00): gboolean {.
    importc, libprag.}

proc getShowPeekIcon*(self: PasswordEntry): bool =
  toBool(gtk_password_entry_get_show_peek_icon(cast[ptr PasswordEntry00](self.impl)))

proc showPeekIcon*(self: PasswordEntry): bool =
  toBool(gtk_password_entry_get_show_peek_icon(cast[ptr PasswordEntry00](self.impl)))

proc gtk_password_entry_set_extra_menu(self: ptr PasswordEntry00; model: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setExtraMenu*(self: PasswordEntry; model: gio.MenuModel = nil) =
  gtk_password_entry_set_extra_menu(cast[ptr PasswordEntry00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc `extraMenu=`*(self: PasswordEntry; model: gio.MenuModel = nil) =
  gtk_password_entry_set_extra_menu(cast[ptr PasswordEntry00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc gtk_password_entry_set_show_peek_icon(self: ptr PasswordEntry00; showPeekIcon: gboolean) {.
    importc, libprag.}

proc setShowPeekIcon*(self: PasswordEntry; showPeekIcon: bool = true) =
  gtk_password_entry_set_show_peek_icon(cast[ptr PasswordEntry00](self.impl), gboolean(showPeekIcon))

proc `showPeekIcon=`*(self: PasswordEntry; showPeekIcon: bool) =
  gtk_password_entry_set_show_peek_icon(cast[ptr PasswordEntry00](self.impl), gboolean(showPeekIcon))

type
  Statusbar* = ref object of Widget
  Statusbar00* = object of Widget00

proc gtk_statusbar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Statusbar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scTextPopped*(self: Statusbar;  p: proc (self: ptr Statusbar00; contextId: uint32; text: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "text-popped", cast[GCallback](p), xdata, nil, cf)

proc scTextPushed*(self: Statusbar;  p: proc (self: ptr Statusbar00; contextId: uint32; text: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "text-pushed", cast[GCallback](p), xdata, nil, cf)

proc gtk_statusbar_new(): ptr Statusbar00 {.
    importc, libprag.}

proc newStatusbar*(): Statusbar {.deprecated.}  =
  let gobj = gtk_statusbar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStatusbar*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is Statusbar)
  let gobj = gtk_statusbar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusbar*[T](result: var T) {.deprecated.} =
  assert(result is Statusbar)
  let gobj = gtk_statusbar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_statusbar_get_context_id(self: ptr Statusbar00; contextDescription: cstring): uint32 {.
    importc, libprag.}

proc getContextId*(self: Statusbar; contextDescription: cstring): int =
  int(gtk_statusbar_get_context_id(cast[ptr Statusbar00](self.impl), contextDescription))

proc gtk_statusbar_pop(self: ptr Statusbar00; contextId: uint32) {.
    importc, libprag.}

proc pop*(self: Statusbar; contextId: int) =
  gtk_statusbar_pop(cast[ptr Statusbar00](self.impl), uint32(contextId))

proc gtk_statusbar_push(self: ptr Statusbar00; contextId: uint32; text: cstring): uint32 {.
    importc, libprag.}

proc push*(self: Statusbar; contextId: int; text: cstring): int =
  int(gtk_statusbar_push(cast[ptr Statusbar00](self.impl), uint32(contextId), text))

proc gtk_statusbar_remove(self: ptr Statusbar00; contextId: uint32; messageId: uint32) {.
    importc, libprag.}

proc remove*(self: Statusbar; contextId: int; messageId: int) =
  gtk_statusbar_remove(cast[ptr Statusbar00](self.impl), uint32(contextId), uint32(messageId))

proc gtk_statusbar_remove_all(self: ptr Statusbar00; contextId: uint32) {.
    importc, libprag.}

proc removeAll*(self: Statusbar; contextId: int) =
  gtk_statusbar_remove_all(cast[ptr Statusbar00](self.impl), uint32(contextId))

type
  EntryIconPosition* {.size: sizeof(cint), pure.} = enum
    primary = 0
    secondary = 1

type
  Entry* = ref object of Widget
  Entry00* = object of Widget00

proc gtk_entry_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Entry()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scIconPress*(self: Entry;  p: proc (self: ptr Entry00; iconPos: EntryIconPosition; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "icon-press", cast[GCallback](p), xdata, nil, cf)

proc scIconRelease*(self: Entry;  p: proc (self: ptr Entry00; iconPos: EntryIconPosition; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "icon-release", cast[GCallback](p), xdata, nil, cf)

proc gtk_entry_new(): ptr Entry00 {.
    importc, libprag.}

proc newEntry*(): Entry =
  let gobj = gtk_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntry*(tdesc: typedesc): tdesc =
  assert(result is Entry)
  let gobj = gtk_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntry*[T](result: var T) {.deprecated.} =
  assert(result is Entry)
  let gobj = gtk_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_activates_default(self: ptr Entry00): gboolean {.
    importc, libprag.}

proc getActivatesDefault*(self: Entry): bool =
  toBool(gtk_entry_get_activates_default(cast[ptr Entry00](self.impl)))

proc activatesDefault*(self: Entry): bool =
  toBool(gtk_entry_get_activates_default(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_alignment(self: ptr Entry00): cfloat {.
    importc, libprag.}

proc getAlignment*(self: Entry): cfloat =
  gtk_entry_get_alignment(cast[ptr Entry00](self.impl))

proc alignment*(self: Entry): cfloat =
  gtk_entry_get_alignment(cast[ptr Entry00](self.impl))

proc gtk_entry_get_attributes(self: ptr Entry00): ptr pango.AttrList00 {.
    importc, libprag.}

proc getAttributes*(self: Entry): pango.AttrList =
  let impl0 = gtk_entry_get_attributes(cast[ptr Entry00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc attributes*(self: Entry): pango.AttrList =
  let impl0 = gtk_entry_get_attributes(cast[ptr Entry00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc gtk_entry_get_current_icon_drag_source(self: ptr Entry00): int32 {.
    importc, libprag.}

proc getCurrentIconDragSource*(self: Entry): int =
  int(gtk_entry_get_current_icon_drag_source(cast[ptr Entry00](self.impl)))

proc currentIconDragSource*(self: Entry): int =
  int(gtk_entry_get_current_icon_drag_source(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_extra_menu(self: ptr Entry00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getExtraMenu*(self: Entry): gio.MenuModel =
  let gobj = gtk_entry_get_extra_menu(cast[ptr Entry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc extraMenu*(self: Entry): gio.MenuModel =
  let gobj = gtk_entry_get_extra_menu(cast[ptr Entry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_has_frame(self: ptr Entry00): gboolean {.
    importc, libprag.}

proc getHasFrame*(self: Entry): bool =
  toBool(gtk_entry_get_has_frame(cast[ptr Entry00](self.impl)))

proc hasFrame*(self: Entry): bool =
  toBool(gtk_entry_get_has_frame(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_icon_activatable(self: ptr Entry00; iconPos: EntryIconPosition): gboolean {.
    importc, libprag.}

proc getIconActivatable*(self: Entry; iconPos: EntryIconPosition): bool =
  toBool(gtk_entry_get_icon_activatable(cast[ptr Entry00](self.impl), iconPos))

proc gtk_entry_get_icon_area(self: ptr Entry00; iconPos: EntryIconPosition;
    iconArea: var gdk4.Rectangle) {.
    importc, libprag.}

proc getIconArea*(self: Entry; iconPos: EntryIconPosition; iconArea: var gdk4.Rectangle) =
  gtk_entry_get_icon_area(cast[ptr Entry00](self.impl), iconPos, iconArea)

proc gtk_entry_get_icon_at_pos(self: ptr Entry00; x: int32; y: int32): int32 {.
    importc, libprag.}

proc getIconAtPos*(self: Entry; x: int; y: int): int =
  int(gtk_entry_get_icon_at_pos(cast[ptr Entry00](self.impl), int32(x), int32(y)))

proc gtk_entry_get_icon_gicon(self: ptr Entry00; iconPos: EntryIconPosition): ptr gio.Icon00 {.
    importc, libprag.}

proc getIconGicon*(self: Entry; iconPos: EntryIconPosition): gio.Icon =
  let gobj = gtk_entry_get_icon_gicon(cast[ptr Entry00](self.impl), iconPos)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_icon_name(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc, libprag.}

proc getIconName*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_name(cast[ptr Entry00](self.impl), iconPos)
  if resul0.isNil:
    return
  result = $resul0

proc gtk_entry_get_icon_paintable(self: ptr Entry00; iconPos: EntryIconPosition): ptr gdk4.Paintable00 {.
    importc, libprag.}

proc getIconPaintable*(self: Entry; iconPos: EntryIconPosition): gdk4.Paintable =
  let gobj = gtk_entry_get_icon_paintable(cast[ptr Entry00](self.impl), iconPos)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_icon_sensitive(self: ptr Entry00; iconPos: EntryIconPosition): gboolean {.
    importc, libprag.}

proc getIconSensitive*(self: Entry; iconPos: EntryIconPosition): bool =
  toBool(gtk_entry_get_icon_sensitive(cast[ptr Entry00](self.impl), iconPos))

proc gtk_entry_get_icon_storage_type(self: ptr Entry00; iconPos: EntryIconPosition): ImageType {.
    importc, libprag.}

proc getIconStorageType*(self: Entry; iconPos: EntryIconPosition): ImageType =
  gtk_entry_get_icon_storage_type(cast[ptr Entry00](self.impl), iconPos)

proc gtk_entry_get_icon_tooltip_markup(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc, libprag.}

proc getIconTooltipMarkup*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_tooltip_markup(cast[ptr Entry00](self.impl), iconPos)
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_entry_get_icon_tooltip_text(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc, libprag.}

proc getIconTooltipText*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_tooltip_text(cast[ptr Entry00](self.impl), iconPos)
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_entry_get_invisible_char(self: ptr Entry00): gunichar {.
    importc, libprag.}

proc getInvisibleChar*(self: Entry): gunichar =
  gtk_entry_get_invisible_char(cast[ptr Entry00](self.impl))

proc invisibleChar*(self: Entry): gunichar =
  gtk_entry_get_invisible_char(cast[ptr Entry00](self.impl))

proc gtk_entry_get_max_length(self: ptr Entry00): int32 {.
    importc, libprag.}

proc getMaxLength*(self: Entry): int =
  int(gtk_entry_get_max_length(cast[ptr Entry00](self.impl)))

proc maxLength*(self: Entry): int =
  int(gtk_entry_get_max_length(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_overwrite_mode(self: ptr Entry00): gboolean {.
    importc, libprag.}

proc getOverwriteMode*(self: Entry): bool =
  toBool(gtk_entry_get_overwrite_mode(cast[ptr Entry00](self.impl)))

proc overwriteMode*(self: Entry): bool =
  toBool(gtk_entry_get_overwrite_mode(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_placeholder_text(self: ptr Entry00): cstring {.
    importc, libprag.}

proc getPlaceholderText*(self: Entry): string =
  let resul0 = gtk_entry_get_placeholder_text(cast[ptr Entry00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc placeholderText*(self: Entry): string =
  let resul0 = gtk_entry_get_placeholder_text(cast[ptr Entry00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_entry_get_progress_fraction(self: ptr Entry00): cdouble {.
    importc, libprag.}

proc getProgressFraction*(self: Entry): cdouble =
  gtk_entry_get_progress_fraction(cast[ptr Entry00](self.impl))

proc progressFraction*(self: Entry): cdouble =
  gtk_entry_get_progress_fraction(cast[ptr Entry00](self.impl))

proc gtk_entry_get_progress_pulse_step(self: ptr Entry00): cdouble {.
    importc, libprag.}

proc getProgressPulseStep*(self: Entry): cdouble =
  gtk_entry_get_progress_pulse_step(cast[ptr Entry00](self.impl))

proc progressPulseStep*(self: Entry): cdouble =
  gtk_entry_get_progress_pulse_step(cast[ptr Entry00](self.impl))

proc gtk_entry_get_tabs(self: ptr Entry00): ptr pango.TabArray00 {.
    importc, libprag.}

proc getTabs*(self: Entry): pango.TabArray =
  let impl0 = gtk_entry_get_tabs(cast[ptr Entry00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_tab_array_get_type(), impl0))

proc tabs*(self: Entry): pango.TabArray =
  let impl0 = gtk_entry_get_tabs(cast[ptr Entry00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_tab_array_get_type(), impl0))

proc gtk_entry_get_text_length(self: ptr Entry00): uint16 {.
    importc, libprag.}

proc getTextLength*(self: Entry): uint16 =
  gtk_entry_get_text_length(cast[ptr Entry00](self.impl))

proc textLength*(self: Entry): uint16 =
  gtk_entry_get_text_length(cast[ptr Entry00](self.impl))

proc gtk_entry_get_visibility(self: ptr Entry00): gboolean {.
    importc, libprag.}

proc getVisibility*(self: Entry): bool =
  toBool(gtk_entry_get_visibility(cast[ptr Entry00](self.impl)))

proc visibility*(self: Entry): bool =
  toBool(gtk_entry_get_visibility(cast[ptr Entry00](self.impl)))

proc gtk_entry_grab_focus_without_selecting(self: ptr Entry00): gboolean {.
    importc, libprag.}

proc grabFocusWithoutSelecting*(self: Entry): bool =
  toBool(gtk_entry_grab_focus_without_selecting(cast[ptr Entry00](self.impl)))

proc gtk_entry_progress_pulse(self: ptr Entry00) {.
    importc, libprag.}

proc progressPulse*(self: Entry) =
  gtk_entry_progress_pulse(cast[ptr Entry00](self.impl))

proc gtk_entry_reset_im_context(self: ptr Entry00) {.
    importc, libprag.}

proc resetImContext*(self: Entry) =
  gtk_entry_reset_im_context(cast[ptr Entry00](self.impl))

proc gtk_entry_set_activates_default(self: ptr Entry00; setting: gboolean) {.
    importc, libprag.}

proc setActivatesDefault*(self: Entry; setting: bool = true) =
  gtk_entry_set_activates_default(cast[ptr Entry00](self.impl), gboolean(setting))

proc `activatesDefault=`*(self: Entry; setting: bool) =
  gtk_entry_set_activates_default(cast[ptr Entry00](self.impl), gboolean(setting))

proc gtk_entry_set_alignment(self: ptr Entry00; xalign: cfloat) {.
    importc, libprag.}

proc setAlignment*(self: Entry; xalign: cfloat) =
  gtk_entry_set_alignment(cast[ptr Entry00](self.impl), xalign)

proc `alignment=`*(self: Entry; xalign: cfloat) =
  gtk_entry_set_alignment(cast[ptr Entry00](self.impl), xalign)

proc gtk_entry_set_attributes(self: ptr Entry00; attrs: ptr pango.AttrList00) {.
    importc, libprag.}

proc setAttributes*(self: Entry; attrs: pango.AttrList) =
  gtk_entry_set_attributes(cast[ptr Entry00](self.impl), cast[ptr pango.AttrList00](attrs.impl))

proc `attributes=`*(self: Entry; attrs: pango.AttrList) =
  gtk_entry_set_attributes(cast[ptr Entry00](self.impl), cast[ptr pango.AttrList00](attrs.impl))

proc gtk_entry_set_extra_menu(self: ptr Entry00; model: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setExtraMenu*(self: Entry; model: gio.MenuModel = nil) =
  gtk_entry_set_extra_menu(cast[ptr Entry00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc `extraMenu=`*(self: Entry; model: gio.MenuModel = nil) =
  gtk_entry_set_extra_menu(cast[ptr Entry00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc gtk_entry_set_has_frame(self: ptr Entry00; setting: gboolean) {.
    importc, libprag.}

proc setHasFrame*(self: Entry; setting: bool = true) =
  gtk_entry_set_has_frame(cast[ptr Entry00](self.impl), gboolean(setting))

proc `hasFrame=`*(self: Entry; setting: bool) =
  gtk_entry_set_has_frame(cast[ptr Entry00](self.impl), gboolean(setting))

proc gtk_entry_set_icon_activatable(self: ptr Entry00; iconPos: EntryIconPosition;
    activatable: gboolean) {.
    importc, libprag.}

proc setIconActivatable*(self: Entry; iconPos: EntryIconPosition;
    activatable: bool) =
  gtk_entry_set_icon_activatable(cast[ptr Entry00](self.impl), iconPos, gboolean(activatable))

proc gtk_entry_set_icon_drag_source(self: ptr Entry00; iconPos: EntryIconPosition;
    provider: ptr gdk4.ContentProvider00; actions: gdk4.DragAction) {.
    importc, libprag.}

proc setIconDragSource*(self: Entry; iconPos: EntryIconPosition;
    provider: gdk4.ContentProvider; actions: gdk4.DragAction) =
  gtk_entry_set_icon_drag_source(cast[ptr Entry00](self.impl), iconPos, cast[ptr gdk4.ContentProvider00](provider.impl), actions)

proc gtk_entry_set_icon_from_gicon(self: ptr Entry00; iconPos: EntryIconPosition;
    icon: ptr gio.Icon00) {.
    importc, libprag.}

proc setIconFromGicon*(self: Entry; iconPos: EntryIconPosition;
    icon: gio.Icon = nil) =
  gtk_entry_set_icon_from_gicon(cast[ptr Entry00](self.impl), iconPos, if icon.isNil: nil else: cast[ptr gio.Icon00](icon.impl))

proc gtk_entry_set_icon_from_icon_name(self: ptr Entry00; iconPos: EntryIconPosition;
    iconName: cstring) {.
    importc, libprag.}

proc setIconFromIconName*(self: Entry; iconPos: EntryIconPosition;
    iconName: cstring = nil) =
  gtk_entry_set_icon_from_icon_name(cast[ptr Entry00](self.impl), iconPos, iconName)

proc gtk_entry_set_icon_from_paintable(self: ptr Entry00; iconPos: EntryIconPosition;
    paintable: ptr gdk4.Paintable00) {.
    importc, libprag.}

proc setIconFromPaintable*(self: Entry; iconPos: EntryIconPosition;
    paintable: gdk4.Paintable = nil) =
  gtk_entry_set_icon_from_paintable(cast[ptr Entry00](self.impl), iconPos, if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))

proc gtk_entry_set_icon_sensitive(self: ptr Entry00; iconPos: EntryIconPosition;
    sensitive: gboolean) {.
    importc, libprag.}

proc setIconSensitive*(self: Entry; iconPos: EntryIconPosition;
    sensitive: bool) =
  gtk_entry_set_icon_sensitive(cast[ptr Entry00](self.impl), iconPos, gboolean(sensitive))

proc gtk_entry_set_icon_tooltip_markup(self: ptr Entry00; iconPos: EntryIconPosition;
    tooltip: cstring) {.
    importc, libprag.}

proc setIconTooltipMarkup*(self: Entry; iconPos: EntryIconPosition;
    tooltip: cstring = nil) =
  gtk_entry_set_icon_tooltip_markup(cast[ptr Entry00](self.impl), iconPos, tooltip)

proc gtk_entry_set_icon_tooltip_text(self: ptr Entry00; iconPos: EntryIconPosition;
    tooltip: cstring) {.
    importc, libprag.}

proc setIconTooltipText*(self: Entry; iconPos: EntryIconPosition;
    tooltip: cstring = nil) =
  gtk_entry_set_icon_tooltip_text(cast[ptr Entry00](self.impl), iconPos, tooltip)

proc gtk_entry_set_invisible_char(self: ptr Entry00; ch: gunichar) {.
    importc, libprag.}

proc setInvisibleChar*(self: Entry; ch: gunichar) =
  gtk_entry_set_invisible_char(cast[ptr Entry00](self.impl), ch)

proc `invisibleChar=`*(self: Entry; ch: gunichar) =
  gtk_entry_set_invisible_char(cast[ptr Entry00](self.impl), ch)

proc gtk_entry_set_max_length(self: ptr Entry00; max: int32) {.
    importc, libprag.}

proc setMaxLength*(self: Entry; max: int) =
  gtk_entry_set_max_length(cast[ptr Entry00](self.impl), int32(max))

proc `maxLength=`*(self: Entry; max: int) =
  gtk_entry_set_max_length(cast[ptr Entry00](self.impl), int32(max))

proc gtk_entry_set_overwrite_mode(self: ptr Entry00; overwrite: gboolean) {.
    importc, libprag.}

proc setOverwriteMode*(self: Entry; overwrite: bool = true) =
  gtk_entry_set_overwrite_mode(cast[ptr Entry00](self.impl), gboolean(overwrite))

proc `overwriteMode=`*(self: Entry; overwrite: bool) =
  gtk_entry_set_overwrite_mode(cast[ptr Entry00](self.impl), gboolean(overwrite))

proc gtk_entry_set_placeholder_text(self: ptr Entry00; text: cstring) {.
    importc, libprag.}

proc setPlaceholderText*(self: Entry; text: cstring = nil) =
  gtk_entry_set_placeholder_text(cast[ptr Entry00](self.impl), text)

proc `placeholderText=`*(self: Entry; text: cstring = nil) =
  gtk_entry_set_placeholder_text(cast[ptr Entry00](self.impl), text)

proc gtk_entry_set_progress_fraction(self: ptr Entry00; fraction: cdouble) {.
    importc, libprag.}

proc setProgressFraction*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_fraction(cast[ptr Entry00](self.impl), fraction)

proc `progressFraction=`*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_fraction(cast[ptr Entry00](self.impl), fraction)

proc gtk_entry_set_progress_pulse_step(self: ptr Entry00; fraction: cdouble) {.
    importc, libprag.}

proc setProgressPulseStep*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_pulse_step(cast[ptr Entry00](self.impl), fraction)

proc `progressPulseStep=`*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_pulse_step(cast[ptr Entry00](self.impl), fraction)

proc gtk_entry_set_tabs(self: ptr Entry00; tabs: ptr pango.TabArray00) {.
    importc, libprag.}

proc setTabs*(self: Entry; tabs: pango.TabArray = nil) =
  gtk_entry_set_tabs(cast[ptr Entry00](self.impl), if tabs.isNil: nil else: cast[ptr pango.TabArray00](tabs.impl))

proc `tabs=`*(self: Entry; tabs: pango.TabArray = nil) =
  gtk_entry_set_tabs(cast[ptr Entry00](self.impl), if tabs.isNil: nil else: cast[ptr pango.TabArray00](tabs.impl))

proc gtk_entry_set_visibility(self: ptr Entry00; visible: gboolean) {.
    importc, libprag.}

proc setVisibility*(self: Entry; visible: bool = true) =
  gtk_entry_set_visibility(cast[ptr Entry00](self.impl), gboolean(visible))

proc `visibility=`*(self: Entry; visible: bool) =
  gtk_entry_set_visibility(cast[ptr Entry00](self.impl), gboolean(visible))

proc gtk_entry_unset_invisible_char(self: ptr Entry00) {.
    importc, libprag.}

proc unsetInvisibleChar*(self: Entry) =
  gtk_entry_unset_invisible_char(cast[ptr Entry00](self.impl))

type
  Fixed* = ref object of Widget
  Fixed00* = object of Widget00

proc gtk_fixed_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Fixed()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_fixed_new(): ptr Fixed00 {.
    importc, libprag.}

proc newFixed*(): Fixed =
  let gobj = gtk_fixed_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFixed*(tdesc: typedesc): tdesc =
  assert(result is Fixed)
  let gobj = gtk_fixed_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFixed*[T](result: var T) {.deprecated.} =
  assert(result is Fixed)
  let gobj = gtk_fixed_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_fixed_get_child_position(self: ptr Fixed00; widget: ptr Widget00;
    x: var cdouble; y: var cdouble) {.
    importc, libprag.}

proc getChildPosition*(self: Fixed; widget: Widget; x: var cdouble;
    y: var cdouble) =
  gtk_fixed_get_child_position(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl), x, y)

proc gtk_fixed_get_child_transform(self: ptr Fixed00; widget: ptr Widget00): ptr gsk.Transform00 {.
    importc, libprag.}

proc getChildTransform*(self: Fixed; widget: Widget): gsk.Transform =
  let impl0 = gtk_fixed_get_child_transform(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGskTransform)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gsk_transform_get_type(), impl0))

proc gtk_fixed_move(self: ptr Fixed00; widget: ptr Widget00; x: cdouble;
    y: cdouble) {.
    importc, libprag.}

proc move*(self: Fixed; widget: Widget; x: cdouble; y: cdouble) =
  gtk_fixed_move(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl), x, y)

proc gtk_fixed_put(self: ptr Fixed00; widget: ptr Widget00; x: cdouble; y: cdouble) {.
    importc, libprag.}

proc put*(self: Fixed; widget: Widget; x: cdouble; y: cdouble) =
  gtk_fixed_put(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl), x, y)

proc gtk_fixed_remove(self: ptr Fixed00; widget: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: Fixed; widget: Widget) =
  gtk_fixed_remove(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_fixed_set_child_transform(self: ptr Fixed00; widget: ptr Widget00;
    transform: ptr gsk.Transform00) {.
    importc, libprag.}

proc setChildTransform*(self: Fixed; widget: Widget; transform: gsk.Transform = nil) =
  gtk_fixed_set_child_transform(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl), if transform.isNil: nil else: cast[ptr gsk.Transform00](transform.impl))

type
  Revealer* = ref object of Widget
  Revealer00* = object of Widget00

proc gtk_revealer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Revealer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_revealer_new(): ptr Revealer00 {.
    importc, libprag.}

proc newRevealer*(): Revealer =
  let gobj = gtk_revealer_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRevealer*(tdesc: typedesc): tdesc =
  assert(result is Revealer)
  let gobj = gtk_revealer_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRevealer*[T](result: var T) {.deprecated.} =
  assert(result is Revealer)
  let gobj = gtk_revealer_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_revealer_get_child(self: ptr Revealer00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: Revealer): Widget =
  let gobj = gtk_revealer_get_child(cast[ptr Revealer00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Revealer): Widget =
  let gobj = gtk_revealer_get_child(cast[ptr Revealer00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_revealer_get_child_revealed(self: ptr Revealer00): gboolean {.
    importc, libprag.}

proc getChildRevealed*(self: Revealer): bool =
  toBool(gtk_revealer_get_child_revealed(cast[ptr Revealer00](self.impl)))

proc childRevealed*(self: Revealer): bool =
  toBool(gtk_revealer_get_child_revealed(cast[ptr Revealer00](self.impl)))

proc gtk_revealer_get_reveal_child(self: ptr Revealer00): gboolean {.
    importc, libprag.}

proc getRevealChild*(self: Revealer): bool =
  toBool(gtk_revealer_get_reveal_child(cast[ptr Revealer00](self.impl)))

proc revealChild*(self: Revealer): bool =
  toBool(gtk_revealer_get_reveal_child(cast[ptr Revealer00](self.impl)))

proc gtk_revealer_get_transition_duration(self: ptr Revealer00): uint32 {.
    importc, libprag.}

proc getTransitionDuration*(self: Revealer): int =
  int(gtk_revealer_get_transition_duration(cast[ptr Revealer00](self.impl)))

proc transitionDuration*(self: Revealer): int =
  int(gtk_revealer_get_transition_duration(cast[ptr Revealer00](self.impl)))

proc gtk_revealer_set_child(self: ptr Revealer00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: Revealer; child: Widget = nil) =
  gtk_revealer_set_child(cast[ptr Revealer00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: Revealer; child: Widget = nil) =
  gtk_revealer_set_child(cast[ptr Revealer00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_revealer_set_reveal_child(self: ptr Revealer00; revealChild: gboolean) {.
    importc, libprag.}

proc setRevealChild*(self: Revealer; revealChild: bool = true) =
  gtk_revealer_set_reveal_child(cast[ptr Revealer00](self.impl), gboolean(revealChild))

proc `revealChild=`*(self: Revealer; revealChild: bool) =
  gtk_revealer_set_reveal_child(cast[ptr Revealer00](self.impl), gboolean(revealChild))

proc gtk_revealer_set_transition_duration(self: ptr Revealer00; duration: uint32) {.
    importc, libprag.}

proc setTransitionDuration*(self: Revealer; duration: int) =
  gtk_revealer_set_transition_duration(cast[ptr Revealer00](self.impl), uint32(duration))

proc `transitionDuration=`*(self: Revealer; duration: int) =
  gtk_revealer_set_transition_duration(cast[ptr Revealer00](self.impl), uint32(duration))

type
  Grid* = ref object of Widget
  Grid00* = object of Widget00

proc gtk_grid_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Grid()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_grid_new(): ptr Grid00 {.
    importc, libprag.}

proc newGrid*(): Grid =
  let gobj = gtk_grid_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGrid*(tdesc: typedesc): tdesc =
  assert(result is Grid)
  let gobj = gtk_grid_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGrid*[T](result: var T) {.deprecated.} =
  assert(result is Grid)
  let gobj = gtk_grid_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_attach(self: ptr Grid00; child: ptr Widget00; column: int32;
    row: int32; width: int32; height: int32) {.
    importc, libprag.}

proc attach*(self: Grid; child: Widget; column: int; row: int; width: int = 1;
    height: int = 1) =
  gtk_grid_attach(cast[ptr Grid00](self.impl), cast[ptr Widget00](child.impl), int32(column), int32(row), int32(width), int32(height))

proc gtk_grid_attach_next_to(self: ptr Grid00; child: ptr Widget00; sibling: ptr Widget00;
    side: PositionType; width: int32; height: int32) {.
    importc, libprag.}

proc attachNextTo*(self: Grid; child: Widget; sibling: Widget = nil;
    side: PositionType; width: int; height: int) =
  gtk_grid_attach_next_to(cast[ptr Grid00](self.impl), cast[ptr Widget00](child.impl), if sibling.isNil: nil else: cast[ptr Widget00](sibling.impl), side, int32(width), int32(height))

proc gtk_grid_get_baseline_row(self: ptr Grid00): int32 {.
    importc, libprag.}

proc getBaselineRow*(self: Grid): int =
  int(gtk_grid_get_baseline_row(cast[ptr Grid00](self.impl)))

proc baselineRow*(self: Grid): int =
  int(gtk_grid_get_baseline_row(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_child_at(self: ptr Grid00; column: int32; row: int32): ptr Widget00 {.
    importc, libprag.}

proc getChildAt*(self: Grid; column: int; row: int): Widget =
  let gobj = gtk_grid_get_child_at(cast[ptr Grid00](self.impl), int32(column), int32(row))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_get_column_homogeneous(self: ptr Grid00): gboolean {.
    importc, libprag.}

proc getColumnHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_column_homogeneous(cast[ptr Grid00](self.impl)))

proc columnHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_column_homogeneous(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_column_spacing(self: ptr Grid00): uint32 {.
    importc, libprag.}

proc getColumnSpacing*(self: Grid): int =
  int(gtk_grid_get_column_spacing(cast[ptr Grid00](self.impl)))

proc columnSpacing*(self: Grid): int =
  int(gtk_grid_get_column_spacing(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_row_baseline_position(self: ptr Grid00; row: int32): BaselinePosition {.
    importc, libprag.}

proc getRowBaselinePosition*(self: Grid; row: int): BaselinePosition =
  gtk_grid_get_row_baseline_position(cast[ptr Grid00](self.impl), int32(row))

proc gtk_grid_get_row_homogeneous(self: ptr Grid00): gboolean {.
    importc, libprag.}

proc getRowHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_row_homogeneous(cast[ptr Grid00](self.impl)))

proc rowHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_row_homogeneous(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_row_spacing(self: ptr Grid00): uint32 {.
    importc, libprag.}

proc getRowSpacing*(self: Grid): int =
  int(gtk_grid_get_row_spacing(cast[ptr Grid00](self.impl)))

proc rowSpacing*(self: Grid): int =
  int(gtk_grid_get_row_spacing(cast[ptr Grid00](self.impl)))

proc gtk_grid_insert_column(self: ptr Grid00; position: int32) {.
    importc, libprag.}

proc insertColumn*(self: Grid; position: int) =
  gtk_grid_insert_column(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_insert_next_to(self: ptr Grid00; sibling: ptr Widget00; side: PositionType) {.
    importc, libprag.}

proc insertNextTo*(self: Grid; sibling: Widget; side: PositionType) =
  gtk_grid_insert_next_to(cast[ptr Grid00](self.impl), cast[ptr Widget00](sibling.impl), side)

proc gtk_grid_insert_row(self: ptr Grid00; position: int32) {.
    importc, libprag.}

proc insertRow*(self: Grid; position: int) =
  gtk_grid_insert_row(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_query_child(self: ptr Grid00; child: ptr Widget00; column: var int32;
    row: var int32; width: var int32; height: var int32) {.
    importc, libprag.}

proc queryChild*(self: Grid; child: Widget; column: var int = cast[var int](nil);
    row: var int = cast[var int](nil); width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var column_00: int32
  var height_00: int32
  var width_00: int32
  var row_00: int32
  gtk_grid_query_child(cast[ptr Grid00](self.impl), cast[ptr Widget00](child.impl), column_00, row_00, width_00, height_00)
  if column.addr != nil:
    column = int(column_00)
  if height.addr != nil:
    height = int(height_00)
  if width.addr != nil:
    width = int(width_00)
  if row.addr != nil:
    row = int(row_00)

proc gtk_grid_remove(self: ptr Grid00; child: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: Grid; child: Widget) =
  gtk_grid_remove(cast[ptr Grid00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_grid_remove_column(self: ptr Grid00; position: int32) {.
    importc, libprag.}

proc removeColumn*(self: Grid; position: int) =
  gtk_grid_remove_column(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_remove_row(self: ptr Grid00; position: int32) {.
    importc, libprag.}

proc removeRow*(self: Grid; position: int) =
  gtk_grid_remove_row(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_set_baseline_row(self: ptr Grid00; row: int32) {.
    importc, libprag.}

proc setBaselineRow*(self: Grid; row: int) =
  gtk_grid_set_baseline_row(cast[ptr Grid00](self.impl), int32(row))

proc `baselineRow=`*(self: Grid; row: int) =
  gtk_grid_set_baseline_row(cast[ptr Grid00](self.impl), int32(row))

proc gtk_grid_set_column_homogeneous(self: ptr Grid00; homogeneous: gboolean) {.
    importc, libprag.}

proc setColumnHomogeneous*(self: Grid; homogeneous: bool = true) =
  gtk_grid_set_column_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc `columnHomogeneous=`*(self: Grid; homogeneous: bool) =
  gtk_grid_set_column_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc gtk_grid_set_column_spacing(self: ptr Grid00; spacing: uint32) {.
    importc, libprag.}

proc setColumnSpacing*(self: Grid; spacing: int) =
  gtk_grid_set_column_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

proc `columnSpacing=`*(self: Grid; spacing: int) =
  gtk_grid_set_column_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

proc gtk_grid_set_row_baseline_position(self: ptr Grid00; row: int32; pos: BaselinePosition) {.
    importc, libprag.}

proc setRowBaselinePosition*(self: Grid; row: int; pos: BaselinePosition) =
  gtk_grid_set_row_baseline_position(cast[ptr Grid00](self.impl), int32(row), pos)

proc gtk_grid_set_row_homogeneous(self: ptr Grid00; homogeneous: gboolean) {.
    importc, libprag.}

proc setRowHomogeneous*(self: Grid; homogeneous: bool = true) =
  gtk_grid_set_row_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc `rowHomogeneous=`*(self: Grid; homogeneous: bool) =
  gtk_grid_set_row_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc gtk_grid_set_row_spacing(self: ptr Grid00; spacing: uint32) {.
    importc, libprag.}

proc setRowSpacing*(self: Grid; spacing: int) =
  gtk_grid_set_row_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

proc `rowSpacing=`*(self: Grid; spacing: int) =
  gtk_grid_set_row_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

type
  Picture* = ref object of Widget
  Picture00* = object of Widget00

proc gtk_picture_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Picture()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_picture_new(): ptr Picture00 {.
    importc, libprag.}

proc newPicture*(): Picture =
  let gobj = gtk_picture_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPicture*(tdesc: typedesc): tdesc =
  assert(result is Picture)
  let gobj = gtk_picture_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPicture*[T](result: var T) {.deprecated.} =
  assert(result is Picture)
  let gobj = gtk_picture_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_picture_new_for_file(file: ptr gio.GFile00): ptr Picture00 {.
    importc, libprag.}

proc newPictureForFile*(file: gio.GFile = nil): Picture =
  let gobj = gtk_picture_new_for_file(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPictureForFile*(tdesc: typedesc; file: gio.GFile = nil): tdesc =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_file(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPictureForFile*[T](result: var T; file: gio.GFile = nil) {.deprecated.} =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_file(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_picture_new_for_filename(filename: cstring): ptr Picture00 {.
    importc, libprag.}

proc newPictureForFilename*(filename: cstring = nil): Picture =
  let gobj = gtk_picture_new_for_filename(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPictureForFilename*(tdesc: typedesc; filename: cstring = nil): tdesc =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_filename(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPictureForFilename*[T](result: var T; filename: cstring = nil) {.deprecated.} =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_filename(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_picture_new_for_paintable(paintable: ptr gdk4.Paintable00): ptr Picture00 {.
    importc, libprag.}

proc newPictureForPaintable*(paintable: gdk4.Paintable = nil): Picture =
  let gobj = gtk_picture_new_for_paintable(if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPictureForPaintable*(tdesc: typedesc; paintable: gdk4.Paintable = nil): tdesc =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_paintable(if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPictureForPaintable*[T](result: var T; paintable: gdk4.Paintable = nil) {.deprecated.} =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_paintable(if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_picture_new_for_pixbuf(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr Picture00 {.
    importc, libprag.}

proc newPictureForPixbuf*(pixbuf: gdkpixbuf.Pixbuf = nil): Picture {.deprecated.}  =
  let gobj = gtk_picture_new_for_pixbuf(if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPictureForPixbuf*(tdesc: typedesc; pixbuf: gdkpixbuf.Pixbuf = nil): tdesc {.deprecated.}  =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_pixbuf(if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPictureForPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf = nil) {.deprecated.} =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_pixbuf(if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_picture_new_for_resource(resourcePath: cstring): ptr Picture00 {.
    importc, libprag.}

proc newPictureForResource*(resourcePath: cstring = nil): Picture =
  let gobj = gtk_picture_new_for_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPictureForResource*(tdesc: typedesc; resourcePath: cstring = nil): tdesc =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPictureForResource*[T](result: var T; resourcePath: cstring = nil) {.deprecated.} =
  assert(result is Picture)
  let gobj = gtk_picture_new_for_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_picture_get_alternative_text(self: ptr Picture00): cstring {.
    importc, libprag.}

proc getAlternativeText*(self: Picture): string =
  let resul0 = gtk_picture_get_alternative_text(cast[ptr Picture00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc alternativeText*(self: Picture): string =
  let resul0 = gtk_picture_get_alternative_text(cast[ptr Picture00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_picture_get_can_shrink(self: ptr Picture00): gboolean {.
    importc, libprag.}

proc getCanShrink*(self: Picture): bool =
  toBool(gtk_picture_get_can_shrink(cast[ptr Picture00](self.impl)))

proc canShrink*(self: Picture): bool =
  toBool(gtk_picture_get_can_shrink(cast[ptr Picture00](self.impl)))

proc gtk_picture_get_file(self: ptr Picture00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: Picture): gio.GFile =
  let gobj = gtk_picture_get_file(cast[ptr Picture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: Picture): gio.GFile =
  let gobj = gtk_picture_get_file(cast[ptr Picture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_picture_get_keep_aspect_ratio(self: ptr Picture00): gboolean {.
    importc, libprag.}

proc getKeepAspectRatio*(self: Picture): bool =
  toBool(gtk_picture_get_keep_aspect_ratio(cast[ptr Picture00](self.impl)))

proc keepAspectRatio*(self: Picture): bool =
  toBool(gtk_picture_get_keep_aspect_ratio(cast[ptr Picture00](self.impl)))

proc gtk_picture_get_paintable(self: ptr Picture00): ptr gdk4.Paintable00 {.
    importc, libprag.}

proc getPaintable*(self: Picture): gdk4.Paintable =
  let gobj = gtk_picture_get_paintable(cast[ptr Picture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc paintable*(self: Picture): gdk4.Paintable =
  let gobj = gtk_picture_get_paintable(cast[ptr Picture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_picture_set_alternative_text(self: ptr Picture00; alternativeText: cstring) {.
    importc, libprag.}

proc setAlternativeText*(self: Picture; alternativeText: cstring = nil) =
  gtk_picture_set_alternative_text(cast[ptr Picture00](self.impl), alternativeText)

proc `alternativeText=`*(self: Picture; alternativeText: cstring = nil) =
  gtk_picture_set_alternative_text(cast[ptr Picture00](self.impl), alternativeText)

proc gtk_picture_set_can_shrink(self: ptr Picture00; canShrink: gboolean) {.
    importc, libprag.}

proc setCanShrink*(self: Picture; canShrink: bool = true) =
  gtk_picture_set_can_shrink(cast[ptr Picture00](self.impl), gboolean(canShrink))

proc `canShrink=`*(self: Picture; canShrink: bool) =
  gtk_picture_set_can_shrink(cast[ptr Picture00](self.impl), gboolean(canShrink))

proc gtk_picture_set_file(self: ptr Picture00; file: ptr gio.GFile00) {.
    importc, libprag.}

proc setFile*(self: Picture; file: gio.GFile = nil) =
  gtk_picture_set_file(cast[ptr Picture00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc `file=`*(self: Picture; file: gio.GFile = nil) =
  gtk_picture_set_file(cast[ptr Picture00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc gtk_picture_set_filename(self: ptr Picture00; filename: cstring) {.
    importc, libprag.}

proc setFilename*(self: Picture; filename: cstring = nil) =
  gtk_picture_set_filename(cast[ptr Picture00](self.impl), filename)

proc `filename=`*(self: Picture; filename: cstring = nil) =
  gtk_picture_set_filename(cast[ptr Picture00](self.impl), filename)

proc gtk_picture_set_keep_aspect_ratio(self: ptr Picture00; keepAspectRatio: gboolean) {.
    importc, libprag.}

proc setKeepAspectRatio*(self: Picture; keepAspectRatio: bool = true) =
  gtk_picture_set_keep_aspect_ratio(cast[ptr Picture00](self.impl), gboolean(keepAspectRatio))

proc `keepAspectRatio=`*(self: Picture; keepAspectRatio: bool) =
  gtk_picture_set_keep_aspect_ratio(cast[ptr Picture00](self.impl), gboolean(keepAspectRatio))

proc gtk_picture_set_paintable(self: ptr Picture00; paintable: ptr gdk4.Paintable00) {.
    importc, libprag.}

proc setPaintable*(self: Picture; paintable: gdk4.Paintable = nil) =
  gtk_picture_set_paintable(cast[ptr Picture00](self.impl), if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))

proc `paintable=`*(self: Picture; paintable: gdk4.Paintable = nil) =
  gtk_picture_set_paintable(cast[ptr Picture00](self.impl), if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl))

proc gtk_picture_set_pixbuf(self: ptr Picture00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setPixbuf*(self: Picture; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_picture_set_pixbuf(cast[ptr Picture00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `pixbuf=`*(self: Picture; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_picture_set_pixbuf(cast[ptr Picture00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_picture_set_resource(self: ptr Picture00; resourcePath: cstring) {.
    importc, libprag.}

proc setResource*(self: Picture; resourcePath: cstring = nil) =
  gtk_picture_set_resource(cast[ptr Picture00](self.impl), resourcePath)

proc `resource=`*(self: Picture; resourcePath: cstring = nil) =
  gtk_picture_set_resource(cast[ptr Picture00](self.impl), resourcePath)

type
  NotebookTab* {.size: sizeof(cint), pure.} = enum
    first = 0
    last = 1

type
  Notebook* = ref object of Widget
  Notebook00* = object of Widget00

proc gtk_notebook_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Notebook()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChangeCurrentPage*(self: Notebook;  p: proc (self: ptr Notebook00; obj: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "change-current-page", cast[GCallback](p), xdata, nil, cf)

proc scCreateWindow*(self: Notebook;  p: proc (self: ptr Notebook00; page: ptr Widget00; xdata: pointer): ptr Notebook00 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "create-window", cast[GCallback](p), xdata, nil, cf)

proc scFocusTab*(self: Notebook;  p: proc (self: ptr Notebook00; obj: NotebookTab; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus-tab", cast[GCallback](p), xdata, nil, cf)

proc scMoveFocusOut*(self: Notebook;  p: proc (self: ptr Notebook00; obj: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-focus-out", cast[GCallback](p), xdata, nil, cf)

proc scPageAdded*(self: Notebook;  p: proc (self: ptr Notebook00; child: ptr Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "page-added", cast[GCallback](p), xdata, nil, cf)

proc scPageRemoved*(self: Notebook;  p: proc (self: ptr Notebook00; child: ptr Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "page-removed", cast[GCallback](p), xdata, nil, cf)

proc scPageReordered*(self: Notebook;  p: proc (self: ptr Notebook00; child: ptr Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "page-reordered", cast[GCallback](p), xdata, nil, cf)

proc scReorderTab*(self: Notebook;  p: proc (self: ptr Notebook00; obj: DirectionType; p0: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "reorder-tab", cast[GCallback](p), xdata, nil, cf)

proc scSelectPage*(self: Notebook;  p: proc (self: ptr Notebook00; obj: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-page", cast[GCallback](p), xdata, nil, cf)

proc scSwitchPage*(self: Notebook;  p: proc (self: ptr Notebook00; page: ptr Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "switch-page", cast[GCallback](p), xdata, nil, cf)

proc gtk_notebook_new(): ptr Notebook00 {.
    importc, libprag.}

proc newNotebook*(): Notebook =
  let gobj = gtk_notebook_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newNotebook*(tdesc: typedesc): tdesc =
  assert(result is Notebook)
  let gobj = gtk_notebook_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initNotebook*[T](result: var T) {.deprecated.} =
  assert(result is Notebook)
  let gobj = gtk_notebook_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_append_page(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00): int32 {.
    importc, libprag.}

proc appendPage*(self: Notebook; child: Widget; tabLabel: Widget = nil): int =
  int(gtk_notebook_append_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl)))

proc gtk_notebook_append_page_menu(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00; menuLabel: ptr Widget00): int32 {.
    importc, libprag.}

proc appendPageMenu*(self: Notebook; child: Widget; tabLabel: Widget = nil;
    menuLabel: Widget = nil): int =
  int(gtk_notebook_append_page_menu(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl), if menuLabel.isNil: nil else: cast[ptr Widget00](menuLabel.impl)))

proc gtk_notebook_detach_tab(self: ptr Notebook00; child: ptr Widget00) {.
    importc, libprag.}

proc detachTab*(self: Notebook; child: Widget) =
  gtk_notebook_detach_tab(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_notebook_get_current_page(self: ptr Notebook00): int32 {.
    importc, libprag.}

proc getCurrentPage*(self: Notebook): int =
  int(gtk_notebook_get_current_page(cast[ptr Notebook00](self.impl)))

proc currentPage*(self: Notebook): int =
  int(gtk_notebook_get_current_page(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_group_name(self: ptr Notebook00): cstring {.
    importc, libprag.}

proc getGroupName*(self: Notebook): string =
  let resul0 = gtk_notebook_get_group_name(cast[ptr Notebook00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc groupName*(self: Notebook): string =
  let resul0 = gtk_notebook_get_group_name(cast[ptr Notebook00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_notebook_get_menu_label(self: ptr Notebook00; child: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getMenuLabel*(self: Notebook; child: Widget): Widget =
  let gobj = gtk_notebook_get_menu_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_menu_label_text(self: ptr Notebook00; child: ptr Widget00): cstring {.
    importc, libprag.}

proc getMenuLabelText*(self: Notebook; child: Widget): string =
  let resul0 = gtk_notebook_get_menu_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_notebook_get_n_pages(self: ptr Notebook00): int32 {.
    importc, libprag.}

proc getNPages*(self: Notebook): int =
  int(gtk_notebook_get_n_pages(cast[ptr Notebook00](self.impl)))

proc nPages*(self: Notebook): int =
  int(gtk_notebook_get_n_pages(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_nth_page(self: ptr Notebook00; pageNum: int32): ptr Widget00 {.
    importc, libprag.}

proc getNthPage*(self: Notebook; pageNum: int): Widget =
  let gobj = gtk_notebook_get_nth_page(cast[ptr Notebook00](self.impl), int32(pageNum))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_pages(self: ptr Notebook00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getPages*(self: Notebook): gio.ListModel =
  let gobj = gtk_notebook_get_pages(cast[ptr Notebook00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pages*(self: Notebook): gio.ListModel =
  let gobj = gtk_notebook_get_pages(cast[ptr Notebook00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_scrollable(self: ptr Notebook00): gboolean {.
    importc, libprag.}

proc getScrollable*(self: Notebook): bool =
  toBool(gtk_notebook_get_scrollable(cast[ptr Notebook00](self.impl)))

proc scrollable*(self: Notebook): bool =
  toBool(gtk_notebook_get_scrollable(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_show_border(self: ptr Notebook00): gboolean {.
    importc, libprag.}

proc getShowBorder*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_border(cast[ptr Notebook00](self.impl)))

proc showBorder*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_border(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_show_tabs(self: ptr Notebook00): gboolean {.
    importc, libprag.}

proc getShowTabs*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_tabs(cast[ptr Notebook00](self.impl)))

proc showTabs*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_tabs(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_tab_detachable(self: ptr Notebook00; child: ptr Widget00): gboolean {.
    importc, libprag.}

proc getTabDetachable*(self: Notebook; child: Widget): bool =
  toBool(gtk_notebook_get_tab_detachable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_notebook_get_tab_label(self: ptr Notebook00; child: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getTabLabel*(self: Notebook; child: Widget): Widget =
  let gobj = gtk_notebook_get_tab_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_tab_label_text(self: ptr Notebook00; child: ptr Widget00): cstring {.
    importc, libprag.}

proc getTabLabelText*(self: Notebook; child: Widget): string =
  let resul0 = gtk_notebook_get_tab_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_notebook_get_tab_pos(self: ptr Notebook00): PositionType {.
    importc, libprag.}

proc getTabPos*(self: Notebook): PositionType =
  gtk_notebook_get_tab_pos(cast[ptr Notebook00](self.impl))

proc tabPos*(self: Notebook): PositionType =
  gtk_notebook_get_tab_pos(cast[ptr Notebook00](self.impl))

proc gtk_notebook_get_tab_reorderable(self: ptr Notebook00; child: ptr Widget00): gboolean {.
    importc, libprag.}

proc getTabReorderable*(self: Notebook; child: Widget): bool =
  toBool(gtk_notebook_get_tab_reorderable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_notebook_insert_page(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00; position: int32): int32 {.
    importc, libprag.}

proc insertPage*(self: Notebook; child: Widget; tabLabel: Widget = nil;
    position: int): int =
  int(gtk_notebook_insert_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl), int32(position)))

proc gtk_notebook_insert_page_menu(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00; menuLabel: ptr Widget00; position: int32): int32 {.
    importc, libprag.}

proc insertPageMenu*(self: Notebook; child: Widget; tabLabel: Widget = nil;
    menuLabel: Widget = nil; position: int): int =
  int(gtk_notebook_insert_page_menu(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl), if menuLabel.isNil: nil else: cast[ptr Widget00](menuLabel.impl), int32(position)))

proc gtk_notebook_next_page(self: ptr Notebook00) {.
    importc, libprag.}

proc nextPage*(self: Notebook) =
  gtk_notebook_next_page(cast[ptr Notebook00](self.impl))

proc gtk_notebook_page_num(self: ptr Notebook00; child: ptr Widget00): int32 {.
    importc, libprag.}

proc pageNum*(self: Notebook; child: Widget): int =
  int(gtk_notebook_page_num(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_notebook_popup_disable(self: ptr Notebook00) {.
    importc, libprag.}

proc popupDisable*(self: Notebook) =
  gtk_notebook_popup_disable(cast[ptr Notebook00](self.impl))

proc gtk_notebook_popup_enable(self: ptr Notebook00) {.
    importc, libprag.}

proc popupEnable*(self: Notebook) =
  gtk_notebook_popup_enable(cast[ptr Notebook00](self.impl))

proc gtk_notebook_prepend_page(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00): int32 {.
    importc, libprag.}

proc prependPage*(self: Notebook; child: Widget; tabLabel: Widget = nil): int =
  int(gtk_notebook_prepend_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl)))

proc gtk_notebook_prepend_page_menu(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00; menuLabel: ptr Widget00): int32 {.
    importc, libprag.}

proc prependPageMenu*(self: Notebook; child: Widget; tabLabel: Widget = nil;
    menuLabel: Widget = nil): int =
  int(gtk_notebook_prepend_page_menu(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl), if menuLabel.isNil: nil else: cast[ptr Widget00](menuLabel.impl)))

proc gtk_notebook_prev_page(self: ptr Notebook00) {.
    importc, libprag.}

proc prevPage*(self: Notebook) =
  gtk_notebook_prev_page(cast[ptr Notebook00](self.impl))

proc gtk_notebook_remove_page(self: ptr Notebook00; pageNum: int32) {.
    importc, libprag.}

proc removePage*(self: Notebook; pageNum: int) =
  gtk_notebook_remove_page(cast[ptr Notebook00](self.impl), int32(pageNum))

proc gtk_notebook_reorder_child(self: ptr Notebook00; child: ptr Widget00;
    position: int32) {.
    importc, libprag.}

proc reorderChild*(self: Notebook; child: Widget; position: int) =
  gtk_notebook_reorder_child(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_notebook_set_current_page(self: ptr Notebook00; pageNum: int32) {.
    importc, libprag.}

proc setCurrentPage*(self: Notebook; pageNum: int) =
  gtk_notebook_set_current_page(cast[ptr Notebook00](self.impl), int32(pageNum))

proc `currentPage=`*(self: Notebook; pageNum: int) =
  gtk_notebook_set_current_page(cast[ptr Notebook00](self.impl), int32(pageNum))

proc gtk_notebook_set_group_name(self: ptr Notebook00; groupName: cstring) {.
    importc, libprag.}

proc setGroupName*(self: Notebook; groupName: cstring = nil) =
  gtk_notebook_set_group_name(cast[ptr Notebook00](self.impl), groupName)

proc `groupName=`*(self: Notebook; groupName: cstring = nil) =
  gtk_notebook_set_group_name(cast[ptr Notebook00](self.impl), groupName)

proc gtk_notebook_set_menu_label(self: ptr Notebook00; child: ptr Widget00;
    menuLabel: ptr Widget00) {.
    importc, libprag.}

proc setMenuLabel*(self: Notebook; child: Widget; menuLabel: Widget = nil) =
  gtk_notebook_set_menu_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if menuLabel.isNil: nil else: cast[ptr Widget00](menuLabel.impl))

proc gtk_notebook_set_menu_label_text(self: ptr Notebook00; child: ptr Widget00;
    menuText: cstring) {.
    importc, libprag.}

proc setMenuLabelText*(self: Notebook; child: Widget; menuText: cstring) =
  gtk_notebook_set_menu_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), menuText)

proc gtk_notebook_set_scrollable(self: ptr Notebook00; scrollable: gboolean) {.
    importc, libprag.}

proc setScrollable*(self: Notebook; scrollable: bool = true) =
  gtk_notebook_set_scrollable(cast[ptr Notebook00](self.impl), gboolean(scrollable))

proc `scrollable=`*(self: Notebook; scrollable: bool) =
  gtk_notebook_set_scrollable(cast[ptr Notebook00](self.impl), gboolean(scrollable))

proc gtk_notebook_set_show_border(self: ptr Notebook00; showBorder: gboolean) {.
    importc, libprag.}

proc setShowBorder*(self: Notebook; showBorder: bool = true) =
  gtk_notebook_set_show_border(cast[ptr Notebook00](self.impl), gboolean(showBorder))

proc `showBorder=`*(self: Notebook; showBorder: bool) =
  gtk_notebook_set_show_border(cast[ptr Notebook00](self.impl), gboolean(showBorder))

proc gtk_notebook_set_show_tabs(self: ptr Notebook00; showTabs: gboolean) {.
    importc, libprag.}

proc setShowTabs*(self: Notebook; showTabs: bool = true) =
  gtk_notebook_set_show_tabs(cast[ptr Notebook00](self.impl), gboolean(showTabs))

proc `showTabs=`*(self: Notebook; showTabs: bool) =
  gtk_notebook_set_show_tabs(cast[ptr Notebook00](self.impl), gboolean(showTabs))

proc gtk_notebook_set_tab_detachable(self: ptr Notebook00; child: ptr Widget00;
    detachable: gboolean) {.
    importc, libprag.}

proc setTabDetachable*(self: Notebook; child: Widget; detachable: bool) =
  gtk_notebook_set_tab_detachable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), gboolean(detachable))

proc gtk_notebook_set_tab_label(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00) {.
    importc, libprag.}

proc setTabLabel*(self: Notebook; child: Widget; tabLabel: Widget = nil) =
  gtk_notebook_set_tab_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl))

proc gtk_notebook_set_tab_label_text(self: ptr Notebook00; child: ptr Widget00;
    tabText: cstring) {.
    importc, libprag.}

proc setTabLabelText*(self: Notebook; child: Widget; tabText: cstring) =
  gtk_notebook_set_tab_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), tabText)

proc gtk_notebook_set_tab_pos(self: ptr Notebook00; pos: PositionType) {.
    importc, libprag.}

proc setTabPos*(self: Notebook; pos: PositionType) =
  gtk_notebook_set_tab_pos(cast[ptr Notebook00](self.impl), pos)

proc `tabPos=`*(self: Notebook; pos: PositionType) =
  gtk_notebook_set_tab_pos(cast[ptr Notebook00](self.impl), pos)

proc gtk_notebook_set_tab_reorderable(self: ptr Notebook00; child: ptr Widget00;
    reorderable: gboolean) {.
    importc, libprag.}

proc setTabReorderable*(self: Notebook; child: Widget; reorderable: bool) =
  gtk_notebook_set_tab_reorderable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), gboolean(reorderable))

type
  TreeViewColumn* = ref object of gobject.InitiallyUnowned
  TreeViewColumn00* = object of gobject.InitiallyUnowned00

proc gtk_tree_view_column_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeViewColumn()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClicked*(self: TreeViewColumn;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "clicked", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_view_column_new(): ptr TreeViewColumn00 {.
    importc, libprag.}

proc newTreeViewColumn*(): TreeViewColumn {.deprecated.}  =
  let gobj = gtk_tree_view_column_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeViewColumn*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is TreeViewColumn)
  let gobj = gtk_tree_view_column_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeViewColumn*[T](result: var T) {.deprecated.} =
  assert(result is TreeViewColumn)
  let gobj = gtk_tree_view_column_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_cell_get_size(self: ptr TreeViewColumn00; xOffset: var int32;
    yOffset: var int32; width: var int32; height: var int32) {.
    importc, libprag.}

proc cellGetSize*(self: TreeViewColumn; xOffset: var int = cast[var int](nil);
    yOffset: var int = cast[var int](nil); width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var height_00: int32
  var yOffset_00: int32
  var width_00: int32
  var xOffset_00: int32
  gtk_tree_view_column_cell_get_size(cast[ptr TreeViewColumn00](self.impl), xOffset_00, yOffset_00, width_00, height_00)
  if height.addr != nil:
    height = int(height_00)
  if yOffset.addr != nil:
    yOffset = int(yOffset_00)
  if width.addr != nil:
    width = int(width_00)
  if xOffset.addr != nil:
    xOffset = int(xOffset_00)

proc gtk_tree_view_column_cell_is_visible(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc cellIsVisible*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_cell_is_visible(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_cell_set_cell_data(self: ptr TreeViewColumn00;
    treeModel: ptr TreeModel00; iter: TreeIter; isExpander: gboolean; isExpanded: gboolean) {.
    importc, libprag.}

proc cellSetCellData*(self: TreeViewColumn; treeModel: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter; isExpander: bool; isExpanded: bool) =
  gtk_tree_view_column_cell_set_cell_data(cast[ptr TreeViewColumn00](self.impl), cast[ptr TreeModel00](treeModel.impl), iter, gboolean(isExpander), gboolean(isExpanded))

proc gtk_tree_view_column_clear(self: ptr TreeViewColumn00) {.
    importc, libprag.}

proc clear*(self: TreeViewColumn) =
  gtk_tree_view_column_clear(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_clicked(self: ptr TreeViewColumn00) {.
    importc, libprag.}

proc clicked*(self: TreeViewColumn) =
  gtk_tree_view_column_clicked(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_get_alignment(self: ptr TreeViewColumn00): cfloat {.
    importc, libprag.}

proc getAlignment*(self: TreeViewColumn): cfloat =
  gtk_tree_view_column_get_alignment(cast[ptr TreeViewColumn00](self.impl))

proc alignment*(self: TreeViewColumn): cfloat =
  gtk_tree_view_column_get_alignment(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_get_button(self: ptr TreeViewColumn00): ptr Widget00 {.
    importc, libprag.}

proc getButton*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_button(cast[ptr TreeViewColumn00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc button*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_button(cast[ptr TreeViewColumn00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_get_clickable(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getClickable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_clickable(cast[ptr TreeViewColumn00](self.impl)))

proc clickable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_clickable(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_expand(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getExpand*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_expand(cast[ptr TreeViewColumn00](self.impl)))

proc expand*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_expand(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_fixed_width(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getFixedWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_fixed_width(cast[ptr TreeViewColumn00](self.impl)))

proc fixedWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_fixed_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_max_width(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getMaxWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_max_width(cast[ptr TreeViewColumn00](self.impl)))

proc maxWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_max_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_min_width(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getMinWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_min_width(cast[ptr TreeViewColumn00](self.impl)))

proc minWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_min_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_reorderable(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getReorderable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_reorderable(cast[ptr TreeViewColumn00](self.impl)))

proc reorderable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_reorderable(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_resizable(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getResizable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_resizable(cast[ptr TreeViewColumn00](self.impl)))

proc resizable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_resizable(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_sort_column_id(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getSortColumnId*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_sort_column_id(cast[ptr TreeViewColumn00](self.impl)))

proc sortColumnId*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_sort_column_id(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_sort_indicator(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getSortIndicator*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_sort_indicator(cast[ptr TreeViewColumn00](self.impl)))

proc sortIndicator*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_sort_indicator(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_spacing(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getSpacing*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_spacing(cast[ptr TreeViewColumn00](self.impl)))

proc spacing*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_spacing(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_title(self: ptr TreeViewColumn00): cstring {.
    importc, libprag.}

proc getTitle*(self: TreeViewColumn): string =
  result = $gtk_tree_view_column_get_title(cast[ptr TreeViewColumn00](self.impl))

proc title*(self: TreeViewColumn): string =
  result = $gtk_tree_view_column_get_title(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_get_tree_view(self: ptr TreeViewColumn00): ptr Widget00 {.
    importc, libprag.}

proc getTreeView*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_tree_view(cast[ptr TreeViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc treeView*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_tree_view(cast[ptr TreeViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_get_visible(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getVisible*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_visible(cast[ptr TreeViewColumn00](self.impl)))

proc visible*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_visible(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_widget(self: ptr TreeViewColumn00): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_widget(cast[ptr TreeViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_widget(cast[ptr TreeViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_get_width(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_width(cast[ptr TreeViewColumn00](self.impl)))

proc width*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_x_offset(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getXOffset*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_x_offset(cast[ptr TreeViewColumn00](self.impl)))

proc xOffset*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_x_offset(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_queue_resize(self: ptr TreeViewColumn00) {.
    importc, libprag.}

proc queueResize*(self: TreeViewColumn) =
  gtk_tree_view_column_queue_resize(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_set_alignment(self: ptr TreeViewColumn00; xalign: cfloat) {.
    importc, libprag.}

proc setAlignment*(self: TreeViewColumn; xalign: cfloat) =
  gtk_tree_view_column_set_alignment(cast[ptr TreeViewColumn00](self.impl), xalign)

proc `alignment=`*(self: TreeViewColumn; xalign: cfloat) =
  gtk_tree_view_column_set_alignment(cast[ptr TreeViewColumn00](self.impl), xalign)

proc gtk_tree_view_column_set_clickable(self: ptr TreeViewColumn00; clickable: gboolean) {.
    importc, libprag.}

proc setClickable*(self: TreeViewColumn; clickable: bool = true) =
  gtk_tree_view_column_set_clickable(cast[ptr TreeViewColumn00](self.impl), gboolean(clickable))

proc `clickable=`*(self: TreeViewColumn; clickable: bool) =
  gtk_tree_view_column_set_clickable(cast[ptr TreeViewColumn00](self.impl), gboolean(clickable))

proc gtk_tree_view_column_set_expand(self: ptr TreeViewColumn00; expand: gboolean) {.
    importc, libprag.}

proc setExpand*(self: TreeViewColumn; expand: bool = true) =
  gtk_tree_view_column_set_expand(cast[ptr TreeViewColumn00](self.impl), gboolean(expand))

proc `expand=`*(self: TreeViewColumn; expand: bool) =
  gtk_tree_view_column_set_expand(cast[ptr TreeViewColumn00](self.impl), gboolean(expand))

proc gtk_tree_view_column_set_fixed_width(self: ptr TreeViewColumn00; fixedWidth: int32) {.
    importc, libprag.}

proc setFixedWidth*(self: TreeViewColumn; fixedWidth: int) =
  gtk_tree_view_column_set_fixed_width(cast[ptr TreeViewColumn00](self.impl), int32(fixedWidth))

proc `fixedWidth=`*(self: TreeViewColumn; fixedWidth: int) =
  gtk_tree_view_column_set_fixed_width(cast[ptr TreeViewColumn00](self.impl), int32(fixedWidth))

proc gtk_tree_view_column_set_max_width(self: ptr TreeViewColumn00; maxWidth: int32) {.
    importc, libprag.}

proc setMaxWidth*(self: TreeViewColumn; maxWidth: int) =
  gtk_tree_view_column_set_max_width(cast[ptr TreeViewColumn00](self.impl), int32(maxWidth))

proc `maxWidth=`*(self: TreeViewColumn; maxWidth: int) =
  gtk_tree_view_column_set_max_width(cast[ptr TreeViewColumn00](self.impl), int32(maxWidth))

proc gtk_tree_view_column_set_min_width(self: ptr TreeViewColumn00; minWidth: int32) {.
    importc, libprag.}

proc setMinWidth*(self: TreeViewColumn; minWidth: int) =
  gtk_tree_view_column_set_min_width(cast[ptr TreeViewColumn00](self.impl), int32(minWidth))

proc `minWidth=`*(self: TreeViewColumn; minWidth: int) =
  gtk_tree_view_column_set_min_width(cast[ptr TreeViewColumn00](self.impl), int32(minWidth))

proc gtk_tree_view_column_set_reorderable(self: ptr TreeViewColumn00; reorderable: gboolean) {.
    importc, libprag.}

proc setReorderable*(self: TreeViewColumn; reorderable: bool = true) =
  gtk_tree_view_column_set_reorderable(cast[ptr TreeViewColumn00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: TreeViewColumn; reorderable: bool) =
  gtk_tree_view_column_set_reorderable(cast[ptr TreeViewColumn00](self.impl), gboolean(reorderable))

proc gtk_tree_view_column_set_resizable(self: ptr TreeViewColumn00; resizable: gboolean) {.
    importc, libprag.}

proc setResizable*(self: TreeViewColumn; resizable: bool = true) =
  gtk_tree_view_column_set_resizable(cast[ptr TreeViewColumn00](self.impl), gboolean(resizable))

proc `resizable=`*(self: TreeViewColumn; resizable: bool) =
  gtk_tree_view_column_set_resizable(cast[ptr TreeViewColumn00](self.impl), gboolean(resizable))

proc gtk_tree_view_column_set_sort_column_id(self: ptr TreeViewColumn00;
    sortColumnId: int32) {.
    importc, libprag.}

proc setSortColumnId*(self: TreeViewColumn; sortColumnId: int) =
  gtk_tree_view_column_set_sort_column_id(cast[ptr TreeViewColumn00](self.impl), int32(sortColumnId))

proc `sortColumnId=`*(self: TreeViewColumn; sortColumnId: int) =
  gtk_tree_view_column_set_sort_column_id(cast[ptr TreeViewColumn00](self.impl), int32(sortColumnId))

proc gtk_tree_view_column_set_sort_indicator(self: ptr TreeViewColumn00;
    setting: gboolean) {.
    importc, libprag.}

proc setSortIndicator*(self: TreeViewColumn; setting: bool = true) =
  gtk_tree_view_column_set_sort_indicator(cast[ptr TreeViewColumn00](self.impl), gboolean(setting))

proc `sortIndicator=`*(self: TreeViewColumn; setting: bool) =
  gtk_tree_view_column_set_sort_indicator(cast[ptr TreeViewColumn00](self.impl), gboolean(setting))

proc gtk_tree_view_column_set_spacing(self: ptr TreeViewColumn00; spacing: int32) {.
    importc, libprag.}

proc setSpacing*(self: TreeViewColumn; spacing: int) =
  gtk_tree_view_column_set_spacing(cast[ptr TreeViewColumn00](self.impl), int32(spacing))

proc `spacing=`*(self: TreeViewColumn; spacing: int) =
  gtk_tree_view_column_set_spacing(cast[ptr TreeViewColumn00](self.impl), int32(spacing))

proc gtk_tree_view_column_set_title(self: ptr TreeViewColumn00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: TreeViewColumn; title: cstring) =
  gtk_tree_view_column_set_title(cast[ptr TreeViewColumn00](self.impl), title)

proc `title=`*(self: TreeViewColumn; title: cstring) =
  gtk_tree_view_column_set_title(cast[ptr TreeViewColumn00](self.impl), title)

proc gtk_tree_view_column_set_visible(self: ptr TreeViewColumn00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: TreeViewColumn; visible: bool = true) =
  gtk_tree_view_column_set_visible(cast[ptr TreeViewColumn00](self.impl), gboolean(visible))

proc `visible=`*(self: TreeViewColumn; visible: bool) =
  gtk_tree_view_column_set_visible(cast[ptr TreeViewColumn00](self.impl), gboolean(visible))

proc gtk_tree_view_column_set_widget(self: ptr TreeViewColumn00; widget: ptr Widget00) {.
    importc, libprag.}

proc setWidget*(self: TreeViewColumn; widget: Widget = nil) =
  gtk_tree_view_column_set_widget(cast[ptr TreeViewColumn00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `widget=`*(self: TreeViewColumn; widget: Widget = nil) =
  gtk_tree_view_column_set_widget(cast[ptr TreeViewColumn00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

type
  TreeView* = ref object of Widget
  TreeView00* = object of Widget00

proc gtk_tree_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scColumnsChanged*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "columns-changed", cast[GCallback](p), xdata, nil, cf)

proc scCursorChanged*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cursor-changed", cast[GCallback](p), xdata, nil, cf)

proc scExpandCollapseCursorRow*(self: TreeView;  p: proc (self: ptr TreeView00; obj: gboolean; p0: gboolean; p1: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "expand-collapse-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: TreeView;  p: proc (self: ptr TreeView00; step: MovementStep; direction: int32; extend: gboolean; modify: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scRowActivated*(self: TreeView;  p: proc (self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-activated", cast[GCallback](p), xdata, nil, cf)

proc scRowCollapsed*(self: TreeView;  p: proc (self: ptr TreeView00; iter: TreeIter; path: ptr TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-collapsed", cast[GCallback](p), xdata, nil, cf)

proc scRowExpanded*(self: TreeView;  p: proc (self: ptr TreeView00; iter: TreeIter; path: ptr TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-expanded", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSelectCursorParent*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-cursor-parent", cast[GCallback](p), xdata, nil, cf)

proc scSelectCursorRow*(self: TreeView;  p: proc (self: ptr TreeView00; obj: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scStartInteractiveSearch*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "start-interactive-search", cast[GCallback](p), xdata, nil, cf)

proc scTestCollapseRow*(self: TreeView;  p: proc (self: ptr TreeView00; iter: TreeIter; path: ptr TreePath00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "test-collapse-row", cast[GCallback](p), xdata, nil, cf)

proc scTestExpandRow*(self: TreeView;  p: proc (self: ptr TreeView00; iter: TreeIter; path: ptr TreePath00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "test-expand-row", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorRow*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scUnselectAll*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_view_new(): ptr TreeView00 {.
    importc, libprag.}

proc newTreeView*(): TreeView {.deprecated.}  =
  let gobj = gtk_tree_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeView*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is TreeView)
  let gobj = gtk_tree_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeView*[T](result: var T) {.deprecated.} =
  assert(result is TreeView)
  let gobj = gtk_tree_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_new_with_model(model: ptr TreeModel00): ptr TreeView00 {.
    importc, libprag.}

proc newTreeViewWithModel*(model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): TreeView {.deprecated.}  =
  let gobj = gtk_tree_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeViewWithModel*(tdesc: typedesc; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore): tdesc {.deprecated.}  =
  assert(result is TreeView)
  let gobj = gtk_tree_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeViewWithModel*[T](result: var T; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) {.deprecated.} =
  assert(result is TreeView)
  let gobj = gtk_tree_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_append_column(self: ptr TreeView00; column: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc appendColumn*(self: TreeView; column: TreeViewColumn): int =
  int(gtk_tree_view_append_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl)))

proc gtk_tree_view_collapse_all(self: ptr TreeView00) {.
    importc, libprag.}

proc collapseAll*(self: TreeView) =
  gtk_tree_view_collapse_all(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_collapse_row(self: ptr TreeView00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc collapseRow*(self: TreeView; path: TreePath): bool =
  toBool(gtk_tree_view_collapse_row(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_view_columns_autosize(self: ptr TreeView00) {.
    importc, libprag.}

proc columnsAutosize*(self: TreeView) =
  gtk_tree_view_columns_autosize(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_convert_bin_window_to_tree_coords(self: ptr TreeView00;
    bx: int32; by: int32; tx: var int32; ty: var int32) {.
    importc, libprag.}

proc convertBinWindowToTreeCoords*(self: TreeView; bx: int;
    by: int; tx: var int; ty: var int) =
  var ty_00: int32
  var tx_00: int32
  gtk_tree_view_convert_bin_window_to_tree_coords(cast[ptr TreeView00](self.impl), int32(bx), int32(by), tx_00, ty_00)
  if ty.addr != nil:
    ty = int(ty_00)
  if tx.addr != nil:
    tx = int(tx_00)

proc gtk_tree_view_convert_bin_window_to_widget_coords(self: ptr TreeView00;
    bx: int32; by: int32; wx: var int32; wy: var int32) {.
    importc, libprag.}

proc convertBinWindowToWidgetCoords*(self: TreeView; bx: int;
    by: int; wx: var int; wy: var int) =
  var wx_00: int32
  var wy_00: int32
  gtk_tree_view_convert_bin_window_to_widget_coords(cast[ptr TreeView00](self.impl), int32(bx), int32(by), wx_00, wy_00)
  if wx.addr != nil:
    wx = int(wx_00)
  if wy.addr != nil:
    wy = int(wy_00)

proc gtk_tree_view_convert_tree_to_bin_window_coords(self: ptr TreeView00;
    tx: int32; ty: int32; bx: var int32; by: var int32) {.
    importc, libprag.}

proc convertTreeToBinWindowCoords*(self: TreeView; tx: int;
    ty: int; bx: var int; by: var int) =
  var by_00: int32
  var bx_00: int32
  gtk_tree_view_convert_tree_to_bin_window_coords(cast[ptr TreeView00](self.impl), int32(tx), int32(ty), bx_00, by_00)
  if by.addr != nil:
    by = int(by_00)
  if bx.addr != nil:
    bx = int(bx_00)

proc gtk_tree_view_convert_tree_to_widget_coords(self: ptr TreeView00; tx: int32;
    ty: int32; wx: var int32; wy: var int32) {.
    importc, libprag.}

proc convertTreeToWidgetCoords*(self: TreeView; tx: int;
    ty: int; wx: var int; wy: var int) =
  var wx_00: int32
  var wy_00: int32
  gtk_tree_view_convert_tree_to_widget_coords(cast[ptr TreeView00](self.impl), int32(tx), int32(ty), wx_00, wy_00)
  if wx.addr != nil:
    wx = int(wx_00)
  if wy.addr != nil:
    wy = int(wy_00)

proc gtk_tree_view_convert_widget_to_bin_window_coords(self: ptr TreeView00;
    wx: int32; wy: int32; bx: var int32; by: var int32) {.
    importc, libprag.}

proc convertWidgetToBinWindowCoords*(self: TreeView; wx: int;
    wy: int; bx: var int; by: var int) =
  var by_00: int32
  var bx_00: int32
  gtk_tree_view_convert_widget_to_bin_window_coords(cast[ptr TreeView00](self.impl), int32(wx), int32(wy), bx_00, by_00)
  if by.addr != nil:
    by = int(by_00)
  if bx.addr != nil:
    bx = int(bx_00)

proc gtk_tree_view_convert_widget_to_tree_coords(self: ptr TreeView00; wx: int32;
    wy: int32; tx: var int32; ty: var int32) {.
    importc, libprag.}

proc convertWidgetToTreeCoords*(self: TreeView; wx: int;
    wy: int; tx: var int; ty: var int) =
  var ty_00: int32
  var tx_00: int32
  gtk_tree_view_convert_widget_to_tree_coords(cast[ptr TreeView00](self.impl), int32(wx), int32(wy), tx_00, ty_00)
  if ty.addr != nil:
    ty = int(ty_00)
  if tx.addr != nil:
    tx = int(tx_00)

proc gtk_tree_view_create_row_drag_icon(self: ptr TreeView00; path: ptr TreePath00): ptr gdk4.Paintable00 {.
    importc, libprag.}

proc createRowDragIcon*(self: TreeView; path: TreePath): gdk4.Paintable =
  let gobj = gtk_tree_view_create_row_drag_icon(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_enable_model_drag_dest(self: ptr TreeView00; formats: ptr gdk4.ContentFormats00;
    actions: gdk4.DragAction) {.
    importc, libprag.}

proc enableModelDragDest*(self: TreeView; formats: gdk4.ContentFormats;
    actions: gdk4.DragAction) =
  gtk_tree_view_enable_model_drag_dest(cast[ptr TreeView00](self.impl), cast[ptr gdk4.ContentFormats00](formats.impl), actions)

proc gtk_tree_view_enable_model_drag_source(self: ptr TreeView00; startButtonMask: gdk4.ModifierType;
    formats: ptr gdk4.ContentFormats00; actions: gdk4.DragAction) {.
    importc, libprag.}

proc enableModelDragSource*(self: TreeView; startButtonMask: gdk4.ModifierType;
    formats: gdk4.ContentFormats; actions: gdk4.DragAction) =
  gtk_tree_view_enable_model_drag_source(cast[ptr TreeView00](self.impl), startButtonMask, cast[ptr gdk4.ContentFormats00](formats.impl), actions)

proc gtk_tree_view_expand_all(self: ptr TreeView00) {.
    importc, libprag.}

proc expandAll*(self: TreeView) =
  gtk_tree_view_expand_all(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_expand_row(self: ptr TreeView00; path: ptr TreePath00;
    openAll: gboolean): gboolean {.
    importc, libprag.}

proc expandRow*(self: TreeView; path: TreePath; openAll: bool): bool =
  toBool(gtk_tree_view_expand_row(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), gboolean(openAll)))

proc gtk_tree_view_expand_to_path(self: ptr TreeView00; path: ptr TreePath00) {.
    importc, libprag.}

proc expandToPath*(self: TreeView; path: TreePath) =
  gtk_tree_view_expand_to_path(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_view_get_activate_on_single_click(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getActivateOnSingleClick*(self: TreeView): bool =
  toBool(gtk_tree_view_get_activate_on_single_click(cast[ptr TreeView00](self.impl)))

proc activateOnSingleClick*(self: TreeView): bool =
  toBool(gtk_tree_view_get_activate_on_single_click(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_background_area(self: ptr TreeView00; path: ptr TreePath00;
    column: ptr TreeViewColumn00; rect: var gdk4.Rectangle) {.
    importc, libprag.}

proc getBackgroundArea*(self: TreeView; path: TreePath = nil;
    column: TreeViewColumn = nil; rect: var gdk4.Rectangle) =
  gtk_tree_view_get_background_area(cast[ptr TreeView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl), rect)

proc gtk_tree_view_get_cell_area(self: ptr TreeView00; path: ptr TreePath00;
    column: ptr TreeViewColumn00; rect: var gdk4.Rectangle) {.
    importc, libprag.}

proc getCellArea*(self: TreeView; path: TreePath = nil; column: TreeViewColumn = nil;
    rect: var gdk4.Rectangle) =
  gtk_tree_view_get_cell_area(cast[ptr TreeView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl), rect)

proc gtk_tree_view_get_column(self: ptr TreeView00; n: int32): ptr TreeViewColumn00 {.
    importc, libprag.}

proc getColumn*(self: TreeView; n: int): TreeViewColumn =
  let gobj = gtk_tree_view_get_column(cast[ptr TreeView00](self.impl), int32(n))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_columns(self: ptr TreeView00): ptr glib.List {.
    importc, libprag.}

proc getColumns*(self: TreeView): seq[TreeViewColumn] =
  let resul0 = gtk_tree_view_get_columns(cast[ptr TreeView00](self.impl))
  result = glistObjects2seq(TreeViewColumn, resul0, false)
  g_list_free(resul0)

proc columns*(self: TreeView): seq[TreeViewColumn] =
  let resul0 = gtk_tree_view_get_columns(cast[ptr TreeView00](self.impl))
  result = glistObjects2seq(TreeViewColumn, resul0, false)
  g_list_free(resul0)

proc gtk_tree_view_get_cursor(self: ptr TreeView00; path: var ptr TreePath00;
    focusColumn: var ptr TreeViewColumn00) {.
    importc, libprag.}

proc getCursor*(self: TreeView; path: var TreePath = cast[var TreePath](nil);
    focusColumn: var TreeViewColumn = cast[var TreeViewColumn](nil)) =
  var tmpoutgobjectarg: ptr TreeViewColumn00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  gtk_tree_view_get_cursor(cast[ptr TreeView00](self.impl), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr TreeViewColumn00](if addr(focusColumn) == nil: nil else: addr tmpoutgobjectarg))
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil
#  dothemagic(focusColumn
  if addr(focusColumn) != nil:
    focusColumn = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      focusColumn = cast[type(focusColumn)](argqdata)
      assert(focusColumn.impl == tmpoutgobjectarg)
    else:
      fnew(focusColumn, gtk4.finalizeGObject)
      focusColumn.impl = tmpoutgobjectarg
      GC_ref(focusColumn)
      if g_object_is_floating(focusColumn.impl).int != 0:
        discard g_object_ref_sink(focusColumn.impl)
      g_object_add_toggle_ref(focusColumn.impl, toggleNotify, addr(focusColumn[]))
      g_object_unref(focusColumn.impl)
      assert(g_object_get_qdata(focusColumn.impl, Quark) == nil)
      g_object_set_qdata(focusColumn.impl, Quark, addr(focusColumn[]))


proc gtk_tree_view_get_enable_search(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getEnableSearch*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_search(cast[ptr TreeView00](self.impl)))

proc enableSearch*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_search(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_enable_tree_lines(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getEnableTreeLines*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_tree_lines(cast[ptr TreeView00](self.impl)))

proc enableTreeLines*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_tree_lines(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_expander_column(self: ptr TreeView00): ptr TreeViewColumn00 {.
    importc, libprag.}

proc getExpanderColumn*(self: TreeView): TreeViewColumn =
  let gobj = gtk_tree_view_get_expander_column(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc expanderColumn*(self: TreeView): TreeViewColumn =
  let gobj = gtk_tree_view_get_expander_column(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_fixed_height_mode(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getFixedHeightMode*(self: TreeView): bool =
  toBool(gtk_tree_view_get_fixed_height_mode(cast[ptr TreeView00](self.impl)))

proc fixedHeightMode*(self: TreeView): bool =
  toBool(gtk_tree_view_get_fixed_height_mode(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_headers_clickable(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getHeadersClickable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_clickable(cast[ptr TreeView00](self.impl)))

proc headersClickable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_clickable(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_headers_visible(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getHeadersVisible*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_visible(cast[ptr TreeView00](self.impl)))

proc headersVisible*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_visible(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_hover_expand(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getHoverExpand*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_expand(cast[ptr TreeView00](self.impl)))

proc hoverExpand*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_expand(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_hover_selection(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getHoverSelection*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_selection(cast[ptr TreeView00](self.impl)))

proc hoverSelection*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_selection(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_level_indentation(self: ptr TreeView00): int32 {.
    importc, libprag.}

proc getLevelIndentation*(self: TreeView): int =
  int(gtk_tree_view_get_level_indentation(cast[ptr TreeView00](self.impl)))

proc levelIndentation*(self: TreeView): int =
  int(gtk_tree_view_get_level_indentation(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_model(self: ptr TreeView00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: TreeView): TreeModel =
  let gobj = gtk_tree_view_get_model(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: TreeView): TreeModel =
  let gobj = gtk_tree_view_get_model(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_n_columns(self: ptr TreeView00): uint32 {.
    importc, libprag.}

proc getNColumns*(self: TreeView): int =
  int(gtk_tree_view_get_n_columns(cast[ptr TreeView00](self.impl)))

proc nColumns*(self: TreeView): int =
  int(gtk_tree_view_get_n_columns(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_path_at_pos(self: ptr TreeView00; x: int32; y: int32;
    path: var ptr TreePath00; column: var ptr TreeViewColumn00; cellX: var int32;
    cellY: var int32): gboolean {.
    importc, libprag.}

proc getPathAtPos*(self: TreeView; x: int; y: int; path: var TreePath = cast[var TreePath](nil);
    column: var TreeViewColumn = cast[var TreeViewColumn](nil); cellX: var int = cast[var int](nil);
    cellY: var int = cast[var int](nil)): bool =
  var tmpoutgobjectarg: ptr TreeViewColumn00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  var cellX_00: int32
  var cellY_00: int32
  result = toBool(gtk_tree_view_get_path_at_pos(cast[ptr TreeView00](self.impl), int32(x), int32(y), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr TreeViewColumn00](if addr(column) == nil: nil else: addr tmpoutgobjectarg), cellX_00, cellY_00))
  if cellX.addr != nil:
    cellX = int(cellX_00)
  if cellY.addr != nil:
    cellY = int(cellY_00)
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil
#  dothemagic(column
  if addr(column) != nil:
    column = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      column = cast[type(column)](argqdata)
      assert(column.impl == tmpoutgobjectarg)
    else:
      fnew(column, gtk4.finalizeGObject)
      column.impl = tmpoutgobjectarg
      GC_ref(column)
      if g_object_is_floating(column.impl).int != 0:
        discard g_object_ref_sink(column.impl)
      g_object_add_toggle_ref(column.impl, toggleNotify, addr(column[]))
      g_object_unref(column.impl)
      assert(g_object_get_qdata(column.impl, Quark) == nil)
      g_object_set_qdata(column.impl, Quark, addr(column[]))


proc gtk_tree_view_get_reorderable(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getReorderable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_reorderable(cast[ptr TreeView00](self.impl)))

proc reorderable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_reorderable(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_rubber_banding(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getRubberBanding*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rubber_banding(cast[ptr TreeView00](self.impl)))

proc rubberBanding*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rubber_banding(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_search_column(self: ptr TreeView00): int32 {.
    importc, libprag.}

proc getSearchColumn*(self: TreeView): int =
  int(gtk_tree_view_get_search_column(cast[ptr TreeView00](self.impl)))

proc searchColumn*(self: TreeView): int =
  int(gtk_tree_view_get_search_column(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_show_expanders(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getShowExpanders*(self: TreeView): bool =
  toBool(gtk_tree_view_get_show_expanders(cast[ptr TreeView00](self.impl)))

proc showExpanders*(self: TreeView): bool =
  toBool(gtk_tree_view_get_show_expanders(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_tooltip_column(self: ptr TreeView00): int32 {.
    importc, libprag.}

proc getTooltipColumn*(self: TreeView): int =
  int(gtk_tree_view_get_tooltip_column(cast[ptr TreeView00](self.impl)))

proc tooltipColumn*(self: TreeView): int =
  int(gtk_tree_view_get_tooltip_column(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_tooltip_context(self: ptr TreeView00; x: int32; y: int32;
    keyboardTip: gboolean; model: var ptr TreeModel00; path: var ptr TreePath00;
    iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getTooltipContext*(self: TreeView; x: int; y: int; keyboardTip: bool;
    model: var (TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) = cast[var TreeModel](nil);
    path: var TreePath = cast[var TreePath](nil); iter: var TreeIter = cast[var TreeIter](nil)): bool =
  var tmpoutgobjectarg: ptr TreeModel00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_tree_view_get_tooltip_context(cast[ptr TreeView00](self.impl), int32(x), int32(y), gboolean(keyboardTip), cast[var ptr TreeModel00](if addr(model) == nil: nil else: addr tmpoutgobjectarg), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), iter))
#  dothemagic(model
  if addr(model) != nil:
    model = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      model = cast[type(model)](argqdata)
      assert(model.impl == tmpoutgobjectarg)
    else:
      fnew(model, gtk4.finalizeGObject)
      model.impl = tmpoutgobjectarg
      GC_ref(model)
      if g_object_is_floating(model.impl).int != 0:
        discard g_object_ref_sink(model.impl)
      g_object_add_toggle_ref(model.impl, toggleNotify, addr(model[]))
      g_object_unref(model.impl)
      assert(g_object_get_qdata(model.impl, Quark) == nil)
      g_object_set_qdata(model.impl, Quark, addr(model[]))


proc gtk_tree_view_get_visible_range(self: ptr TreeView00; startPath: var ptr TreePath00;
    endPath: var ptr TreePath00): gboolean {.
    importc, libprag.}

proc getVisibleRange*(self: TreeView; startPath: var TreePath = cast[var TreePath](nil);
    endPath: var TreePath = cast[var TreePath](nil)): bool =
  if addr(startPath) != nil:
    fnew(startPath, gBoxedFreeGtkTreePath)
  if addr(endPath) != nil:
    fnew(endPath, gBoxedFreeGtkTreePath)
  toBool(gtk_tree_view_get_visible_range(cast[ptr TreeView00](self.impl), cast[var ptr TreePath00](if addr(startPath) == nil: nil else: addr startPath.impl), cast[var ptr TreePath00](if addr(endPath) == nil: nil else: addr endPath.impl)))

proc gtk_tree_view_get_visible_rect(self: ptr TreeView00; visibleRect: var gdk4.Rectangle) {.
    importc, libprag.}

proc getVisibleRect*(self: TreeView; visibleRect: var gdk4.Rectangle) =
  gtk_tree_view_get_visible_rect(cast[ptr TreeView00](self.impl), visibleRect)

proc getVisibleRect*(self: TreeView): gdk4.Rectangle =
  gtk_tree_view_get_visible_rect(cast[ptr TreeView00](self.impl), result)

proc gtk_tree_view_insert_column(self: ptr TreeView00; column: ptr TreeViewColumn00;
    position: int32): int32 {.
    importc, libprag.}

proc insertColumn*(self: TreeView; column: TreeViewColumn;
    position: int): int =
  int(gtk_tree_view_insert_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl), int32(position)))

proc gtk_tree_view_is_blank_at_pos(self: ptr TreeView00; x: int32; y: int32;
    path: var ptr TreePath00; column: var ptr TreeViewColumn00; cellX: var int32;
    cellY: var int32): gboolean {.
    importc, libprag.}

proc isBlankAtPos*(self: TreeView; x: int; y: int; path: var TreePath = cast[var TreePath](nil);
    column: var TreeViewColumn = cast[var TreeViewColumn](nil); cellX: var int = cast[var int](nil);
    cellY: var int = cast[var int](nil)): bool =
  var tmpoutgobjectarg: ptr TreeViewColumn00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  var cellX_00: int32
  var cellY_00: int32
  result = toBool(gtk_tree_view_is_blank_at_pos(cast[ptr TreeView00](self.impl), int32(x), int32(y), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr TreeViewColumn00](if addr(column) == nil: nil else: addr tmpoutgobjectarg), cellX_00, cellY_00))
  if cellX.addr != nil:
    cellX = int(cellX_00)
  if cellY.addr != nil:
    cellY = int(cellY_00)
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil
#  dothemagic(column
  if addr(column) != nil:
    column = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      column = cast[type(column)](argqdata)
      assert(column.impl == tmpoutgobjectarg)
    else:
      fnew(column, gtk4.finalizeGObject)
      column.impl = tmpoutgobjectarg
      GC_ref(column)
      if g_object_is_floating(column.impl).int != 0:
        discard g_object_ref_sink(column.impl)
      g_object_add_toggle_ref(column.impl, toggleNotify, addr(column[]))
      g_object_unref(column.impl)
      assert(g_object_get_qdata(column.impl, Quark) == nil)
      g_object_set_qdata(column.impl, Quark, addr(column[]))


proc gtk_tree_view_is_rubber_banding_active(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc isRubberBandingActive*(self: TreeView): bool =
  toBool(gtk_tree_view_is_rubber_banding_active(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_move_column_after(self: ptr TreeView00; column: ptr TreeViewColumn00;
    baseColumn: ptr TreeViewColumn00) {.
    importc, libprag.}

proc moveColumnAfter*(self: TreeView; column: TreeViewColumn;
    baseColumn: TreeViewColumn = nil) =
  gtk_tree_view_move_column_after(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl), if baseColumn.isNil: nil else: cast[ptr TreeViewColumn00](baseColumn.impl))

proc gtk_tree_view_remove_column(self: ptr TreeView00; column: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc removeColumn*(self: TreeView; column: TreeViewColumn): int =
  int(gtk_tree_view_remove_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl)))

proc gtk_tree_view_row_activated(self: ptr TreeView00; path: ptr TreePath00;
    column: ptr TreeViewColumn00) {.
    importc, libprag.}

proc rowActivated*(self: TreeView; path: TreePath; column: TreeViewColumn = nil) =
  gtk_tree_view_row_activated(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl))

proc gtk_tree_view_row_expanded(self: ptr TreeView00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc rowExpanded*(self: TreeView; path: TreePath): bool =
  toBool(gtk_tree_view_row_expanded(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_view_scroll_to_cell(self: ptr TreeView00; path: ptr TreePath00;
    column: ptr TreeViewColumn00; useAlign: gboolean; rowAlign: cfloat; colAlign: cfloat) {.
    importc, libprag.}

proc scrollToCell*(self: TreeView; path: TreePath = nil; column: TreeViewColumn = nil;
    useAlign: bool; rowAlign: cfloat; colAlign: cfloat) =
  gtk_tree_view_scroll_to_cell(cast[ptr TreeView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl), gboolean(useAlign), rowAlign, colAlign)

proc gtk_tree_view_scroll_to_point(self: ptr TreeView00; treeX: int32; treeY: int32) {.
    importc, libprag.}

proc scrollToPoint*(self: TreeView; treeX: int; treeY: int) =
  gtk_tree_view_scroll_to_point(cast[ptr TreeView00](self.impl), int32(treeX), int32(treeY))

proc gtk_tree_view_set_activate_on_single_click(self: ptr TreeView00; single: gboolean) {.
    importc, libprag.}

proc setActivateOnSingleClick*(self: TreeView; single: bool = true) =
  gtk_tree_view_set_activate_on_single_click(cast[ptr TreeView00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: TreeView; single: bool) =
  gtk_tree_view_set_activate_on_single_click(cast[ptr TreeView00](self.impl), gboolean(single))

proc gtk_tree_view_set_cursor(self: ptr TreeView00; path: ptr TreePath00;
    focusColumn: ptr TreeViewColumn00; startEditing: gboolean) {.
    importc, libprag.}

proc setCursor*(self: TreeView; path: TreePath; focusColumn: TreeViewColumn = nil;
    startEditing: bool) =
  gtk_tree_view_set_cursor(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), if focusColumn.isNil: nil else: cast[ptr TreeViewColumn00](focusColumn.impl), gboolean(startEditing))

proc gtk_tree_view_set_enable_search(self: ptr TreeView00; enableSearch: gboolean) {.
    importc, libprag.}

proc setEnableSearch*(self: TreeView; enableSearch: bool = true) =
  gtk_tree_view_set_enable_search(cast[ptr TreeView00](self.impl), gboolean(enableSearch))

proc `enableSearch=`*(self: TreeView; enableSearch: bool) =
  gtk_tree_view_set_enable_search(cast[ptr TreeView00](self.impl), gboolean(enableSearch))

proc gtk_tree_view_set_enable_tree_lines(self: ptr TreeView00; enabled: gboolean) {.
    importc, libprag.}

proc setEnableTreeLines*(self: TreeView; enabled: bool = true) =
  gtk_tree_view_set_enable_tree_lines(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc `enableTreeLines=`*(self: TreeView; enabled: bool) =
  gtk_tree_view_set_enable_tree_lines(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc gtk_tree_view_set_expander_column(self: ptr TreeView00; column: ptr TreeViewColumn00) {.
    importc, libprag.}

proc setExpanderColumn*(self: TreeView; column: TreeViewColumn = nil) =
  gtk_tree_view_set_expander_column(cast[ptr TreeView00](self.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl))

proc `expanderColumn=`*(self: TreeView; column: TreeViewColumn = nil) =
  gtk_tree_view_set_expander_column(cast[ptr TreeView00](self.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl))

proc gtk_tree_view_set_fixed_height_mode(self: ptr TreeView00; enable: gboolean) {.
    importc, libprag.}

proc setFixedHeightMode*(self: TreeView; enable: bool = true) =
  gtk_tree_view_set_fixed_height_mode(cast[ptr TreeView00](self.impl), gboolean(enable))

proc `fixedHeightMode=`*(self: TreeView; enable: bool) =
  gtk_tree_view_set_fixed_height_mode(cast[ptr TreeView00](self.impl), gboolean(enable))

proc gtk_tree_view_set_headers_clickable(self: ptr TreeView00; setting: gboolean) {.
    importc, libprag.}

proc setHeadersClickable*(self: TreeView; setting: bool = true) =
  gtk_tree_view_set_headers_clickable(cast[ptr TreeView00](self.impl), gboolean(setting))

proc `headersClickable=`*(self: TreeView; setting: bool) =
  gtk_tree_view_set_headers_clickable(cast[ptr TreeView00](self.impl), gboolean(setting))

proc gtk_tree_view_set_headers_visible(self: ptr TreeView00; headersVisible: gboolean) {.
    importc, libprag.}

proc setHeadersVisible*(self: TreeView; headersVisible: bool = true) =
  gtk_tree_view_set_headers_visible(cast[ptr TreeView00](self.impl), gboolean(headersVisible))

proc `headersVisible=`*(self: TreeView; headersVisible: bool) =
  gtk_tree_view_set_headers_visible(cast[ptr TreeView00](self.impl), gboolean(headersVisible))

proc gtk_tree_view_set_hover_expand(self: ptr TreeView00; expand: gboolean) {.
    importc, libprag.}

proc setHoverExpand*(self: TreeView; expand: bool = true) =
  gtk_tree_view_set_hover_expand(cast[ptr TreeView00](self.impl), gboolean(expand))

proc `hoverExpand=`*(self: TreeView; expand: bool) =
  gtk_tree_view_set_hover_expand(cast[ptr TreeView00](self.impl), gboolean(expand))

proc gtk_tree_view_set_hover_selection(self: ptr TreeView00; hover: gboolean) {.
    importc, libprag.}

proc setHoverSelection*(self: TreeView; hover: bool = true) =
  gtk_tree_view_set_hover_selection(cast[ptr TreeView00](self.impl), gboolean(hover))

proc `hoverSelection=`*(self: TreeView; hover: bool) =
  gtk_tree_view_set_hover_selection(cast[ptr TreeView00](self.impl), gboolean(hover))

proc gtk_tree_view_set_level_indentation(self: ptr TreeView00; indentation: int32) {.
    importc, libprag.}

proc setLevelIndentation*(self: TreeView; indentation: int) =
  gtk_tree_view_set_level_indentation(cast[ptr TreeView00](self.impl), int32(indentation))

proc `levelIndentation=`*(self: TreeView; indentation: int) =
  gtk_tree_view_set_level_indentation(cast[ptr TreeView00](self.impl), int32(indentation))

proc gtk_tree_view_set_model(self: ptr TreeView00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: TreeView; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_tree_view_set_model(cast[ptr TreeView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: TreeView; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_tree_view_set_model(cast[ptr TreeView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc gtk_tree_view_set_reorderable(self: ptr TreeView00; reorderable: gboolean) {.
    importc, libprag.}

proc setReorderable*(self: TreeView; reorderable: bool = true) =
  gtk_tree_view_set_reorderable(cast[ptr TreeView00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: TreeView; reorderable: bool) =
  gtk_tree_view_set_reorderable(cast[ptr TreeView00](self.impl), gboolean(reorderable))

proc gtk_tree_view_set_rubber_banding(self: ptr TreeView00; enable: gboolean) {.
    importc, libprag.}

proc setRubberBanding*(self: TreeView; enable: bool = true) =
  gtk_tree_view_set_rubber_banding(cast[ptr TreeView00](self.impl), gboolean(enable))

proc `rubberBanding=`*(self: TreeView; enable: bool) =
  gtk_tree_view_set_rubber_banding(cast[ptr TreeView00](self.impl), gboolean(enable))

proc gtk_tree_view_set_search_column(self: ptr TreeView00; column: int32) {.
    importc, libprag.}

proc setSearchColumn*(self: TreeView; column: int) =
  gtk_tree_view_set_search_column(cast[ptr TreeView00](self.impl), int32(column))

proc `searchColumn=`*(self: TreeView; column: int) =
  gtk_tree_view_set_search_column(cast[ptr TreeView00](self.impl), int32(column))

proc gtk_tree_view_set_show_expanders(self: ptr TreeView00; enabled: gboolean) {.
    importc, libprag.}

proc setShowExpanders*(self: TreeView; enabled: bool = true) =
  gtk_tree_view_set_show_expanders(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc `showExpanders=`*(self: TreeView; enabled: bool) =
  gtk_tree_view_set_show_expanders(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc gtk_tree_view_set_tooltip_column(self: ptr TreeView00; column: int32) {.
    importc, libprag.}

proc setTooltipColumn*(self: TreeView; column: int) =
  gtk_tree_view_set_tooltip_column(cast[ptr TreeView00](self.impl), int32(column))

proc `tooltipColumn=`*(self: TreeView; column: int) =
  gtk_tree_view_set_tooltip_column(cast[ptr TreeView00](self.impl), int32(column))

proc gtk_tree_view_set_tooltip_row(self: ptr TreeView00; tooltip: ptr Tooltip00;
    path: ptr TreePath00) {.
    importc, libprag.}

proc setTooltipRow*(self: TreeView; tooltip: Tooltip; path: TreePath) =
  gtk_tree_view_set_tooltip_row(cast[ptr TreeView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_view_unset_rows_drag_dest(self: ptr TreeView00) {.
    importc, libprag.}

proc unsetRowsDragDest*(self: TreeView) =
  gtk_tree_view_unset_rows_drag_dest(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_unset_rows_drag_source(self: ptr TreeView00) {.
    importc, libprag.}

proc unsetRowsDragSource*(self: TreeView) =
  gtk_tree_view_unset_rows_drag_source(cast[ptr TreeView00](self.impl))

type
  SpinButton* = ref object of Widget
  SpinButton00* = object of Widget00

proc gtk_spin_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SpinButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scChangeValue*(self: SpinButton;  p: proc (self: ptr SpinButton00; scroll: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "change-value", cast[GCallback](p), xdata, nil, cf)

proc scInput*(self: SpinButton;  p: proc (self: ptr SpinButton00; newValue: var cdouble; xdata: pointer): int32 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "input", cast[GCallback](p), xdata, nil, cf)

proc scOutput*(self: SpinButton;  p: proc (self: ptr SpinButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "output", cast[GCallback](p), xdata, nil, cf)

proc scValueChanged*(self: SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cf)

proc scWrapped*(self: SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "wrapped", cast[GCallback](p), xdata, nil, cf)

proc gtk_spin_button_new_with_range(min: cdouble; max: cdouble; step: cdouble): ptr SpinButton00 {.
    importc, libprag.}

proc newSpinButtonWithRange*(min: cdouble; max: cdouble; step: cdouble): SpinButton =
  let gobj = gtk_spin_button_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSpinButtonWithRange*(tdesc: typedesc; min: cdouble; max: cdouble; step: cdouble): tdesc =
  assert(result is SpinButton)
  let gobj = gtk_spin_button_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSpinButtonWithRange*[T](result: var T; min: cdouble; max: cdouble; step: cdouble) {.deprecated.} =
  assert(result is SpinButton)
  let gobj = gtk_spin_button_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spin_button_get_activates_default(self: ptr SpinButton00): gboolean {.
    importc, libprag.}

proc getActivatesDefault*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_activates_default(cast[ptr SpinButton00](self.impl)))

proc activatesDefault*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_activates_default(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_climb_rate(self: ptr SpinButton00): cdouble {.
    importc, libprag.}

proc getClimbRate*(self: SpinButton): cdouble =
  gtk_spin_button_get_climb_rate(cast[ptr SpinButton00](self.impl))

proc climbRate*(self: SpinButton): cdouble =
  gtk_spin_button_get_climb_rate(cast[ptr SpinButton00](self.impl))

proc gtk_spin_button_get_digits(self: ptr SpinButton00): uint32 {.
    importc, libprag.}

proc getDigits*(self: SpinButton): int =
  int(gtk_spin_button_get_digits(cast[ptr SpinButton00](self.impl)))

proc digits*(self: SpinButton): int =
  int(gtk_spin_button_get_digits(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_increments(self: ptr SpinButton00; step: var cdouble;
    page: var cdouble) {.
    importc, libprag.}

proc getIncrements*(self: SpinButton; step: var cdouble = cast[var cdouble](nil);
    page: var cdouble = cast[var cdouble](nil)) =
  gtk_spin_button_get_increments(cast[ptr SpinButton00](self.impl), step, page)

proc gtk_spin_button_get_numeric(self: ptr SpinButton00): gboolean {.
    importc, libprag.}

proc getNumeric*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_numeric(cast[ptr SpinButton00](self.impl)))

proc numeric*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_numeric(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_range(self: ptr SpinButton00; min: var cdouble;
    max: var cdouble) {.
    importc, libprag.}

proc getRange*(self: SpinButton; min: var cdouble = cast[var cdouble](nil);
    max: var cdouble = cast[var cdouble](nil)) =
  gtk_spin_button_get_range(cast[ptr SpinButton00](self.impl), min, max)

proc gtk_spin_button_get_snap_to_ticks(self: ptr SpinButton00): gboolean {.
    importc, libprag.}

proc getSnapToTicks*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_snap_to_ticks(cast[ptr SpinButton00](self.impl)))

proc snapToTicks*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_snap_to_ticks(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_value(self: ptr SpinButton00): cdouble {.
    importc, libprag.}

proc getValue*(self: SpinButton): cdouble =
  gtk_spin_button_get_value(cast[ptr SpinButton00](self.impl))

proc value*(self: SpinButton): cdouble =
  gtk_spin_button_get_value(cast[ptr SpinButton00](self.impl))

proc gtk_spin_button_get_value_as_int(self: ptr SpinButton00): int32 {.
    importc, libprag.}

proc getValueAsInt*(self: SpinButton): int =
  int(gtk_spin_button_get_value_as_int(cast[ptr SpinButton00](self.impl)))

proc valueAsInt*(self: SpinButton): int =
  int(gtk_spin_button_get_value_as_int(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_wrap(self: ptr SpinButton00): gboolean {.
    importc, libprag.}

proc getWrap*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_wrap(cast[ptr SpinButton00](self.impl)))

proc wrap*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_wrap(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_set_activates_default(self: ptr SpinButton00; activatesDefault: gboolean) {.
    importc, libprag.}

proc setActivatesDefault*(self: SpinButton; activatesDefault: bool = true) =
  gtk_spin_button_set_activates_default(cast[ptr SpinButton00](self.impl), gboolean(activatesDefault))

proc `activatesDefault=`*(self: SpinButton; activatesDefault: bool) =
  gtk_spin_button_set_activates_default(cast[ptr SpinButton00](self.impl), gboolean(activatesDefault))

proc gtk_spin_button_set_climb_rate(self: ptr SpinButton00; climbRate: cdouble) {.
    importc, libprag.}

proc setClimbRate*(self: SpinButton; climbRate: cdouble) =
  gtk_spin_button_set_climb_rate(cast[ptr SpinButton00](self.impl), climbRate)

proc `climbRate=`*(self: SpinButton; climbRate: cdouble) =
  gtk_spin_button_set_climb_rate(cast[ptr SpinButton00](self.impl), climbRate)

proc gtk_spin_button_set_digits(self: ptr SpinButton00; digits: uint32) {.
    importc, libprag.}

proc setDigits*(self: SpinButton; digits: int) =
  gtk_spin_button_set_digits(cast[ptr SpinButton00](self.impl), uint32(digits))

proc `digits=`*(self: SpinButton; digits: int) =
  gtk_spin_button_set_digits(cast[ptr SpinButton00](self.impl), uint32(digits))

proc gtk_spin_button_set_increments(self: ptr SpinButton00; step: cdouble;
    page: cdouble) {.
    importc, libprag.}

proc setIncrements*(self: SpinButton; step: cdouble; page: cdouble) =
  gtk_spin_button_set_increments(cast[ptr SpinButton00](self.impl), step, page)

proc gtk_spin_button_set_numeric(self: ptr SpinButton00; numeric: gboolean) {.
    importc, libprag.}

proc setNumeric*(self: SpinButton; numeric: bool = true) =
  gtk_spin_button_set_numeric(cast[ptr SpinButton00](self.impl), gboolean(numeric))

proc `numeric=`*(self: SpinButton; numeric: bool) =
  gtk_spin_button_set_numeric(cast[ptr SpinButton00](self.impl), gboolean(numeric))

proc gtk_spin_button_set_range(self: ptr SpinButton00; min: cdouble; max: cdouble) {.
    importc, libprag.}

proc setRange*(self: SpinButton; min: cdouble; max: cdouble) =
  gtk_spin_button_set_range(cast[ptr SpinButton00](self.impl), min, max)

proc gtk_spin_button_set_snap_to_ticks(self: ptr SpinButton00; snapToTicks: gboolean) {.
    importc, libprag.}

proc setSnapToTicks*(self: SpinButton; snapToTicks: bool = true) =
  gtk_spin_button_set_snap_to_ticks(cast[ptr SpinButton00](self.impl), gboolean(snapToTicks))

proc `snapToTicks=`*(self: SpinButton; snapToTicks: bool) =
  gtk_spin_button_set_snap_to_ticks(cast[ptr SpinButton00](self.impl), gboolean(snapToTicks))

proc gtk_spin_button_set_value(self: ptr SpinButton00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: SpinButton; value: cdouble) =
  gtk_spin_button_set_value(cast[ptr SpinButton00](self.impl), value)

proc `value=`*(self: SpinButton; value: cdouble) =
  gtk_spin_button_set_value(cast[ptr SpinButton00](self.impl), value)

proc gtk_spin_button_set_wrap(self: ptr SpinButton00; wrap: gboolean) {.
    importc, libprag.}

proc setWrap*(self: SpinButton; wrap: bool = true) =
  gtk_spin_button_set_wrap(cast[ptr SpinButton00](self.impl), gboolean(wrap))

proc `wrap=`*(self: SpinButton; wrap: bool) =
  gtk_spin_button_set_wrap(cast[ptr SpinButton00](self.impl), gboolean(wrap))

proc gtk_spin_button_update(self: ptr SpinButton00) {.
    importc, libprag.}

proc update*(self: SpinButton) =
  gtk_spin_button_update(cast[ptr SpinButton00](self.impl))

type
  WindowHandle* = ref object of Widget
  WindowHandle00* = object of Widget00

proc gtk_window_handle_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(WindowHandle()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_window_handle_new(): ptr WindowHandle00 {.
    importc, libprag.}

proc newWindowHandle*(): WindowHandle =
  let gobj = gtk_window_handle_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newWindowHandle*(tdesc: typedesc): tdesc =
  assert(result is WindowHandle)
  let gobj = gtk_window_handle_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initWindowHandle*[T](result: var T) {.deprecated.} =
  assert(result is WindowHandle)
  let gobj = gtk_window_handle_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_handle_get_child(self: ptr WindowHandle00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: WindowHandle): Widget =
  let gobj = gtk_window_handle_get_child(cast[ptr WindowHandle00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: WindowHandle): Widget =
  let gobj = gtk_window_handle_get_child(cast[ptr WindowHandle00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_handle_set_child(self: ptr WindowHandle00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: WindowHandle; child: Widget = nil) =
  gtk_window_handle_set_child(cast[ptr WindowHandle00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: WindowHandle; child: Widget = nil) =
  gtk_window_handle_set_child(cast[ptr WindowHandle00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

type
  PopoverMenu* = ref object of Popover
  PopoverMenu00* = object of Popover00

proc gtk_popover_menu_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PopoverMenu()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_popover_menu_new_from_model(model: ptr gio.MenuModel00): ptr PopoverMenu00 {.
    importc, libprag.}

proc newPopoverMenu*(model: gio.MenuModel = nil): PopoverMenu =
  let gobj = gtk_popover_menu_new_from_model(if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPopoverMenu*(tdesc: typedesc; model: gio.MenuModel = nil): tdesc =
  assert(result is PopoverMenu)
  let gobj = gtk_popover_menu_new_from_model(if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopoverMenu*[T](result: var T; model: gio.MenuModel = nil) {.deprecated.} =
  assert(result is PopoverMenu)
  let gobj = gtk_popover_menu_new_from_model(if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_menu_add_child(self: ptr PopoverMenu00; child: ptr Widget00;
    id: cstring): gboolean {.
    importc, libprag.}

proc addChild*(self: PopoverMenu; child: Widget; id: cstring): bool =
  toBool(gtk_popover_menu_add_child(cast[ptr PopoverMenu00](self.impl), cast[ptr Widget00](child.impl), id))

proc gtk_popover_menu_get_menu_model(self: ptr PopoverMenu00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getMenuModel*(self: PopoverMenu): gio.MenuModel =
  let gobj = gtk_popover_menu_get_menu_model(cast[ptr PopoverMenu00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menuModel*(self: PopoverMenu): gio.MenuModel =
  let gobj = gtk_popover_menu_get_menu_model(cast[ptr PopoverMenu00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_menu_remove_child(self: ptr PopoverMenu00; child: ptr Widget00): gboolean {.
    importc, libprag.}

proc removeChild*(self: PopoverMenu; child: Widget): bool =
  toBool(gtk_popover_menu_remove_child(cast[ptr PopoverMenu00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_popover_menu_set_menu_model(self: ptr PopoverMenu00; model: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setMenuModel*(self: PopoverMenu; model: gio.MenuModel = nil) =
  gtk_popover_menu_set_menu_model(cast[ptr PopoverMenu00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc `menuModel=`*(self: PopoverMenu; model: gio.MenuModel = nil) =
  gtk_popover_menu_set_menu_model(cast[ptr PopoverMenu00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

type
  AspectFrame* = ref object of Widget
  AspectFrame00* = object of Widget00

proc gtk_aspect_frame_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AspectFrame()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_aspect_frame_new(xalign: cfloat; yalign: cfloat; ratio: cfloat;
    obeyChild: gboolean): ptr AspectFrame00 {.
    importc, libprag.}

proc newAspectFrame*(xalign: cfloat; yalign: cfloat; ratio: cfloat;
    obeyChild: bool): AspectFrame =
  let gobj = gtk_aspect_frame_new(xalign, yalign, ratio, gboolean(obeyChild))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAspectFrame*(tdesc: typedesc; xalign: cfloat; yalign: cfloat; ratio: cfloat;
    obeyChild: bool): tdesc =
  assert(result is AspectFrame)
  let gobj = gtk_aspect_frame_new(xalign, yalign, ratio, gboolean(obeyChild))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAspectFrame*[T](result: var T; xalign: cfloat; yalign: cfloat; ratio: cfloat;
    obeyChild: bool) {.deprecated.} =
  assert(result is AspectFrame)
  let gobj = gtk_aspect_frame_new(xalign, yalign, ratio, gboolean(obeyChild))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_aspect_frame_get_child(self: ptr AspectFrame00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: AspectFrame): Widget =
  let gobj = gtk_aspect_frame_get_child(cast[ptr AspectFrame00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: AspectFrame): Widget =
  let gobj = gtk_aspect_frame_get_child(cast[ptr AspectFrame00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_aspect_frame_get_obey_child(self: ptr AspectFrame00): gboolean {.
    importc, libprag.}

proc getObeyChild*(self: AspectFrame): bool =
  toBool(gtk_aspect_frame_get_obey_child(cast[ptr AspectFrame00](self.impl)))

proc obeyChild*(self: AspectFrame): bool =
  toBool(gtk_aspect_frame_get_obey_child(cast[ptr AspectFrame00](self.impl)))

proc gtk_aspect_frame_get_ratio(self: ptr AspectFrame00): cfloat {.
    importc, libprag.}

proc getRatio*(self: AspectFrame): cfloat =
  gtk_aspect_frame_get_ratio(cast[ptr AspectFrame00](self.impl))

proc ratio*(self: AspectFrame): cfloat =
  gtk_aspect_frame_get_ratio(cast[ptr AspectFrame00](self.impl))

proc gtk_aspect_frame_get_xalign(self: ptr AspectFrame00): cfloat {.
    importc, libprag.}

proc getXalign*(self: AspectFrame): cfloat =
  gtk_aspect_frame_get_xalign(cast[ptr AspectFrame00](self.impl))

proc xalign*(self: AspectFrame): cfloat =
  gtk_aspect_frame_get_xalign(cast[ptr AspectFrame00](self.impl))

proc gtk_aspect_frame_get_yalign(self: ptr AspectFrame00): cfloat {.
    importc, libprag.}

proc getYalign*(self: AspectFrame): cfloat =
  gtk_aspect_frame_get_yalign(cast[ptr AspectFrame00](self.impl))

proc yalign*(self: AspectFrame): cfloat =
  gtk_aspect_frame_get_yalign(cast[ptr AspectFrame00](self.impl))

proc gtk_aspect_frame_set_child(self: ptr AspectFrame00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: AspectFrame; child: Widget = nil) =
  gtk_aspect_frame_set_child(cast[ptr AspectFrame00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: AspectFrame; child: Widget = nil) =
  gtk_aspect_frame_set_child(cast[ptr AspectFrame00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_aspect_frame_set_obey_child(self: ptr AspectFrame00; obeyChild: gboolean) {.
    importc, libprag.}

proc setObeyChild*(self: AspectFrame; obeyChild: bool = true) =
  gtk_aspect_frame_set_obey_child(cast[ptr AspectFrame00](self.impl), gboolean(obeyChild))

proc `obeyChild=`*(self: AspectFrame; obeyChild: bool) =
  gtk_aspect_frame_set_obey_child(cast[ptr AspectFrame00](self.impl), gboolean(obeyChild))

proc gtk_aspect_frame_set_ratio(self: ptr AspectFrame00; ratio: cfloat) {.
    importc, libprag.}

proc setRatio*(self: AspectFrame; ratio: cfloat) =
  gtk_aspect_frame_set_ratio(cast[ptr AspectFrame00](self.impl), ratio)

proc `ratio=`*(self: AspectFrame; ratio: cfloat) =
  gtk_aspect_frame_set_ratio(cast[ptr AspectFrame00](self.impl), ratio)

proc gtk_aspect_frame_set_xalign(self: ptr AspectFrame00; xalign: cfloat) {.
    importc, libprag.}

proc setXalign*(self: AspectFrame; xalign: cfloat) =
  gtk_aspect_frame_set_xalign(cast[ptr AspectFrame00](self.impl), xalign)

proc `xalign=`*(self: AspectFrame; xalign: cfloat) =
  gtk_aspect_frame_set_xalign(cast[ptr AspectFrame00](self.impl), xalign)

proc gtk_aspect_frame_set_yalign(self: ptr AspectFrame00; yalign: cfloat) {.
    importc, libprag.}

proc setYalign*(self: AspectFrame; yalign: cfloat) =
  gtk_aspect_frame_set_yalign(cast[ptr AspectFrame00](self.impl), yalign)

proc `yalign=`*(self: AspectFrame; yalign: cfloat) =
  gtk_aspect_frame_set_yalign(cast[ptr AspectFrame00](self.impl), yalign)

type
  Paned* = ref object of Widget
  Paned00* = object of Widget00

proc gtk_paned_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Paned()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAcceptPosition*(self: Paned;  p: proc (self: ptr Paned00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accept-position", cast[GCallback](p), xdata, nil, cf)

proc scCancelPosition*(self: Paned;  p: proc (self: ptr Paned00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cancel-position", cast[GCallback](p), xdata, nil, cf)

proc scCycleChildFocus*(self: Paned;  p: proc (self: ptr Paned00; reversed: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cycle-child-focus", cast[GCallback](p), xdata, nil, cf)

proc scCycleHandleFocus*(self: Paned;  p: proc (self: ptr Paned00; reversed: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cycle-handle-focus", cast[GCallback](p), xdata, nil, cf)

proc scMoveHandle*(self: Paned;  p: proc (self: ptr Paned00; scrollType: ScrollType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-handle", cast[GCallback](p), xdata, nil, cf)

proc scToggleHandleFocus*(self: Paned;  p: proc (self: ptr Paned00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-handle-focus", cast[GCallback](p), xdata, nil, cf)

proc gtk_paned_get_end_child(self: ptr Paned00): ptr Widget00 {.
    importc, libprag.}

proc getEndChild*(self: Paned): Widget =
  let gobj = gtk_paned_get_end_child(cast[ptr Paned00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc endChild*(self: Paned): Widget =
  let gobj = gtk_paned_get_end_child(cast[ptr Paned00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_get_position(self: ptr Paned00): int32 {.
    importc, libprag.}

proc getPosition*(self: Paned): int =
  int(gtk_paned_get_position(cast[ptr Paned00](self.impl)))

proc position*(self: Paned): int =
  int(gtk_paned_get_position(cast[ptr Paned00](self.impl)))

proc gtk_paned_get_resize_end_child(self: ptr Paned00): gboolean {.
    importc, libprag.}

proc getResizeEndChild*(self: Paned): bool =
  toBool(gtk_paned_get_resize_end_child(cast[ptr Paned00](self.impl)))

proc resizeEndChild*(self: Paned): bool =
  toBool(gtk_paned_get_resize_end_child(cast[ptr Paned00](self.impl)))

proc gtk_paned_get_resize_start_child(self: ptr Paned00): gboolean {.
    importc, libprag.}

proc getResizeStartChild*(self: Paned): bool =
  toBool(gtk_paned_get_resize_start_child(cast[ptr Paned00](self.impl)))

proc resizeStartChild*(self: Paned): bool =
  toBool(gtk_paned_get_resize_start_child(cast[ptr Paned00](self.impl)))

proc gtk_paned_get_shrink_end_child(self: ptr Paned00): gboolean {.
    importc, libprag.}

proc getShrinkEndChild*(self: Paned): bool =
  toBool(gtk_paned_get_shrink_end_child(cast[ptr Paned00](self.impl)))

proc shrinkEndChild*(self: Paned): bool =
  toBool(gtk_paned_get_shrink_end_child(cast[ptr Paned00](self.impl)))

proc gtk_paned_get_shrink_start_child(self: ptr Paned00): gboolean {.
    importc, libprag.}

proc getShrinkStartChild*(self: Paned): bool =
  toBool(gtk_paned_get_shrink_start_child(cast[ptr Paned00](self.impl)))

proc shrinkStartChild*(self: Paned): bool =
  toBool(gtk_paned_get_shrink_start_child(cast[ptr Paned00](self.impl)))

proc gtk_paned_get_start_child(self: ptr Paned00): ptr Widget00 {.
    importc, libprag.}

proc getStartChild*(self: Paned): Widget =
  let gobj = gtk_paned_get_start_child(cast[ptr Paned00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc startChild*(self: Paned): Widget =
  let gobj = gtk_paned_get_start_child(cast[ptr Paned00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_get_wide_handle(self: ptr Paned00): gboolean {.
    importc, libprag.}

proc getWideHandle*(self: Paned): bool =
  toBool(gtk_paned_get_wide_handle(cast[ptr Paned00](self.impl)))

proc wideHandle*(self: Paned): bool =
  toBool(gtk_paned_get_wide_handle(cast[ptr Paned00](self.impl)))

proc gtk_paned_set_end_child(self: ptr Paned00; child: ptr Widget00) {.
    importc, libprag.}

proc setEndChild*(self: Paned; child: Widget = nil) =
  gtk_paned_set_end_child(cast[ptr Paned00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `endChild=`*(self: Paned; child: Widget = nil) =
  gtk_paned_set_end_child(cast[ptr Paned00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_paned_set_position(self: ptr Paned00; position: int32) {.
    importc, libprag.}

proc setPosition*(self: Paned; position: int) =
  gtk_paned_set_position(cast[ptr Paned00](self.impl), int32(position))

proc `position=`*(self: Paned; position: int) =
  gtk_paned_set_position(cast[ptr Paned00](self.impl), int32(position))

proc gtk_paned_set_resize_end_child(self: ptr Paned00; resize: gboolean) {.
    importc, libprag.}

proc setResizeEndChild*(self: Paned; resize: bool = true) =
  gtk_paned_set_resize_end_child(cast[ptr Paned00](self.impl), gboolean(resize))

proc `resizeEndChild=`*(self: Paned; resize: bool) =
  gtk_paned_set_resize_end_child(cast[ptr Paned00](self.impl), gboolean(resize))

proc gtk_paned_set_resize_start_child(self: ptr Paned00; resize: gboolean) {.
    importc, libprag.}

proc setResizeStartChild*(self: Paned; resize: bool = true) =
  gtk_paned_set_resize_start_child(cast[ptr Paned00](self.impl), gboolean(resize))

proc `resizeStartChild=`*(self: Paned; resize: bool) =
  gtk_paned_set_resize_start_child(cast[ptr Paned00](self.impl), gboolean(resize))

proc gtk_paned_set_shrink_end_child(self: ptr Paned00; resize: gboolean) {.
    importc, libprag.}

proc setShrinkEndChild*(self: Paned; resize: bool = true) =
  gtk_paned_set_shrink_end_child(cast[ptr Paned00](self.impl), gboolean(resize))

proc `shrinkEndChild=`*(self: Paned; resize: bool) =
  gtk_paned_set_shrink_end_child(cast[ptr Paned00](self.impl), gboolean(resize))

proc gtk_paned_set_shrink_start_child(self: ptr Paned00; resize: gboolean) {.
    importc, libprag.}

proc setShrinkStartChild*(self: Paned; resize: bool = true) =
  gtk_paned_set_shrink_start_child(cast[ptr Paned00](self.impl), gboolean(resize))

proc `shrinkStartChild=`*(self: Paned; resize: bool) =
  gtk_paned_set_shrink_start_child(cast[ptr Paned00](self.impl), gboolean(resize))

proc gtk_paned_set_start_child(self: ptr Paned00; child: ptr Widget00) {.
    importc, libprag.}

proc setStartChild*(self: Paned; child: Widget = nil) =
  gtk_paned_set_start_child(cast[ptr Paned00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `startChild=`*(self: Paned; child: Widget = nil) =
  gtk_paned_set_start_child(cast[ptr Paned00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_paned_set_wide_handle(self: ptr Paned00; wide: gboolean) {.
    importc, libprag.}

proc setWideHandle*(self: Paned; wide: bool = true) =
  gtk_paned_set_wide_handle(cast[ptr Paned00](self.impl), gboolean(wide))

proc `wideHandle=`*(self: Paned; wide: bool) =
  gtk_paned_set_wide_handle(cast[ptr Paned00](self.impl), gboolean(wide))

type
  Video* = ref object of Widget
  Video00* = object of Widget00

proc gtk_video_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Video()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_video_new(): ptr Video00 {.
    importc, libprag.}

proc newVideo*(): Video =
  let gobj = gtk_video_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVideo*(tdesc: typedesc): tdesc =
  assert(result is Video)
  let gobj = gtk_video_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVideo*[T](result: var T) {.deprecated.} =
  assert(result is Video)
  let gobj = gtk_video_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_video_new_for_file(file: ptr gio.GFile00): ptr Video00 {.
    importc, libprag.}

proc newVideoForFile*(file: gio.GFile = nil): Video =
  let gobj = gtk_video_new_for_file(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVideoForFile*(tdesc: typedesc; file: gio.GFile = nil): tdesc =
  assert(result is Video)
  let gobj = gtk_video_new_for_file(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVideoForFile*[T](result: var T; file: gio.GFile = nil) {.deprecated.} =
  assert(result is Video)
  let gobj = gtk_video_new_for_file(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_video_new_for_filename(filename: cstring): ptr Video00 {.
    importc, libprag.}

proc newVideoForFilename*(filename: cstring = nil): Video =
  let gobj = gtk_video_new_for_filename(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVideoForFilename*(tdesc: typedesc; filename: cstring = nil): tdesc =
  assert(result is Video)
  let gobj = gtk_video_new_for_filename(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVideoForFilename*[T](result: var T; filename: cstring = nil) {.deprecated.} =
  assert(result is Video)
  let gobj = gtk_video_new_for_filename(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_video_new_for_media_stream(stream: ptr MediaStream00): ptr Video00 {.
    importc, libprag.}

proc newVideoForMediaStream*(stream: MediaStream = nil): Video =
  let gobj = gtk_video_new_for_media_stream(if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVideoForMediaStream*(tdesc: typedesc; stream: MediaStream = nil): tdesc =
  assert(result is Video)
  let gobj = gtk_video_new_for_media_stream(if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVideoForMediaStream*[T](result: var T; stream: MediaStream = nil) {.deprecated.} =
  assert(result is Video)
  let gobj = gtk_video_new_for_media_stream(if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_video_new_for_resource(resourcePath: cstring): ptr Video00 {.
    importc, libprag.}

proc newVideoForResource*(resourcePath: cstring = nil): Video =
  let gobj = gtk_video_new_for_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVideoForResource*(tdesc: typedesc; resourcePath: cstring = nil): tdesc =
  assert(result is Video)
  let gobj = gtk_video_new_for_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVideoForResource*[T](result: var T; resourcePath: cstring = nil) {.deprecated.} =
  assert(result is Video)
  let gobj = gtk_video_new_for_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_video_get_autoplay(self: ptr Video00): gboolean {.
    importc, libprag.}

proc getAutoplay*(self: Video): bool =
  toBool(gtk_video_get_autoplay(cast[ptr Video00](self.impl)))

proc autoplay*(self: Video): bool =
  toBool(gtk_video_get_autoplay(cast[ptr Video00](self.impl)))

proc gtk_video_get_file(self: ptr Video00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: Video): gio.GFile =
  let gobj = gtk_video_get_file(cast[ptr Video00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: Video): gio.GFile =
  let gobj = gtk_video_get_file(cast[ptr Video00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_video_get_loop(self: ptr Video00): gboolean {.
    importc, libprag.}

proc getLoop*(self: Video): bool =
  toBool(gtk_video_get_loop(cast[ptr Video00](self.impl)))

proc loop*(self: Video): bool =
  toBool(gtk_video_get_loop(cast[ptr Video00](self.impl)))

proc gtk_video_get_media_stream(self: ptr Video00): ptr MediaStream00 {.
    importc, libprag.}

proc getMediaStream*(self: Video): MediaStream =
  let gobj = gtk_video_get_media_stream(cast[ptr Video00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc mediaStream*(self: Video): MediaStream =
  let gobj = gtk_video_get_media_stream(cast[ptr Video00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_video_set_autoplay(self: ptr Video00; autoplay: gboolean) {.
    importc, libprag.}

proc setAutoplay*(self: Video; autoplay: bool = true) =
  gtk_video_set_autoplay(cast[ptr Video00](self.impl), gboolean(autoplay))

proc `autoplay=`*(self: Video; autoplay: bool) =
  gtk_video_set_autoplay(cast[ptr Video00](self.impl), gboolean(autoplay))

proc gtk_video_set_file(self: ptr Video00; file: ptr gio.GFile00) {.
    importc, libprag.}

proc setFile*(self: Video; file: gio.GFile = nil) =
  gtk_video_set_file(cast[ptr Video00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc `file=`*(self: Video; file: gio.GFile = nil) =
  gtk_video_set_file(cast[ptr Video00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc gtk_video_set_filename(self: ptr Video00; filename: cstring) {.
    importc, libprag.}

proc setFilename*(self: Video; filename: cstring = nil) =
  gtk_video_set_filename(cast[ptr Video00](self.impl), filename)

proc `filename=`*(self: Video; filename: cstring = nil) =
  gtk_video_set_filename(cast[ptr Video00](self.impl), filename)

proc gtk_video_set_loop(self: ptr Video00; loop: gboolean) {.
    importc, libprag.}

proc setLoop*(self: Video; loop: bool = true) =
  gtk_video_set_loop(cast[ptr Video00](self.impl), gboolean(loop))

proc `loop=`*(self: Video; loop: bool) =
  gtk_video_set_loop(cast[ptr Video00](self.impl), gboolean(loop))

proc gtk_video_set_media_stream(self: ptr Video00; stream: ptr MediaStream00) {.
    importc, libprag.}

proc setMediaStream*(self: Video; stream: MediaStream = nil) =
  gtk_video_set_media_stream(cast[ptr Video00](self.impl), if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))

proc `mediaStream=`*(self: Video; stream: MediaStream = nil) =
  gtk_video_set_media_stream(cast[ptr Video00](self.impl), if stream.isNil: nil else: cast[ptr MediaStream00](stream.impl))

proc gtk_video_set_resource(self: ptr Video00; resourcePath: cstring) {.
    importc, libprag.}

proc setResource*(self: Video; resourcePath: cstring = nil) =
  gtk_video_set_resource(cast[ptr Video00](self.impl), resourcePath)

proc `resource=`*(self: Video; resourcePath: cstring = nil) =
  gtk_video_set_resource(cast[ptr Video00](self.impl), resourcePath)

type
  LevelBar* = ref object of Widget
  LevelBar00* = object of Widget00

proc gtk_level_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LevelBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scOffsetChanged*(self: LevelBar;  p: proc (self: ptr LevelBar00; name: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "offset-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_level_bar_new(): ptr LevelBar00 {.
    importc, libprag.}

proc newLevelBar*(): LevelBar =
  let gobj = gtk_level_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLevelBar*(tdesc: typedesc): tdesc =
  assert(result is LevelBar)
  let gobj = gtk_level_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLevelBar*[T](result: var T) {.deprecated.} =
  assert(result is LevelBar)
  let gobj = gtk_level_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_level_bar_new_for_interval(minValue: cdouble; maxValue: cdouble): ptr LevelBar00 {.
    importc, libprag.}

proc newLevelBarForInterval*(minValue: cdouble; maxValue: cdouble): LevelBar =
  let gobj = gtk_level_bar_new_for_interval(minValue, maxValue)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLevelBarForInterval*(tdesc: typedesc; minValue: cdouble; maxValue: cdouble): tdesc =
  assert(result is LevelBar)
  let gobj = gtk_level_bar_new_for_interval(minValue, maxValue)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLevelBarForInterval*[T](result: var T; minValue: cdouble; maxValue: cdouble) {.deprecated.} =
  assert(result is LevelBar)
  let gobj = gtk_level_bar_new_for_interval(minValue, maxValue)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_level_bar_add_offset_value(self: ptr LevelBar00; name: cstring;
    value: cdouble) {.
    importc, libprag.}

proc addOffsetValue*(self: LevelBar; name: cstring; value: cdouble) =
  gtk_level_bar_add_offset_value(cast[ptr LevelBar00](self.impl), name, value)

proc gtk_level_bar_get_inverted(self: ptr LevelBar00): gboolean {.
    importc, libprag.}

proc getInverted*(self: LevelBar): bool =
  toBool(gtk_level_bar_get_inverted(cast[ptr LevelBar00](self.impl)))

proc inverted*(self: LevelBar): bool =
  toBool(gtk_level_bar_get_inverted(cast[ptr LevelBar00](self.impl)))

proc gtk_level_bar_get_max_value(self: ptr LevelBar00): cdouble {.
    importc, libprag.}

proc getMaxValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_max_value(cast[ptr LevelBar00](self.impl))

proc maxValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_max_value(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_get_min_value(self: ptr LevelBar00): cdouble {.
    importc, libprag.}

proc getMinValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_min_value(cast[ptr LevelBar00](self.impl))

proc minValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_min_value(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_get_offset_value(self: ptr LevelBar00; name: cstring;
    value: var cdouble): gboolean {.
    importc, libprag.}

proc getOffsetValue*(self: LevelBar; name: cstring = nil;
    value: var cdouble): bool =
  toBool(gtk_level_bar_get_offset_value(cast[ptr LevelBar00](self.impl), name, value))

proc gtk_level_bar_get_value(self: ptr LevelBar00): cdouble {.
    importc, libprag.}

proc getValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_value(cast[ptr LevelBar00](self.impl))

proc value*(self: LevelBar): cdouble =
  gtk_level_bar_get_value(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_remove_offset_value(self: ptr LevelBar00; name: cstring) {.
    importc, libprag.}

proc removeOffsetValue*(self: LevelBar; name: cstring = nil) =
  gtk_level_bar_remove_offset_value(cast[ptr LevelBar00](self.impl), name)

proc gtk_level_bar_set_inverted(self: ptr LevelBar00; inverted: gboolean) {.
    importc, libprag.}

proc setInverted*(self: LevelBar; inverted: bool = true) =
  gtk_level_bar_set_inverted(cast[ptr LevelBar00](self.impl), gboolean(inverted))

proc `inverted=`*(self: LevelBar; inverted: bool) =
  gtk_level_bar_set_inverted(cast[ptr LevelBar00](self.impl), gboolean(inverted))

proc gtk_level_bar_set_max_value(self: ptr LevelBar00; value: cdouble) {.
    importc, libprag.}

proc setMaxValue*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_max_value(cast[ptr LevelBar00](self.impl), value)

proc `maxValue=`*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_max_value(cast[ptr LevelBar00](self.impl), value)

proc gtk_level_bar_set_min_value(self: ptr LevelBar00; value: cdouble) {.
    importc, libprag.}

proc setMinValue*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_min_value(cast[ptr LevelBar00](self.impl), value)

proc `minValue=`*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_min_value(cast[ptr LevelBar00](self.impl), value)

proc gtk_level_bar_set_value(self: ptr LevelBar00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_value(cast[ptr LevelBar00](self.impl), value)

proc `value=`*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_value(cast[ptr LevelBar00](self.impl), value)

type
  ActionBar* = ref object of Widget
  ActionBar00* = object of Widget00

proc gtk_action_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ActionBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_action_bar_new(): ptr ActionBar00 {.
    importc, libprag.}

proc newActionBar*(): ActionBar =
  let gobj = gtk_action_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newActionBar*(tdesc: typedesc): tdesc =
  assert(result is ActionBar)
  let gobj = gtk_action_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initActionBar*[T](result: var T) {.deprecated.} =
  assert(result is ActionBar)
  let gobj = gtk_action_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_bar_get_center_widget(self: ptr ActionBar00): ptr Widget00 {.
    importc, libprag.}

proc getCenterWidget*(self: ActionBar): Widget =
  let gobj = gtk_action_bar_get_center_widget(cast[ptr ActionBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc centerWidget*(self: ActionBar): Widget =
  let gobj = gtk_action_bar_get_center_widget(cast[ptr ActionBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_bar_get_revealed(self: ptr ActionBar00): gboolean {.
    importc, libprag.}

proc getRevealed*(self: ActionBar): bool =
  toBool(gtk_action_bar_get_revealed(cast[ptr ActionBar00](self.impl)))

proc revealed*(self: ActionBar): bool =
  toBool(gtk_action_bar_get_revealed(cast[ptr ActionBar00](self.impl)))

proc gtk_action_bar_pack_end(self: ptr ActionBar00; child: ptr Widget00) {.
    importc, libprag.}

proc packEnd*(self: ActionBar; child: Widget) =
  gtk_action_bar_pack_end(cast[ptr ActionBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_action_bar_pack_start(self: ptr ActionBar00; child: ptr Widget00) {.
    importc, libprag.}

proc packStart*(self: ActionBar; child: Widget) =
  gtk_action_bar_pack_start(cast[ptr ActionBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_action_bar_remove(self: ptr ActionBar00; child: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: ActionBar; child: Widget) =
  gtk_action_bar_remove(cast[ptr ActionBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_action_bar_set_center_widget(self: ptr ActionBar00; centerWidget: ptr Widget00) {.
    importc, libprag.}

proc setCenterWidget*(self: ActionBar; centerWidget: Widget = nil) =
  gtk_action_bar_set_center_widget(cast[ptr ActionBar00](self.impl), if centerWidget.isNil: nil else: cast[ptr Widget00](centerWidget.impl))

proc `centerWidget=`*(self: ActionBar; centerWidget: Widget = nil) =
  gtk_action_bar_set_center_widget(cast[ptr ActionBar00](self.impl), if centerWidget.isNil: nil else: cast[ptr Widget00](centerWidget.impl))

proc gtk_action_bar_set_revealed(self: ptr ActionBar00; revealed: gboolean) {.
    importc, libprag.}

proc setRevealed*(self: ActionBar; revealed: bool = true) =
  gtk_action_bar_set_revealed(cast[ptr ActionBar00](self.impl), gboolean(revealed))

proc `revealed=`*(self: ActionBar; revealed: bool) =
  gtk_action_bar_set_revealed(cast[ptr ActionBar00](self.impl), gboolean(revealed))

type
  Text* = ref object of Widget
  Text00* = object of Widget00

proc gtk_text_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Text()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Text;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scBackspace*(self: Text;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "backspace", cast[GCallback](p), xdata, nil, cf)

proc scCopyClipboard*(self: Text;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "copy-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scCutClipboard*(self: Text;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cut-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scDeleteFromCursor*(self: Text;  p: proc (self: ptr Text00; `type`: DeleteType; count: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-from-cursor", cast[GCallback](p), xdata, nil, cf)

proc scInsertAtCursor*(self: Text;  p: proc (self: ptr Text00; string: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-at-cursor", cast[GCallback](p), xdata, nil, cf)

proc scInsertEmoji*(self: Text;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-emoji", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: Text;  p: proc (self: ptr Text00; step: MovementStep; count: int32; extend: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scPasteClipboard*(self: Text;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "paste-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scPreeditChanged*(self: Text;  p: proc (self: ptr Text00; preedit: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-changed", cast[GCallback](p), xdata, nil, cf)

proc scToggleOverwrite*(self: Text;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-overwrite", cast[GCallback](p), xdata, nil, cf)

proc gtk_text_new(): ptr Text00 {.
    importc, libprag.}

proc newText*(): Text =
  let gobj = gtk_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newText*(tdesc: typedesc): tdesc =
  assert(result is Text)
  let gobj = gtk_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initText*[T](result: var T) {.deprecated.} =
  assert(result is Text)
  let gobj = gtk_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_compute_cursor_extents(self: ptr Text00; position: uint64;
    strong: var graphene.Rect; weak: var graphene.Rect) {.
    importc, libprag.}

proc computeCursorExtents*(self: Text; position: uint64; strong: var graphene.Rect = cast[var graphene.Rect](nil);
    weak: var graphene.Rect = cast[var graphene.Rect](nil)) =
  gtk_text_compute_cursor_extents(cast[ptr Text00](self.impl), position, strong, weak)

proc gtk_text_get_activates_default(self: ptr Text00): gboolean {.
    importc, libprag.}

proc getActivatesDefault*(self: Text): bool =
  toBool(gtk_text_get_activates_default(cast[ptr Text00](self.impl)))

proc activatesDefault*(self: Text): bool =
  toBool(gtk_text_get_activates_default(cast[ptr Text00](self.impl)))

proc gtk_text_get_attributes(self: ptr Text00): ptr pango.AttrList00 {.
    importc, libprag.}

proc getAttributes*(self: Text): pango.AttrList =
  let impl0 = gtk_text_get_attributes(cast[ptr Text00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc attributes*(self: Text): pango.AttrList =
  let impl0 = gtk_text_get_attributes(cast[ptr Text00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc gtk_text_get_enable_emoji_completion(self: ptr Text00): gboolean {.
    importc, libprag.}

proc getEnableEmojiCompletion*(self: Text): bool =
  toBool(gtk_text_get_enable_emoji_completion(cast[ptr Text00](self.impl)))

proc enableEmojiCompletion*(self: Text): bool =
  toBool(gtk_text_get_enable_emoji_completion(cast[ptr Text00](self.impl)))

proc gtk_text_get_extra_menu(self: ptr Text00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getExtraMenu*(self: Text): gio.MenuModel =
  let gobj = gtk_text_get_extra_menu(cast[ptr Text00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc extraMenu*(self: Text): gio.MenuModel =
  let gobj = gtk_text_get_extra_menu(cast[ptr Text00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_get_invisible_char(self: ptr Text00): gunichar {.
    importc, libprag.}

proc getInvisibleChar*(self: Text): gunichar =
  gtk_text_get_invisible_char(cast[ptr Text00](self.impl))

proc invisibleChar*(self: Text): gunichar =
  gtk_text_get_invisible_char(cast[ptr Text00](self.impl))

proc gtk_text_get_max_length(self: ptr Text00): int32 {.
    importc, libprag.}

proc getMaxLength*(self: Text): int =
  int(gtk_text_get_max_length(cast[ptr Text00](self.impl)))

proc maxLength*(self: Text): int =
  int(gtk_text_get_max_length(cast[ptr Text00](self.impl)))

proc gtk_text_get_overwrite_mode(self: ptr Text00): gboolean {.
    importc, libprag.}

proc getOverwriteMode*(self: Text): bool =
  toBool(gtk_text_get_overwrite_mode(cast[ptr Text00](self.impl)))

proc overwriteMode*(self: Text): bool =
  toBool(gtk_text_get_overwrite_mode(cast[ptr Text00](self.impl)))

proc gtk_text_get_placeholder_text(self: ptr Text00): cstring {.
    importc, libprag.}

proc getPlaceholderText*(self: Text): string =
  let resul0 = gtk_text_get_placeholder_text(cast[ptr Text00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc placeholderText*(self: Text): string =
  let resul0 = gtk_text_get_placeholder_text(cast[ptr Text00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_text_get_propagate_text_width(self: ptr Text00): gboolean {.
    importc, libprag.}

proc getPropagateTextWidth*(self: Text): bool =
  toBool(gtk_text_get_propagate_text_width(cast[ptr Text00](self.impl)))

proc propagateTextWidth*(self: Text): bool =
  toBool(gtk_text_get_propagate_text_width(cast[ptr Text00](self.impl)))

proc gtk_text_get_tabs(self: ptr Text00): ptr pango.TabArray00 {.
    importc, libprag.}

proc getTabs*(self: Text): pango.TabArray =
  let impl0 = gtk_text_get_tabs(cast[ptr Text00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_tab_array_get_type(), impl0))

proc tabs*(self: Text): pango.TabArray =
  let impl0 = gtk_text_get_tabs(cast[ptr Text00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_tab_array_get_type(), impl0))

proc gtk_text_get_text_length(self: ptr Text00): uint16 {.
    importc, libprag.}

proc getTextLength*(self: Text): uint16 =
  gtk_text_get_text_length(cast[ptr Text00](self.impl))

proc textLength*(self: Text): uint16 =
  gtk_text_get_text_length(cast[ptr Text00](self.impl))

proc gtk_text_get_truncate_multiline(self: ptr Text00): gboolean {.
    importc, libprag.}

proc getTruncateMultiline*(self: Text): bool =
  toBool(gtk_text_get_truncate_multiline(cast[ptr Text00](self.impl)))

proc truncateMultiline*(self: Text): bool =
  toBool(gtk_text_get_truncate_multiline(cast[ptr Text00](self.impl)))

proc gtk_text_get_visibility(self: ptr Text00): gboolean {.
    importc, libprag.}

proc getVisibility*(self: Text): bool =
  toBool(gtk_text_get_visibility(cast[ptr Text00](self.impl)))

proc visibility*(self: Text): bool =
  toBool(gtk_text_get_visibility(cast[ptr Text00](self.impl)))

proc gtk_text_grab_focus_without_selecting(self: ptr Text00): gboolean {.
    importc, libprag.}

proc grabFocusWithoutSelecting*(self: Text): bool =
  toBool(gtk_text_grab_focus_without_selecting(cast[ptr Text00](self.impl)))

proc gtk_text_set_activates_default(self: ptr Text00; activates: gboolean) {.
    importc, libprag.}

proc setActivatesDefault*(self: Text; activates: bool = true) =
  gtk_text_set_activates_default(cast[ptr Text00](self.impl), gboolean(activates))

proc `activatesDefault=`*(self: Text; activates: bool) =
  gtk_text_set_activates_default(cast[ptr Text00](self.impl), gboolean(activates))

proc gtk_text_set_attributes(self: ptr Text00; attrs: ptr pango.AttrList00) {.
    importc, libprag.}

proc setAttributes*(self: Text; attrs: pango.AttrList = nil) =
  gtk_text_set_attributes(cast[ptr Text00](self.impl), if attrs.isNil: nil else: cast[ptr pango.AttrList00](attrs.impl))

proc `attributes=`*(self: Text; attrs: pango.AttrList = nil) =
  gtk_text_set_attributes(cast[ptr Text00](self.impl), if attrs.isNil: nil else: cast[ptr pango.AttrList00](attrs.impl))

proc gtk_text_set_enable_emoji_completion(self: ptr Text00; enableEmojiCompletion: gboolean) {.
    importc, libprag.}

proc setEnableEmojiCompletion*(self: Text; enableEmojiCompletion: bool = true) =
  gtk_text_set_enable_emoji_completion(cast[ptr Text00](self.impl), gboolean(enableEmojiCompletion))

proc `enableEmojiCompletion=`*(self: Text; enableEmojiCompletion: bool) =
  gtk_text_set_enable_emoji_completion(cast[ptr Text00](self.impl), gboolean(enableEmojiCompletion))

proc gtk_text_set_extra_menu(self: ptr Text00; model: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setExtraMenu*(self: Text; model: gio.MenuModel = nil) =
  gtk_text_set_extra_menu(cast[ptr Text00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc `extraMenu=`*(self: Text; model: gio.MenuModel = nil) =
  gtk_text_set_extra_menu(cast[ptr Text00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl))

proc gtk_text_set_invisible_char(self: ptr Text00; ch: gunichar) {.
    importc, libprag.}

proc setInvisibleChar*(self: Text; ch: gunichar) =
  gtk_text_set_invisible_char(cast[ptr Text00](self.impl), ch)

proc `invisibleChar=`*(self: Text; ch: gunichar) =
  gtk_text_set_invisible_char(cast[ptr Text00](self.impl), ch)

proc gtk_text_set_max_length(self: ptr Text00; length: int32) {.
    importc, libprag.}

proc setMaxLength*(self: Text; length: int) =
  gtk_text_set_max_length(cast[ptr Text00](self.impl), int32(length))

proc `maxLength=`*(self: Text; length: int) =
  gtk_text_set_max_length(cast[ptr Text00](self.impl), int32(length))

proc gtk_text_set_overwrite_mode(self: ptr Text00; overwrite: gboolean) {.
    importc, libprag.}

proc setOverwriteMode*(self: Text; overwrite: bool = true) =
  gtk_text_set_overwrite_mode(cast[ptr Text00](self.impl), gboolean(overwrite))

proc `overwriteMode=`*(self: Text; overwrite: bool) =
  gtk_text_set_overwrite_mode(cast[ptr Text00](self.impl), gboolean(overwrite))

proc gtk_text_set_placeholder_text(self: ptr Text00; text: cstring) {.
    importc, libprag.}

proc setPlaceholderText*(self: Text; text: cstring = nil) =
  gtk_text_set_placeholder_text(cast[ptr Text00](self.impl), text)

proc `placeholderText=`*(self: Text; text: cstring = nil) =
  gtk_text_set_placeholder_text(cast[ptr Text00](self.impl), text)

proc gtk_text_set_propagate_text_width(self: ptr Text00; propagateTextWidth: gboolean) {.
    importc, libprag.}

proc setPropagateTextWidth*(self: Text; propagateTextWidth: bool = true) =
  gtk_text_set_propagate_text_width(cast[ptr Text00](self.impl), gboolean(propagateTextWidth))

proc `propagateTextWidth=`*(self: Text; propagateTextWidth: bool) =
  gtk_text_set_propagate_text_width(cast[ptr Text00](self.impl), gboolean(propagateTextWidth))

proc gtk_text_set_tabs(self: ptr Text00; tabs: ptr pango.TabArray00) {.
    importc, libprag.}

proc setTabs*(self: Text; tabs: pango.TabArray = nil) =
  gtk_text_set_tabs(cast[ptr Text00](self.impl), if tabs.isNil: nil else: cast[ptr pango.TabArray00](tabs.impl))

proc `tabs=`*(self: Text; tabs: pango.TabArray = nil) =
  gtk_text_set_tabs(cast[ptr Text00](self.impl), if tabs.isNil: nil else: cast[ptr pango.TabArray00](tabs.impl))

proc gtk_text_set_truncate_multiline(self: ptr Text00; truncateMultiline: gboolean) {.
    importc, libprag.}

proc setTruncateMultiline*(self: Text; truncateMultiline: bool = true) =
  gtk_text_set_truncate_multiline(cast[ptr Text00](self.impl), gboolean(truncateMultiline))

proc `truncateMultiline=`*(self: Text; truncateMultiline: bool) =
  gtk_text_set_truncate_multiline(cast[ptr Text00](self.impl), gboolean(truncateMultiline))

proc gtk_text_set_visibility(self: ptr Text00; visible: gboolean) {.
    importc, libprag.}

proc setVisibility*(self: Text; visible: bool = true) =
  gtk_text_set_visibility(cast[ptr Text00](self.impl), gboolean(visible))

proc `visibility=`*(self: Text; visible: bool) =
  gtk_text_set_visibility(cast[ptr Text00](self.impl), gboolean(visible))

proc gtk_text_unset_invisible_char(self: ptr Text00) {.
    importc, libprag.}

proc unsetInvisibleChar*(self: Text) =
  gtk_text_unset_invisible_char(cast[ptr Text00](self.impl))

type
  Scrollbar* = ref object of Widget
  Scrollbar00* = object of Widget00

proc gtk_scrollbar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Scrollbar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  Separator* = ref object of Widget
  Separator00* = object of Widget00

proc gtk_separator_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Separator()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  Switch* = ref object of Widget
  Switch00* = object of Widget00

proc gtk_switch_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Switch()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Switch;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scStateSet*(self: Switch;  p: proc (self: ptr Switch00; state: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "state-set", cast[GCallback](p), xdata, nil, cf)

proc gtk_switch_new(): ptr Switch00 {.
    importc, libprag.}

proc newSwitch*(): Switch =
  let gobj = gtk_switch_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSwitch*(tdesc: typedesc): tdesc =
  assert(result is Switch)
  let gobj = gtk_switch_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSwitch*[T](result: var T) {.deprecated.} =
  assert(result is Switch)
  let gobj = gtk_switch_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_switch_get_active(self: ptr Switch00): gboolean {.
    importc, libprag.}

proc getActive*(self: Switch): bool =
  toBool(gtk_switch_get_active(cast[ptr Switch00](self.impl)))

proc active*(self: Switch): bool =
  toBool(gtk_switch_get_active(cast[ptr Switch00](self.impl)))

proc gtk_switch_get_state(self: ptr Switch00): gboolean {.
    importc, libprag.}

proc getState*(self: Switch): bool =
  toBool(gtk_switch_get_state(cast[ptr Switch00](self.impl)))

proc state*(self: Switch): bool =
  toBool(gtk_switch_get_state(cast[ptr Switch00](self.impl)))

proc gtk_switch_set_active(self: ptr Switch00; isActive: gboolean) {.
    importc, libprag.}

proc setActive*(self: Switch; isActive: bool = true) =
  gtk_switch_set_active(cast[ptr Switch00](self.impl), gboolean(isActive))

proc `active=`*(self: Switch; isActive: bool) =
  gtk_switch_set_active(cast[ptr Switch00](self.impl), gboolean(isActive))

proc gtk_switch_set_state(self: ptr Switch00; state: gboolean) {.
    importc, libprag.}

proc setState*(self: Switch; state: bool = true) =
  gtk_switch_set_state(cast[ptr Switch00](self.impl), gboolean(state))

proc `state=`*(self: Switch; state: bool) =
  gtk_switch_set_state(cast[ptr Switch00](self.impl), gboolean(state))

type
  MessageDialog* = ref object of Dialog
  MessageDialog00* = object of Dialog00

proc gtk_message_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MessageDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_message_dialog_get_message_area(self: ptr MessageDialog00): ptr Widget00 {.
    importc, libprag.}

proc getMessageArea*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_message_area(cast[ptr MessageDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc messageArea*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_message_area(cast[ptr MessageDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_message_dialog_set_markup(self: ptr MessageDialog00; str: cstring) {.
    importc, libprag.}

proc setMarkup*(self: MessageDialog; str: cstring) =
  gtk_message_dialog_set_markup(cast[ptr MessageDialog00](self.impl), str)

proc `markup=`*(self: MessageDialog; str: cstring) =
  gtk_message_dialog_set_markup(cast[ptr MessageDialog00](self.impl), str)

type
  CenterBox* = ref object of Widget
  CenterBox00* = object of Widget00

proc gtk_center_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CenterBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_center_box_new(): ptr CenterBox00 {.
    importc, libprag.}

proc newCenterBox*(): CenterBox =
  let gobj = gtk_center_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCenterBox*(tdesc: typedesc): tdesc =
  assert(result is CenterBox)
  let gobj = gtk_center_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCenterBox*[T](result: var T) {.deprecated.} =
  assert(result is CenterBox)
  let gobj = gtk_center_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_center_box_get_baseline_position(self: ptr CenterBox00): BaselinePosition {.
    importc, libprag.}

proc getBaselinePosition*(self: CenterBox): BaselinePosition =
  gtk_center_box_get_baseline_position(cast[ptr CenterBox00](self.impl))

proc baselinePosition*(self: CenterBox): BaselinePosition =
  gtk_center_box_get_baseline_position(cast[ptr CenterBox00](self.impl))

proc gtk_center_box_get_center_widget(self: ptr CenterBox00): ptr Widget00 {.
    importc, libprag.}

proc getCenterWidget*(self: CenterBox): Widget =
  let gobj = gtk_center_box_get_center_widget(cast[ptr CenterBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc centerWidget*(self: CenterBox): Widget =
  let gobj = gtk_center_box_get_center_widget(cast[ptr CenterBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_center_box_get_end_widget(self: ptr CenterBox00): ptr Widget00 {.
    importc, libprag.}

proc getEndWidget*(self: CenterBox): Widget =
  let gobj = gtk_center_box_get_end_widget(cast[ptr CenterBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc endWidget*(self: CenterBox): Widget =
  let gobj = gtk_center_box_get_end_widget(cast[ptr CenterBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_center_box_get_shrink_center_last(self: ptr CenterBox00): gboolean {.
    importc, libprag.}

proc getShrinkCenterLast*(self: CenterBox): bool =
  toBool(gtk_center_box_get_shrink_center_last(cast[ptr CenterBox00](self.impl)))

proc shrinkCenterLast*(self: CenterBox): bool =
  toBool(gtk_center_box_get_shrink_center_last(cast[ptr CenterBox00](self.impl)))

proc gtk_center_box_get_start_widget(self: ptr CenterBox00): ptr Widget00 {.
    importc, libprag.}

proc getStartWidget*(self: CenterBox): Widget =
  let gobj = gtk_center_box_get_start_widget(cast[ptr CenterBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc startWidget*(self: CenterBox): Widget =
  let gobj = gtk_center_box_get_start_widget(cast[ptr CenterBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_center_box_set_baseline_position(self: ptr CenterBox00; position: BaselinePosition) {.
    importc, libprag.}

proc setBaselinePosition*(self: CenterBox; position: BaselinePosition) =
  gtk_center_box_set_baseline_position(cast[ptr CenterBox00](self.impl), position)

proc `baselinePosition=`*(self: CenterBox; position: BaselinePosition) =
  gtk_center_box_set_baseline_position(cast[ptr CenterBox00](self.impl), position)

proc gtk_center_box_set_center_widget(self: ptr CenterBox00; child: ptr Widget00) {.
    importc, libprag.}

proc setCenterWidget*(self: CenterBox; child: Widget = nil) =
  gtk_center_box_set_center_widget(cast[ptr CenterBox00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `centerWidget=`*(self: CenterBox; child: Widget = nil) =
  gtk_center_box_set_center_widget(cast[ptr CenterBox00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_center_box_set_end_widget(self: ptr CenterBox00; child: ptr Widget00) {.
    importc, libprag.}

proc setEndWidget*(self: CenterBox; child: Widget = nil) =
  gtk_center_box_set_end_widget(cast[ptr CenterBox00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `endWidget=`*(self: CenterBox; child: Widget = nil) =
  gtk_center_box_set_end_widget(cast[ptr CenterBox00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_center_box_set_shrink_center_last(self: ptr CenterBox00; shrinkCenterLast: gboolean) {.
    importc, libprag.}

proc setShrinkCenterLast*(self: CenterBox; shrinkCenterLast: bool = true) =
  gtk_center_box_set_shrink_center_last(cast[ptr CenterBox00](self.impl), gboolean(shrinkCenterLast))

proc `shrinkCenterLast=`*(self: CenterBox; shrinkCenterLast: bool) =
  gtk_center_box_set_shrink_center_last(cast[ptr CenterBox00](self.impl), gboolean(shrinkCenterLast))

proc gtk_center_box_set_start_widget(self: ptr CenterBox00; child: ptr Widget00) {.
    importc, libprag.}

proc setStartWidget*(self: CenterBox; child: Widget = nil) =
  gtk_center_box_set_start_widget(cast[ptr CenterBox00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `startWidget=`*(self: CenterBox; child: Widget = nil) =
  gtk_center_box_set_start_widget(cast[ptr CenterBox00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

type
  SearchEntry* = ref object of Widget
  SearchEntry00* = object of Widget00

proc gtk_search_entry_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SearchEntry()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scNextMatch*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "next-match", cast[GCallback](p), xdata, nil, cf)

proc scPreviousMatch*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "previous-match", cast[GCallback](p), xdata, nil, cf)

proc scSearchChanged*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "search-changed", cast[GCallback](p), xdata, nil, cf)

proc scSearchStarted*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "search-started", cast[GCallback](p), xdata, nil, cf)

proc scStopSearch*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "stop-search", cast[GCallback](p), xdata, nil, cf)

proc gtk_search_entry_new(): ptr SearchEntry00 {.
    importc, libprag.}

proc newSearchEntry*(): SearchEntry =
  let gobj = gtk_search_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSearchEntry*(tdesc: typedesc): tdesc =
  assert(result is SearchEntry)
  let gobj = gtk_search_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSearchEntry*[T](result: var T) {.deprecated.} =
  assert(result is SearchEntry)
  let gobj = gtk_search_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_search_entry_get_key_capture_widget(self: ptr SearchEntry00): ptr Widget00 {.
    importc, libprag.}

proc getKeyCaptureWidget*(self: SearchEntry): Widget =
  let gobj = gtk_search_entry_get_key_capture_widget(cast[ptr SearchEntry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc keyCaptureWidget*(self: SearchEntry): Widget =
  let gobj = gtk_search_entry_get_key_capture_widget(cast[ptr SearchEntry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_search_entry_get_placeholder_text(self: ptr SearchEntry00): cstring {.
    importc, libprag.}

proc getPlaceholderText*(self: SearchEntry): string =
  let resul0 = gtk_search_entry_get_placeholder_text(cast[ptr SearchEntry00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc placeholderText*(self: SearchEntry): string =
  let resul0 = gtk_search_entry_get_placeholder_text(cast[ptr SearchEntry00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_search_entry_get_search_delay(self: ptr SearchEntry00): uint32 {.
    importc, libprag.}

proc getSearchDelay*(self: SearchEntry): int =
  int(gtk_search_entry_get_search_delay(cast[ptr SearchEntry00](self.impl)))

proc searchDelay*(self: SearchEntry): int =
  int(gtk_search_entry_get_search_delay(cast[ptr SearchEntry00](self.impl)))

proc gtk_search_entry_set_key_capture_widget(self: ptr SearchEntry00; widget: ptr Widget00) {.
    importc, libprag.}

proc setKeyCaptureWidget*(self: SearchEntry; widget: Widget = nil) =
  gtk_search_entry_set_key_capture_widget(cast[ptr SearchEntry00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `keyCaptureWidget=`*(self: SearchEntry; widget: Widget = nil) =
  gtk_search_entry_set_key_capture_widget(cast[ptr SearchEntry00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_search_entry_set_placeholder_text(self: ptr SearchEntry00; text: cstring) {.
    importc, libprag.}

proc setPlaceholderText*(self: SearchEntry; text: cstring = nil) =
  gtk_search_entry_set_placeholder_text(cast[ptr SearchEntry00](self.impl), text)

proc `placeholderText=`*(self: SearchEntry; text: cstring = nil) =
  gtk_search_entry_set_placeholder_text(cast[ptr SearchEntry00](self.impl), text)

proc gtk_search_entry_set_search_delay(self: ptr SearchEntry00; delay: uint32) {.
    importc, libprag.}

proc setSearchDelay*(self: SearchEntry; delay: int) =
  gtk_search_entry_set_search_delay(cast[ptr SearchEntry00](self.impl), uint32(delay))

proc `searchDelay=`*(self: SearchEntry; delay: int) =
  gtk_search_entry_set_search_delay(cast[ptr SearchEntry00](self.impl), uint32(delay))

type
  ListView* = ref object of ListBase
  ListView00* = object of ListBase00

proc gtk_list_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: ListView;  p: proc (self: ptr ListView00; position: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_list_view_get_enable_rubberband(self: ptr ListView00): gboolean {.
    importc, libprag.}

proc getEnableRubberband*(self: ListView): bool =
  toBool(gtk_list_view_get_enable_rubberband(cast[ptr ListView00](self.impl)))

proc enableRubberband*(self: ListView): bool =
  toBool(gtk_list_view_get_enable_rubberband(cast[ptr ListView00](self.impl)))

proc gtk_list_view_get_model(self: ptr ListView00): ptr SelectionModel00 {.
    importc, libprag.}

proc getModel*(self: ListView): SelectionModel =
  let gobj = gtk_list_view_get_model(cast[ptr ListView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: ListView): SelectionModel =
  let gobj = gtk_list_view_get_model(cast[ptr ListView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_view_get_show_separators(self: ptr ListView00): gboolean {.
    importc, libprag.}

proc getShowSeparators*(self: ListView): bool =
  toBool(gtk_list_view_get_show_separators(cast[ptr ListView00](self.impl)))

proc showSeparators*(self: ListView): bool =
  toBool(gtk_list_view_get_show_separators(cast[ptr ListView00](self.impl)))

proc gtk_list_view_get_single_click_activate(self: ptr ListView00): gboolean {.
    importc, libprag.}

proc getSingleClickActivate*(self: ListView): bool =
  toBool(gtk_list_view_get_single_click_activate(cast[ptr ListView00](self.impl)))

proc singleClickActivate*(self: ListView): bool =
  toBool(gtk_list_view_get_single_click_activate(cast[ptr ListView00](self.impl)))

proc gtk_list_view_set_enable_rubberband(self: ptr ListView00; enableRubberband: gboolean) {.
    importc, libprag.}

proc setEnableRubberband*(self: ListView; enableRubberband: bool = true) =
  gtk_list_view_set_enable_rubberband(cast[ptr ListView00](self.impl), gboolean(enableRubberband))

proc `enableRubberband=`*(self: ListView; enableRubberband: bool) =
  gtk_list_view_set_enable_rubberband(cast[ptr ListView00](self.impl), gboolean(enableRubberband))

proc gtk_list_view_set_model(self: ptr ListView00; model: ptr SelectionModel00) {.
    importc, libprag.}

proc setModel*(self: ListView; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) =
  gtk_list_view_set_model(cast[ptr ListView00](self.impl), if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))

proc `model=`*(self: ListView; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) =
  gtk_list_view_set_model(cast[ptr ListView00](self.impl), if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))

proc gtk_list_view_set_show_separators(self: ptr ListView00; showSeparators: gboolean) {.
    importc, libprag.}

proc setShowSeparators*(self: ListView; showSeparators: bool = true) =
  gtk_list_view_set_show_separators(cast[ptr ListView00](self.impl), gboolean(showSeparators))

proc `showSeparators=`*(self: ListView; showSeparators: bool) =
  gtk_list_view_set_show_separators(cast[ptr ListView00](self.impl), gboolean(showSeparators))

proc gtk_list_view_set_single_click_activate(self: ptr ListView00; singleClickActivate: gboolean) {.
    importc, libprag.}

proc setSingleClickActivate*(self: ListView; singleClickActivate: bool = true) =
  gtk_list_view_set_single_click_activate(cast[ptr ListView00](self.impl), gboolean(singleClickActivate))

proc `singleClickActivate=`*(self: ListView; singleClickActivate: bool) =
  gtk_list_view_set_single_click_activate(cast[ptr ListView00](self.impl), gboolean(singleClickActivate))

type
  ColorButton* = ref object of Widget
  ColorButton00* = object of Widget00

proc gtk_color_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: ColorButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scColorSet*(self: ColorButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "color-set", cast[GCallback](p), xdata, nil, cf)

proc gtk_color_button_new(): ptr ColorButton00 {.
    importc, libprag.}

proc newColorButton*(): ColorButton {.deprecated.}  =
  let gobj = gtk_color_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorButton*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorButton*[T](result: var T) {.deprecated.} =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_button_new_with_rgba(rgba: gdk4.RGBA): ptr ColorButton00 {.
    importc, libprag.}

proc newColorButtonWithRgba*(rgba: gdk4.RGBA): ColorButton =
  let gobj = gtk_color_button_new_with_rgba(rgba)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorButtonWithRgba*(tdesc: typedesc; rgba: gdk4.RGBA): tdesc =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new_with_rgba(rgba)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorButtonWithRgba*[T](result: var T; rgba: gdk4.RGBA) {.deprecated.} =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new_with_rgba(rgba)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_button_get_modal(self: ptr ColorButton00): gboolean {.
    importc, libprag.}

proc getModal*(self: ColorButton): bool =
  toBool(gtk_color_button_get_modal(cast[ptr ColorButton00](self.impl)))

proc modal*(self: ColorButton): bool =
  toBool(gtk_color_button_get_modal(cast[ptr ColorButton00](self.impl)))

proc gtk_color_button_get_title(self: ptr ColorButton00): cstring {.
    importc, libprag.}

proc getTitle*(self: ColorButton): string =
  result = $gtk_color_button_get_title(cast[ptr ColorButton00](self.impl))

proc title*(self: ColorButton): string =
  result = $gtk_color_button_get_title(cast[ptr ColorButton00](self.impl))

proc gtk_color_button_set_modal(self: ptr ColorButton00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: ColorButton; modal: bool = true) =
  gtk_color_button_set_modal(cast[ptr ColorButton00](self.impl), gboolean(modal))

proc `modal=`*(self: ColorButton; modal: bool) =
  gtk_color_button_set_modal(cast[ptr ColorButton00](self.impl), gboolean(modal))

proc gtk_color_button_set_title(self: ptr ColorButton00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: ColorButton; title: cstring) =
  gtk_color_button_set_title(cast[ptr ColorButton00](self.impl), title)

proc `title=`*(self: ColorButton; title: cstring) =
  gtk_color_button_set_title(cast[ptr ColorButton00](self.impl), title)

type
  GraphicsOffload* = ref object of Widget
  GraphicsOffload00* = object of Widget00

proc gtk_graphics_offload_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GraphicsOffload()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_graphics_offload_new(child: ptr Widget00): ptr GraphicsOffload00 {.
    importc, libprag.}

proc newGraphicsOffload*(child: Widget = nil): GraphicsOffload =
  let gobj = gtk_graphics_offload_new(if child.isNil: nil else: cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGraphicsOffload*(tdesc: typedesc; child: Widget = nil): tdesc =
  assert(result is GraphicsOffload)
  let gobj = gtk_graphics_offload_new(if child.isNil: nil else: cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGraphicsOffload*[T](result: var T; child: Widget = nil) {.deprecated.} =
  assert(result is GraphicsOffload)
  let gobj = gtk_graphics_offload_new(if child.isNil: nil else: cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_graphics_offload_get_child(self: ptr GraphicsOffload00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: GraphicsOffload): Widget =
  let gobj = gtk_graphics_offload_get_child(cast[ptr GraphicsOffload00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: GraphicsOffload): Widget =
  let gobj = gtk_graphics_offload_get_child(cast[ptr GraphicsOffload00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_graphics_offload_set_child(self: ptr GraphicsOffload00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: GraphicsOffload; child: Widget = nil) =
  gtk_graphics_offload_set_child(cast[ptr GraphicsOffload00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: GraphicsOffload; child: Widget = nil) =
  gtk_graphics_offload_set_child(cast[ptr GraphicsOffload00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_accessible_announce(self: ptr Accessible00; message: cstring; priority: AccessibleAnnouncementPriority) {.
    importc, libprag.}

proc announce*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    message: cstring; priority: AccessibleAnnouncementPriority) =
  gtk_accessible_announce(cast[ptr Accessible00](self.impl), message, priority)

proc gtk_accessible_get_accessible_parent(self: ptr Accessible00): ptr Accessible00 {.
    importc, libprag.}

proc getAccessibleParent*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): Accessible =
  let gobj = gtk_accessible_get_accessible_parent(cast[ptr Accessible00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accessibleParent*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): Accessible =
  let gobj = gtk_accessible_get_accessible_parent(cast[ptr Accessible00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accessible_get_at_context(self: ptr Accessible00): ptr ATContext00 {.
    importc, libprag.}

proc getAtContext*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): ATContext =
  let gobj = gtk_accessible_get_at_context(cast[ptr Accessible00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc atContext*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): ATContext =
  let gobj = gtk_accessible_get_at_context(cast[ptr Accessible00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accessible_get_bounds(self: ptr Accessible00; x: var int32; y: var int32;
    width: var int32; height: var int32): gboolean {.
    importc, libprag.}

proc getBounds*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    x: var int; y: var int; width: var int; height: var int): bool =
  var x_00: int32
  var height_00: int32
  var y_00: int32
  var width_00: int32
  result = toBool(gtk_accessible_get_bounds(cast[ptr Accessible00](self.impl), x_00, y_00, width_00, height_00))
  if x.addr != nil:
    x = int(x_00)
  if height.addr != nil:
    height = int(height_00)
  if y.addr != nil:
    y = int(y_00)
  if width.addr != nil:
    width = int(width_00)

proc gtk_accessible_get_first_accessible_child(self: ptr Accessible00): ptr Accessible00 {.
    importc, libprag.}

proc getFirstAccessibleChild*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): Accessible =
  let gobj = gtk_accessible_get_first_accessible_child(cast[ptr Accessible00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc firstAccessibleChild*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): Accessible =
  let gobj = gtk_accessible_get_first_accessible_child(cast[ptr Accessible00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accessible_get_next_accessible_sibling(self: ptr Accessible00): ptr Accessible00 {.
    importc, libprag.}

proc getNextAccessibleSibling*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): Accessible =
  let gobj = gtk_accessible_get_next_accessible_sibling(cast[ptr Accessible00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc nextAccessibleSibling*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): Accessible =
  let gobj = gtk_accessible_get_next_accessible_sibling(cast[ptr Accessible00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accessible_get_platform_state(self: ptr Accessible00; state: AccessiblePlatformState): gboolean {.
    importc, libprag.}

proc getPlatformState*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    state: AccessiblePlatformState): bool =
  toBool(gtk_accessible_get_platform_state(cast[ptr Accessible00](self.impl), state))

proc gtk_accessible_set_accessible_parent(self: ptr Accessible00; parent: ptr Accessible00;
    nextSibling: ptr Accessible00) {.
    importc, libprag.}

proc setAccessibleParent*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    parent: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = Accessible(nil);
    nextSibling: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = Accessible(nil)) =
  gtk_accessible_set_accessible_parent(cast[ptr Accessible00](self.impl), if parent.isNil: nil else: cast[ptr Accessible00](parent.impl), if nextSibling.isNil: nil else: cast[ptr Accessible00](nextSibling.impl))

proc gtk_accessible_update_next_accessible_sibling(self: ptr Accessible00;
    newSibling: ptr Accessible00) {.
    importc, libprag.}

proc updateNextAccessibleSibling*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    newSibling: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = Accessible(nil)) =
  gtk_accessible_update_next_accessible_sibling(cast[ptr Accessible00](self.impl), if newSibling.isNil: nil else: cast[ptr Accessible00](newSibling.impl))

type
  LevelBarMode* {.size: sizeof(cint), pure.} = enum
    continuous = 0
    discrete = 1

proc gtk_level_bar_get_mode(self: ptr LevelBar00): LevelBarMode {.
    importc, libprag.}

proc getMode*(self: LevelBar): LevelBarMode =
  gtk_level_bar_get_mode(cast[ptr LevelBar00](self.impl))

proc mode*(self: LevelBar): LevelBarMode =
  gtk_level_bar_get_mode(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_set_mode(self: ptr LevelBar00; mode: LevelBarMode) {.
    importc, libprag.}

proc setMode*(self: LevelBar; mode: LevelBarMode) =
  gtk_level_bar_set_mode(cast[ptr LevelBar00](self.impl), mode)

proc `mode=`*(self: LevelBar; mode: LevelBarMode) =
  gtk_level_bar_set_mode(cast[ptr LevelBar00](self.impl), mode)

type
  GraphicsOffloadEnabled* {.size: sizeof(cint), pure.} = enum
    enabled = 0
    disabled = 1

proc gtk_video_get_graphics_offload(self: ptr Video00): GraphicsOffloadEnabled {.
    importc, libprag.}

proc getGraphicsOffload*(self: Video): GraphicsOffloadEnabled =
  gtk_video_get_graphics_offload(cast[ptr Video00](self.impl))

proc graphicsOffload*(self: Video): GraphicsOffloadEnabled =
  gtk_video_get_graphics_offload(cast[ptr Video00](self.impl))

proc gtk_video_set_graphics_offload(self: ptr Video00; enabled: GraphicsOffloadEnabled) {.
    importc, libprag.}

proc setGraphicsOffload*(self: Video; enabled: GraphicsOffloadEnabled) =
  gtk_video_set_graphics_offload(cast[ptr Video00](self.impl), enabled)

proc `graphicsOffload=`*(self: Video; enabled: GraphicsOffloadEnabled) =
  gtk_video_set_graphics_offload(cast[ptr Video00](self.impl), enabled)

proc gtk_graphics_offload_get_enabled(self: ptr GraphicsOffload00): GraphicsOffloadEnabled {.
    importc, libprag.}

proc getEnabled*(self: GraphicsOffload): GraphicsOffloadEnabled =
  gtk_graphics_offload_get_enabled(cast[ptr GraphicsOffload00](self.impl))

proc enabled*(self: GraphicsOffload): GraphicsOffloadEnabled =
  gtk_graphics_offload_get_enabled(cast[ptr GraphicsOffload00](self.impl))

proc gtk_graphics_offload_set_enabled(self: ptr GraphicsOffload00; enabled: GraphicsOffloadEnabled) {.
    importc, libprag.}

proc setEnabled*(self: GraphicsOffload; enabled: GraphicsOffloadEnabled) =
  gtk_graphics_offload_set_enabled(cast[ptr GraphicsOffload00](self.impl), enabled)

proc `enabled=`*(self: GraphicsOffload; enabled: GraphicsOffloadEnabled) =
  gtk_graphics_offload_set_enabled(cast[ptr GraphicsOffload00](self.impl), enabled)

type
  PopoverMenuFlag* {.size: sizeof(cint), pure.} = enum
    nested = 0

  PopoverMenuFlags* = set[PopoverMenuFlag]

const
  PopoverMenuFlagsSliding* = PopoverMenuFlags({})
proc sliding*(t: typedesc[PopoverMenuFlags]): PopoverMenuFlags = PopoverMenuFlags({})

proc gtk_popover_menu_new_from_model_full(model: ptr gio.MenuModel00; flags: PopoverMenuFlags): ptr PopoverMenu00 {.
    importc, libprag.}

proc newPopoverMenuFromModelFull*(model: gio.MenuModel; flags: PopoverMenuFlags): PopoverMenu =
  let gobj = gtk_popover_menu_new_from_model_full(cast[ptr gio.MenuModel00](model.impl), flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPopoverMenuFromModelFull*(tdesc: typedesc; model: gio.MenuModel; flags: PopoverMenuFlags): tdesc =
  assert(result is PopoverMenu)
  let gobj = gtk_popover_menu_new_from_model_full(cast[ptr gio.MenuModel00](model.impl), flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopoverMenuFromModelFull*[T](result: var T; model: gio.MenuModel; flags: PopoverMenuFlags) {.deprecated.} =
  assert(result is PopoverMenu)
  let gobj = gtk_popover_menu_new_from_model_full(cast[ptr gio.MenuModel00](model.impl), flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_menu_get_flags(self: ptr PopoverMenu00): PopoverMenuFlags {.
    importc, libprag.}

proc getFlags*(self: PopoverMenu): PopoverMenuFlags =
  gtk_popover_menu_get_flags(cast[ptr PopoverMenu00](self.impl))

proc flags*(self: PopoverMenu): PopoverMenuFlags =
  gtk_popover_menu_get_flags(cast[ptr PopoverMenu00](self.impl))

proc gtk_popover_menu_set_flags(self: ptr PopoverMenu00; flags: PopoverMenuFlags) {.
    importc, libprag.}

proc setFlags*(self: PopoverMenu; flags: PopoverMenuFlags) =
  gtk_popover_menu_set_flags(cast[ptr PopoverMenu00](self.impl), flags)

proc `flags=`*(self: PopoverMenu; flags: PopoverMenuFlags) =
  gtk_popover_menu_set_flags(cast[ptr PopoverMenu00](self.impl), flags)

type
  SpinButtonUpdatePolicy* {.size: sizeof(cint), pure.} = enum
    always = 0
    ifValid = 1

proc gtk_spin_button_get_update_policy(self: ptr SpinButton00): SpinButtonUpdatePolicy {.
    importc, libprag.}

proc getUpdatePolicy*(self: SpinButton): SpinButtonUpdatePolicy =
  gtk_spin_button_get_update_policy(cast[ptr SpinButton00](self.impl))

proc updatePolicy*(self: SpinButton): SpinButtonUpdatePolicy =
  gtk_spin_button_get_update_policy(cast[ptr SpinButton00](self.impl))

proc gtk_spin_button_set_update_policy(self: ptr SpinButton00; policy: SpinButtonUpdatePolicy) {.
    importc, libprag.}

proc setUpdatePolicy*(self: SpinButton; policy: SpinButtonUpdatePolicy) =
  gtk_spin_button_set_update_policy(cast[ptr SpinButton00](self.impl), policy)

proc `updatePolicy=`*(self: SpinButton; policy: SpinButtonUpdatePolicy) =
  gtk_spin_button_set_update_policy(cast[ptr SpinButton00](self.impl), policy)

type
  SpinType* {.size: sizeof(cint), pure.} = enum
    stepForward = 0
    stepBackward = 1
    pageForward = 2
    pageBackward = 3
    home = 4
    `end` = 5
    userDefined = 6

proc gtk_spin_button_spin(self: ptr SpinButton00; direction: SpinType; increment: cdouble) {.
    importc, libprag.}

proc spin*(self: SpinButton; direction: SpinType; increment: cdouble) =
  gtk_spin_button_spin(cast[ptr SpinButton00](self.impl), direction, increment)

type
  TreeViewColumnSizing* {.size: sizeof(cint), pure.} = enum
    growOnly = 0
    autosize = 1
    fixed = 2

proc gtk_tree_view_column_get_sizing(self: ptr TreeViewColumn00): TreeViewColumnSizing {.
    importc, libprag.}

proc getSizing*(self: TreeViewColumn): TreeViewColumnSizing =
  gtk_tree_view_column_get_sizing(cast[ptr TreeViewColumn00](self.impl))

proc sizing*(self: TreeViewColumn): TreeViewColumnSizing =
  gtk_tree_view_column_get_sizing(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_set_sizing(self: ptr TreeViewColumn00; `type`: TreeViewColumnSizing) {.
    importc, libprag.}

proc setSizing*(self: TreeViewColumn; `type`: TreeViewColumnSizing) =
  gtk_tree_view_column_set_sizing(cast[ptr TreeViewColumn00](self.impl), `type`)

proc `sizing=`*(self: TreeViewColumn; `type`: TreeViewColumnSizing) =
  gtk_tree_view_column_set_sizing(cast[ptr TreeViewColumn00](self.impl), `type`)

type
  SortType* {.size: sizeof(cint), pure.} = enum
    ascending = 0
    descending = 1

proc gtk_tree_view_column_get_sort_order(self: ptr TreeViewColumn00): SortType {.
    importc, libprag.}

proc getSortOrder*(self: TreeViewColumn): SortType =
  gtk_tree_view_column_get_sort_order(cast[ptr TreeViewColumn00](self.impl))

proc sortOrder*(self: TreeViewColumn): SortType =
  gtk_tree_view_column_get_sort_order(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_set_sort_order(self: ptr TreeViewColumn00; order: SortType) {.
    importc, libprag.}

proc setSortOrder*(self: TreeViewColumn; order: SortType) =
  gtk_tree_view_column_set_sort_order(cast[ptr TreeViewColumn00](self.impl), order)

proc `sortOrder=`*(self: TreeViewColumn; order: SortType) =
  gtk_tree_view_column_set_sort_order(cast[ptr TreeViewColumn00](self.impl), order)

type
  TreeSelection* = ref object of gobject.Object
  TreeSelection00* = object of gobject.Object00

proc gtk_tree_selection_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeSelection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: TreeSelection;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_selection_count_selected_rows(self: ptr TreeSelection00): int32 {.
    importc, libprag.}

proc countSelectedRows*(self: TreeSelection): int =
  int(gtk_tree_selection_count_selected_rows(cast[ptr TreeSelection00](self.impl)))

proc gtk_tree_selection_get_selected(self: ptr TreeSelection00; model: var ptr TreeModel00;
    iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getSelected*(self: TreeSelection; model: var (TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) = cast[var TreeModel](nil);
    iter: var TreeIter = cast[var TreeIter](nil)): bool =
  var tmpoutgobjectarg: ptr TreeModel00
  result = toBool(gtk_tree_selection_get_selected(cast[ptr TreeSelection00](self.impl), cast[var ptr TreeModel00](if addr(model) == nil: nil else: addr tmpoutgobjectarg), iter))
#  dothemagic(model
  if addr(model) != nil:
    model = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      model = cast[type(model)](argqdata)
      assert(model.impl == tmpoutgobjectarg)
    else:
      fnew(model, gtk4.finalizeGObject)
      model.impl = tmpoutgobjectarg
      GC_ref(model)
      if g_object_is_floating(model.impl).int != 0:
        discard g_object_ref_sink(model.impl)
      g_object_add_toggle_ref(model.impl, toggleNotify, addr(model[]))
      g_object_unref(model.impl)
      assert(g_object_get_qdata(model.impl, Quark) == nil)
      g_object_set_qdata(model.impl, Quark, addr(model[]))


proc gtk_tree_selection_get_selected_rows(self: ptr TreeSelection00; model: var ptr TreeModel00): ptr glib.List {.
    importc, libprag.}

proc getSelectedRows*(self: TreeSelection; model: var (TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) = cast[var TreeModel](nil)): seq[TreePath] =
  var tmpoutgobjectarg: ptr TreeModel00
  let resul0 = gtk_tree_selection_get_selected_rows(cast[ptr TreeSelection00](self.impl), cast[var ptr TreeModel00](if addr(model) == nil: nil else: addr tmpoutgobjectarg))
  result = glistStructs2seq[TreePath](resul0, false)
  g_list_free(resul0)
#  dothemagic(model
  if addr(model) != nil:
    model = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      model = cast[type(model)](argqdata)
      assert(model.impl == tmpoutgobjectarg)
    else:
      fnew(model, gtk4.finalizeGObject)
      model.impl = tmpoutgobjectarg
      GC_ref(model)
      if g_object_is_floating(model.impl).int != 0:
        discard g_object_ref_sink(model.impl)
      g_object_add_toggle_ref(model.impl, toggleNotify, addr(model[]))
      g_object_unref(model.impl)
      assert(g_object_get_qdata(model.impl, Quark) == nil)
      g_object_set_qdata(model.impl, Quark, addr(model[]))


proc gtk_tree_selection_get_tree_view(self: ptr TreeSelection00): ptr TreeView00 {.
    importc, libprag.}

proc getTreeView*(self: TreeSelection): TreeView =
  let gobj = gtk_tree_selection_get_tree_view(cast[ptr TreeSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc treeView*(self: TreeSelection): TreeView =
  let gobj = gtk_tree_selection_get_tree_view(cast[ptr TreeSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_selection_iter_is_selected(self: ptr TreeSelection00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterIsSelected*(self: TreeSelection; iter: TreeIter): bool =
  toBool(gtk_tree_selection_iter_is_selected(cast[ptr TreeSelection00](self.impl), iter))

proc gtk_tree_selection_path_is_selected(self: ptr TreeSelection00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc pathIsSelected*(self: TreeSelection; path: TreePath): bool =
  toBool(gtk_tree_selection_path_is_selected(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_selection_select_all(self: ptr TreeSelection00) {.
    importc, libprag.}

proc selectAll*(self: TreeSelection) =
  gtk_tree_selection_select_all(cast[ptr TreeSelection00](self.impl))

proc gtk_tree_selection_select_iter(self: ptr TreeSelection00; iter: TreeIter) {.
    importc, libprag.}

proc selectIter*(self: TreeSelection; iter: TreeIter) =
  gtk_tree_selection_select_iter(cast[ptr TreeSelection00](self.impl), iter)

proc gtk_tree_selection_select_path(self: ptr TreeSelection00; path: ptr TreePath00) {.
    importc, libprag.}

proc selectPath*(self: TreeSelection; path: TreePath) =
  gtk_tree_selection_select_path(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_selection_select_range(self: ptr TreeSelection00; startPath: ptr TreePath00;
    endPath: ptr TreePath00) {.
    importc, libprag.}

proc selectRange*(self: TreeSelection; startPath: TreePath;
    endPath: TreePath) =
  gtk_tree_selection_select_range(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](startPath.impl), cast[ptr TreePath00](endPath.impl))

proc gtk_tree_selection_unselect_all(self: ptr TreeSelection00) {.
    importc, libprag.}

proc unselectAll*(self: TreeSelection) =
  gtk_tree_selection_unselect_all(cast[ptr TreeSelection00](self.impl))

proc gtk_tree_selection_unselect_iter(self: ptr TreeSelection00; iter: TreeIter) {.
    importc, libprag.}

proc unselectIter*(self: TreeSelection; iter: TreeIter) =
  gtk_tree_selection_unselect_iter(cast[ptr TreeSelection00](self.impl), iter)

proc gtk_tree_selection_unselect_path(self: ptr TreeSelection00; path: ptr TreePath00) {.
    importc, libprag.}

proc unselectPath*(self: TreeSelection; path: TreePath) =
  gtk_tree_selection_unselect_path(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_selection_unselect_range(self: ptr TreeSelection00; startPath: ptr TreePath00;
    endPath: ptr TreePath00) {.
    importc, libprag.}

proc unselectRange*(self: TreeSelection; startPath: TreePath;
    endPath: TreePath) =
  gtk_tree_selection_unselect_range(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](startPath.impl), cast[ptr TreePath00](endPath.impl))

proc gtk_tree_view_get_selection(self: ptr TreeView00): ptr TreeSelection00 {.
    importc, libprag.}

proc getSelection*(self: TreeView): TreeSelection =
  let gobj = gtk_tree_view_get_selection(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selection*(self: TreeView): TreeSelection =
  let gobj = gtk_tree_view_get_selection(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TreeViewDropPosition* {.size: sizeof(cint), pure.} = enum
    before = 0
    after = 1
    intoOrBefore = 2
    intoOrAfter = 3

proc gtk_tree_view_get_dest_row_at_pos(self: ptr TreeView00; dragX: int32;
    dragY: int32; path: var ptr TreePath00; pos: var TreeViewDropPosition): gboolean {.
    importc, libprag.}

proc getDestRowAtPos*(self: TreeView; dragX: int; dragY: int;
    path: var TreePath = cast[var TreePath](nil); pos: var TreeViewDropPosition = cast[var TreeViewDropPosition](nil)): bool =
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_tree_view_get_dest_row_at_pos(cast[ptr TreeView00](self.impl), int32(dragX), int32(dragY), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), pos))
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil

proc gtk_tree_view_get_drag_dest_row(self: ptr TreeView00; path: var ptr TreePath00;
    pos: var TreeViewDropPosition) {.
    importc, libprag.}

proc getDragDestRow*(self: TreeView; path: var TreePath = cast[var TreePath](nil);
    pos: var TreeViewDropPosition = cast[var TreeViewDropPosition](nil)) =
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  gtk_tree_view_get_drag_dest_row(cast[ptr TreeView00](self.impl), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), pos)
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil

proc gtk_tree_view_set_drag_dest_row(self: ptr TreeView00; path: ptr TreePath00;
    pos: TreeViewDropPosition) {.
    importc, libprag.}

proc setDragDestRow*(self: TreeView; path: TreePath = nil;
    pos: TreeViewDropPosition) =
  gtk_tree_view_set_drag_dest_row(cast[ptr TreeView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), pos)

type
  TreeViewGridLines* {.size: sizeof(cint), pure.} = enum
    none = 0
    horizontal = 1
    vertical = 2
    both = 3

proc gtk_tree_view_get_grid_lines(self: ptr TreeView00): TreeViewGridLines {.
    importc, libprag.}

proc getGridLines*(self: TreeView): TreeViewGridLines =
  gtk_tree_view_get_grid_lines(cast[ptr TreeView00](self.impl))

proc gridLines*(self: TreeView): TreeViewGridLines =
  gtk_tree_view_get_grid_lines(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_set_grid_lines(self: ptr TreeView00; gridLines: TreeViewGridLines) {.
    importc, libprag.}

proc setGridLines*(self: TreeView; gridLines: TreeViewGridLines) =
  gtk_tree_view_set_grid_lines(cast[ptr TreeView00](self.impl), gridLines)

proc `gridLines=`*(self: TreeView; gridLines: TreeViewGridLines) =
  gtk_tree_view_set_grid_lines(cast[ptr TreeView00](self.impl), gridLines)

type
  NotebookPage* = ref object of gobject.Object
  NotebookPage00* = object of gobject.Object00

proc gtk_notebook_page_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NotebookPage()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_notebook_page_get_child(self: ptr NotebookPage00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: NotebookPage): Widget =
  let gobj = gtk_notebook_page_get_child(cast[ptr NotebookPage00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: NotebookPage): Widget =
  let gobj = gtk_notebook_page_get_child(cast[ptr NotebookPage00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_page(self: ptr Notebook00; child: ptr Widget00): ptr NotebookPage00 {.
    importc, libprag.}

proc getPage*(self: Notebook; child: Widget): NotebookPage =
  let gobj = gtk_notebook_get_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ContentFit* {.size: sizeof(cint), pure.} = enum
    fill = 0
    contain = 1
    cover = 2
    scaleDown = 3

proc gtk_picture_get_content_fit(self: ptr Picture00): ContentFit {.
    importc, libprag.}

proc getContentFit*(self: Picture): ContentFit =
  gtk_picture_get_content_fit(cast[ptr Picture00](self.impl))

proc contentFit*(self: Picture): ContentFit =
  gtk_picture_get_content_fit(cast[ptr Picture00](self.impl))

proc gtk_picture_set_content_fit(self: ptr Picture00; contentFit: ContentFit) {.
    importc, libprag.}

proc setContentFit*(self: Picture; contentFit: ContentFit) =
  gtk_picture_set_content_fit(cast[ptr Picture00](self.impl), contentFit)

proc `contentFit=`*(self: Picture; contentFit: ContentFit) =
  gtk_picture_set_content_fit(cast[ptr Picture00](self.impl), contentFit)

type
  RevealerTransitionType* {.size: sizeof(cint), pure.} = enum
    none = 0
    crossfade = 1
    slideRight = 2
    slideLeft = 3
    slideUp = 4
    slideDown = 5
    swingRight = 6
    swingLeft = 7
    swingUp = 8
    swingDown = 9

proc gtk_revealer_get_transition_type(self: ptr Revealer00): RevealerTransitionType {.
    importc, libprag.}

proc getTransitionType*(self: Revealer): RevealerTransitionType =
  gtk_revealer_get_transition_type(cast[ptr Revealer00](self.impl))

proc transitionType*(self: Revealer): RevealerTransitionType =
  gtk_revealer_get_transition_type(cast[ptr Revealer00](self.impl))

proc gtk_revealer_set_transition_type(self: ptr Revealer00; transition: RevealerTransitionType) {.
    importc, libprag.}

proc setTransitionType*(self: Revealer; transition: RevealerTransitionType) =
  gtk_revealer_set_transition_type(cast[ptr Revealer00](self.impl), transition)

proc `transitionType=`*(self: Revealer; transition: RevealerTransitionType) =
  gtk_revealer_set_transition_type(cast[ptr Revealer00](self.impl), transition)

type
  EntryBuffer* = ref object of gobject.Object
  EntryBuffer00* = object of gobject.Object00

proc gtk_entry_buffer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EntryBuffer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDeletedText*(self: EntryBuffer;  p: proc (self: ptr EntryBuffer00; position: uint32; nChars: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "deleted-text", cast[GCallback](p), xdata, nil, cf)

proc scInsertedText*(self: EntryBuffer;  p: proc (self: ptr EntryBuffer00; position: uint32; chars: cstring; nChars: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "inserted-text", cast[GCallback](p), xdata, nil, cf)

proc gtk_entry_buffer_new(initialChars: cstring; nInitialChars: int32): ptr EntryBuffer00 {.
    importc, libprag.}

proc newEntryBuffer*(initialChars: cstring = nil; nInitialChars: int): EntryBuffer =
  let gobj = gtk_entry_buffer_new(initialChars, int32(nInitialChars))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntryBuffer*(tdesc: typedesc; initialChars: cstring = nil; nInitialChars: int): tdesc =
  assert(result is EntryBuffer)
  let gobj = gtk_entry_buffer_new(initialChars, int32(nInitialChars))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryBuffer*[T](result: var T; initialChars: cstring = nil; nInitialChars: int) {.deprecated.} =
  assert(result is EntryBuffer)
  let gobj = gtk_entry_buffer_new(initialChars, int32(nInitialChars))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_buffer_delete_text(self: ptr EntryBuffer00; position: uint32;
    nChars: int32): uint32 {.
    importc, libprag.}

proc deleteText*(self: EntryBuffer; position: int; nChars: int): int =
  int(gtk_entry_buffer_delete_text(cast[ptr EntryBuffer00](self.impl), uint32(position), int32(nChars)))

proc gtk_entry_buffer_emit_deleted_text(self: ptr EntryBuffer00; position: uint32;
    nChars: uint32) {.
    importc, libprag.}

proc emitDeletedText*(self: EntryBuffer; position: int;
    nChars: int) =
  gtk_entry_buffer_emit_deleted_text(cast[ptr EntryBuffer00](self.impl), uint32(position), uint32(nChars))

proc gtk_entry_buffer_emit_inserted_text(self: ptr EntryBuffer00; position: uint32;
    chars: cstring; nChars: uint32) {.
    importc, libprag.}

proc emitInsertedText*(self: EntryBuffer; position: int;
    chars: cstring; nChars: int) =
  gtk_entry_buffer_emit_inserted_text(cast[ptr EntryBuffer00](self.impl), uint32(position), chars, uint32(nChars))

proc gtk_entry_buffer_get_bytes(self: ptr EntryBuffer00): uint64 {.
    importc, libprag.}

proc getBytes*(self: EntryBuffer): uint64 =
  gtk_entry_buffer_get_bytes(cast[ptr EntryBuffer00](self.impl))

proc bytes*(self: EntryBuffer): uint64 =
  gtk_entry_buffer_get_bytes(cast[ptr EntryBuffer00](self.impl))

proc gtk_entry_buffer_get_length(self: ptr EntryBuffer00): uint32 {.
    importc, libprag.}

proc getLength*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_length(cast[ptr EntryBuffer00](self.impl)))

proc length*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_length(cast[ptr EntryBuffer00](self.impl)))

proc gtk_entry_buffer_get_max_length(self: ptr EntryBuffer00): int32 {.
    importc, libprag.}

proc getMaxLength*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_max_length(cast[ptr EntryBuffer00](self.impl)))

proc maxLength*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_max_length(cast[ptr EntryBuffer00](self.impl)))

proc gtk_entry_buffer_get_text(self: ptr EntryBuffer00): cstring {.
    importc, libprag.}

proc getText*(self: EntryBuffer): string =
  result = $gtk_entry_buffer_get_text(cast[ptr EntryBuffer00](self.impl))

proc text*(self: EntryBuffer): string =
  result = $gtk_entry_buffer_get_text(cast[ptr EntryBuffer00](self.impl))

proc gtk_entry_buffer_insert_text(self: ptr EntryBuffer00; position: uint32;
    chars: cstring; nChars: int32): uint32 {.
    importc, libprag.}

proc insertText*(self: EntryBuffer; position: int; chars: cstring;
    nChars: int): int =
  int(gtk_entry_buffer_insert_text(cast[ptr EntryBuffer00](self.impl), uint32(position), chars, int32(nChars)))

proc gtk_entry_buffer_set_max_length(self: ptr EntryBuffer00; maxLength: int32) {.
    importc, libprag.}

proc setMaxLength*(self: EntryBuffer; maxLength: int) =
  gtk_entry_buffer_set_max_length(cast[ptr EntryBuffer00](self.impl), int32(maxLength))

proc `maxLength=`*(self: EntryBuffer; maxLength: int) =
  gtk_entry_buffer_set_max_length(cast[ptr EntryBuffer00](self.impl), int32(maxLength))

proc gtk_entry_buffer_set_text(self: ptr EntryBuffer00; chars: cstring; nChars: int32) {.
    importc, libprag.}

proc setText*(self: EntryBuffer; chars: cstring; nChars: int) =
  gtk_entry_buffer_set_text(cast[ptr EntryBuffer00](self.impl), chars, int32(nChars))

proc gtk_entry_new_with_buffer(buffer: ptr EntryBuffer00): ptr Entry00 {.
    importc, libprag.}

proc newEntryWithBuffer*(buffer: EntryBuffer): Entry =
  let gobj = gtk_entry_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntryWithBuffer*(tdesc: typedesc; buffer: EntryBuffer): tdesc =
  assert(result is Entry)
  let gobj = gtk_entry_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryWithBuffer*[T](result: var T; buffer: EntryBuffer) {.deprecated.} =
  assert(result is Entry)
  let gobj = gtk_entry_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_buffer(self: ptr Entry00): ptr EntryBuffer00 {.
    importc, libprag.}

proc getBuffer*(self: Entry): EntryBuffer =
  let gobj = gtk_entry_get_buffer(cast[ptr Entry00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: Entry): EntryBuffer =
  let gobj = gtk_entry_get_buffer(cast[ptr Entry00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_set_buffer(self: ptr Entry00; buffer: ptr EntryBuffer00) {.
    importc, libprag.}

proc setBuffer*(self: Entry; buffer: EntryBuffer) =
  gtk_entry_set_buffer(cast[ptr Entry00](self.impl), cast[ptr EntryBuffer00](buffer.impl))

proc `buffer=`*(self: Entry; buffer: EntryBuffer) =
  gtk_entry_set_buffer(cast[ptr Entry00](self.impl), cast[ptr EntryBuffer00](buffer.impl))

proc gtk_text_new_with_buffer(buffer: ptr EntryBuffer00): ptr Text00 {.
    importc, libprag.}

proc newTextWithBuffer*(buffer: EntryBuffer): Text =
  let gobj = gtk_text_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextWithBuffer*(tdesc: typedesc; buffer: EntryBuffer): tdesc =
  assert(result is Text)
  let gobj = gtk_text_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextWithBuffer*[T](result: var T; buffer: EntryBuffer) {.deprecated.} =
  assert(result is Text)
  let gobj = gtk_text_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_get_buffer(self: ptr Text00): ptr EntryBuffer00 {.
    importc, libprag.}

proc getBuffer*(self: Text): EntryBuffer =
  let gobj = gtk_text_get_buffer(cast[ptr Text00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: Text): EntryBuffer =
  let gobj = gtk_text_get_buffer(cast[ptr Text00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_set_buffer(self: ptr Text00; buffer: ptr EntryBuffer00) {.
    importc, libprag.}

proc setBuffer*(self: Text; buffer: EntryBuffer) =
  gtk_text_set_buffer(cast[ptr Text00](self.impl), cast[ptr EntryBuffer00](buffer.impl))

proc `buffer=`*(self: Text; buffer: EntryBuffer) =
  gtk_text_set_buffer(cast[ptr Text00](self.impl), cast[ptr EntryBuffer00](buffer.impl))

type
  EntryCompletion* = ref object of gobject.Object
  EntryCompletion00* = object of gobject.Object00

proc gtk_entry_completion_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EntryCompletion()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scCursorOnMatch*(self: EntryCompletion;  p: proc (self: ptr EntryCompletion00; model: ptr TreeModel00; iter: TreeIter; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cursor-on-match", cast[GCallback](p), xdata, nil, cf)

proc scInsertPrefix*(self: EntryCompletion;  p: proc (self: ptr EntryCompletion00; prefix: cstring; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-prefix", cast[GCallback](p), xdata, nil, cf)

proc scMatchSelected*(self: EntryCompletion;  p: proc (self: ptr EntryCompletion00; model: ptr TreeModel00; iter: TreeIter; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "match-selected", cast[GCallback](p), xdata, nil, cf)

proc scNoMatches*(self: EntryCompletion;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "no-matches", cast[GCallback](p), xdata, nil, cf)

proc gtk_entry_completion_new(): ptr EntryCompletion00 {.
    importc, libprag.}

proc newEntryCompletion*(): EntryCompletion {.deprecated.}  =
  let gobj = gtk_entry_completion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntryCompletion*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is EntryCompletion)
  let gobj = gtk_entry_completion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryCompletion*[T](result: var T) {.deprecated.} =
  assert(result is EntryCompletion)
  let gobj = gtk_entry_completion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_complete(self: ptr EntryCompletion00) {.
    importc, libprag.}

proc complete*(self: EntryCompletion) =
  gtk_entry_completion_complete(cast[ptr EntryCompletion00](self.impl))

proc gtk_entry_completion_compute_prefix(self: ptr EntryCompletion00; key: cstring): cstring {.
    importc, libprag.}

proc computePrefix*(self: EntryCompletion; key: cstring): string =
  let resul0 = gtk_entry_completion_compute_prefix(cast[ptr EntryCompletion00](self.impl), key)
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_entry_completion_get_completion_prefix(self: ptr EntryCompletion00): cstring {.
    importc, libprag.}

proc getCompletionPrefix*(self: EntryCompletion): string =
  let resul0 = gtk_entry_completion_get_completion_prefix(cast[ptr EntryCompletion00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc completionPrefix*(self: EntryCompletion): string =
  let resul0 = gtk_entry_completion_get_completion_prefix(cast[ptr EntryCompletion00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_entry_completion_get_entry(self: ptr EntryCompletion00): ptr Widget00 {.
    importc, libprag.}

proc getEntry*(self: EntryCompletion): Widget =
  let gobj = gtk_entry_completion_get_entry(cast[ptr EntryCompletion00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc entry*(self: EntryCompletion): Widget =
  let gobj = gtk_entry_completion_get_entry(cast[ptr EntryCompletion00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_get_inline_completion(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getInlineCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_completion(cast[ptr EntryCompletion00](self.impl)))

proc inlineCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_completion(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_inline_selection(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getInlineSelection*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_selection(cast[ptr EntryCompletion00](self.impl)))

proc inlineSelection*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_selection(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_minimum_key_length(self: ptr EntryCompletion00): int32 {.
    importc, libprag.}

proc getMinimumKeyLength*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_minimum_key_length(cast[ptr EntryCompletion00](self.impl)))

proc minimumKeyLength*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_minimum_key_length(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_model(self: ptr EntryCompletion00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: EntryCompletion): TreeModel =
  let gobj = gtk_entry_completion_get_model(cast[ptr EntryCompletion00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: EntryCompletion): TreeModel =
  let gobj = gtk_entry_completion_get_model(cast[ptr EntryCompletion00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_get_popup_completion(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getPopupCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_completion(cast[ptr EntryCompletion00](self.impl)))

proc popupCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_completion(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_popup_set_width(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getPopupSetWidth*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_set_width(cast[ptr EntryCompletion00](self.impl)))

proc popupSetWidth*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_set_width(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_popup_single_match(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getPopupSingleMatch*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_single_match(cast[ptr EntryCompletion00](self.impl)))

proc popupSingleMatch*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_single_match(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_text_column(self: ptr EntryCompletion00): int32 {.
    importc, libprag.}

proc getTextColumn*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_text_column(cast[ptr EntryCompletion00](self.impl)))

proc textColumn*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_text_column(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_insert_prefix(self: ptr EntryCompletion00) {.
    importc, libprag.}

proc insertPrefix*(self: EntryCompletion) =
  gtk_entry_completion_insert_prefix(cast[ptr EntryCompletion00](self.impl))

proc gtk_entry_completion_set_inline_completion(self: ptr EntryCompletion00;
    inlineCompletion: gboolean) {.
    importc, libprag.}

proc setInlineCompletion*(self: EntryCompletion; inlineCompletion: bool = true) =
  gtk_entry_completion_set_inline_completion(cast[ptr EntryCompletion00](self.impl), gboolean(inlineCompletion))

proc `inlineCompletion=`*(self: EntryCompletion; inlineCompletion: bool) =
  gtk_entry_completion_set_inline_completion(cast[ptr EntryCompletion00](self.impl), gboolean(inlineCompletion))

proc gtk_entry_completion_set_inline_selection(self: ptr EntryCompletion00;
    inlineSelection: gboolean) {.
    importc, libprag.}

proc setInlineSelection*(self: EntryCompletion; inlineSelection: bool = true) =
  gtk_entry_completion_set_inline_selection(cast[ptr EntryCompletion00](self.impl), gboolean(inlineSelection))

proc `inlineSelection=`*(self: EntryCompletion; inlineSelection: bool) =
  gtk_entry_completion_set_inline_selection(cast[ptr EntryCompletion00](self.impl), gboolean(inlineSelection))

proc gtk_entry_completion_set_minimum_key_length(self: ptr EntryCompletion00;
    length: int32) {.
    importc, libprag.}

proc setMinimumKeyLength*(self: EntryCompletion; length: int) =
  gtk_entry_completion_set_minimum_key_length(cast[ptr EntryCompletion00](self.impl), int32(length))

proc `minimumKeyLength=`*(self: EntryCompletion; length: int) =
  gtk_entry_completion_set_minimum_key_length(cast[ptr EntryCompletion00](self.impl), int32(length))

proc gtk_entry_completion_set_model(self: ptr EntryCompletion00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: EntryCompletion; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_entry_completion_set_model(cast[ptr EntryCompletion00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: EntryCompletion; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore = TreeModel(nil)) =
  gtk_entry_completion_set_model(cast[ptr EntryCompletion00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc gtk_entry_completion_set_popup_completion(self: ptr EntryCompletion00;
    popupCompletion: gboolean) {.
    importc, libprag.}

proc setPopupCompletion*(self: EntryCompletion; popupCompletion: bool = true) =
  gtk_entry_completion_set_popup_completion(cast[ptr EntryCompletion00](self.impl), gboolean(popupCompletion))

proc `popupCompletion=`*(self: EntryCompletion; popupCompletion: bool) =
  gtk_entry_completion_set_popup_completion(cast[ptr EntryCompletion00](self.impl), gboolean(popupCompletion))

proc gtk_entry_completion_set_popup_set_width(self: ptr EntryCompletion00;
    popupSetWidth: gboolean) {.
    importc, libprag.}

proc setPopupSetWidth*(self: EntryCompletion; popupSetWidth: bool = true) =
  gtk_entry_completion_set_popup_set_width(cast[ptr EntryCompletion00](self.impl), gboolean(popupSetWidth))

proc `popupSetWidth=`*(self: EntryCompletion; popupSetWidth: bool) =
  gtk_entry_completion_set_popup_set_width(cast[ptr EntryCompletion00](self.impl), gboolean(popupSetWidth))

proc gtk_entry_completion_set_popup_single_match(self: ptr EntryCompletion00;
    popupSingleMatch: gboolean) {.
    importc, libprag.}

proc setPopupSingleMatch*(self: EntryCompletion; popupSingleMatch: bool = true) =
  gtk_entry_completion_set_popup_single_match(cast[ptr EntryCompletion00](self.impl), gboolean(popupSingleMatch))

proc `popupSingleMatch=`*(self: EntryCompletion; popupSingleMatch: bool) =
  gtk_entry_completion_set_popup_single_match(cast[ptr EntryCompletion00](self.impl), gboolean(popupSingleMatch))

proc gtk_entry_completion_set_text_column(self: ptr EntryCompletion00; column: int32) {.
    importc, libprag.}

proc setTextColumn*(self: EntryCompletion; column: int) =
  gtk_entry_completion_set_text_column(cast[ptr EntryCompletion00](self.impl), int32(column))

proc `textColumn=`*(self: EntryCompletion; column: int) =
  gtk_entry_completion_set_text_column(cast[ptr EntryCompletion00](self.impl), int32(column))

proc gtk_entry_get_completion(self: ptr Entry00): ptr EntryCompletion00 {.
    importc, libprag.}

proc getCompletion*(self: Entry): EntryCompletion =
  let gobj = gtk_entry_get_completion(cast[ptr Entry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc completion*(self: Entry): EntryCompletion =
  let gobj = gtk_entry_get_completion(cast[ptr Entry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_set_completion(self: ptr Entry00; completion: ptr EntryCompletion00) {.
    importc, libprag.}

proc setCompletion*(self: Entry; completion: EntryCompletion = nil) =
  gtk_entry_set_completion(cast[ptr Entry00](self.impl), if completion.isNil: nil else: cast[ptr EntryCompletion00](completion.impl))

proc `completion=`*(self: Entry; completion: EntryCompletion = nil) =
  gtk_entry_set_completion(cast[ptr Entry00](self.impl), if completion.isNil: nil else: cast[ptr EntryCompletion00](completion.impl))

type
  IconViewDropPosition* {.size: sizeof(cint), pure.} = enum
    noDrop = 0
    dropInto = 1
    dropLeft = 2
    dropRight = 3
    dropAbove = 4
    dropBelow = 5

proc gtk_icon_view_get_dest_item_at_pos(self: ptr IconView00; dragX: int32;
    dragY: int32; path: var ptr TreePath00; pos: var IconViewDropPosition): gboolean {.
    importc, libprag.}

proc getDestItemAtPos*(self: IconView; dragX: int; dragY: int;
    path: var TreePath = cast[var TreePath](nil); pos: var IconViewDropPosition = cast[var IconViewDropPosition](nil)): bool =
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  toBool(gtk_icon_view_get_dest_item_at_pos(cast[ptr IconView00](self.impl), int32(dragX), int32(dragY), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), pos))

proc gtk_icon_view_get_drag_dest_item(self: ptr IconView00; path: var ptr TreePath00;
    pos: var IconViewDropPosition) {.
    importc, libprag.}

proc getDragDestItem*(self: IconView; path: var TreePath = cast[var TreePath](nil);
    pos: var IconViewDropPosition = cast[var IconViewDropPosition](nil)) =
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  gtk_icon_view_get_drag_dest_item(cast[ptr IconView00](self.impl), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), pos)
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil

proc gtk_icon_view_set_drag_dest_item(self: ptr IconView00; path: ptr TreePath00;
    pos: IconViewDropPosition) {.
    importc, libprag.}

proc setDragDestItem*(self: IconView; path: TreePath = nil;
    pos: IconViewDropPosition) =
  gtk_icon_view_set_drag_dest_item(cast[ptr IconView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), pos)

type
  CellEditable00* = object of gobject.Object00
  CellEditable* = ref object of gobject.Object

proc scEditingDone*(self: CellEditable | ComboBox | ComboBoxText | Entry | SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "editing-done", cast[GCallback](p), xdata, nil, cf)

proc scRemoveWidget*(self: CellEditable | ComboBox | ComboBoxText | Entry | SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "remove-widget", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_editable_editing_done(self: ptr CellEditable00) {.
    importc, libprag.}

proc editingDone*(self: CellEditable | ComboBox | ComboBoxText | Entry | SpinButton) =
  gtk_cell_editable_editing_done(cast[ptr CellEditable00](self.impl))

proc gtk_cell_editable_remove_widget(self: ptr CellEditable00) {.
    importc, libprag.}

proc removeWidget*(self: CellEditable | ComboBox | ComboBoxText | Entry | SpinButton) =
  gtk_cell_editable_remove_widget(cast[ptr CellEditable00](self.impl))

proc gtk_cell_editable_start_editing(self: ptr CellEditable00; event: ptr gdk4.Event00) {.
    importc, libprag.}

proc startEditing*(self: CellEditable | ComboBox | ComboBoxText | Entry | SpinButton;
    event: gdk4.Event = nil) =
  gtk_cell_editable_start_editing(cast[ptr CellEditable00](self.impl), if event.isNil: nil else: cast[ptr gdk4.Event00](event.impl))

type
  CellRenderer* = ref object of gobject.InitiallyUnowned
  CellRenderer00* = object of gobject.InitiallyUnowned00

proc gtk_cell_renderer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRenderer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEditingCanceled*(self: CellRenderer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "editing-canceled", cast[GCallback](p), xdata, nil, cf)

proc scEditingStarted*(self: CellRenderer;  p: proc (self: ptr CellRenderer00; editable: ptr CellEditable00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "editing-started", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_get_alignment(self: ptr CellRenderer00; xalign: var cfloat;
    yalign: var cfloat) {.
    importc, libprag.}

proc getAlignment*(self: CellRenderer; xalign: var cfloat = cast[var cfloat](nil);
    yalign: var cfloat = cast[var cfloat](nil)) =
  gtk_cell_renderer_get_alignment(cast[ptr CellRenderer00](self.impl), xalign, yalign)

proc gtk_cell_renderer_get_fixed_size(self: ptr CellRenderer00; width: var int32;
    height: var int32) {.
    importc, libprag.}

proc getFixedSize*(self: CellRenderer; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var height_00: int32
  var width_00: int32
  gtk_cell_renderer_get_fixed_size(cast[ptr CellRenderer00](self.impl), width_00, height_00)
  if height.addr != nil:
    height = int(height_00)
  if width.addr != nil:
    width = int(width_00)

proc gtk_cell_renderer_get_is_expanded(self: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getIsExpanded*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_is_expanded(cast[ptr CellRenderer00](self.impl)))

proc isExpanded*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_is_expanded(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_get_is_expander(self: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getIsExpander*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_is_expander(cast[ptr CellRenderer00](self.impl)))

proc isExpander*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_is_expander(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_get_padding(self: ptr CellRenderer00; xpad: var int32;
    ypad: var int32) {.
    importc, libprag.}

proc getPadding*(self: CellRenderer; xpad: var int = cast[var int](nil);
    ypad: var int = cast[var int](nil)) =
  var xpad_00: int32
  var ypad_00: int32
  gtk_cell_renderer_get_padding(cast[ptr CellRenderer00](self.impl), xpad_00, ypad_00)
  if xpad.addr != nil:
    xpad = int(xpad_00)
  if ypad.addr != nil:
    ypad = int(ypad_00)

proc gtk_cell_renderer_get_preferred_height(self: ptr CellRenderer00; widget: ptr Widget00;
    minimumSize: var int32; naturalSize: var int32) {.
    importc, libprag.}

proc getPreferredHeight*(self: CellRenderer; widget: Widget;
    minimumSize: var int = cast[var int](nil); naturalSize: var int = cast[var int](nil)) =
  var minimumSize_00: int32
  var naturalSize_00: int32
  gtk_cell_renderer_get_preferred_height(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize_00, naturalSize_00)
  if minimumSize.addr != nil:
    minimumSize = int(minimumSize_00)
  if naturalSize.addr != nil:
    naturalSize = int(naturalSize_00)

proc gtk_cell_renderer_get_preferred_height_for_width(self: ptr CellRenderer00;
    widget: ptr Widget00; width: int32; minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeightForWidth*(self: CellRenderer;
    widget: Widget; width: int; minimumHeight: var int = cast[var int](nil);
    naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_renderer_get_preferred_height_for_width(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), int32(width), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_renderer_get_preferred_width(self: ptr CellRenderer00; widget: ptr Widget00;
    minimumSize: var int32; naturalSize: var int32) {.
    importc, libprag.}

proc getPreferredWidth*(self: CellRenderer; widget: Widget;
    minimumSize: var int = cast[var int](nil); naturalSize: var int = cast[var int](nil)) =
  var minimumSize_00: int32
  var naturalSize_00: int32
  gtk_cell_renderer_get_preferred_width(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize_00, naturalSize_00)
  if minimumSize.addr != nil:
    minimumSize = int(minimumSize_00)
  if naturalSize.addr != nil:
    naturalSize = int(naturalSize_00)

proc gtk_cell_renderer_get_preferred_width_for_height(self: ptr CellRenderer00;
    widget: ptr Widget00; height: int32; minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidthForHeight*(self: CellRenderer;
    widget: Widget; height: int; minimumWidth: var int = cast[var int](nil);
    naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_renderer_get_preferred_width_for_height(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), int32(height), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_cell_renderer_get_sensitive(self: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getSensitive*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_sensitive(cast[ptr CellRenderer00](self.impl)))

proc sensitive*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_sensitive(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_get_visible(self: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getVisible*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_visible(cast[ptr CellRenderer00](self.impl)))

proc visible*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_visible(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_is_activatable(self: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc isActivatable*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_is_activatable(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_set_alignment(self: ptr CellRenderer00; xalign: cfloat;
    yalign: cfloat) {.
    importc, libprag.}

proc setAlignment*(self: CellRenderer; xalign: cfloat;
    yalign: cfloat) =
  gtk_cell_renderer_set_alignment(cast[ptr CellRenderer00](self.impl), xalign, yalign)

proc gtk_cell_renderer_set_fixed_size(self: ptr CellRenderer00; width: int32;
    height: int32) {.
    importc, libprag.}

proc setFixedSize*(self: CellRenderer; width: int; height: int) =
  gtk_cell_renderer_set_fixed_size(cast[ptr CellRenderer00](self.impl), int32(width), int32(height))

proc gtk_cell_renderer_set_is_expanded(self: ptr CellRenderer00; isExpanded: gboolean) {.
    importc, libprag.}

proc setIsExpanded*(self: CellRenderer; isExpanded: bool = true) =
  gtk_cell_renderer_set_is_expanded(cast[ptr CellRenderer00](self.impl), gboolean(isExpanded))

proc `isExpanded=`*(self: CellRenderer; isExpanded: bool) =
  gtk_cell_renderer_set_is_expanded(cast[ptr CellRenderer00](self.impl), gboolean(isExpanded))

proc gtk_cell_renderer_set_is_expander(self: ptr CellRenderer00; isExpander: gboolean) {.
    importc, libprag.}

proc setIsExpander*(self: CellRenderer; isExpander: bool = true) =
  gtk_cell_renderer_set_is_expander(cast[ptr CellRenderer00](self.impl), gboolean(isExpander))

proc `isExpander=`*(self: CellRenderer; isExpander: bool) =
  gtk_cell_renderer_set_is_expander(cast[ptr CellRenderer00](self.impl), gboolean(isExpander))

proc gtk_cell_renderer_set_padding(self: ptr CellRenderer00; xpad: int32;
    ypad: int32) {.
    importc, libprag.}

proc setPadding*(self: CellRenderer; xpad: int; ypad: int) =
  gtk_cell_renderer_set_padding(cast[ptr CellRenderer00](self.impl), int32(xpad), int32(ypad))

proc gtk_cell_renderer_set_sensitive(self: ptr CellRenderer00; sensitive: gboolean) {.
    importc, libprag.}

proc setSensitive*(self: CellRenderer; sensitive: bool = true) =
  gtk_cell_renderer_set_sensitive(cast[ptr CellRenderer00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: CellRenderer; sensitive: bool) =
  gtk_cell_renderer_set_sensitive(cast[ptr CellRenderer00](self.impl), gboolean(sensitive))

proc gtk_cell_renderer_set_visible(self: ptr CellRenderer00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: CellRenderer; visible: bool = true) =
  gtk_cell_renderer_set_visible(cast[ptr CellRenderer00](self.impl), gboolean(visible))

proc `visible=`*(self: CellRenderer; visible: bool) =
  gtk_cell_renderer_set_visible(cast[ptr CellRenderer00](self.impl), gboolean(visible))

proc gtk_cell_renderer_stop_editing(self: ptr CellRenderer00; canceled: gboolean) {.
    importc, libprag.}

proc stopEditing*(self: CellRenderer; canceled: bool) =
  gtk_cell_renderer_stop_editing(cast[ptr CellRenderer00](self.impl), gboolean(canceled))

proc gtk_icon_view_get_cell_rect(self: ptr IconView00; path: ptr TreePath00;
    cell: ptr CellRenderer00; rect: var gdk4.Rectangle): gboolean {.
    importc, libprag.}

proc getCellRect*(self: IconView; path: TreePath; cell: CellRenderer = nil;
    rect: var gdk4.Rectangle): bool =
  toBool(gtk_icon_view_get_cell_rect(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl), if cell.isNil: nil else: cast[ptr CellRenderer00](cell.impl), rect))

proc gtk_icon_view_get_cursor(self: ptr IconView00; path: var ptr TreePath00;
    cell: var ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getCursor*(self: IconView; path: var TreePath = cast[var TreePath](nil);
    cell: var CellRenderer = cast[var CellRenderer](nil)): bool =
  var tmpoutgobjectarg: ptr CellRenderer00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_icon_view_get_cursor(cast[ptr IconView00](self.impl), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr CellRenderer00](if addr(cell) == nil: nil else: addr tmpoutgobjectarg)))
#  dothemagic(cell
  if addr(cell) != nil:
    cell = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      cell = cast[type(cell)](argqdata)
      assert(cell.impl == tmpoutgobjectarg)
    else:
      fnew(cell, gtk4.finalizeGObject)
      cell.impl = tmpoutgobjectarg
      GC_ref(cell)
      if g_object_is_floating(cell.impl).int != 0:
        discard g_object_ref_sink(cell.impl)
      g_object_add_toggle_ref(cell.impl, toggleNotify, addr(cell[]))
      g_object_unref(cell.impl)
      assert(g_object_get_qdata(cell.impl, Quark) == nil)
      g_object_set_qdata(cell.impl, Quark, addr(cell[]))


proc gtk_icon_view_get_item_at_pos(self: ptr IconView00; x: int32; y: int32;
    path: var ptr TreePath00; cell: var ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getItemAtPos*(self: IconView; x: int; y: int; path: var TreePath = cast[var TreePath](nil);
    cell: var CellRenderer = cast[var CellRenderer](nil)): bool =
  var tmpoutgobjectarg: ptr CellRenderer00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_icon_view_get_item_at_pos(cast[ptr IconView00](self.impl), int32(x), int32(y), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr CellRenderer00](if addr(cell) == nil: nil else: addr tmpoutgobjectarg)))
#  dothemagic(cell
  if addr(cell) != nil:
    cell = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      cell = cast[type(cell)](argqdata)
      assert(cell.impl == tmpoutgobjectarg)
    else:
      fnew(cell, gtk4.finalizeGObject)
      cell.impl = tmpoutgobjectarg
      GC_ref(cell)
      if g_object_is_floating(cell.impl).int != 0:
        discard g_object_ref_sink(cell.impl)
      g_object_add_toggle_ref(cell.impl, toggleNotify, addr(cell[]))
      g_object_unref(cell.impl)
      assert(g_object_get_qdata(cell.impl, Quark) == nil)
      g_object_set_qdata(cell.impl, Quark, addr(cell[]))


proc gtk_icon_view_set_cursor(self: ptr IconView00; path: ptr TreePath00;
    cell: ptr CellRenderer00; startEditing: gboolean) {.
    importc, libprag.}

proc setCursor*(self: IconView; path: TreePath; cell: CellRenderer = nil;
    startEditing: bool) =
  gtk_icon_view_set_cursor(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl), if cell.isNil: nil else: cast[ptr CellRenderer00](cell.impl), gboolean(startEditing))

proc gtk_icon_view_set_tooltip_cell(self: ptr IconView00; tooltip: ptr Tooltip00;
    path: ptr TreePath00; cell: ptr CellRenderer00) {.
    importc, libprag.}

proc setTooltipCell*(self: IconView; tooltip: Tooltip; path: TreePath;
    cell: CellRenderer = nil) =
  gtk_icon_view_set_tooltip_cell(cast[ptr IconView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl), if cell.isNil: nil else: cast[ptr CellRenderer00](cell.impl))

proc gtk_tree_view_column_add_attribute(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00;
    attribute: cstring; column: int32) {.
    importc, libprag.}

proc addAttribute*(self: TreeViewColumn; cellRenderer: CellRenderer;
    attribute: cstring; column: int) =
  gtk_tree_view_column_add_attribute(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl), attribute, int32(column))

proc gtk_tree_view_column_cell_get_position(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00;
    xOffset: var int32; width: var int32): gboolean {.
    importc, libprag.}

proc cellGetPosition*(self: TreeViewColumn; cellRenderer: CellRenderer;
    xOffset: var int = cast[var int](nil); width: var int = cast[var int](nil)): bool =
  var width_00: int32
  var xOffset_00: int32
  result = toBool(gtk_tree_view_column_cell_get_position(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl), xOffset_00, width_00))
  if width.addr != nil:
    width = int(width_00)
  if xOffset.addr != nil:
    xOffset = int(xOffset_00)

proc gtk_tree_view_column_clear_attributes(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00) {.
    importc, libprag.}

proc clearAttributes*(self: TreeViewColumn; cellRenderer: CellRenderer) =
  gtk_tree_view_column_clear_attributes(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl))

proc gtk_tree_view_column_focus_cell(self: ptr TreeViewColumn00; cell: ptr CellRenderer00) {.
    importc, libprag.}

proc focusCell*(self: TreeViewColumn; cell: CellRenderer) =
  gtk_tree_view_column_focus_cell(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cell.impl))

proc gtk_tree_view_column_pack_end(self: ptr TreeViewColumn00; cell: ptr CellRenderer00;
    expand: gboolean) {.
    importc, libprag.}

proc packEnd*(self: TreeViewColumn; cell: CellRenderer;
    expand: bool) =
  gtk_tree_view_column_pack_end(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_tree_view_column_pack_start(self: ptr TreeViewColumn00; cell: ptr CellRenderer00;
    expand: gboolean) {.
    importc, libprag.}

proc packStart*(self: TreeViewColumn; cell: CellRenderer;
    expand: bool) =
  gtk_tree_view_column_pack_start(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_tree_view_set_cursor_on_cell(self: ptr TreeView00; path: ptr TreePath00;
    focusColumn: ptr TreeViewColumn00; focusCell: ptr CellRenderer00; startEditing: gboolean) {.
    importc, libprag.}

proc setCursorOnCell*(self: TreeView; path: TreePath; focusColumn: TreeViewColumn = nil;
    focusCell: CellRenderer = nil; startEditing: bool) =
  gtk_tree_view_set_cursor_on_cell(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), if focusColumn.isNil: nil else: cast[ptr TreeViewColumn00](focusColumn.impl), if focusCell.isNil: nil else: cast[ptr CellRenderer00](focusCell.impl), gboolean(startEditing))

proc gtk_tree_view_set_tooltip_cell(self: ptr TreeView00; tooltip: ptr Tooltip00;
    path: ptr TreePath00; column: ptr TreeViewColumn00; cell: ptr CellRenderer00) {.
    importc, libprag.}

proc setTooltipCell*(self: TreeView; tooltip: Tooltip; path: TreePath = nil;
    column: TreeViewColumn = nil; cell: CellRenderer = nil) =
  gtk_tree_view_set_tooltip_cell(cast[ptr TreeView00](self.impl), cast[ptr Tooltip00](tooltip.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl), if cell.isNil: nil else: cast[ptr CellRenderer00](cell.impl))

type
  CellRendererStateFlag* {.size: sizeof(cint), pure.} = enum
    selected = 0
    prelit = 1
    insensitive = 2
    sorted = 3
    focused = 4
    expandable = 5
    expanded = 6

  CellRendererState* = set[CellRendererStateFlag]

proc gtk_cell_renderer_activate(self: ptr CellRenderer00; event: ptr gdk4.Event00;
    widget: ptr Widget00; path: cstring; backgroundArea: gdk4.Rectangle; cellArea: gdk4.Rectangle;
    flags: CellRendererState): gboolean {.
    importc, libprag.}

proc activate*(self: CellRenderer; event: gdk4.Event; widget: Widget;
    path: cstring; backgroundArea: gdk4.Rectangle; cellArea: gdk4.Rectangle;
    flags: CellRendererState): bool =
  toBool(gtk_cell_renderer_activate(cast[ptr CellRenderer00](self.impl), cast[ptr gdk4.Event00](event.impl), cast[ptr Widget00](widget.impl), path, backgroundArea, cellArea, flags))

proc gtk_cell_renderer_get_aligned_area(self: ptr CellRenderer00; widget: ptr Widget00;
    flags: CellRendererState; cellArea: gdk4.Rectangle; alignedArea: var gdk4.Rectangle) {.
    importc, libprag.}

proc getAlignedArea*(self: CellRenderer; widget: Widget;
    flags: CellRendererState; cellArea: gdk4.Rectangle; alignedArea: var gdk4.Rectangle) =
  gtk_cell_renderer_get_aligned_area(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), flags, cellArea, alignedArea)

proc gtk_cell_renderer_get_state(self: ptr CellRenderer00; widget: ptr Widget00;
    cellState: CellRendererState): StateFlags {.
    importc, libprag.}

proc getState*(self: CellRenderer; widget: Widget = nil;
    cellState: CellRendererState): StateFlags =
  gtk_cell_renderer_get_state(cast[ptr CellRenderer00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl), cellState)

proc gtk_cell_renderer_start_editing(self: ptr CellRenderer00; event: ptr gdk4.Event00;
    widget: ptr Widget00; path: cstring; backgroundArea: gdk4.Rectangle; cellArea: gdk4.Rectangle;
    flags: CellRendererState): ptr CellEditable00 {.
    importc, libprag.}

proc startEditing*(self: CellRenderer; event: gdk4.Event = nil;
    widget: Widget; path: cstring; backgroundArea: gdk4.Rectangle; cellArea: gdk4.Rectangle;
    flags: CellRendererState): CellEditable =
  let gobj = gtk_cell_renderer_start_editing(cast[ptr CellRenderer00](self.impl), if event.isNil: nil else: cast[ptr gdk4.Event00](event.impl), cast[ptr Widget00](widget.impl), path, backgroundArea, cellArea, flags)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  MessageType* {.size: sizeof(cint), pure.} = enum
    info = 0
    warning = 1
    question = 2
    error = 3
    other = 4

proc gtk_info_bar_get_message_type(self: ptr InfoBar00): MessageType {.
    importc, libprag.}

proc getMessageType*(self: InfoBar): MessageType =
  gtk_info_bar_get_message_type(cast[ptr InfoBar00](self.impl))

proc messageType*(self: InfoBar): MessageType =
  gtk_info_bar_get_message_type(cast[ptr InfoBar00](self.impl))

proc gtk_info_bar_set_message_type(self: ptr InfoBar00; messageType: MessageType) {.
    importc, libprag.}

proc setMessageType*(self: InfoBar; messageType: MessageType) =
  gtk_info_bar_set_message_type(cast[ptr InfoBar00](self.impl), messageType)

proc `messageType=`*(self: InfoBar; messageType: MessageType) =
  gtk_info_bar_set_message_type(cast[ptr InfoBar00](self.impl), messageType)

type
  SorterChange* {.size: sizeof(cint), pure.} = enum
    different = 0
    inverted = 1
    lessStrict = 2
    moreStrict = 3

type
  Sorter* = ref object of gobject.Object
  Sorter00* = object of gobject.Object00

proc gtk_sorter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Sorter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: Sorter;  p: proc (self: ptr Sorter00; change: SorterChange; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_sorter_changed(self: ptr Sorter00; change: SorterChange) {.
    importc, libprag.}

proc changed*(self: Sorter; change: SorterChange) =
  gtk_sorter_changed(cast[ptr Sorter00](self.impl), change)

proc gtk_column_view_get_sorter(self: ptr ColumnView00): ptr Sorter00 {.
    importc, libprag.}

proc getSorter*(self: ColumnView): Sorter =
  let gobj = gtk_column_view_get_sorter(cast[ptr ColumnView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc sorter*(self: ColumnView): Sorter =
  let gobj = gtk_column_view_get_sorter(cast[ptr ColumnView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Ordering* {.size: sizeof(cint), pure.} = enum
    smaller = -1
    equal = 0
    larger = 1

proc gtk_sorter_compare(self: ptr Sorter00; item1: ptr gobject.Object00;
    item2: ptr gobject.Object00): Ordering {.
    importc, libprag.}

proc compare*(self: Sorter; item1: gobject.Object; item2: gobject.Object): Ordering =
  gtk_sorter_compare(cast[ptr Sorter00](self.impl), cast[ptr gobject.Object00](item1.impl), cast[ptr gobject.Object00](item2.impl))

type
  SorterOrder* {.size: sizeof(cint), pure.} = enum
    partial = 0
    none = 1
    total = 2

proc gtk_sorter_get_order(self: ptr Sorter00): SorterOrder {.
    importc, libprag.}

proc getOrder*(self: Sorter): SorterOrder =
  gtk_sorter_get_order(cast[ptr Sorter00](self.impl))

proc order*(self: Sorter): SorterOrder =
  gtk_sorter_get_order(cast[ptr Sorter00](self.impl))

type
  ColumnViewColumn* = ref object of gobject.Object
  ColumnViewColumn00* = object of gobject.Object00

proc gtk_column_view_column_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColumnViewColumn()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_column_view_column_get_column_view(self: ptr ColumnViewColumn00): ptr ColumnView00 {.
    importc, libprag.}

proc getColumnView*(self: ColumnViewColumn): ColumnView =
  let gobj = gtk_column_view_column_get_column_view(cast[ptr ColumnViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc columnView*(self: ColumnViewColumn): ColumnView =
  let gobj = gtk_column_view_column_get_column_view(cast[ptr ColumnViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_column_get_expand(self: ptr ColumnViewColumn00): gboolean {.
    importc, libprag.}

proc getExpand*(self: ColumnViewColumn): bool =
  toBool(gtk_column_view_column_get_expand(cast[ptr ColumnViewColumn00](self.impl)))

proc expand*(self: ColumnViewColumn): bool =
  toBool(gtk_column_view_column_get_expand(cast[ptr ColumnViewColumn00](self.impl)))

proc gtk_column_view_column_get_fixed_width(self: ptr ColumnViewColumn00): int32 {.
    importc, libprag.}

proc getFixedWidth*(self: ColumnViewColumn): int =
  int(gtk_column_view_column_get_fixed_width(cast[ptr ColumnViewColumn00](self.impl)))

proc fixedWidth*(self: ColumnViewColumn): int =
  int(gtk_column_view_column_get_fixed_width(cast[ptr ColumnViewColumn00](self.impl)))

proc gtk_column_view_column_get_header_menu(self: ptr ColumnViewColumn00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getHeaderMenu*(self: ColumnViewColumn): gio.MenuModel =
  let gobj = gtk_column_view_column_get_header_menu(cast[ptr ColumnViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc headerMenu*(self: ColumnViewColumn): gio.MenuModel =
  let gobj = gtk_column_view_column_get_header_menu(cast[ptr ColumnViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_column_get_id(self: ptr ColumnViewColumn00): cstring {.
    importc, libprag.}

proc getId*(self: ColumnViewColumn): string =
  let resul0 = gtk_column_view_column_get_id(cast[ptr ColumnViewColumn00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc id*(self: ColumnViewColumn): string =
  let resul0 = gtk_column_view_column_get_id(cast[ptr ColumnViewColumn00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_column_view_column_get_resizable(self: ptr ColumnViewColumn00): gboolean {.
    importc, libprag.}

proc getResizable*(self: ColumnViewColumn): bool =
  toBool(gtk_column_view_column_get_resizable(cast[ptr ColumnViewColumn00](self.impl)))

proc resizable*(self: ColumnViewColumn): bool =
  toBool(gtk_column_view_column_get_resizable(cast[ptr ColumnViewColumn00](self.impl)))

proc gtk_column_view_column_get_sorter(self: ptr ColumnViewColumn00): ptr Sorter00 {.
    importc, libprag.}

proc getSorter*(self: ColumnViewColumn): Sorter =
  let gobj = gtk_column_view_column_get_sorter(cast[ptr ColumnViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc sorter*(self: ColumnViewColumn): Sorter =
  let gobj = gtk_column_view_column_get_sorter(cast[ptr ColumnViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_column_get_title(self: ptr ColumnViewColumn00): cstring {.
    importc, libprag.}

proc getTitle*(self: ColumnViewColumn): string =
  let resul0 = gtk_column_view_column_get_title(cast[ptr ColumnViewColumn00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc title*(self: ColumnViewColumn): string =
  let resul0 = gtk_column_view_column_get_title(cast[ptr ColumnViewColumn00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_column_view_column_get_visible(self: ptr ColumnViewColumn00): gboolean {.
    importc, libprag.}

proc getVisible*(self: ColumnViewColumn): bool =
  toBool(gtk_column_view_column_get_visible(cast[ptr ColumnViewColumn00](self.impl)))

proc visible*(self: ColumnViewColumn): bool =
  toBool(gtk_column_view_column_get_visible(cast[ptr ColumnViewColumn00](self.impl)))

proc gtk_column_view_column_set_expand(self: ptr ColumnViewColumn00; expand: gboolean) {.
    importc, libprag.}

proc setExpand*(self: ColumnViewColumn; expand: bool = true) =
  gtk_column_view_column_set_expand(cast[ptr ColumnViewColumn00](self.impl), gboolean(expand))

proc `expand=`*(self: ColumnViewColumn; expand: bool) =
  gtk_column_view_column_set_expand(cast[ptr ColumnViewColumn00](self.impl), gboolean(expand))

proc gtk_column_view_column_set_fixed_width(self: ptr ColumnViewColumn00;
    fixedWidth: int32) {.
    importc, libprag.}

proc setFixedWidth*(self: ColumnViewColumn; fixedWidth: int) =
  gtk_column_view_column_set_fixed_width(cast[ptr ColumnViewColumn00](self.impl), int32(fixedWidth))

proc `fixedWidth=`*(self: ColumnViewColumn; fixedWidth: int) =
  gtk_column_view_column_set_fixed_width(cast[ptr ColumnViewColumn00](self.impl), int32(fixedWidth))

proc gtk_column_view_column_set_header_menu(self: ptr ColumnViewColumn00;
    menu: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setHeaderMenu*(self: ColumnViewColumn; menu: gio.MenuModel = nil) =
  gtk_column_view_column_set_header_menu(cast[ptr ColumnViewColumn00](self.impl), if menu.isNil: nil else: cast[ptr gio.MenuModel00](menu.impl))

proc `headerMenu=`*(self: ColumnViewColumn; menu: gio.MenuModel = nil) =
  gtk_column_view_column_set_header_menu(cast[ptr ColumnViewColumn00](self.impl), if menu.isNil: nil else: cast[ptr gio.MenuModel00](menu.impl))

proc gtk_column_view_column_set_id(self: ptr ColumnViewColumn00; id: cstring) {.
    importc, libprag.}

proc setId*(self: ColumnViewColumn; id: cstring = nil) =
  gtk_column_view_column_set_id(cast[ptr ColumnViewColumn00](self.impl), id)

proc `id=`*(self: ColumnViewColumn; id: cstring = nil) =
  gtk_column_view_column_set_id(cast[ptr ColumnViewColumn00](self.impl), id)

proc gtk_column_view_column_set_resizable(self: ptr ColumnViewColumn00; resizable: gboolean) {.
    importc, libprag.}

proc setResizable*(self: ColumnViewColumn; resizable: bool = true) =
  gtk_column_view_column_set_resizable(cast[ptr ColumnViewColumn00](self.impl), gboolean(resizable))

proc `resizable=`*(self: ColumnViewColumn; resizable: bool) =
  gtk_column_view_column_set_resizable(cast[ptr ColumnViewColumn00](self.impl), gboolean(resizable))

proc gtk_column_view_column_set_sorter(self: ptr ColumnViewColumn00; sorter: ptr Sorter00) {.
    importc, libprag.}

proc setSorter*(self: ColumnViewColumn; sorter: Sorter = nil) =
  gtk_column_view_column_set_sorter(cast[ptr ColumnViewColumn00](self.impl), if sorter.isNil: nil else: cast[ptr Sorter00](sorter.impl))

proc `sorter=`*(self: ColumnViewColumn; sorter: Sorter = nil) =
  gtk_column_view_column_set_sorter(cast[ptr ColumnViewColumn00](self.impl), if sorter.isNil: nil else: cast[ptr Sorter00](sorter.impl))

proc gtk_column_view_column_set_title(self: ptr ColumnViewColumn00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: ColumnViewColumn; title: cstring = nil) =
  gtk_column_view_column_set_title(cast[ptr ColumnViewColumn00](self.impl), title)

proc `title=`*(self: ColumnViewColumn; title: cstring = nil) =
  gtk_column_view_column_set_title(cast[ptr ColumnViewColumn00](self.impl), title)

proc gtk_column_view_column_set_visible(self: ptr ColumnViewColumn00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: ColumnViewColumn; visible: bool = true) =
  gtk_column_view_column_set_visible(cast[ptr ColumnViewColumn00](self.impl), gboolean(visible))

proc `visible=`*(self: ColumnViewColumn; visible: bool) =
  gtk_column_view_column_set_visible(cast[ptr ColumnViewColumn00](self.impl), gboolean(visible))

proc gtk_column_view_append_column(self: ptr ColumnView00; column: ptr ColumnViewColumn00) {.
    importc, libprag.}

proc appendColumn*(self: ColumnView; column: ColumnViewColumn) =
  gtk_column_view_append_column(cast[ptr ColumnView00](self.impl), cast[ptr ColumnViewColumn00](column.impl))

proc gtk_column_view_insert_column(self: ptr ColumnView00; position: uint32;
    column: ptr ColumnViewColumn00) {.
    importc, libprag.}

proc insertColumn*(self: ColumnView; position: int; column: ColumnViewColumn) =
  gtk_column_view_insert_column(cast[ptr ColumnView00](self.impl), uint32(position), cast[ptr ColumnViewColumn00](column.impl))

proc gtk_column_view_remove_column(self: ptr ColumnView00; column: ptr ColumnViewColumn00) {.
    importc, libprag.}

proc removeColumn*(self: ColumnView; column: ColumnViewColumn) =
  gtk_column_view_remove_column(cast[ptr ColumnView00](self.impl), cast[ptr ColumnViewColumn00](column.impl))

proc gtk_column_view_sort_by_column(self: ptr ColumnView00; column: ptr ColumnViewColumn00;
    direction: SortType) {.
    importc, libprag.}

proc sortByColumn*(self: ColumnView; column: ColumnViewColumn = nil;
    direction: SortType) =
  gtk_column_view_sort_by_column(cast[ptr ColumnView00](self.impl), if column.isNil: nil else: cast[ptr ColumnViewColumn00](column.impl), direction)

type
  FontDialog* = ref object of gobject.Object
  FontDialog00* = object of gobject.Object00

proc gtk_font_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_font_dialog_new(): ptr FontDialog00 {.
    importc, libprag.}

proc newFontDialog*(): FontDialog =
  let gobj = gtk_font_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontDialog*(tdesc: typedesc): tdesc =
  assert(result is FontDialog)
  let gobj = gtk_font_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontDialog*[T](result: var T) {.deprecated.} =
  assert(result is FontDialog)
  let gobj = gtk_font_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_dialog_choose_face(self: ptr FontDialog00; parent: ptr Window00;
    initialValue: ptr pango.FontFace00; cancellable: ptr gio.Cancellable00;
    callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc chooseFace*(self: FontDialog; parent: Window = nil;
    initialValue: pango.FontFace = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_font_dialog_choose_face(cast[ptr FontDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if initialValue.isNil: nil else: cast[ptr pango.FontFace00](initialValue.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_font_dialog_choose_face_finish(self: ptr FontDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr pango.FontFace00 {.
    importc, libprag.}

proc chooseFaceFinish*(self: FontDialog; resu: gio.AsyncResult): pango.FontFace =
  var gerror: ptr glib.Error
  let gobj = gtk_font_dialog_choose_face_finish(cast[ptr FontDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_dialog_choose_family(self: ptr FontDialog00; parent: ptr Window00;
    initialValue: ptr pango.FontFamily00; cancellable: ptr gio.Cancellable00;
    callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc chooseFamily*(self: FontDialog; parent: Window = nil;
    initialValue: pango.FontFamily = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_font_dialog_choose_family(cast[ptr FontDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if initialValue.isNil: nil else: cast[ptr pango.FontFamily00](initialValue.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_font_dialog_choose_family_finish(self: ptr FontDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr pango.FontFamily00 {.
    importc, libprag.}

proc chooseFamilyFinish*(self: FontDialog; resu: gio.AsyncResult): pango.FontFamily =
  var gerror: ptr glib.Error
  let gobj = gtk_font_dialog_choose_family_finish(cast[ptr FontDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_dialog_choose_font(self: ptr FontDialog00; parent: ptr Window00;
    initialValue: ptr pango.FontDescription00; cancellable: ptr gio.Cancellable00;
    callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc chooseFont*(self: FontDialog; parent: Window = nil;
    initialValue: pango.FontDescription = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_font_dialog_choose_font(cast[ptr FontDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if initialValue.isNil: nil else: cast[ptr pango.FontDescription00](initialValue.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_font_dialog_choose_font_and_features(self: ptr FontDialog00; parent: ptr Window00;
    initialValue: ptr pango.FontDescription00; cancellable: ptr gio.Cancellable00;
    callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc chooseFontAndFeatures*(self: FontDialog; parent: Window = nil;
    initialValue: pango.FontDescription = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_font_dialog_choose_font_and_features(cast[ptr FontDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if initialValue.isNil: nil else: cast[ptr pango.FontDescription00](initialValue.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_font_dialog_choose_font_and_features_finish(self: ptr FontDialog00;
    resu: ptr gio.AsyncResult00; fontDesc: var ptr pango.FontDescription00;
    fontFeatures: var cstring; language: var ptr pango.Language00; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc chooseFontAndFeaturesFinish*(self: FontDialog; resu: gio.AsyncResult;
    fontDesc: var pango.FontDescription; fontFeatures: var string; language: var pango.Language): bool =
  fnew(fontDesc, gBoxedFreePangoFontDescription)
  fnew(language, gBoxedFreePangoLanguage)
  var gerror: ptr glib.Error
  var fontFeatures_00: cstring
  let resul0 = gtk_font_dialog_choose_font_and_features_finish(cast[ptr FontDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), cast[var ptr pango.FontDescription00](addr fontDesc.impl), fontFeatures_00, cast[var ptr pango.Language00](addr language.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)
  if fontFeatures.addr != nil:
    fontFeatures = $(fontFeatures_00)

proc gtk_font_dialog_choose_font_finish(self: ptr FontDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr pango.FontDescription00 {.
    importc, libprag.}

proc chooseFontFinish*(self: FontDialog; resu: gio.AsyncResult): pango.FontDescription =
  var gerror: ptr glib.Error
  let impl0 = gtk_font_dialog_choose_font_finish(cast[ptr FontDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoFontDescription)
  result.impl = impl0

proc gtk_font_dialog_get_font_map(self: ptr FontDialog00): ptr pango.FontMap00 {.
    importc, libprag.}

proc getFontMap*(self: FontDialog): pango.FontMap =
  let gobj = gtk_font_dialog_get_font_map(cast[ptr FontDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontMap*(self: FontDialog): pango.FontMap =
  let gobj = gtk_font_dialog_get_font_map(cast[ptr FontDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_dialog_get_language(self: ptr FontDialog00): ptr pango.Language00 {.
    importc, libprag.}

proc getLanguage*(self: FontDialog): pango.Language =
  let impl0 = gtk_font_dialog_get_language(cast[ptr FontDialog00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = impl0

proc language*(self: FontDialog): pango.Language =
  let impl0 = gtk_font_dialog_get_language(cast[ptr FontDialog00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = impl0

proc gtk_font_dialog_get_modal(self: ptr FontDialog00): gboolean {.
    importc, libprag.}

proc getModal*(self: FontDialog): bool =
  toBool(gtk_font_dialog_get_modal(cast[ptr FontDialog00](self.impl)))

proc modal*(self: FontDialog): bool =
  toBool(gtk_font_dialog_get_modal(cast[ptr FontDialog00](self.impl)))

proc gtk_font_dialog_get_title(self: ptr FontDialog00): cstring {.
    importc, libprag.}

proc getTitle*(self: FontDialog): string =
  result = $gtk_font_dialog_get_title(cast[ptr FontDialog00](self.impl))

proc title*(self: FontDialog): string =
  result = $gtk_font_dialog_get_title(cast[ptr FontDialog00](self.impl))

proc gtk_font_dialog_set_font_map(self: ptr FontDialog00; fontmap: ptr pango.FontMap00) {.
    importc, libprag.}

proc setFontMap*(self: FontDialog; fontmap: pango.FontMap = nil) =
  gtk_font_dialog_set_font_map(cast[ptr FontDialog00](self.impl), if fontmap.isNil: nil else: cast[ptr pango.FontMap00](fontmap.impl))

proc `fontMap=`*(self: FontDialog; fontmap: pango.FontMap = nil) =
  gtk_font_dialog_set_font_map(cast[ptr FontDialog00](self.impl), if fontmap.isNil: nil else: cast[ptr pango.FontMap00](fontmap.impl))

proc gtk_font_dialog_set_language(self: ptr FontDialog00; language: ptr pango.Language00) {.
    importc, libprag.}

proc setLanguage*(self: FontDialog; language: pango.Language) =
  gtk_font_dialog_set_language(cast[ptr FontDialog00](self.impl), cast[ptr pango.Language00](language.impl))

proc `language=`*(self: FontDialog; language: pango.Language) =
  gtk_font_dialog_set_language(cast[ptr FontDialog00](self.impl), cast[ptr pango.Language00](language.impl))

proc gtk_font_dialog_set_modal(self: ptr FontDialog00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: FontDialog; modal: bool = true) =
  gtk_font_dialog_set_modal(cast[ptr FontDialog00](self.impl), gboolean(modal))

proc `modal=`*(self: FontDialog; modal: bool) =
  gtk_font_dialog_set_modal(cast[ptr FontDialog00](self.impl), gboolean(modal))

proc gtk_font_dialog_set_title(self: ptr FontDialog00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: FontDialog; title: cstring) =
  gtk_font_dialog_set_title(cast[ptr FontDialog00](self.impl), title)

proc `title=`*(self: FontDialog; title: cstring) =
  gtk_font_dialog_set_title(cast[ptr FontDialog00](self.impl), title)

proc gtk_font_dialog_button_new(dialog: ptr FontDialog00): ptr FontDialogButton00 {.
    importc, libprag.}

proc newFontDialogButton*(dialog: FontDialog = nil): FontDialogButton =
  let gobj = gtk_font_dialog_button_new(if dialog.isNil: nil else: cast[ptr FontDialog00](g_object_ref(dialog.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontDialogButton*(tdesc: typedesc; dialog: FontDialog = nil): tdesc =
  assert(result is FontDialogButton)
  let gobj = gtk_font_dialog_button_new(if dialog.isNil: nil else: cast[ptr FontDialog00](g_object_ref(dialog.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontDialogButton*[T](result: var T; dialog: FontDialog = nil) {.deprecated.} =
  assert(result is FontDialogButton)
  let gobj = gtk_font_dialog_button_new(if dialog.isNil: nil else: cast[ptr FontDialog00](g_object_ref(dialog.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_dialog_button_get_dialog(self: ptr FontDialogButton00): ptr FontDialog00 {.
    importc, libprag.}

proc getDialog*(self: FontDialogButton): FontDialog =
  let gobj = gtk_font_dialog_button_get_dialog(cast[ptr FontDialogButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc dialog*(self: FontDialogButton): FontDialog =
  let gobj = gtk_font_dialog_button_get_dialog(cast[ptr FontDialogButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_dialog_button_set_dialog(self: ptr FontDialogButton00; dialog: ptr FontDialog00) {.
    importc, libprag.}

proc setDialog*(self: FontDialogButton; dialog: FontDialog) =
  gtk_font_dialog_button_set_dialog(cast[ptr FontDialogButton00](self.impl), cast[ptr FontDialog00](dialog.impl))

proc `dialog=`*(self: FontDialogButton; dialog: FontDialog) =
  gtk_font_dialog_button_set_dialog(cast[ptr FontDialogButton00](self.impl), cast[ptr FontDialog00](dialog.impl))

type
  FilterChange* {.size: sizeof(cint), pure.} = enum
    different = 0
    lessStrict = 1
    moreStrict = 2

type
  Filter* = ref object of gobject.Object
  Filter00* = object of gobject.Object00

proc gtk_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Filter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: Filter;  p: proc (self: ptr Filter00; change: FilterChange; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_filter_changed(self: ptr Filter00; change: FilterChange) {.
    importc, libprag.}

proc changed*(self: Filter; change: FilterChange) =
  gtk_filter_changed(cast[ptr Filter00](self.impl), change)

proc gtk_filter_match(self: ptr Filter00; item: ptr gobject.Object00): gboolean {.
    importc, libprag.}

proc match*(self: Filter; item: gobject.Object): bool =
  toBool(gtk_filter_match(cast[ptr Filter00](self.impl), cast[ptr gobject.Object00](item.impl)))

proc gtk_font_dialog_get_filter(self: ptr FontDialog00): ptr Filter00 {.
    importc, libprag.}

proc getFilter*(self: FontDialog): Filter =
  let gobj = gtk_font_dialog_get_filter(cast[ptr FontDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc filter*(self: FontDialog): Filter =
  let gobj = gtk_font_dialog_get_filter(cast[ptr FontDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_dialog_set_filter(self: ptr FontDialog00; filter: ptr Filter00) {.
    importc, libprag.}

proc setFilter*(self: FontDialog; filter: Filter = nil) =
  gtk_font_dialog_set_filter(cast[ptr FontDialog00](self.impl), if filter.isNil: nil else: cast[ptr Filter00](filter.impl))

proc `filter=`*(self: FontDialog; filter: Filter = nil) =
  gtk_font_dialog_set_filter(cast[ptr FontDialog00](self.impl), if filter.isNil: nil else: cast[ptr Filter00](filter.impl))

type
  FilterMatch* {.size: sizeof(cint), pure.} = enum
    some = 0
    none = 1
    all = 2

proc gtk_filter_get_strictness(self: ptr Filter00): FilterMatch {.
    importc, libprag.}

proc getStrictness*(self: Filter): FilterMatch =
  gtk_filter_get_strictness(cast[ptr Filter00](self.impl))

proc strictness*(self: Filter): FilterMatch =
  gtk_filter_get_strictness(cast[ptr Filter00](self.impl))

type
  FontLevel* {.size: sizeof(cint), pure.} = enum
    family = 0
    face = 1
    font = 2
    features = 3

proc gtk_font_dialog_button_get_level(self: ptr FontDialogButton00): FontLevel {.
    importc, libprag.}

proc getLevel*(self: FontDialogButton): FontLevel =
  gtk_font_dialog_button_get_level(cast[ptr FontDialogButton00](self.impl))

proc level*(self: FontDialogButton): FontLevel =
  gtk_font_dialog_button_get_level(cast[ptr FontDialogButton00](self.impl))

proc gtk_font_dialog_button_set_level(self: ptr FontDialogButton00; level: FontLevel) {.
    importc, libprag.}

proc setLevel*(self: FontDialogButton; level: FontLevel) =
  gtk_font_dialog_button_set_level(cast[ptr FontDialogButton00](self.impl), level)

proc `level=`*(self: FontDialogButton; level: FontLevel) =
  gtk_font_dialog_button_set_level(cast[ptr FontDialogButton00](self.impl), level)

type
  Editable00* = object of gobject.Object00
  Editable* = ref object of gobject.Object

proc scChanged*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scDeleteText*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;  p: proc (self: ptr Editable00; startPos: int32; endPos: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-text", cast[GCallback](p), xdata, nil, cf)

proc scInsertText*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;  p: proc (self: ptr Editable00; text: cstring; length: int32; position: var int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-text", cast[GCallback](p), xdata, nil, cf)

proc gtk_editable_delegate_get_property(obj: ptr gobject.Object00; propId: uint32;
    value: gobject.Value; pspec: ptr gobject.ParamSpec00): gboolean {.
    importc, libprag.}

proc delegateGetProperty*(obj: gobject.Object; propId: int;
    value: gobject.Value; pspec: gobject.ParamSpec): bool =
  toBool(gtk_editable_delegate_get_property(cast[ptr gobject.Object00](obj.impl), uint32(propId), value, cast[ptr gobject.ParamSpec00](pspec.impl)))

proc gtk_editable_delegate_set_property(obj: ptr gobject.Object00; propId: uint32;
    value: gobject.Value; pspec: ptr gobject.ParamSpec00): gboolean {.
    importc, libprag.}

proc delegateSetProperty*(obj: gobject.Object; propId: int;
    value: gobject.Value; pspec: gobject.ParamSpec): bool =
  toBool(gtk_editable_delegate_set_property(cast[ptr gobject.Object00](obj.impl), uint32(propId), value, cast[ptr gobject.ParamSpec00](pspec.impl)))

proc gtk_editable_install_properties(objectClass: ptr gobject.ObjectClass00;
    firstProp: uint32): uint32 {.
    importc, libprag.}

proc installProperties*(objectClass: gobject.ObjectClass; firstProp: int): int =
  int(gtk_editable_install_properties(cast[ptr gobject.ObjectClass00](objectClass.impl), uint32(firstProp)))

proc gtk_editable_delegate_get_accessible_platform_state(self: ptr Editable00;
    state: AccessiblePlatformState): gboolean {.
    importc, libprag.}

proc delegateGetAccessiblePlatformState*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    state: AccessiblePlatformState): bool =
  toBool(gtk_editable_delegate_get_accessible_platform_state(cast[ptr Editable00](self.impl), state))

proc gtk_editable_delete_selection(self: ptr Editable00) {.
    importc, libprag.}

proc deleteSelection*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry) =
  gtk_editable_delete_selection(cast[ptr Editable00](self.impl))

proc gtk_editable_delete_text(self: ptr Editable00; startPos: int32; endPos: int32) {.
    importc, libprag.}

proc deleteText*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    startPos: int; endPos: int) =
  gtk_editable_delete_text(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))

proc gtk_editable_finish_delegate(self: ptr Editable00) {.
    importc, libprag.}

proc finishDelegate*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry) =
  gtk_editable_finish_delegate(cast[ptr Editable00](self.impl))

proc gtk_editable_get_alignment(self: ptr Editable00): cfloat {.
    importc, libprag.}

proc getAlignment*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): cfloat =
  gtk_editable_get_alignment(cast[ptr Editable00](self.impl))

proc alignment*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): cfloat =
  gtk_editable_get_alignment(cast[ptr Editable00](self.impl))

proc gtk_editable_get_chars(self: ptr Editable00; startPos: int32; endPos: int32): cstring {.
    importc, libprag.}

proc getChars*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    startPos: int; endPos: int): string =
  let resul0 = gtk_editable_get_chars(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))
  result = $resul0
  cogfree(resul0)

proc gtk_editable_get_delegate(self: ptr Editable00): ptr Editable00 {.
    importc, libprag.}

proc getDelegate*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): Editable =
  let gobj = gtk_editable_get_delegate(cast[ptr Editable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc delegate*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): Editable =
  let gobj = gtk_editable_get_delegate(cast[ptr Editable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_editable_get_editable(self: ptr Editable00): gboolean {.
    importc, libprag.}

proc getEditable*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): bool =
  toBool(gtk_editable_get_editable(cast[ptr Editable00](self.impl)))

proc editable*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): bool =
  toBool(gtk_editable_get_editable(cast[ptr Editable00](self.impl)))

proc gtk_editable_get_enable_undo(self: ptr Editable00): gboolean {.
    importc, libprag.}

proc getEnableUndo*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): bool =
  toBool(gtk_editable_get_enable_undo(cast[ptr Editable00](self.impl)))

proc enableUndo*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): bool =
  toBool(gtk_editable_get_enable_undo(cast[ptr Editable00](self.impl)))

proc gtk_editable_get_max_width_chars(self: ptr Editable00): int32 {.
    importc, libprag.}

proc getMaxWidthChars*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): int =
  int(gtk_editable_get_max_width_chars(cast[ptr Editable00](self.impl)))

proc maxWidthChars*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): int =
  int(gtk_editable_get_max_width_chars(cast[ptr Editable00](self.impl)))

proc gtk_editable_get_position(self: ptr Editable00): int32 {.
    importc, libprag.}

proc getPosition*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): int =
  int(gtk_editable_get_position(cast[ptr Editable00](self.impl)))

proc position*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): int =
  int(gtk_editable_get_position(cast[ptr Editable00](self.impl)))

proc gtk_editable_get_selection_bounds(self: ptr Editable00; startPos: var int32;
    endPos: var int32): gboolean {.
    importc, libprag.}

proc getSelectionBounds*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    startPos: var int = cast[var int](nil); endPos: var int = cast[var int](nil)): bool =
  var endPos_00: int32
  var startPos_00: int32
  result = toBool(gtk_editable_get_selection_bounds(cast[ptr Editable00](self.impl), startPos_00, endPos_00))
  if endPos.addr != nil:
    endPos = int(endPos_00)
  if startPos.addr != nil:
    startPos = int(startPos_00)

proc gtk_editable_get_text(self: ptr Editable00): cstring {.
    importc, libprag.}

proc getText*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): string =
  result = $gtk_editable_get_text(cast[ptr Editable00](self.impl))

proc text*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): string =
  result = $gtk_editable_get_text(cast[ptr Editable00](self.impl))

proc gtk_editable_get_width_chars(self: ptr Editable00): int32 {.
    importc, libprag.}

proc getWidthChars*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): int =
  int(gtk_editable_get_width_chars(cast[ptr Editable00](self.impl)))

proc widthChars*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry): int =
  int(gtk_editable_get_width_chars(cast[ptr Editable00](self.impl)))

proc gtk_editable_init_delegate(self: ptr Editable00) {.
    importc, libprag.}

proc initDelegate*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry) =
  gtk_editable_init_delegate(cast[ptr Editable00](self.impl))

proc gtk_editable_insert_text(self: ptr Editable00; text: cstring; length: int32;
    position: var int32) {.
    importc, libprag.}

proc insertText*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    text: cstring; length: int; position: var int) =
  var position_00 = int32(position)
  gtk_editable_insert_text(cast[ptr Editable00](self.impl), text, int32(length), position_00)
  position = int(position_00)

proc gtk_editable_select_region(self: ptr Editable00; startPos: int32; endPos: int32) {.
    importc, libprag.}

proc selectRegion*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    startPos: int; endPos: int) =
  gtk_editable_select_region(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))

proc gtk_editable_set_alignment(self: ptr Editable00; xalign: cfloat) {.
    importc, libprag.}

proc setAlignment*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    xalign: cfloat) =
  gtk_editable_set_alignment(cast[ptr Editable00](self.impl), xalign)

proc `alignment=`*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    xalign: cfloat) =
  gtk_editable_set_alignment(cast[ptr Editable00](self.impl), xalign)

proc gtk_editable_set_editable(self: ptr Editable00; isEditable: gboolean) {.
    importc, libprag.}

proc setEditable*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    isEditable: bool = true) =
  gtk_editable_set_editable(cast[ptr Editable00](self.impl), gboolean(isEditable))

proc `editable=`*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    isEditable: bool) =
  gtk_editable_set_editable(cast[ptr Editable00](self.impl), gboolean(isEditable))

proc gtk_editable_set_enable_undo(self: ptr Editable00; enableUndo: gboolean) {.
    importc, libprag.}

proc setEnableUndo*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    enableUndo: bool = true) =
  gtk_editable_set_enable_undo(cast[ptr Editable00](self.impl), gboolean(enableUndo))

proc `enableUndo=`*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    enableUndo: bool) =
  gtk_editable_set_enable_undo(cast[ptr Editable00](self.impl), gboolean(enableUndo))

proc gtk_editable_set_max_width_chars(self: ptr Editable00; nChars: int32) {.
    importc, libprag.}

proc setMaxWidthChars*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    nChars: int) =
  gtk_editable_set_max_width_chars(cast[ptr Editable00](self.impl), int32(nChars))

proc `maxWidthChars=`*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    nChars: int) =
  gtk_editable_set_max_width_chars(cast[ptr Editable00](self.impl), int32(nChars))

proc gtk_editable_set_position(self: ptr Editable00; position: int32) {.
    importc, libprag.}

proc setPosition*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    position: int) =
  gtk_editable_set_position(cast[ptr Editable00](self.impl), int32(position))

proc `position=`*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    position: int) =
  gtk_editable_set_position(cast[ptr Editable00](self.impl), int32(position))

proc gtk_editable_set_text(self: ptr Editable00; text: cstring) {.
    importc, libprag.}

proc setText*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    text: cstring) =
  gtk_editable_set_text(cast[ptr Editable00](self.impl), text)

proc `text=`*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    text: cstring) =
  gtk_editable_set_text(cast[ptr Editable00](self.impl), text)

proc gtk_editable_set_width_chars(self: ptr Editable00; nChars: int32) {.
    importc, libprag.}

proc setWidthChars*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    nChars: int) =
  gtk_editable_set_width_chars(cast[ptr Editable00](self.impl), int32(nChars))

proc `widthChars=`*(self: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry;
    nChars: int) =
  gtk_editable_set_width_chars(cast[ptr Editable00](self.impl), int32(nChars))

proc gtk_search_bar_connect_entry(self: ptr SearchBar00; entry: ptr Editable00) {.
    importc, libprag.}

proc connectEntry*(self: SearchBar; entry: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry) =
  gtk_search_bar_connect_entry(cast[ptr SearchBar00](self.impl), cast[ptr Editable00](entry.impl))

proc gtk_tree_view_get_search_entry(self: ptr TreeView00): ptr Editable00 {.
    importc, libprag.}

proc getSearchEntry*(self: TreeView): Editable =
  let gobj = gtk_tree_view_get_search_entry(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc searchEntry*(self: TreeView): Editable =
  let gobj = gtk_tree_view_get_search_entry(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_set_search_entry(self: ptr TreeView00; entry: ptr Editable00) {.
    importc, libprag.}

proc setSearchEntry*(self: TreeView; entry: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry = Editable(nil)) =
  gtk_tree_view_set_search_entry(cast[ptr TreeView00](self.impl), if entry.isNil: nil else: cast[ptr Editable00](entry.impl))

proc `searchEntry=`*(self: TreeView; entry: Editable | EditableLabel | PasswordEntry | Entry | SpinButton | Text | SearchEntry = Editable(nil)) =
  gtk_tree_view_set_search_entry(cast[ptr TreeView00](self.impl), if entry.isNil: nil else: cast[ptr Editable00](entry.impl))

type
  NaturalWrapMode* {.size: sizeof(cint), pure.} = enum
    inherit = 0
    none = 1
    word = 2

proc gtk_label_get_natural_wrap_mode(self: ptr Label00): NaturalWrapMode {.
    importc, libprag.}

proc getNaturalWrapMode*(self: Label): NaturalWrapMode =
  gtk_label_get_natural_wrap_mode(cast[ptr Label00](self.impl))

proc naturalWrapMode*(self: Label): NaturalWrapMode =
  gtk_label_get_natural_wrap_mode(cast[ptr Label00](self.impl))

proc gtk_label_set_natural_wrap_mode(self: ptr Label00; wrapMode: NaturalWrapMode) {.
    importc, libprag.}

proc setNaturalWrapMode*(self: Label; wrapMode: NaturalWrapMode) =
  gtk_label_set_natural_wrap_mode(cast[ptr Label00](self.impl), wrapMode)

proc `naturalWrapMode=`*(self: Label; wrapMode: NaturalWrapMode) =
  gtk_label_set_natural_wrap_mode(cast[ptr Label00](self.impl), wrapMode)

type
  ListScrollFlag* {.size: sizeof(cint), pure.} = enum
    focus = 0
    select = 1

  ListScrollFlags* = set[ListScrollFlag]

const
  ListScrollFlagsNone* = ListScrollFlags({})
proc none*(t: typedesc[ListScrollFlags]): ListScrollFlags = ListScrollFlags({})

proc gtk_grid_view_scroll_to(self: ptr GridView00; pos: uint32; flags: ListScrollFlags;
    scroll: ptr ScrollInfo00) {.
    importc, libprag.}

proc scrollTo*(self: GridView; pos: int; flags: ListScrollFlags;
    scroll: ScrollInfo = nil) =
  gtk_grid_view_scroll_to(cast[ptr GridView00](self.impl), uint32(pos), flags, if scroll.isNil: nil else: cast[ptr ScrollInfo00](g_boxed_copy(gtk_scroll_info_get_type(), scroll.impl)))

proc gtk_column_view_scroll_to(self: ptr ColumnView00; pos: uint32; column: ptr ColumnViewColumn00;
    flags: ListScrollFlags; scroll: ptr ScrollInfo00) {.
    importc, libprag.}

proc scrollTo*(self: ColumnView; pos: int; column: ColumnViewColumn = nil;
    flags: ListScrollFlags; scroll: ScrollInfo = nil) =
  gtk_column_view_scroll_to(cast[ptr ColumnView00](self.impl), uint32(pos), if column.isNil: nil else: cast[ptr ColumnViewColumn00](column.impl), flags, if scroll.isNil: nil else: cast[ptr ScrollInfo00](g_boxed_copy(gtk_scroll_info_get_type(), scroll.impl)))

proc gtk_list_view_scroll_to(self: ptr ListView00; pos: uint32; flags: ListScrollFlags;
    scroll: ptr ScrollInfo00) {.
    importc, libprag.}

proc scrollTo*(self: ListView; pos: int; flags: ListScrollFlags;
    scroll: ScrollInfo = nil) =
  gtk_list_view_scroll_to(cast[ptr ListView00](self.impl), uint32(pos), flags, if scroll.isNil: nil else: cast[ptr ScrollInfo00](g_boxed_copy(gtk_scroll_info_get_type(), scroll.impl)))

type
  ListTabBehavior* {.size: sizeof(cint), pure.} = enum
    all = 0
    item = 1
    cell = 2

proc gtk_grid_view_get_tab_behavior(self: ptr GridView00): ListTabBehavior {.
    importc, libprag.}

proc getTabBehavior*(self: GridView): ListTabBehavior =
  gtk_grid_view_get_tab_behavior(cast[ptr GridView00](self.impl))

proc tabBehavior*(self: GridView): ListTabBehavior =
  gtk_grid_view_get_tab_behavior(cast[ptr GridView00](self.impl))

proc gtk_grid_view_set_tab_behavior(self: ptr GridView00; tabBehavior: ListTabBehavior) {.
    importc, libprag.}

proc setTabBehavior*(self: GridView; tabBehavior: ListTabBehavior) =
  gtk_grid_view_set_tab_behavior(cast[ptr GridView00](self.impl), tabBehavior)

proc `tabBehavior=`*(self: GridView; tabBehavior: ListTabBehavior) =
  gtk_grid_view_set_tab_behavior(cast[ptr GridView00](self.impl), tabBehavior)

proc gtk_column_view_get_tab_behavior(self: ptr ColumnView00): ListTabBehavior {.
    importc, libprag.}

proc getTabBehavior*(self: ColumnView): ListTabBehavior =
  gtk_column_view_get_tab_behavior(cast[ptr ColumnView00](self.impl))

proc tabBehavior*(self: ColumnView): ListTabBehavior =
  gtk_column_view_get_tab_behavior(cast[ptr ColumnView00](self.impl))

proc gtk_column_view_set_tab_behavior(self: ptr ColumnView00; tabBehavior: ListTabBehavior) {.
    importc, libprag.}

proc setTabBehavior*(self: ColumnView; tabBehavior: ListTabBehavior) =
  gtk_column_view_set_tab_behavior(cast[ptr ColumnView00](self.impl), tabBehavior)

proc `tabBehavior=`*(self: ColumnView; tabBehavior: ListTabBehavior) =
  gtk_column_view_set_tab_behavior(cast[ptr ColumnView00](self.impl), tabBehavior)

proc gtk_list_view_get_tab_behavior(self: ptr ListView00): ListTabBehavior {.
    importc, libprag.}

proc getTabBehavior*(self: ListView): ListTabBehavior =
  gtk_list_view_get_tab_behavior(cast[ptr ListView00](self.impl))

proc tabBehavior*(self: ListView): ListTabBehavior =
  gtk_list_view_get_tab_behavior(cast[ptr ListView00](self.impl))

proc gtk_list_view_set_tab_behavior(self: ptr ListView00; tabBehavior: ListTabBehavior) {.
    importc, libprag.}

proc setTabBehavior*(self: ListView; tabBehavior: ListTabBehavior) =
  gtk_list_view_set_tab_behavior(cast[ptr ListView00](self.impl), tabBehavior)

proc `tabBehavior=`*(self: ListView; tabBehavior: ListTabBehavior) =
  gtk_list_view_set_tab_behavior(cast[ptr ListView00](self.impl), tabBehavior)

type
  Printer* = ref object of gobject.Object
  Printer00* = object of gobject.Object00

proc gtk_printer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Printer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDetailsAcquired*(self: Printer;  p: proc (self: ptr Printer00; success: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "details-acquired", cast[GCallback](p), xdata, nil, cf)

proc gtk_printer_accepts_pdf(self: ptr Printer00): gboolean {.
    importc, libprag.}

proc acceptsPdf*(self: Printer): bool =
  toBool(gtk_printer_accepts_pdf(cast[ptr Printer00](self.impl)))

proc gtk_printer_accepts_ps(self: ptr Printer00): gboolean {.
    importc, libprag.}

proc acceptsPs*(self: Printer): bool =
  toBool(gtk_printer_accepts_ps(cast[ptr Printer00](self.impl)))

proc gtk_printer_compare(self: ptr Printer00; b: ptr Printer00): int32 {.
    importc, libprag.}

proc compare*(self: Printer; b: Printer): int =
  int(gtk_printer_compare(cast[ptr Printer00](self.impl), cast[ptr Printer00](b.impl)))

proc gtk_printer_get_description(self: ptr Printer00): cstring {.
    importc, libprag.}

proc getDescription*(self: Printer): string =
  result = $gtk_printer_get_description(cast[ptr Printer00](self.impl))

proc description*(self: Printer): string =
  result = $gtk_printer_get_description(cast[ptr Printer00](self.impl))

proc gtk_printer_get_hard_margins(self: ptr Printer00; top: var cdouble;
    bottom: var cdouble; left: var cdouble; right: var cdouble): gboolean {.
    importc, libprag.}

proc getHardMargins*(self: Printer; top: var cdouble; bottom: var cdouble;
    left: var cdouble; right: var cdouble): bool =
  toBool(gtk_printer_get_hard_margins(cast[ptr Printer00](self.impl), top, bottom, left, right))

proc gtk_printer_get_icon_name(self: ptr Printer00): cstring {.
    importc, libprag.}

proc getIconName*(self: Printer): string =
  result = $gtk_printer_get_icon_name(cast[ptr Printer00](self.impl))

proc iconName*(self: Printer): string =
  result = $gtk_printer_get_icon_name(cast[ptr Printer00](self.impl))

proc gtk_printer_get_job_count(self: ptr Printer00): int32 {.
    importc, libprag.}

proc getJobCount*(self: Printer): int =
  int(gtk_printer_get_job_count(cast[ptr Printer00](self.impl)))

proc jobCount*(self: Printer): int =
  int(gtk_printer_get_job_count(cast[ptr Printer00](self.impl)))

proc gtk_printer_get_location(self: ptr Printer00): cstring {.
    importc, libprag.}

proc getLocation*(self: Printer): string =
  result = $gtk_printer_get_location(cast[ptr Printer00](self.impl))

proc location*(self: Printer): string =
  result = $gtk_printer_get_location(cast[ptr Printer00](self.impl))

proc gtk_printer_get_name(self: ptr Printer00): cstring {.
    importc, libprag.}

proc getName*(self: Printer): string =
  result = $gtk_printer_get_name(cast[ptr Printer00](self.impl))

proc name*(self: Printer): string =
  result = $gtk_printer_get_name(cast[ptr Printer00](self.impl))

proc gtk_printer_get_state_message(self: ptr Printer00): cstring {.
    importc, libprag.}

proc getStateMessage*(self: Printer): string =
  result = $gtk_printer_get_state_message(cast[ptr Printer00](self.impl))

proc stateMessage*(self: Printer): string =
  result = $gtk_printer_get_state_message(cast[ptr Printer00](self.impl))

proc gtk_printer_has_details(self: ptr Printer00): gboolean {.
    importc, libprag.}

proc hasDetails*(self: Printer): bool =
  toBool(gtk_printer_has_details(cast[ptr Printer00](self.impl)))

proc gtk_printer_is_accepting_jobs(self: ptr Printer00): gboolean {.
    importc, libprag.}

proc isAcceptingJobs*(self: Printer): bool =
  toBool(gtk_printer_is_accepting_jobs(cast[ptr Printer00](self.impl)))

proc gtk_printer_is_active(self: ptr Printer00): gboolean {.
    importc, libprag.}

proc isActive*(self: Printer): bool =
  toBool(gtk_printer_is_active(cast[ptr Printer00](self.impl)))

proc gtk_printer_is_default(self: ptr Printer00): gboolean {.
    importc, libprag.}

proc isDefault*(self: Printer): bool =
  toBool(gtk_printer_is_default(cast[ptr Printer00](self.impl)))

proc gtk_printer_is_paused(self: ptr Printer00): gboolean {.
    importc, libprag.}

proc isPaused*(self: Printer): bool =
  toBool(gtk_printer_is_paused(cast[ptr Printer00](self.impl)))

proc gtk_printer_is_virtual(self: ptr Printer00): gboolean {.
    importc, libprag.}

proc isVirtual*(self: Printer): bool =
  toBool(gtk_printer_is_virtual(cast[ptr Printer00](self.impl)))

proc gtk_printer_request_details(self: ptr Printer00) {.
    importc, libprag.}

proc requestDetails*(self: Printer) =
  gtk_printer_request_details(cast[ptr Printer00](self.impl))

proc gtk_print_unix_dialog_get_selected_printer(self: ptr PrintUnixDialog00): ptr Printer00 {.
    importc, libprag.}

proc getSelectedPrinter*(self: PrintUnixDialog): Printer =
  let gobj = gtk_print_unix_dialog_get_selected_printer(cast[ptr PrintUnixDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectedPrinter*(self: PrintUnixDialog): Printer =
  let gobj = gtk_print_unix_dialog_get_selected_printer(cast[ptr PrintUnixDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  PrintBackend00* {.pure.} = object
  PrintBackend* = ref object
    impl*: ptr PrintBackend00
    ignoreFinalizer*: bool

proc gtk_printer_new(name: cstring; backend: ptr PrintBackend00; virtual: gboolean): ptr Printer00 {.
    importc, libprag.}

proc newPrinter*(name: cstring; backend: PrintBackend; virtual: bool): Printer =
  let gobj = gtk_printer_new(name, cast[ptr PrintBackend00](backend.impl), gboolean(virtual))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrinter*(tdesc: typedesc; name: cstring; backend: PrintBackend; virtual: bool): tdesc =
  assert(result is Printer)
  let gobj = gtk_printer_new(name, cast[ptr PrintBackend00](backend.impl), gboolean(virtual))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrinter*[T](result: var T; name: cstring; backend: PrintBackend; virtual: bool) {.deprecated.} =
  assert(result is Printer)
  let gobj = gtk_printer_new(name, cast[ptr PrintBackend00](backend.impl), gboolean(virtual))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_printer_get_backend(self: ptr Printer00): ptr PrintBackend00 {.
    importc, libprag.}

proc getBackend*(self: Printer): PrintBackend =
  new(result)
  result.impl = gtk_printer_get_backend(cast[ptr Printer00](self.impl))
  result.ignoreFinalizer = true

proc backend*(self: Printer): PrintBackend =
  new(result)
  result.impl = gtk_printer_get_backend(cast[ptr Printer00](self.impl))
  result.ignoreFinalizer = true

type
  PaperSize00* {.pure.} = object
  PaperSize* = ref object
    impl*: ptr PaperSize00
    ignoreFinalizer*: bool

proc gtk_paper_size_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkPaperSize*(self: PaperSize) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_paper_size_get_type(), cast[ptr PaperSize00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PaperSize()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_paper_size_get_type(), cast[ptr PaperSize00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var PaperSize) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkPaperSize)

proc gtk_paper_size_free(self: ptr PaperSize00) {.
    importc, libprag.}

proc free*(self: PaperSize) =
  gtk_paper_size_free(cast[ptr PaperSize00](self.impl))

proc finalizerfree*(self: PaperSize) =
  if not self.ignoreFinalizer:
    gtk_paper_size_free(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_new_from_gvariant(variant: ptr glib.Variant00): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeFromGvariant*(variant: glib.Variant): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))

proc newPaperSizeFromGvariant*(tdesc: typedesc; variant: glib.Variant): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))

proc initPaperSizeFromGvariant*[T](result: var T; variant: glib.Variant) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))

proc gtk_paper_size_new_from_ipp(ippName: cstring; width: cdouble; height: cdouble): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeFromIpp*(ippName: cstring; width: cdouble; height: cdouble): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ipp(ippName, width, height)

proc newPaperSizeFromIpp*(tdesc: typedesc; ippName: cstring; width: cdouble; height: cdouble): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ipp(ippName, width, height)

proc initPaperSizeFromIpp*[T](result: var T; ippName: cstring; width: cdouble; height: cdouble) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ipp(ippName, width, height)

proc gtk_paper_size_new_from_key_file(keyFile: ptr glib.KeyFile00; groupName: cstring;
    error: ptr ptr glib.Error = nil): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeFromKeyFile*(keyFile: glib.KeyFile; groupName: cstring = nil): PaperSize =
  var gerror: ptr glib.Error
  let impl0 = gtk_paper_size_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = impl0

proc newPaperSizeFromKeyFile*(tdesc: typedesc; keyFile: glib.KeyFile; groupName: cstring = nil): tdesc =
  var gerror: ptr glib.Error
  assert(result is PaperSize)
  let impl0 = gtk_paper_size_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = impl0

proc initPaperSizeFromKeyFile*[T](result: var T; keyFile: glib.KeyFile; groupName: cstring = nil) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PaperSize)
  let impl0 = gtk_paper_size_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = impl0

proc gtk_paper_size_new_from_ppd(ppdName: cstring; ppdDisplayName: cstring;
    width: cdouble; height: cdouble): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeFromPpd*(ppdName: cstring; ppdDisplayName: cstring;
    width: cdouble; height: cdouble): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ppd(ppdName, ppdDisplayName, width, height)

proc newPaperSizeFromPpd*(tdesc: typedesc; ppdName: cstring; ppdDisplayName: cstring;
    width: cdouble; height: cdouble): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ppd(ppdName, ppdDisplayName, width, height)

proc initPaperSizeFromPpd*[T](result: var T; ppdName: cstring; ppdDisplayName: cstring;
    width: cdouble; height: cdouble) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ppd(ppdName, ppdDisplayName, width, height)

proc gtk_paper_size_copy(self: ptr PaperSize00): ptr PaperSize00 {.
    importc, libprag.}

proc copy*(self: PaperSize): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_copy(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_new(name: cstring): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSize*(name: cstring = nil): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new(name)

proc newPaperSize*(tdesc: typedesc; name: cstring = nil): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new(name)

proc initPaperSize*[T](result: var T; name: cstring = nil) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new(name)

proc gtk_paper_size_get_display_name(self: ptr PaperSize00): cstring {.
    importc, libprag.}

proc getDisplayName*(self: PaperSize): string =
  result = $gtk_paper_size_get_display_name(cast[ptr PaperSize00](self.impl))

proc displayName*(self: PaperSize): string =
  result = $gtk_paper_size_get_display_name(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_get_name(self: ptr PaperSize00): cstring {.
    importc, libprag.}

proc getName*(self: PaperSize): string =
  result = $gtk_paper_size_get_name(cast[ptr PaperSize00](self.impl))

proc name*(self: PaperSize): string =
  result = $gtk_paper_size_get_name(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_get_ppd_name(self: ptr PaperSize00): cstring {.
    importc, libprag.}

proc getPpdName*(self: PaperSize): string =
  result = $gtk_paper_size_get_ppd_name(cast[ptr PaperSize00](self.impl))

proc ppdName*(self: PaperSize): string =
  result = $gtk_paper_size_get_ppd_name(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_is_custom(self: ptr PaperSize00): gboolean {.
    importc, libprag.}

proc isCustom*(self: PaperSize): bool =
  toBool(gtk_paper_size_is_custom(cast[ptr PaperSize00](self.impl)))

proc gtk_paper_size_is_equal(self: ptr PaperSize00; size2: ptr PaperSize00): gboolean {.
    importc, libprag.}

proc isEqual*(self: PaperSize; size2: PaperSize): bool =
  toBool(gtk_paper_size_is_equal(cast[ptr PaperSize00](self.impl), cast[ptr PaperSize00](size2.impl)))

proc gtk_paper_size_is_ipp(self: ptr PaperSize00): gboolean {.
    importc, libprag.}

proc isIpp*(self: PaperSize): bool =
  toBool(gtk_paper_size_is_ipp(cast[ptr PaperSize00](self.impl)))

proc gtk_paper_size_to_gvariant(self: ptr PaperSize00): ptr glib.Variant00 {.
    importc, libprag.}

proc toGvariant*(self: PaperSize): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_paper_size_to_gvariant(cast[ptr PaperSize00](self.impl))
  result.ignoreFinalizer = true # GVariant

proc gtk_paper_size_to_key_file(self: ptr PaperSize00; keyFile: ptr glib.KeyFile00;
    groupName: cstring) {.
    importc, libprag.}

proc toKeyFile*(self: PaperSize; keyFile: glib.KeyFile; groupName: cstring) =
  gtk_paper_size_to_key_file(cast[ptr PaperSize00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName)

proc gtk_paper_size_get_default(): cstring {.
    importc, libprag.}

proc getDefaultPaperSize*(): string =
  result = $gtk_paper_size_get_default()

proc gtk_paper_size_get_paper_sizes(includeCustom: gboolean): ptr glib.List {.
    importc, libprag.}

proc getPaperSizes*(includeCustom: bool): seq[PaperSize] =
  let resul0 = gtk_paper_size_get_paper_sizes(gboolean(includeCustom))
  result = glistStructs2seq[PaperSize](resul0, false)
  g_list_free(resul0)

proc paperSizes*(includeCustom: bool): seq[PaperSize] =
  let resul0 = gtk_paper_size_get_paper_sizes(gboolean(includeCustom))
  result = glistStructs2seq[PaperSize](resul0, false)
  g_list_free(resul0)

proc gtk_printer_get_hard_margins_for_paper_size(self: ptr Printer00; paperSize: ptr PaperSize00;
    top: var cdouble; bottom: var cdouble; left: var cdouble; right: var cdouble): gboolean {.
    importc, libprag.}

proc getHardMarginsForPaperSize*(self: Printer; paperSize: PaperSize;
    top: var cdouble; bottom: var cdouble; left: var cdouble; right: var cdouble): bool =
  toBool(gtk_printer_get_hard_margins_for_paper_size(cast[ptr Printer00](self.impl), cast[ptr PaperSize00](paperSize.impl), top, bottom, left, right))

type
  Unit* {.size: sizeof(cint), pure.} = enum
    none = 0
    points = 1
    inch = 2
    mm = 3

proc gtk_paper_size_new_custom(name: cstring; displayName: cstring; width: cdouble;
    height: cdouble; unit: Unit): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeCustom*(name: cstring; displayName: cstring; width: cdouble;
    height: cdouble; unit: Unit): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_custom(name, displayName, width, height, unit)

proc newPaperSizeCustom*(tdesc: typedesc; name: cstring; displayName: cstring; width: cdouble;
    height: cdouble; unit: Unit): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_custom(name, displayName, width, height, unit)

proc initPaperSizeCustom*[T](result: var T; name: cstring; displayName: cstring; width: cdouble;
    height: cdouble; unit: Unit) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_custom(name, displayName, width, height, unit)

proc gtk_paper_size_get_default_bottom_margin(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getDefaultBottomMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_bottom_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_default_left_margin(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getDefaultLeftMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_left_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_default_right_margin(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getDefaultRightMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_right_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_default_top_margin(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getDefaultTopMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_top_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_height(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getHeight*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_height(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_width(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getWidth*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_width(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_set_size(self: ptr PaperSize00; width: cdouble; height: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setSize*(self: PaperSize; width: cdouble; height: cdouble;
    unit: Unit) =
  gtk_paper_size_set_size(cast[ptr PaperSize00](self.impl), width, height, unit)

type
  PrintCapabilitiesFlag* {.size: sizeof(cint), pure.} = enum
    pageSet = 0
    copies = 1
    collate = 2
    reverse = 3
    scale = 4
    generatePdf = 5
    generatePs = 6
    preview = 7
    numberUp = 8
    numberUpLayout = 9

  PrintCapabilities* = set[PrintCapabilitiesFlag]

proc gtk_print_unix_dialog_get_manual_capabilities(self: ptr PrintUnixDialog00): PrintCapabilities {.
    importc, libprag.}

proc getManualCapabilities*(self: PrintUnixDialog): PrintCapabilities =
  gtk_print_unix_dialog_get_manual_capabilities(cast[ptr PrintUnixDialog00](self.impl))

proc manualCapabilities*(self: PrintUnixDialog): PrintCapabilities =
  gtk_print_unix_dialog_get_manual_capabilities(cast[ptr PrintUnixDialog00](self.impl))

proc gtk_print_unix_dialog_set_manual_capabilities(self: ptr PrintUnixDialog00;
    capabilities: PrintCapabilities) {.
    importc, libprag.}

proc setManualCapabilities*(self: PrintUnixDialog;
    capabilities: PrintCapabilities) =
  gtk_print_unix_dialog_set_manual_capabilities(cast[ptr PrintUnixDialog00](self.impl), capabilities)

proc `manualCapabilities=`*(self: PrintUnixDialog;
    capabilities: PrintCapabilities) =
  gtk_print_unix_dialog_set_manual_capabilities(cast[ptr PrintUnixDialog00](self.impl), capabilities)

proc gtk_printer_get_capabilities(self: ptr Printer00): PrintCapabilities {.
    importc, libprag.}

proc getCapabilities*(self: Printer): PrintCapabilities =
  gtk_printer_get_capabilities(cast[ptr Printer00](self.impl))

proc capabilities*(self: Printer): PrintCapabilities =
  gtk_printer_get_capabilities(cast[ptr Printer00](self.impl))

type
  PageSetup* = ref object of gobject.Object
  PageSetup00* = object of gobject.Object00

proc gtk_page_setup_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PageSetup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_page_setup_new(): ptr PageSetup00 {.
    importc, libprag.}

proc newPageSetup*(): PageSetup =
  let gobj = gtk_page_setup_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPageSetup*(tdesc: typedesc): tdesc =
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetup*[T](result: var T) {.deprecated.} =
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_new_from_file(fileName: cstring; error: ptr ptr glib.Error = nil): ptr PageSetup00 {.
    importc, libprag.}

proc newPageSetupFromFile*(fileName: cstring): PageSetup =
  var gerror: ptr glib.Error
  let gobj = gtk_page_setup_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPageSetupFromFile*(tdesc: typedesc; fileName: cstring): tdesc =
  var gerror: ptr glib.Error
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupFromFile*[T](result: var T; fileName: cstring) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_new_from_gvariant(variant: ptr glib.Variant00): ptr PageSetup00 {.
    importc, libprag.}

proc newPageSetupFromGvariant*(variant: glib.Variant): PageSetup =
  let gobj = gtk_page_setup_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPageSetupFromGvariant*(tdesc: typedesc; variant: glib.Variant): tdesc =
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupFromGvariant*[T](result: var T; variant: glib.Variant) {.deprecated.} =
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_new_from_key_file(keyFile: ptr glib.KeyFile00; groupName: cstring;
    error: ptr ptr glib.Error = nil): ptr PageSetup00 {.
    importc, libprag.}

proc newPageSetupFromKeyFile*(keyFile: glib.KeyFile; groupName: cstring = nil): PageSetup =
  var gerror: ptr glib.Error
  let gobj = gtk_page_setup_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPageSetupFromKeyFile*(tdesc: typedesc; keyFile: glib.KeyFile; groupName: cstring = nil): tdesc =
  var gerror: ptr glib.Error
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupFromKeyFile*[T](result: var T; keyFile: glib.KeyFile; groupName: cstring = nil) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_copy(self: ptr PageSetup00): ptr PageSetup00 {.
    importc, libprag.}

proc copy*(self: PageSetup): PageSetup =
  let gobj = gtk_page_setup_copy(cast[ptr PageSetup00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_get_bottom_margin(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getBottomMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_bottom_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_left_margin(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getLeftMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_left_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_page_height(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPageHeight*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_page_height(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_page_width(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPageWidth*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_page_width(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_paper_height(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPaperHeight*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_paper_height(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_paper_size(self: ptr PageSetup00): ptr PaperSize00 {.
    importc, libprag.}

proc getPaperSize*(self: PageSetup): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_page_setup_get_paper_size(cast[ptr PageSetup00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_paper_size_get_type(), result.impl))

proc paperSize*(self: PageSetup): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_page_setup_get_paper_size(cast[ptr PageSetup00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_paper_size_get_type(), result.impl))

proc gtk_page_setup_get_paper_width(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPaperWidth*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_paper_width(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_right_margin(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getRightMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_right_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_top_margin(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getTopMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_top_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_load_file(self: ptr PageSetup00; fileName: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadFile*(self: PageSetup; fileName: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_page_setup_load_file(cast[ptr PageSetup00](self.impl), fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_page_setup_load_key_file(self: ptr PageSetup00; keyFile: ptr glib.KeyFile00;
    groupName: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadKeyFile*(self: PageSetup; keyFile: glib.KeyFile;
    groupName: cstring = nil): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_page_setup_load_key_file(cast[ptr PageSetup00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_page_setup_set_bottom_margin(self: ptr PageSetup00; margin: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setBottomMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_bottom_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_set_left_margin(self: ptr PageSetup00; margin: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setLeftMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_left_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_set_paper_size(self: ptr PageSetup00; size: ptr PaperSize00) {.
    importc, libprag.}

proc setPaperSize*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc `paperSize=`*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc gtk_page_setup_set_paper_size_and_default_margins(self: ptr PageSetup00;
    size: ptr PaperSize00) {.
    importc, libprag.}

proc setPaperSizeAndDefaultMargins*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size_and_default_margins(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc `paperSizeAndDefaultMargins=`*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size_and_default_margins(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc gtk_page_setup_set_right_margin(self: ptr PageSetup00; margin: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setRightMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_right_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_set_top_margin(self: ptr PageSetup00; margin: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setTopMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_top_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_to_file(self: ptr PageSetup00; fileName: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc toFile*(self: PageSetup; fileName: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_page_setup_to_file(cast[ptr PageSetup00](self.impl), fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_page_setup_to_gvariant(self: ptr PageSetup00): ptr glib.Variant00 {.
    importc, libprag.}

proc toGvariant*(self: PageSetup): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_page_setup_to_gvariant(cast[ptr PageSetup00](self.impl))
  result.ignoreFinalizer = true # GVariant

proc gtk_page_setup_to_key_file(self: ptr PageSetup00; keyFile: ptr glib.KeyFile00;
    groupName: cstring) {.
    importc, libprag.}

proc toKeyFile*(self: PageSetup; keyFile: glib.KeyFile; groupName: cstring = nil) =
  gtk_page_setup_to_key_file(cast[ptr PageSetup00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName)

proc gtk_print_unix_dialog_get_page_setup(self: ptr PrintUnixDialog00): ptr PageSetup00 {.
    importc, libprag.}

proc getPageSetup*(self: PrintUnixDialog): PageSetup =
  let gobj = gtk_print_unix_dialog_get_page_setup(cast[ptr PrintUnixDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pageSetup*(self: PrintUnixDialog): PageSetup =
  let gobj = gtk_print_unix_dialog_get_page_setup(cast[ptr PrintUnixDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_unix_dialog_set_page_setup(self: ptr PrintUnixDialog00; pageSetup: ptr PageSetup00) {.
    importc, libprag.}

proc setPageSetup*(self: PrintUnixDialog; pageSetup: PageSetup) =
  gtk_print_unix_dialog_set_page_setup(cast[ptr PrintUnixDialog00](self.impl), cast[ptr PageSetup00](pageSetup.impl))

proc `pageSetup=`*(self: PrintUnixDialog; pageSetup: PageSetup) =
  gtk_print_unix_dialog_set_page_setup(cast[ptr PrintUnixDialog00](self.impl), cast[ptr PageSetup00](pageSetup.impl))

proc gtk_page_setup_unix_dialog_get_page_setup(self: ptr PageSetupUnixDialog00): ptr PageSetup00 {.
    importc, libprag.}

proc getPageSetup*(self: PageSetupUnixDialog): PageSetup =
  let gobj = gtk_page_setup_unix_dialog_get_page_setup(cast[ptr PageSetupUnixDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pageSetup*(self: PageSetupUnixDialog): PageSetup =
  let gobj = gtk_page_setup_unix_dialog_get_page_setup(cast[ptr PageSetupUnixDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_unix_dialog_set_page_setup(self: ptr PageSetupUnixDialog00;
    pageSetup: ptr PageSetup00) {.
    importc, libprag.}

proc setPageSetup*(self: PageSetupUnixDialog;
    pageSetup: PageSetup) =
  gtk_page_setup_unix_dialog_set_page_setup(cast[ptr PageSetupUnixDialog00](self.impl), cast[ptr PageSetup00](pageSetup.impl))

proc `pageSetup=`*(self: PageSetupUnixDialog;
    pageSetup: PageSetup) =
  gtk_page_setup_unix_dialog_set_page_setup(cast[ptr PageSetupUnixDialog00](self.impl), cast[ptr PageSetup00](pageSetup.impl))

proc gtk_printer_get_default_page_size(self: ptr Printer00): ptr PageSetup00 {.
    importc, libprag.}

proc getDefaultPageSize*(self: Printer): PageSetup =
  let gobj = gtk_printer_get_default_page_size(cast[ptr Printer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultPageSize*(self: Printer): PageSetup =
  let gobj = gtk_printer_get_default_page_size(cast[ptr Printer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_printer_list_papers(self: ptr Printer00): ptr glib.List {.
    importc, libprag.}

proc listPapers*(self: Printer): seq[PageSetup] =
  let resul0 = gtk_printer_list_papers(cast[ptr Printer00](self.impl))
  result = glistObjects2seq(PageSetup, resul0, true)
  g_list_free(resul0)

type
  PageOrientation* {.size: sizeof(cint), pure.} = enum
    portrait = 0
    landscape = 1
    reversePortrait = 2
    reverseLandscape = 3

proc gtk_page_setup_get_orientation(self: ptr PageSetup00): PageOrientation {.
    importc, libprag.}

proc getOrientation*(self: PageSetup): PageOrientation =
  gtk_page_setup_get_orientation(cast[ptr PageSetup00](self.impl))

proc orientation*(self: PageSetup): PageOrientation =
  gtk_page_setup_get_orientation(cast[ptr PageSetup00](self.impl))

proc gtk_page_setup_set_orientation(self: ptr PageSetup00; orientation: PageOrientation) {.
    importc, libprag.}

proc setOrientation*(self: PageSetup; orientation: PageOrientation) =
  gtk_page_setup_set_orientation(cast[ptr PageSetup00](self.impl), orientation)

proc `orientation=`*(self: PageSetup; orientation: PageOrientation) =
  gtk_page_setup_set_orientation(cast[ptr PageSetup00](self.impl), orientation)

type
  PrintSettings* = ref object of gobject.Object
  PrintSettings00* = object of gobject.Object00

proc gtk_print_settings_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintSettings()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_print_settings_new(): ptr PrintSettings00 {.
    importc, libprag.}

proc newPrintSettings*(): PrintSettings =
  let gobj = gtk_print_settings_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintSettings*(tdesc: typedesc): tdesc =
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettings*[T](result: var T) {.deprecated.} =
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_new_from_file(fileName: cstring; error: ptr ptr glib.Error = nil): ptr PrintSettings00 {.
    importc, libprag.}

proc newPrintSettingsFromFile*(fileName: cstring): PrintSettings =
  var gerror: ptr glib.Error
  let gobj = gtk_print_settings_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintSettingsFromFile*(tdesc: typedesc; fileName: cstring): tdesc =
  var gerror: ptr glib.Error
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettingsFromFile*[T](result: var T; fileName: cstring) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_new_from_gvariant(variant: ptr glib.Variant00): ptr PrintSettings00 {.
    importc, libprag.}

proc newPrintSettingsFromGvariant*(variant: glib.Variant): PrintSettings =
  let gobj = gtk_print_settings_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintSettingsFromGvariant*(tdesc: typedesc; variant: glib.Variant): tdesc =
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettingsFromGvariant*[T](result: var T; variant: glib.Variant) {.deprecated.} =
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_new_from_key_file(keyFile: ptr glib.KeyFile00; groupName: cstring;
    error: ptr ptr glib.Error = nil): ptr PrintSettings00 {.
    importc, libprag.}

proc newPrintSettingsFromKeyFile*(keyFile: glib.KeyFile; groupName: cstring = nil): PrintSettings =
  var gerror: ptr glib.Error
  let gobj = gtk_print_settings_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintSettingsFromKeyFile*(tdesc: typedesc; keyFile: glib.KeyFile; groupName: cstring = nil): tdesc =
  var gerror: ptr glib.Error
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettingsFromKeyFile*[T](result: var T; keyFile: glib.KeyFile; groupName: cstring = nil) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_copy(self: ptr PrintSettings00): ptr PrintSettings00 {.
    importc, libprag.}

proc copy*(self: PrintSettings): PrintSettings =
  let gobj = gtk_print_settings_copy(cast[ptr PrintSettings00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_get(self: ptr PrintSettings00; key: cstring): cstring {.
    importc, libprag.}

proc getPrintSettings*(self: PrintSettings; key: cstring): string =
  let resul0 = gtk_print_settings_get(cast[ptr PrintSettings00](self.impl), key)
  if resul0.isNil:
    return
  result = $resul0

proc gtk_print_settings_get_bool(self: ptr PrintSettings00; key: cstring): gboolean {.
    importc, libprag.}

proc getBool*(self: PrintSettings; key: cstring): bool =
  toBool(gtk_print_settings_get_bool(cast[ptr PrintSettings00](self.impl), key))

proc gtk_print_settings_get_collate(self: ptr PrintSettings00): gboolean {.
    importc, libprag.}

proc getCollate*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_collate(cast[ptr PrintSettings00](self.impl)))

proc collate*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_collate(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_default_source(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getDefaultSource*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_default_source(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc defaultSource*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_default_source(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_print_settings_get_dither(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getDither*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_dither(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc dither*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_dither(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_print_settings_get_double(self: ptr PrintSettings00; key: cstring): cdouble {.
    importc, libprag.}

proc getDouble*(self: PrintSettings; key: cstring): cdouble =
  gtk_print_settings_get_double(cast[ptr PrintSettings00](self.impl), key)

proc gtk_print_settings_get_double_with_default(self: ptr PrintSettings00;
    key: cstring; def: cdouble): cdouble {.
    importc, libprag.}

proc getDoubleWithDefault*(self: PrintSettings; key: cstring;
    def: cdouble): cdouble =
  gtk_print_settings_get_double_with_default(cast[ptr PrintSettings00](self.impl), key, def)

proc gtk_print_settings_get_finishings(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getFinishings*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_finishings(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc finishings*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_finishings(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_print_settings_get_int(self: ptr PrintSettings00; key: cstring): int32 {.
    importc, libprag.}

proc getInt*(self: PrintSettings; key: cstring): int =
  int(gtk_print_settings_get_int(cast[ptr PrintSettings00](self.impl), key))

proc gtk_print_settings_get_int_with_default(self: ptr PrintSettings00; key: cstring;
    def: int32): int32 {.
    importc, libprag.}

proc getIntWithDefault*(self: PrintSettings; key: cstring;
    def: int): int =
  int(gtk_print_settings_get_int_with_default(cast[ptr PrintSettings00](self.impl), key, int32(def)))

proc gtk_print_settings_get_length(self: ptr PrintSettings00; key: cstring;
    unit: Unit): cdouble {.
    importc, libprag.}

proc getLength*(self: PrintSettings; key: cstring; unit: Unit): cdouble =
  gtk_print_settings_get_length(cast[ptr PrintSettings00](self.impl), key, unit)

proc gtk_print_settings_get_media_type(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getMediaType*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_media_type(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc mediaType*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_media_type(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_print_settings_get_n_copies(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getNCopies*(self: PrintSettings): int =
  int(gtk_print_settings_get_n_copies(cast[ptr PrintSettings00](self.impl)))

proc nCopies*(self: PrintSettings): int =
  int(gtk_print_settings_get_n_copies(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_number_up(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getNumberUp*(self: PrintSettings): int =
  int(gtk_print_settings_get_number_up(cast[ptr PrintSettings00](self.impl)))

proc numberUp*(self: PrintSettings): int =
  int(gtk_print_settings_get_number_up(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_orientation(self: ptr PrintSettings00): PageOrientation {.
    importc, libprag.}

proc getOrientation*(self: PrintSettings): PageOrientation =
  gtk_print_settings_get_orientation(cast[ptr PrintSettings00](self.impl))

proc orientation*(self: PrintSettings): PageOrientation =
  gtk_print_settings_get_orientation(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_output_bin(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getOutputBin*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_output_bin(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc outputBin*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_output_bin(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_print_settings_get_paper_height(self: ptr PrintSettings00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPaperHeight*(self: PrintSettings; unit: Unit): cdouble =
  gtk_print_settings_get_paper_height(cast[ptr PrintSettings00](self.impl), unit)

proc gtk_print_settings_get_paper_size(self: ptr PrintSettings00): ptr PaperSize00 {.
    importc, libprag.}

proc getPaperSize*(self: PrintSettings): PaperSize =
  let impl0 = gtk_print_settings_get_paper_size(cast[ptr PrintSettings00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = impl0

proc paperSize*(self: PrintSettings): PaperSize =
  let impl0 = gtk_print_settings_get_paper_size(cast[ptr PrintSettings00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = impl0

proc gtk_print_settings_get_paper_width(self: ptr PrintSettings00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPaperWidth*(self: PrintSettings; unit: Unit): cdouble =
  gtk_print_settings_get_paper_width(cast[ptr PrintSettings00](self.impl), unit)

proc gtk_print_settings_get_printer(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getPrinter*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_printer(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc printer*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_printer(cast[ptr PrintSettings00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_print_settings_get_printer_lpi(self: ptr PrintSettings00): cdouble {.
    importc, libprag.}

proc getPrinterLpi*(self: PrintSettings): cdouble =
  gtk_print_settings_get_printer_lpi(cast[ptr PrintSettings00](self.impl))

proc printerLpi*(self: PrintSettings): cdouble =
  gtk_print_settings_get_printer_lpi(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_resolution(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getResolution*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution(cast[ptr PrintSettings00](self.impl)))

proc resolution*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_resolution_x(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getResolutionX*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_x(cast[ptr PrintSettings00](self.impl)))

proc resolutionX*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_x(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_resolution_y(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getResolutionY*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_y(cast[ptr PrintSettings00](self.impl)))

proc resolutionY*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_y(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_reverse(self: ptr PrintSettings00): gboolean {.
    importc, libprag.}

proc getReverse*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_reverse(cast[ptr PrintSettings00](self.impl)))

proc reverse*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_reverse(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_scale(self: ptr PrintSettings00): cdouble {.
    importc, libprag.}

proc getScale*(self: PrintSettings): cdouble =
  gtk_print_settings_get_scale(cast[ptr PrintSettings00](self.impl))

proc scale*(self: PrintSettings): cdouble =
  gtk_print_settings_get_scale(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_use_color(self: ptr PrintSettings00): gboolean {.
    importc, libprag.}

proc getUseColor*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_use_color(cast[ptr PrintSettings00](self.impl)))

proc useColor*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_use_color(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_has_key(self: ptr PrintSettings00; key: cstring): gboolean {.
    importc, libprag.}

proc hasKey*(self: PrintSettings; key: cstring): bool =
  toBool(gtk_print_settings_has_key(cast[ptr PrintSettings00](self.impl), key))

proc gtk_print_settings_load_file(self: ptr PrintSettings00; fileName: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadFile*(self: PrintSettings; fileName: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_settings_load_file(cast[ptr PrintSettings00](self.impl), fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_print_settings_load_key_file(self: ptr PrintSettings00; keyFile: ptr glib.KeyFile00;
    groupName: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadKeyFile*(self: PrintSettings; keyFile: glib.KeyFile;
    groupName: cstring = nil): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_settings_load_key_file(cast[ptr PrintSettings00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_print_settings_set(self: ptr PrintSettings00; key: cstring; value: cstring) {.
    importc, libprag.}

proc set*(self: PrintSettings; key: cstring; value: cstring = nil) =
  gtk_print_settings_set(cast[ptr PrintSettings00](self.impl), key, value)

proc gtk_print_settings_set_bool(self: ptr PrintSettings00; key: cstring;
    value: gboolean) {.
    importc, libprag.}

proc setBool*(self: PrintSettings; key: cstring; value: bool) =
  gtk_print_settings_set_bool(cast[ptr PrintSettings00](self.impl), key, gboolean(value))

proc gtk_print_settings_set_collate(self: ptr PrintSettings00; collate: gboolean) {.
    importc, libprag.}

proc setCollate*(self: PrintSettings; collate: bool = true) =
  gtk_print_settings_set_collate(cast[ptr PrintSettings00](self.impl), gboolean(collate))

proc `collate=`*(self: PrintSettings; collate: bool) =
  gtk_print_settings_set_collate(cast[ptr PrintSettings00](self.impl), gboolean(collate))

proc gtk_print_settings_set_default_source(self: ptr PrintSettings00; defaultSource: cstring) {.
    importc, libprag.}

proc setDefaultSource*(self: PrintSettings; defaultSource: cstring) =
  gtk_print_settings_set_default_source(cast[ptr PrintSettings00](self.impl), defaultSource)

proc `defaultSource=`*(self: PrintSettings; defaultSource: cstring) =
  gtk_print_settings_set_default_source(cast[ptr PrintSettings00](self.impl), defaultSource)

proc gtk_print_settings_set_dither(self: ptr PrintSettings00; dither: cstring) {.
    importc, libprag.}

proc setDither*(self: PrintSettings; dither: cstring) =
  gtk_print_settings_set_dither(cast[ptr PrintSettings00](self.impl), dither)

proc `dither=`*(self: PrintSettings; dither: cstring) =
  gtk_print_settings_set_dither(cast[ptr PrintSettings00](self.impl), dither)

proc gtk_print_settings_set_double(self: ptr PrintSettings00; key: cstring;
    value: cdouble) {.
    importc, libprag.}

proc setDouble*(self: PrintSettings; key: cstring; value: cdouble) =
  gtk_print_settings_set_double(cast[ptr PrintSettings00](self.impl), key, value)

proc gtk_print_settings_set_finishings(self: ptr PrintSettings00; finishings: cstring) {.
    importc, libprag.}

proc setFinishings*(self: PrintSettings; finishings: cstring) =
  gtk_print_settings_set_finishings(cast[ptr PrintSettings00](self.impl), finishings)

proc `finishings=`*(self: PrintSettings; finishings: cstring) =
  gtk_print_settings_set_finishings(cast[ptr PrintSettings00](self.impl), finishings)

proc gtk_print_settings_set_int(self: ptr PrintSettings00; key: cstring;
    value: int32) {.
    importc, libprag.}

proc setInt*(self: PrintSettings; key: cstring; value: int) =
  gtk_print_settings_set_int(cast[ptr PrintSettings00](self.impl), key, int32(value))

proc gtk_print_settings_set_length(self: ptr PrintSettings00; key: cstring;
    value: cdouble; unit: Unit) {.
    importc, libprag.}

proc setLength*(self: PrintSettings; key: cstring; value: cdouble;
    unit: Unit) =
  gtk_print_settings_set_length(cast[ptr PrintSettings00](self.impl), key, value, unit)

proc gtk_print_settings_set_media_type(self: ptr PrintSettings00; mediaType: cstring) {.
    importc, libprag.}

proc setMediaType*(self: PrintSettings; mediaType: cstring) =
  gtk_print_settings_set_media_type(cast[ptr PrintSettings00](self.impl), mediaType)

proc `mediaType=`*(self: PrintSettings; mediaType: cstring) =
  gtk_print_settings_set_media_type(cast[ptr PrintSettings00](self.impl), mediaType)

proc gtk_print_settings_set_n_copies(self: ptr PrintSettings00; numCopies: int32) {.
    importc, libprag.}

proc setNCopies*(self: PrintSettings; numCopies: int) =
  gtk_print_settings_set_n_copies(cast[ptr PrintSettings00](self.impl), int32(numCopies))

proc `nCopies=`*(self: PrintSettings; numCopies: int) =
  gtk_print_settings_set_n_copies(cast[ptr PrintSettings00](self.impl), int32(numCopies))

proc gtk_print_settings_set_number_up(self: ptr PrintSettings00; numberUp: int32) {.
    importc, libprag.}

proc setNumberUp*(self: PrintSettings; numberUp: int) =
  gtk_print_settings_set_number_up(cast[ptr PrintSettings00](self.impl), int32(numberUp))

proc `numberUp=`*(self: PrintSettings; numberUp: int) =
  gtk_print_settings_set_number_up(cast[ptr PrintSettings00](self.impl), int32(numberUp))

proc gtk_print_settings_set_orientation(self: ptr PrintSettings00; orientation: PageOrientation) {.
    importc, libprag.}

proc setOrientation*(self: PrintSettings; orientation: PageOrientation) =
  gtk_print_settings_set_orientation(cast[ptr PrintSettings00](self.impl), orientation)

proc `orientation=`*(self: PrintSettings; orientation: PageOrientation) =
  gtk_print_settings_set_orientation(cast[ptr PrintSettings00](self.impl), orientation)

proc gtk_print_settings_set_output_bin(self: ptr PrintSettings00; outputBin: cstring) {.
    importc, libprag.}

proc setOutputBin*(self: PrintSettings; outputBin: cstring) =
  gtk_print_settings_set_output_bin(cast[ptr PrintSettings00](self.impl), outputBin)

proc `outputBin=`*(self: PrintSettings; outputBin: cstring) =
  gtk_print_settings_set_output_bin(cast[ptr PrintSettings00](self.impl), outputBin)

proc gtk_print_settings_set_paper_height(self: ptr PrintSettings00; height: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setPaperHeight*(self: PrintSettings; height: cdouble;
    unit: Unit) =
  gtk_print_settings_set_paper_height(cast[ptr PrintSettings00](self.impl), height, unit)

proc gtk_print_settings_set_paper_size(self: ptr PrintSettings00; paperSize: ptr PaperSize00) {.
    importc, libprag.}

proc setPaperSize*(self: PrintSettings; paperSize: PaperSize) =
  gtk_print_settings_set_paper_size(cast[ptr PrintSettings00](self.impl), cast[ptr PaperSize00](paperSize.impl))

proc `paperSize=`*(self: PrintSettings; paperSize: PaperSize) =
  gtk_print_settings_set_paper_size(cast[ptr PrintSettings00](self.impl), cast[ptr PaperSize00](paperSize.impl))

proc gtk_print_settings_set_paper_width(self: ptr PrintSettings00; width: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setPaperWidth*(self: PrintSettings; width: cdouble;
    unit: Unit) =
  gtk_print_settings_set_paper_width(cast[ptr PrintSettings00](self.impl), width, unit)

proc gtk_print_settings_set_printer(self: ptr PrintSettings00; printer: cstring) {.
    importc, libprag.}

proc setPrinter*(self: PrintSettings; printer: cstring) =
  gtk_print_settings_set_printer(cast[ptr PrintSettings00](self.impl), printer)

proc `printer=`*(self: PrintSettings; printer: cstring) =
  gtk_print_settings_set_printer(cast[ptr PrintSettings00](self.impl), printer)

proc gtk_print_settings_set_printer_lpi(self: ptr PrintSettings00; lpi: cdouble) {.
    importc, libprag.}

proc setPrinterLpi*(self: PrintSettings; lpi: cdouble) =
  gtk_print_settings_set_printer_lpi(cast[ptr PrintSettings00](self.impl), lpi)

proc `printerLpi=`*(self: PrintSettings; lpi: cdouble) =
  gtk_print_settings_set_printer_lpi(cast[ptr PrintSettings00](self.impl), lpi)

proc gtk_print_settings_set_resolution(self: ptr PrintSettings00; resolution: int32) {.
    importc, libprag.}

proc setResolution*(self: PrintSettings; resolution: int) =
  gtk_print_settings_set_resolution(cast[ptr PrintSettings00](self.impl), int32(resolution))

proc `resolution=`*(self: PrintSettings; resolution: int) =
  gtk_print_settings_set_resolution(cast[ptr PrintSettings00](self.impl), int32(resolution))

proc gtk_print_settings_set_resolution_xy(self: ptr PrintSettings00; resolutionX: int32;
    resolutionY: int32) {.
    importc, libprag.}

proc setResolutionXy*(self: PrintSettings; resolutionX: int;
    resolutionY: int) =
  gtk_print_settings_set_resolution_xy(cast[ptr PrintSettings00](self.impl), int32(resolutionX), int32(resolutionY))

proc gtk_print_settings_set_reverse(self: ptr PrintSettings00; reverse: gboolean) {.
    importc, libprag.}

proc setReverse*(self: PrintSettings; reverse: bool = true) =
  gtk_print_settings_set_reverse(cast[ptr PrintSettings00](self.impl), gboolean(reverse))

proc `reverse=`*(self: PrintSettings; reverse: bool) =
  gtk_print_settings_set_reverse(cast[ptr PrintSettings00](self.impl), gboolean(reverse))

proc gtk_print_settings_set_scale(self: ptr PrintSettings00; scale: cdouble) {.
    importc, libprag.}

proc setScale*(self: PrintSettings; scale: cdouble) =
  gtk_print_settings_set_scale(cast[ptr PrintSettings00](self.impl), scale)

proc `scale=`*(self: PrintSettings; scale: cdouble) =
  gtk_print_settings_set_scale(cast[ptr PrintSettings00](self.impl), scale)

proc gtk_print_settings_set_use_color(self: ptr PrintSettings00; useColor: gboolean) {.
    importc, libprag.}

proc setUseColor*(self: PrintSettings; useColor: bool = true) =
  gtk_print_settings_set_use_color(cast[ptr PrintSettings00](self.impl), gboolean(useColor))

proc `useColor=`*(self: PrintSettings; useColor: bool) =
  gtk_print_settings_set_use_color(cast[ptr PrintSettings00](self.impl), gboolean(useColor))

proc gtk_print_settings_to_file(self: ptr PrintSettings00; fileName: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc toFile*(self: PrintSettings; fileName: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_settings_to_file(cast[ptr PrintSettings00](self.impl), fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_print_settings_to_gvariant(self: ptr PrintSettings00): ptr glib.Variant00 {.
    importc, libprag.}

proc toGvariant*(self: PrintSettings): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_print_settings_to_gvariant(cast[ptr PrintSettings00](self.impl))
  result.ignoreFinalizer = true # GVariant

proc gtk_print_settings_to_key_file(self: ptr PrintSettings00; keyFile: ptr glib.KeyFile00;
    groupName: cstring) {.
    importc, libprag.}

proc toKeyFile*(self: PrintSettings; keyFile: glib.KeyFile;
    groupName: cstring = nil) =
  gtk_print_settings_to_key_file(cast[ptr PrintSettings00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName)

proc gtk_print_settings_unset(self: ptr PrintSettings00; key: cstring) {.
    importc, libprag.}

proc unset*(self: PrintSettings; key: cstring) =
  gtk_print_settings_unset(cast[ptr PrintSettings00](self.impl), key)

proc gtk_print_unix_dialog_get_settings(self: ptr PrintUnixDialog00): ptr PrintSettings00 {.
    importc, libprag.}

proc getSettings*(self: PrintUnixDialog): PrintSettings =
  let gobj = gtk_print_unix_dialog_get_settings(cast[ptr PrintUnixDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_unix_dialog_set_settings(self: ptr PrintUnixDialog00; settings: ptr PrintSettings00) {.
    importc, libprag.}

proc setSettings*(self: PrintUnixDialog; settings: PrintSettings = nil) =
  gtk_print_unix_dialog_set_settings(cast[ptr PrintUnixDialog00](self.impl), if settings.isNil: nil else: cast[ptr PrintSettings00](settings.impl))

proc `settings=`*(self: PrintUnixDialog; settings: PrintSettings = nil) =
  gtk_print_unix_dialog_set_settings(cast[ptr PrintUnixDialog00](self.impl), if settings.isNil: nil else: cast[ptr PrintSettings00](settings.impl))

proc gtk_page_setup_unix_dialog_get_print_settings(self: ptr PageSetupUnixDialog00): ptr PrintSettings00 {.
    importc, libprag.}

proc getPrintSettings*(self: PageSetupUnixDialog): PrintSettings =
  let gobj = gtk_page_setup_unix_dialog_get_print_settings(cast[ptr PageSetupUnixDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc printSettings*(self: PageSetupUnixDialog): PrintSettings =
  let gobj = gtk_page_setup_unix_dialog_get_print_settings(cast[ptr PageSetupUnixDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_unix_dialog_set_print_settings(self: ptr PageSetupUnixDialog00;
    printSettings: ptr PrintSettings00) {.
    importc, libprag.}

proc setPrintSettings*(self: PageSetupUnixDialog;
    printSettings: PrintSettings = nil) =
  gtk_page_setup_unix_dialog_set_print_settings(cast[ptr PageSetupUnixDialog00](self.impl), if printSettings.isNil: nil else: cast[ptr PrintSettings00](printSettings.impl))

proc `printSettings=`*(self: PageSetupUnixDialog;
    printSettings: PrintSettings = nil) =
  gtk_page_setup_unix_dialog_set_print_settings(cast[ptr PageSetupUnixDialog00](self.impl), if printSettings.isNil: nil else: cast[ptr PrintSettings00](printSettings.impl))

type
  PrintDuplex* {.size: sizeof(cint), pure.} = enum
    simplex = 0
    horizontal = 1
    vertical = 2

proc gtk_print_settings_get_duplex(self: ptr PrintSettings00): PrintDuplex {.
    importc, libprag.}

proc getDuplex*(self: PrintSettings): PrintDuplex =
  gtk_print_settings_get_duplex(cast[ptr PrintSettings00](self.impl))

proc duplex*(self: PrintSettings): PrintDuplex =
  gtk_print_settings_get_duplex(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_set_duplex(self: ptr PrintSettings00; duplex: PrintDuplex) {.
    importc, libprag.}

proc setDuplex*(self: PrintSettings; duplex: PrintDuplex) =
  gtk_print_settings_set_duplex(cast[ptr PrintSettings00](self.impl), duplex)

proc `duplex=`*(self: PrintSettings; duplex: PrintDuplex) =
  gtk_print_settings_set_duplex(cast[ptr PrintSettings00](self.impl), duplex)

type
  NumberUpLayout* {.size: sizeof(cint), pure.} = enum
    lrtb = 0
    lrbt = 1
    rltb = 2
    rlbt = 3
    tblr = 4
    tbrl = 5
    btlr = 6
    btrl = 7

proc gtk_print_settings_get_number_up_layout(self: ptr PrintSettings00): NumberUpLayout {.
    importc, libprag.}

proc getNumberUpLayout*(self: PrintSettings): NumberUpLayout =
  gtk_print_settings_get_number_up_layout(cast[ptr PrintSettings00](self.impl))

proc numberUpLayout*(self: PrintSettings): NumberUpLayout =
  gtk_print_settings_get_number_up_layout(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_set_number_up_layout(self: ptr PrintSettings00; numberUpLayout: NumberUpLayout) {.
    importc, libprag.}

proc setNumberUpLayout*(self: PrintSettings; numberUpLayout: NumberUpLayout) =
  gtk_print_settings_set_number_up_layout(cast[ptr PrintSettings00](self.impl), numberUpLayout)

proc `numberUpLayout=`*(self: PrintSettings; numberUpLayout: NumberUpLayout) =
  gtk_print_settings_set_number_up_layout(cast[ptr PrintSettings00](self.impl), numberUpLayout)

type
  PageRange* {.pure, byRef.} = object
    start*: int32
    `end`*: int32

proc seq2PageRangeArray(s: openarray[PageRange]; a: var cstringArray):  ptr PageRange =
  assert s.high < 256
  let x = cast[ptr UncheckedArray[ptr PageRange]](a)
  for i in 0 .. s.high:
    x[i] = unsafeaddr(s[i])
  return cast[ptr PageRange](x)

proc pageRangeArrayToSeq(s: ptr PageRange; n: int):  seq[PageRange] =
  let a = cast[ptr UncheckedArray[ptr PageRange]](s)
  for i in 0 ..< n:
    result.add(a[i][])
  cogfree(s)



proc gtk_print_settings_get_page_ranges(self: ptr PrintSettings00; numRanges: var int32): ptr PageRange {.
    importc, libprag.}

proc getPageRanges*(self: PrintSettings; numRanges: var int): seq[PageRange] =
  var numRanges_00: int32
  let resul0 = gtk_print_settings_get_page_ranges(cast[ptr PrintSettings00](self.impl), numRanges_00)
  result = pageRangeArrayToSeq(resul0, numRanges_00.int)
  cogfree(resul0)
  if numRanges.addr != nil:
    numRanges = int(numRanges_00)

proc gtk_print_settings_set_page_ranges(self: ptr PrintSettings00; pageRanges: ptr PageRange;
    numRanges: int32) {.
    importc, libprag.}

proc setPageRanges*(self: PrintSettings; pageRanges: seq[PageRange]) =
  let numRanges = int(pageRanges.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_print_settings_set_page_ranges(cast[ptr PrintSettings00](self.impl), seq2PageRangeArray(pageRanges, fs469n23), int32(numRanges))

type
  PageSet* {.size: sizeof(cint), pure.} = enum
    all = 0
    even = 1
    odd = 2

proc gtk_print_settings_get_page_set(self: ptr PrintSettings00): PageSet {.
    importc, libprag.}

proc getPageSet*(self: PrintSettings): PageSet =
  gtk_print_settings_get_page_set(cast[ptr PrintSettings00](self.impl))

proc pageSet*(self: PrintSettings): PageSet =
  gtk_print_settings_get_page_set(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_set_page_set(self: ptr PrintSettings00; pageSet: PageSet) {.
    importc, libprag.}

proc setPageSet*(self: PrintSettings; pageSet: PageSet) =
  gtk_print_settings_set_page_set(cast[ptr PrintSettings00](self.impl), pageSet)

proc `pageSet=`*(self: PrintSettings; pageSet: PageSet) =
  gtk_print_settings_set_page_set(cast[ptr PrintSettings00](self.impl), pageSet)

type
  PrintPages* {.size: sizeof(cint), pure.} = enum
    all = 0
    current = 1
    ranges = 2
    selection = 3

proc gtk_print_settings_get_print_pages(self: ptr PrintSettings00): PrintPages {.
    importc, libprag.}

proc getPrintPages*(self: PrintSettings): PrintPages =
  gtk_print_settings_get_print_pages(cast[ptr PrintSettings00](self.impl))

proc printPages*(self: PrintSettings): PrintPages =
  gtk_print_settings_get_print_pages(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_set_print_pages(self: ptr PrintSettings00; pages: PrintPages) {.
    importc, libprag.}

proc setPrintPages*(self: PrintSettings; pages: PrintPages) =
  gtk_print_settings_set_print_pages(cast[ptr PrintSettings00](self.impl), pages)

proc `printPages=`*(self: PrintSettings; pages: PrintPages) =
  gtk_print_settings_set_print_pages(cast[ptr PrintSettings00](self.impl), pages)

type
  PrintQuality* {.size: sizeof(cint), pure.} = enum
    low = 0
    normal = 1
    high = 2
    draft = 3

proc gtk_print_settings_get_quality(self: ptr PrintSettings00): PrintQuality {.
    importc, libprag.}

proc getQuality*(self: PrintSettings): PrintQuality =
  gtk_print_settings_get_quality(cast[ptr PrintSettings00](self.impl))

proc quality*(self: PrintSettings): PrintQuality =
  gtk_print_settings_get_quality(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_set_quality(self: ptr PrintSettings00; quality: PrintQuality) {.
    importc, libprag.}

proc setQuality*(self: PrintSettings; quality: PrintQuality) =
  gtk_print_settings_set_quality(cast[ptr PrintSettings00](self.impl), quality)

proc `quality=`*(self: PrintSettings; quality: PrintQuality) =
  gtk_print_settings_set_quality(cast[ptr PrintSettings00](self.impl), quality)

type
  CellArea* = ref object of gobject.InitiallyUnowned
  CellArea00* = object of gobject.InitiallyUnowned00

proc gtk_cell_area_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellArea()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAddEditable*(self: CellArea;  p: proc (self: ptr CellArea00; renderer: ptr CellRenderer00; editable: ptr CellEditable00; cellArea: gdk4.Rectangle;
    path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "add-editable", cast[GCallback](p), xdata, nil, cf)

proc scApplyAttributes*(self: CellArea;  p: proc (self: ptr CellArea00; model: ptr TreeModel00; iter: TreeIter; isExpander: gboolean; isExpanded: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "apply-attributes", cast[GCallback](p), xdata, nil, cf)

proc scFocusChanged*(self: CellArea;  p: proc (self: ptr CellArea00; renderer: ptr CellRenderer00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus-changed", cast[GCallback](p), xdata, nil, cf)

proc scRemoveEditable*(self: CellArea;  p: proc (self: ptr CellArea00; renderer: ptr CellRenderer00; editable: ptr CellEditable00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "remove-editable", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_area_activate_cell(self: ptr CellArea00; widget: ptr Widget00;
    renderer: ptr CellRenderer00; event: ptr gdk4.Event00; cellArea: gdk4.Rectangle;
    flags: CellRendererState): gboolean {.
    importc, libprag.}

proc activateCell*(self: CellArea; widget: Widget; renderer: CellRenderer;
    event: gdk4.Event; cellArea: gdk4.Rectangle; flags: CellRendererState): bool =
  toBool(gtk_cell_area_activate_cell(cast[ptr CellArea00](self.impl), cast[ptr Widget00](widget.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr gdk4.Event00](event.impl), cellArea, flags))

proc gtk_cell_area_add(self: ptr CellArea00; renderer: ptr CellRenderer00) {.
    importc, libprag.}

proc add*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_add(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_add_focus_sibling(self: ptr CellArea00; renderer: ptr CellRenderer00;
    sibling: ptr CellRenderer00) {.
    importc, libprag.}

proc addFocusSibling*(self: CellArea; renderer: CellRenderer;
    sibling: CellRenderer) =
  gtk_cell_area_add_focus_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr CellRenderer00](sibling.impl))

proc gtk_cell_area_apply_attributes(self: ptr CellArea00; treeModel: ptr TreeModel00;
    iter: TreeIter; isExpander: gboolean; isExpanded: gboolean) {.
    importc, libprag.}

proc applyAttributes*(self: CellArea; treeModel: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    iter: TreeIter; isExpander: bool; isExpanded: bool) =
  gtk_cell_area_apply_attributes(cast[ptr CellArea00](self.impl), cast[ptr TreeModel00](treeModel.impl), iter, gboolean(isExpander), gboolean(isExpanded))

proc gtk_cell_area_attribute_connect(self: ptr CellArea00; renderer: ptr CellRenderer00;
    attribute: cstring; column: int32) {.
    importc, libprag.}

proc attributeConnect*(self: CellArea; renderer: CellRenderer;
    attribute: cstring; column: int) =
  gtk_cell_area_attribute_connect(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), attribute, int32(column))

proc gtk_cell_area_attribute_disconnect(self: ptr CellArea00; renderer: ptr CellRenderer00;
    attribute: cstring) {.
    importc, libprag.}

proc attributeDisconnect*(self: CellArea; renderer: CellRenderer;
    attribute: cstring) =
  gtk_cell_area_attribute_disconnect(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), attribute)

proc gtk_cell_area_attribute_get_column(self: ptr CellArea00; renderer: ptr CellRenderer00;
    attribute: cstring): int32 {.
    importc, libprag.}

proc attributeGetColumn*(self: CellArea; renderer: CellRenderer;
    attribute: cstring): int =
  int(gtk_cell_area_attribute_get_column(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), attribute))

proc gtk_cell_area_cell_get_property(self: ptr CellArea00; renderer: ptr CellRenderer00;
    propertyName: cstring; value: gobject.Value) {.
    importc, libprag.}

proc cellGetProperty*(self: CellArea; renderer: CellRenderer;
    propertyName: cstring; value: gobject.Value) =
  gtk_cell_area_cell_get_property(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), propertyName, value)

proc gtk_cell_area_cell_set_property(self: ptr CellArea00; renderer: ptr CellRenderer00;
    propertyName: cstring; value: gobject.Value) {.
    importc, libprag.}

proc cellSetProperty*(self: CellArea; renderer: CellRenderer;
    propertyName: cstring; value: gobject.Value) =
  gtk_cell_area_cell_set_property(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), propertyName, value)

proc gtk_cell_area_focus(self: ptr CellArea00; direction: DirectionType): gboolean {.
    importc, libprag.}

proc focus*(self: CellArea; direction: DirectionType): bool =
  toBool(gtk_cell_area_focus(cast[ptr CellArea00](self.impl), direction))

proc gtk_cell_area_get_current_path_string(self: ptr CellArea00): cstring {.
    importc, libprag.}

proc getCurrentPathString*(self: CellArea): string =
  result = $gtk_cell_area_get_current_path_string(cast[ptr CellArea00](self.impl))

proc currentPathString*(self: CellArea): string =
  result = $gtk_cell_area_get_current_path_string(cast[ptr CellArea00](self.impl))

proc gtk_cell_area_get_edit_widget(self: ptr CellArea00): ptr CellEditable00 {.
    importc, libprag.}

proc getEditWidget*(self: CellArea): CellEditable =
  let gobj = gtk_cell_area_get_edit_widget(cast[ptr CellArea00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc editWidget*(self: CellArea): CellEditable =
  let gobj = gtk_cell_area_get_edit_widget(cast[ptr CellArea00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_edited_cell(self: ptr CellArea00): ptr CellRenderer00 {.
    importc, libprag.}

proc getEditedCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_edited_cell(cast[ptr CellArea00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc editedCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_edited_cell(cast[ptr CellArea00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_focus_cell(self: ptr CellArea00): ptr CellRenderer00 {.
    importc, libprag.}

proc getFocusCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_focus_cell(cast[ptr CellArea00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_focus_cell(cast[ptr CellArea00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_focus_from_sibling(self: ptr CellArea00; renderer: ptr CellRenderer00): ptr CellRenderer00 {.
    importc, libprag.}

proc getFocusFromSibling*(self: CellArea; renderer: CellRenderer): CellRenderer =
  let gobj = gtk_cell_area_get_focus_from_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_focus_siblings(self: ptr CellArea00; renderer: ptr CellRenderer00): ptr glib.List {.
    importc, libprag.}

proc getFocusSiblings*(self: CellArea; renderer: CellRenderer): seq[CellRenderer] =
  result = glistObjects2seq(CellRenderer, gtk_cell_area_get_focus_siblings(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl)), false)

proc gtk_cell_area_has_renderer(self: ptr CellArea00; renderer: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc hasRenderer*(self: CellArea; renderer: CellRenderer): bool =
  toBool(gtk_cell_area_has_renderer(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl)))

proc gtk_cell_area_inner_cell_area(self: ptr CellArea00; widget: ptr Widget00;
    cellArea: gdk4.Rectangle; innerArea: var gdk4.Rectangle) {.
    importc, libprag.}

proc innerCellArea*(self: CellArea; widget: Widget; cellArea: gdk4.Rectangle;
    innerArea: var gdk4.Rectangle) =
  gtk_cell_area_inner_cell_area(cast[ptr CellArea00](self.impl), cast[ptr Widget00](widget.impl), cellArea, innerArea)

proc gtk_cell_area_is_activatable(self: ptr CellArea00): gboolean {.
    importc, libprag.}

proc isActivatable*(self: CellArea): bool =
  toBool(gtk_cell_area_is_activatable(cast[ptr CellArea00](self.impl)))

proc gtk_cell_area_is_focus_sibling(self: ptr CellArea00; renderer: ptr CellRenderer00;
    sibling: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc isFocusSibling*(self: CellArea; renderer: CellRenderer;
    sibling: CellRenderer): bool =
  toBool(gtk_cell_area_is_focus_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr CellRenderer00](sibling.impl)))

proc gtk_cell_area_remove(self: ptr CellArea00; renderer: ptr CellRenderer00) {.
    importc, libprag.}

proc remove*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_remove(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_remove_focus_sibling(self: ptr CellArea00; renderer: ptr CellRenderer00;
    sibling: ptr CellRenderer00) {.
    importc, libprag.}

proc removeFocusSibling*(self: CellArea; renderer: CellRenderer;
    sibling: CellRenderer) =
  gtk_cell_area_remove_focus_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr CellRenderer00](sibling.impl))

proc gtk_cell_area_set_focus_cell(self: ptr CellArea00; renderer: ptr CellRenderer00) {.
    importc, libprag.}

proc setFocusCell*(self: CellArea; renderer: CellRenderer = nil) =
  gtk_cell_area_set_focus_cell(cast[ptr CellArea00](self.impl), if renderer.isNil: nil else: cast[ptr CellRenderer00](renderer.impl))

proc `focusCell=`*(self: CellArea; renderer: CellRenderer = nil) =
  gtk_cell_area_set_focus_cell(cast[ptr CellArea00](self.impl), if renderer.isNil: nil else: cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_stop_editing(self: ptr CellArea00; canceled: gboolean) {.
    importc, libprag.}

proc stopEditing*(self: CellArea; canceled: bool) =
  gtk_cell_area_stop_editing(cast[ptr CellArea00](self.impl), gboolean(canceled))

proc gtk_icon_view_new_with_area(area: ptr CellArea00): ptr IconView00 {.
    importc, libprag.}

proc newIconViewWithArea*(area: CellArea): IconView {.deprecated.}  =
  let gobj = gtk_icon_view_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconViewWithArea*(tdesc: typedesc; area: CellArea): tdesc {.deprecated.}  =
  assert(result is IconView)
  let gobj = gtk_icon_view_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconViewWithArea*[T](result: var T; area: CellArea) {.deprecated.} =
  assert(result is IconView)
  let gobj = gtk_icon_view_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_new_with_area(area: ptr CellArea00): ptr TreeViewColumn00 {.
    importc, libprag.}

proc newTreeViewColumnWithArea*(area: CellArea): TreeViewColumn {.deprecated.}  =
  let gobj = gtk_tree_view_column_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeViewColumnWithArea*(tdesc: typedesc; area: CellArea): tdesc {.deprecated.}  =
  assert(result is TreeViewColumn)
  let gobj = gtk_tree_view_column_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeViewColumnWithArea*[T](result: var T; area: CellArea) {.deprecated.} =
  assert(result is TreeViewColumn)
  let gobj = gtk_tree_view_column_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_new_with_area(area: ptr CellArea00): ptr EntryCompletion00 {.
    importc, libprag.}

proc newEntryCompletionWithArea*(area: CellArea): EntryCompletion {.deprecated.}  =
  let gobj = gtk_entry_completion_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntryCompletionWithArea*(tdesc: typedesc; area: CellArea): tdesc {.deprecated.}  =
  assert(result is EntryCompletion)
  let gobj = gtk_entry_completion_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryCompletionWithArea*[T](result: var T; area: CellArea) {.deprecated.} =
  assert(result is EntryCompletion)
  let gobj = gtk_entry_completion_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellAreaContext* = ref object of gobject.Object
  CellAreaContext00* = object of gobject.Object00

proc gtk_cell_area_context_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellAreaContext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_area_context_allocate(self: ptr CellAreaContext00; width: int32;
    height: int32) {.
    importc, libprag.}

proc allocate*(self: CellAreaContext; width: int; height: int) =
  gtk_cell_area_context_allocate(cast[ptr CellAreaContext00](self.impl), int32(width), int32(height))

proc gtk_cell_area_context_get_allocation(self: ptr CellAreaContext00; width: var int32;
    height: var int32) {.
    importc, libprag.}

proc getAllocation*(self: CellAreaContext; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var height_00: int32
  var width_00: int32
  gtk_cell_area_context_get_allocation(cast[ptr CellAreaContext00](self.impl), width_00, height_00)
  if height.addr != nil:
    height = int(height_00)
  if width.addr != nil:
    width = int(width_00)

proc gtk_cell_area_context_get_area(self: ptr CellAreaContext00): ptr CellArea00 {.
    importc, libprag.}

proc getArea*(self: CellAreaContext): CellArea =
  let gobj = gtk_cell_area_context_get_area(cast[ptr CellAreaContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc area*(self: CellAreaContext): CellArea =
  let gobj = gtk_cell_area_context_get_area(cast[ptr CellAreaContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_context_get_preferred_height(self: ptr CellAreaContext00;
    minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeight*(self: CellAreaContext; minimumHeight: var int = cast[var int](nil);
    naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_area_context_get_preferred_height(cast[ptr CellAreaContext00](self.impl), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_context_get_preferred_height_for_width(self: ptr CellAreaContext00;
    width: int32; minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeightForWidth*(self: CellAreaContext;
    width: int; minimumHeight: var int = cast[var int](nil); naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_area_context_get_preferred_height_for_width(cast[ptr CellAreaContext00](self.impl), int32(width), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_context_get_preferred_width(self: ptr CellAreaContext00;
    minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidth*(self: CellAreaContext; minimumWidth: var int = cast[var int](nil);
    naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_area_context_get_preferred_width(cast[ptr CellAreaContext00](self.impl), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_context_get_preferred_width_for_height(self: ptr CellAreaContext00;
    height: int32; minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidthForHeight*(self: CellAreaContext;
    height: int; minimumWidth: var int = cast[var int](nil); naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_area_context_get_preferred_width_for_height(cast[ptr CellAreaContext00](self.impl), int32(height), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_context_push_preferred_height(self: ptr CellAreaContext00;
    minimumHeight: int32; naturalHeight: int32) {.
    importc, libprag.}

proc pushPreferredHeight*(self: CellAreaContext; minimumHeight: int;
    naturalHeight: int) =
  gtk_cell_area_context_push_preferred_height(cast[ptr CellAreaContext00](self.impl), int32(minimumHeight), int32(naturalHeight))

proc gtk_cell_area_context_push_preferred_width(self: ptr CellAreaContext00;
    minimumWidth: int32; naturalWidth: int32) {.
    importc, libprag.}

proc pushPreferredWidth*(self: CellAreaContext; minimumWidth: int;
    naturalWidth: int) =
  gtk_cell_area_context_push_preferred_width(cast[ptr CellAreaContext00](self.impl), int32(minimumWidth), int32(naturalWidth))

proc gtk_cell_area_context_reset(self: ptr CellAreaContext00) {.
    importc, libprag.}

proc reset*(self: CellAreaContext) =
  gtk_cell_area_context_reset(cast[ptr CellAreaContext00](self.impl))

proc gtk_cell_view_new_with_context(area: ptr CellArea00; context: ptr CellAreaContext00): ptr CellView00 {.
    importc, libprag.}

proc newCellViewWithContext*(area: CellArea; context: CellAreaContext): CellView {.deprecated.}  =
  let gobj = gtk_cell_view_new_with_context(cast[ptr CellArea00](area.impl), cast[ptr CellAreaContext00](context.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellViewWithContext*(tdesc: typedesc; area: CellArea; context: CellAreaContext): tdesc {.deprecated.}  =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_context(cast[ptr CellArea00](area.impl), cast[ptr CellAreaContext00](context.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithContext*[T](result: var T; area: CellArea; context: CellAreaContext) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_context(cast[ptr CellArea00](area.impl), cast[ptr CellAreaContext00](context.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_activate(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; cellArea: gdk4.Rectangle; flags: CellRendererState;
    editOnly: gboolean): gboolean {.
    importc, libprag.}

proc activate*(self: CellArea; context: CellAreaContext; widget: Widget;
    cellArea: gdk4.Rectangle; flags: CellRendererState; editOnly: bool): bool =
  toBool(gtk_cell_area_activate(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cellArea, flags, gboolean(editOnly)))

proc gtk_cell_area_copy_context(self: ptr CellArea00; context: ptr CellAreaContext00): ptr CellAreaContext00 {.
    importc, libprag.}

proc copyContext*(self: CellArea; context: CellAreaContext): CellAreaContext =
  let gobj = gtk_cell_area_copy_context(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_create_context(self: ptr CellArea00): ptr CellAreaContext00 {.
    importc, libprag.}

proc createContext*(self: CellArea): CellAreaContext =
  let gobj = gtk_cell_area_create_context(cast[ptr CellArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_event(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; event: ptr gdk4.Event00; cellArea: gdk4.Rectangle;
    flags: CellRendererState): int32 {.
    importc, libprag.}

proc event*(self: CellArea; context: CellAreaContext; widget: Widget;
    event: gdk4.Event; cellArea: gdk4.Rectangle; flags: CellRendererState): int =
  int(gtk_cell_area_event(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk4.Event00](event.impl), cellArea, flags))

proc gtk_cell_area_get_cell_allocation(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; renderer: ptr CellRenderer00; cellArea: gdk4.Rectangle;
    allocation: var gdk4.Rectangle) {.
    importc, libprag.}

proc getCellAllocation*(self: CellArea; context: CellAreaContext;
    widget: Widget; renderer: CellRenderer; cellArea: gdk4.Rectangle; allocation: var gdk4.Rectangle) =
  gtk_cell_area_get_cell_allocation(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr CellRenderer00](renderer.impl), cellArea, allocation)

proc gtk_cell_area_get_cell_at_position(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; cellArea: gdk4.Rectangle; x: int32; y: int32; allocArea: var gdk4.Rectangle): ptr CellRenderer00 {.
    importc, libprag.}

proc getCellAtPosition*(self: CellArea; context: CellAreaContext;
    widget: Widget; cellArea: gdk4.Rectangle; x: int; y: int; allocArea: var gdk4.Rectangle = cast[var gdk4.Rectangle](nil)): CellRenderer =
  let gobj = gtk_cell_area_get_cell_at_position(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cellArea, int32(x), int32(y), allocArea)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_preferred_height(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeight*(self: CellArea; context: CellAreaContext;
    widget: Widget; minimumHeight: var int = cast[var int](nil); naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_area_get_preferred_height(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_get_preferred_height_for_width(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; width: int32; minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeightForWidth*(self: CellArea; context: CellAreaContext;
    widget: Widget; width: int; minimumHeight: var int = cast[var int](nil);
    naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_area_get_preferred_height_for_width(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), int32(width), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_get_preferred_width(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidth*(self: CellArea; context: CellAreaContext;
    widget: Widget; minimumWidth: var int = cast[var int](nil); naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_area_get_preferred_width(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_get_preferred_width_for_height(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; height: int32; minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidthForHeight*(self: CellArea; context: CellAreaContext;
    widget: Widget; height: int; minimumWidth: var int = cast[var int](nil);
    naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_area_get_preferred_width_for_height(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), int32(height), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

type
  ColorDialog* = ref object of gobject.Object
  ColorDialog00* = object of gobject.Object00

proc gtk_color_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_color_dialog_new(): ptr ColorDialog00 {.
    importc, libprag.}

proc newColorDialog*(): ColorDialog =
  let gobj = gtk_color_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorDialog*(tdesc: typedesc): tdesc =
  assert(result is ColorDialog)
  let gobj = gtk_color_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorDialog*[T](result: var T) {.deprecated.} =
  assert(result is ColorDialog)
  let gobj = gtk_color_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_dialog_choose_rgba(self: ptr ColorDialog00; parent: ptr Window00;
    initialColor: gdk4.RGBA; cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback;
    userData: pointer) {.
    importc, libprag.}

proc chooseRgba*(self: ColorDialog; parent: Window = nil;
    initialColor: gdk4.RGBA = cast[var gdk4.RGBA](nil); cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_color_dialog_choose_rgba(cast[ptr ColorDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), initialColor, if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_color_dialog_choose_rgba_finish(self: ptr ColorDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr gdk4.RGBA {.
    importc, libprag.}

proc chooseRgbaFinish*(self: ColorDialog; resu: gio.AsyncResult): ptr gdk4.RGBA =
  var gerror: ptr glib.Error
  let resul0 = gtk_color_dialog_choose_rgba_finish(cast[ptr ColorDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if resul0.isNil:
    return
  result = resul0

proc gtk_color_dialog_get_modal(self: ptr ColorDialog00): gboolean {.
    importc, libprag.}

proc getModal*(self: ColorDialog): bool =
  toBool(gtk_color_dialog_get_modal(cast[ptr ColorDialog00](self.impl)))

proc modal*(self: ColorDialog): bool =
  toBool(gtk_color_dialog_get_modal(cast[ptr ColorDialog00](self.impl)))

proc gtk_color_dialog_get_title(self: ptr ColorDialog00): cstring {.
    importc, libprag.}

proc getTitle*(self: ColorDialog): string =
  result = $gtk_color_dialog_get_title(cast[ptr ColorDialog00](self.impl))

proc title*(self: ColorDialog): string =
  result = $gtk_color_dialog_get_title(cast[ptr ColorDialog00](self.impl))

proc gtk_color_dialog_get_with_alpha(self: ptr ColorDialog00): gboolean {.
    importc, libprag.}

proc getWithAlpha*(self: ColorDialog): bool =
  toBool(gtk_color_dialog_get_with_alpha(cast[ptr ColorDialog00](self.impl)))

proc withAlpha*(self: ColorDialog): bool =
  toBool(gtk_color_dialog_get_with_alpha(cast[ptr ColorDialog00](self.impl)))

proc gtk_color_dialog_set_modal(self: ptr ColorDialog00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: ColorDialog; modal: bool = true) =
  gtk_color_dialog_set_modal(cast[ptr ColorDialog00](self.impl), gboolean(modal))

proc `modal=`*(self: ColorDialog; modal: bool) =
  gtk_color_dialog_set_modal(cast[ptr ColorDialog00](self.impl), gboolean(modal))

proc gtk_color_dialog_set_title(self: ptr ColorDialog00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: ColorDialog; title: cstring) =
  gtk_color_dialog_set_title(cast[ptr ColorDialog00](self.impl), title)

proc `title=`*(self: ColorDialog; title: cstring) =
  gtk_color_dialog_set_title(cast[ptr ColorDialog00](self.impl), title)

proc gtk_color_dialog_set_with_alpha(self: ptr ColorDialog00; withAlpha: gboolean) {.
    importc, libprag.}

proc setWithAlpha*(self: ColorDialog; withAlpha: bool = true) =
  gtk_color_dialog_set_with_alpha(cast[ptr ColorDialog00](self.impl), gboolean(withAlpha))

proc `withAlpha=`*(self: ColorDialog; withAlpha: bool) =
  gtk_color_dialog_set_with_alpha(cast[ptr ColorDialog00](self.impl), gboolean(withAlpha))

proc gtk_color_dialog_button_new(dialog: ptr ColorDialog00): ptr ColorDialogButton00 {.
    importc, libprag.}

proc newColorDialogButton*(dialog: ColorDialog = nil): ColorDialogButton =
  let gobj = gtk_color_dialog_button_new(if dialog.isNil: nil else: cast[ptr ColorDialog00](g_object_ref(dialog.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorDialogButton*(tdesc: typedesc; dialog: ColorDialog = nil): tdesc =
  assert(result is ColorDialogButton)
  let gobj = gtk_color_dialog_button_new(if dialog.isNil: nil else: cast[ptr ColorDialog00](g_object_ref(dialog.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorDialogButton*[T](result: var T; dialog: ColorDialog = nil) {.deprecated.} =
  assert(result is ColorDialogButton)
  let gobj = gtk_color_dialog_button_new(if dialog.isNil: nil else: cast[ptr ColorDialog00](g_object_ref(dialog.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_dialog_button_get_dialog(self: ptr ColorDialogButton00): ptr ColorDialog00 {.
    importc, libprag.}

proc getDialog*(self: ColorDialogButton): ColorDialog =
  let gobj = gtk_color_dialog_button_get_dialog(cast[ptr ColorDialogButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc dialog*(self: ColorDialogButton): ColorDialog =
  let gobj = gtk_color_dialog_button_get_dialog(cast[ptr ColorDialogButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_dialog_button_set_dialog(self: ptr ColorDialogButton00; dialog: ptr ColorDialog00) {.
    importc, libprag.}

proc setDialog*(self: ColorDialogButton; dialog: ColorDialog) =
  gtk_color_dialog_button_set_dialog(cast[ptr ColorDialogButton00](self.impl), cast[ptr ColorDialog00](dialog.impl))

proc `dialog=`*(self: ColorDialogButton; dialog: ColorDialog) =
  gtk_color_dialog_button_set_dialog(cast[ptr ColorDialogButton00](self.impl), cast[ptr ColorDialog00](dialog.impl))

type
  PackType* {.size: sizeof(cint), pure.} = enum
    start = 0
    `end` = 1

proc gtk_window_controls_new(side: PackType): ptr WindowControls00 {.
    importc, libprag.}

proc newWindowControls*(side: PackType): WindowControls =
  let gobj = gtk_window_controls_new(side)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newWindowControls*(tdesc: typedesc; side: PackType): tdesc =
  assert(result is WindowControls)
  let gobj = gtk_window_controls_new(side)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initWindowControls*[T](result: var T; side: PackType) {.deprecated.} =
  assert(result is WindowControls)
  let gobj = gtk_window_controls_new(side)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_controls_get_side(self: ptr WindowControls00): PackType {.
    importc, libprag.}

proc getSide*(self: WindowControls): PackType =
  gtk_window_controls_get_side(cast[ptr WindowControls00](self.impl))

proc side*(self: WindowControls): PackType =
  gtk_window_controls_get_side(cast[ptr WindowControls00](self.impl))

proc gtk_window_controls_set_side(self: ptr WindowControls00; side: PackType) {.
    importc, libprag.}

proc setSide*(self: WindowControls; side: PackType) =
  gtk_window_controls_set_side(cast[ptr WindowControls00](self.impl), side)

proc `side=`*(self: WindowControls; side: PackType) =
  gtk_window_controls_set_side(cast[ptr WindowControls00](self.impl), side)

proc gtk_notebook_get_action_widget(self: ptr Notebook00; packType: PackType): ptr Widget00 {.
    importc, libprag.}

proc getActionWidget*(self: Notebook; packType: PackType): Widget =
  let gobj = gtk_notebook_get_action_widget(cast[ptr Notebook00](self.impl), packType)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_set_action_widget(self: ptr Notebook00; widget: ptr Widget00;
    packType: PackType) {.
    importc, libprag.}

proc setActionWidget*(self: Notebook; widget: Widget; packType: PackType) =
  gtk_notebook_set_action_widget(cast[ptr Notebook00](self.impl), cast[ptr Widget00](widget.impl), packType)

type
  ArrowType* {.size: sizeof(cint), pure.} = enum
    up = 0
    down = 1
    left = 2
    right = 3
    none = 4

proc gtk_menu_button_get_direction(self: ptr MenuButton00): ArrowType {.
    importc, libprag.}

proc getDirection*(self: MenuButton): ArrowType =
  gtk_menu_button_get_direction(cast[ptr MenuButton00](self.impl))

proc direction*(self: MenuButton): ArrowType =
  gtk_menu_button_get_direction(cast[ptr MenuButton00](self.impl))

proc gtk_menu_button_set_direction(self: ptr MenuButton00; direction: ArrowType) {.
    importc, libprag.}

proc setDirection*(self: MenuButton; direction: ArrowType) =
  gtk_menu_button_set_direction(cast[ptr MenuButton00](self.impl), direction)

proc `direction=`*(self: MenuButton; direction: ArrowType) =
  gtk_menu_button_set_direction(cast[ptr MenuButton00](self.impl), direction)

type
  AssistantPage* = ref object of gobject.Object
  AssistantPage00* = object of gobject.Object00

proc gtk_assistant_page_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AssistantPage()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_assistant_page_get_child(self: ptr AssistantPage00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: AssistantPage): Widget =
  let gobj = gtk_assistant_page_get_child(cast[ptr AssistantPage00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: AssistantPage): Widget =
  let gobj = gtk_assistant_page_get_child(cast[ptr AssistantPage00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_get_page(self: ptr Assistant00; child: ptr Widget00): ptr AssistantPage00 {.
    importc, libprag.}

proc getPage*(self: Assistant; child: Widget): AssistantPage =
  let gobj = gtk_assistant_get_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  AssistantPageType* {.size: sizeof(cint), pure.} = enum
    content = 0
    intro = 1
    confirm = 2
    summary = 3
    progress = 4
    custom = 5

proc gtk_assistant_get_page_type(self: ptr Assistant00; page: ptr Widget00): AssistantPageType {.
    importc, libprag.}

proc getPageType*(self: Assistant; page: Widget): AssistantPageType =
  gtk_assistant_get_page_type(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))

proc gtk_assistant_set_page_type(self: ptr Assistant00; page: ptr Widget00;
    `type`: AssistantPageType) {.
    importc, libprag.}

proc setPageType*(self: Assistant; page: Widget; `type`: AssistantPageType) =
  gtk_assistant_set_page_type(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), `type`)

type
  DialogFlag* {.size: sizeof(cint), pure.} = enum
    modal = 0
    destroyWithParent = 1
    useHeaderBar = 2

  DialogFlags* = set[DialogFlag]

proc gtk_app_chooser_dialog_new(parent: ptr Window00; flags: DialogFlags;
    file: ptr gio.GFile00): ptr AppChooserDialog00 {.
    importc, libprag.}

proc newAppChooserDialog*(parent: Window = nil; flags: DialogFlags;
    file: gio.GFile): AppChooserDialog {.deprecated.}  =
  let gobj = gtk_app_chooser_dialog_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAppChooserDialog*(tdesc: typedesc; parent: Window = nil; flags: DialogFlags;
    file: gio.GFile): tdesc {.deprecated.}  =
  assert(result is AppChooserDialog)
  let gobj = gtk_app_chooser_dialog_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserDialog*[T](result: var T; parent: Window = nil; flags: DialogFlags;
    file: gio.GFile) {.deprecated.} =
  assert(result is AppChooserDialog)
  let gobj = gtk_app_chooser_dialog_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_dialog_new_for_content_type(parent: ptr Window00; flags: DialogFlags;
    contentType: cstring): ptr AppChooserDialog00 {.
    importc, libprag.}

proc newAppChooserDialogForContentType*(parent: Window = nil; flags: DialogFlags;
    contentType: cstring): AppChooserDialog {.deprecated.}  =
  let gobj = gtk_app_chooser_dialog_new_for_content_type(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAppChooserDialogForContentType*(tdesc: typedesc; parent: Window = nil; flags: DialogFlags;
    contentType: cstring): tdesc {.deprecated.}  =
  assert(result is AppChooserDialog)
  let gobj = gtk_app_chooser_dialog_new_for_content_type(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserDialogForContentType*[T](result: var T; parent: Window = nil; flags: DialogFlags;
    contentType: cstring) {.deprecated.} =
  assert(result is AppChooserDialog)
  let gobj = gtk_app_chooser_dialog_new_for_content_type(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Expression* = ref object of RootRef
    impl*: ptr Expression00
    ignoreFinalizer*: bool
  Expression00*{.inheritable, pure.} = object

proc gtk_expression_get_type*(): GType {.importc, libprag.}

proc gtk_expression_unref*(self: ptr Expression00) {.importc, libprag.}

proc generic_gtk_expression_unref*(self: Expression) =
  if not self.ignoreFinalizer:
    gtk_expression_unref(self.impl)

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Expression()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      gtk_expression_unref(self.impl)
      self.impl = nil

proc gtk_expression_evaluate(self: ptr Expression00; this: ptr gobject.Object00;
    value: gobject.Value): gboolean {.
    importc, libprag.}

proc evaluate*(self: Expression; this: gobject.Object = nil;
    value: gobject.Value): bool =
  toBool(gtk_expression_evaluate(cast[ptr Expression00](self.impl), if this.isNil: nil else: cast[ptr gobject.Object00](this.impl), value))

proc gtk_expression_get_value_type(self: ptr Expression00): GType {.
    importc, libprag.}

proc getValueType*(self: Expression): GType =
  gtk_expression_get_value_type(cast[ptr Expression00](self.impl))

proc valueType*(self: Expression): GType =
  gtk_expression_get_value_type(cast[ptr Expression00](self.impl))

proc gtk_expression_is_static(self: ptr Expression00): gboolean {.
    importc, libprag.}

proc isStatic*(self: Expression): bool =
  toBool(gtk_expression_is_static(cast[ptr Expression00](self.impl)))

proc gtk_expression_ref*(self: ptr Expression00): ptr Expression00 {.
    importc, libprag.}

proc `ref`*(self: Expression): Expression =
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_expression_ref(cast[ptr Expression00](self.impl))

proc gtk_drop_down_new(model: ptr gio.ListModel00; expression: ptr Expression00): ptr DropDown00 {.
    importc, libprag.}

proc newDropDown*(model: gio.ListModel = nil; expression: Expression = nil): DropDown =
  let gobj = gtk_drop_down_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDropDown*(tdesc: typedesc; model: gio.ListModel = nil; expression: Expression = nil): tdesc =
  assert(result is DropDown)
  let gobj = gtk_drop_down_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDropDown*[T](result: var T; model: gio.ListModel = nil; expression: Expression = nil) {.deprecated.} =
  assert(result is DropDown)
  let gobj = gtk_drop_down_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_down_get_expression(self: ptr DropDown00): ptr Expression00 {.
    importc, libprag.}

proc getExpression*(self: DropDown): Expression =
  let impl0 = gtk_drop_down_get_expression(cast[ptr DropDown00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc expression*(self: DropDown): Expression =
  let impl0 = gtk_drop_down_get_expression(cast[ptr DropDown00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc gtk_drop_down_set_expression(self: ptr DropDown00; expression: ptr Expression00) {.
    importc, libprag.}

proc setExpression*(self: DropDown; expression: Expression = nil) =
  gtk_drop_down_set_expression(cast[ptr DropDown00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

proc `expression=`*(self: DropDown; expression: Expression = nil) =
  gtk_drop_down_set_expression(cast[ptr DropDown00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

type
  ExpressionWatch00* {.pure.} = object
  ExpressionWatch* = ref object
    impl*: ptr ExpressionWatch00
    ignoreFinalizer*: bool

proc gtk_expression_watch_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkExpressionWatch*(self: ExpressionWatch) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_expression_watch_get_type(), cast[ptr ExpressionWatch00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ExpressionWatch()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_expression_watch_get_type(), cast[ptr ExpressionWatch00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var ExpressionWatch) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkExpressionWatch)

proc gtk_expression_watch_unref(self: ptr ExpressionWatch00) {.
    importc, libprag.}

proc unref*(self: ExpressionWatch) =
  gtk_expression_watch_unref(cast[ptr ExpressionWatch00](g_boxed_copy(gtk_expression_watch_get_type(), self.impl)))

proc finalizerunref*(self: ExpressionWatch) =
  if not self.ignoreFinalizer:
    gtk_expression_watch_unref(cast[ptr ExpressionWatch00](self.impl))

proc gtk_expression_watch_ref(self: ptr ExpressionWatch00): ptr ExpressionWatch00 {.
    importc, libprag.}

proc `ref`*(self: ExpressionWatch): ExpressionWatch =
  fnew(result, gBoxedFreeGtkExpressionWatch)
  result.impl = gtk_expression_watch_ref(cast[ptr ExpressionWatch00](self.impl))

proc gtk_expression_watch_evaluate(self: ptr ExpressionWatch00; value: gobject.Value): gboolean {.
    importc, libprag.}

proc evaluate*(self: ExpressionWatch; value: gobject.Value): bool =
  toBool(gtk_expression_watch_evaluate(cast[ptr ExpressionWatch00](self.impl), value))

proc gtk_expression_watch_unwatch(self: ptr ExpressionWatch00) {.
    importc, libprag.}

proc unwatch*(self: ExpressionWatch) =
  gtk_expression_watch_unwatch(cast[ptr ExpressionWatch00](self.impl))

proc gtk_expression_bind(self: ptr Expression00; target: ptr gobject.Object00;
    property: cstring; this: ptr gobject.Object00): ptr ExpressionWatch00 {.
    importc, libprag.}

proc `bind`*(self: Expression; target: gobject.Object; property: cstring;
    this: gobject.Object = nil): ExpressionWatch =
  fnew(result, gBoxedFreeGtkExpressionWatch)
  result.impl = gtk_expression_bind(cast[ptr Expression00](gtk_expression_ref(self.impl)), cast[ptr gobject.Object00](target.impl), property, if this.isNil: nil else: cast[ptr gobject.Object00](this.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_expression_watch_get_type(), result.impl))

type
  ListItemFactory* = ref object of gobject.Object
  ListItemFactory00* = object of gobject.Object00

proc gtk_list_item_factory_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListItemFactory()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_drop_down_get_factory(self: ptr DropDown00): ptr ListItemFactory00 {.
    importc, libprag.}

proc getFactory*(self: DropDown): ListItemFactory =
  let gobj = gtk_drop_down_get_factory(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc factory*(self: DropDown): ListItemFactory =
  let gobj = gtk_drop_down_get_factory(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_down_get_header_factory(self: ptr DropDown00): ptr ListItemFactory00 {.
    importc, libprag.}

proc getHeaderFactory*(self: DropDown): ListItemFactory =
  let gobj = gtk_drop_down_get_header_factory(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc headerFactory*(self: DropDown): ListItemFactory =
  let gobj = gtk_drop_down_get_header_factory(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_down_get_list_factory(self: ptr DropDown00): ptr ListItemFactory00 {.
    importc, libprag.}

proc getListFactory*(self: DropDown): ListItemFactory =
  let gobj = gtk_drop_down_get_list_factory(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc listFactory*(self: DropDown): ListItemFactory =
  let gobj = gtk_drop_down_get_list_factory(cast[ptr DropDown00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_down_set_factory(self: ptr DropDown00; factory: ptr ListItemFactory00) {.
    importc, libprag.}

proc setFactory*(self: DropDown; factory: ListItemFactory = nil) =
  gtk_drop_down_set_factory(cast[ptr DropDown00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc `factory=`*(self: DropDown; factory: ListItemFactory = nil) =
  gtk_drop_down_set_factory(cast[ptr DropDown00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc gtk_drop_down_set_header_factory(self: ptr DropDown00; factory: ptr ListItemFactory00) {.
    importc, libprag.}

proc setHeaderFactory*(self: DropDown; factory: ListItemFactory = nil) =
  gtk_drop_down_set_header_factory(cast[ptr DropDown00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc `headerFactory=`*(self: DropDown; factory: ListItemFactory = nil) =
  gtk_drop_down_set_header_factory(cast[ptr DropDown00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc gtk_drop_down_set_list_factory(self: ptr DropDown00; factory: ptr ListItemFactory00) {.
    importc, libprag.}

proc setListFactory*(self: DropDown; factory: ListItemFactory = nil) =
  gtk_drop_down_set_list_factory(cast[ptr DropDown00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc `listFactory=`*(self: DropDown; factory: ListItemFactory = nil) =
  gtk_drop_down_set_list_factory(cast[ptr DropDown00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc gtk_grid_view_new(model: ptr SelectionModel00; factory: ptr ListItemFactory00): ptr GridView00 {.
    importc, libprag.}

proc newGridView*(model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil);
    factory: ListItemFactory = nil): GridView =
  let gobj = gtk_grid_view_new(if model.isNil: nil else: cast[ptr SelectionModel00](g_object_ref(model.impl)), if factory.isNil: nil else: cast[ptr ListItemFactory00](g_object_ref(factory.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGridView*(tdesc: typedesc; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil);
    factory: ListItemFactory = nil): tdesc =
  assert(result is GridView)
  let gobj = gtk_grid_view_new(if model.isNil: nil else: cast[ptr SelectionModel00](g_object_ref(model.impl)), if factory.isNil: nil else: cast[ptr ListItemFactory00](g_object_ref(factory.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGridView*[T](result: var T; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil);
    factory: ListItemFactory = nil) {.deprecated.} =
  assert(result is GridView)
  let gobj = gtk_grid_view_new(if model.isNil: nil else: cast[ptr SelectionModel00](g_object_ref(model.impl)), if factory.isNil: nil else: cast[ptr ListItemFactory00](g_object_ref(factory.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_view_get_factory(self: ptr GridView00): ptr ListItemFactory00 {.
    importc, libprag.}

proc getFactory*(self: GridView): ListItemFactory =
  let gobj = gtk_grid_view_get_factory(cast[ptr GridView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc factory*(self: GridView): ListItemFactory =
  let gobj = gtk_grid_view_get_factory(cast[ptr GridView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_view_set_factory(self: ptr GridView00; factory: ptr ListItemFactory00) {.
    importc, libprag.}

proc setFactory*(self: GridView; factory: ListItemFactory = nil) =
  gtk_grid_view_set_factory(cast[ptr GridView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc `factory=`*(self: GridView; factory: ListItemFactory = nil) =
  gtk_grid_view_set_factory(cast[ptr GridView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc gtk_column_view_get_header_factory(self: ptr ColumnView00): ptr ListItemFactory00 {.
    importc, libprag.}

proc getHeaderFactory*(self: ColumnView): ListItemFactory =
  let gobj = gtk_column_view_get_header_factory(cast[ptr ColumnView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc headerFactory*(self: ColumnView): ListItemFactory =
  let gobj = gtk_column_view_get_header_factory(cast[ptr ColumnView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_get_row_factory(self: ptr ColumnView00): ptr ListItemFactory00 {.
    importc, libprag.}

proc getRowFactory*(self: ColumnView): ListItemFactory =
  let gobj = gtk_column_view_get_row_factory(cast[ptr ColumnView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc rowFactory*(self: ColumnView): ListItemFactory =
  let gobj = gtk_column_view_get_row_factory(cast[ptr ColumnView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_set_header_factory(self: ptr ColumnView00; factory: ptr ListItemFactory00) {.
    importc, libprag.}

proc setHeaderFactory*(self: ColumnView; factory: ListItemFactory = nil) =
  gtk_column_view_set_header_factory(cast[ptr ColumnView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc `headerFactory=`*(self: ColumnView; factory: ListItemFactory = nil) =
  gtk_column_view_set_header_factory(cast[ptr ColumnView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc gtk_column_view_set_row_factory(self: ptr ColumnView00; factory: ptr ListItemFactory00) {.
    importc, libprag.}

proc setRowFactory*(self: ColumnView; factory: ListItemFactory = nil) =
  gtk_column_view_set_row_factory(cast[ptr ColumnView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc `rowFactory=`*(self: ColumnView; factory: ListItemFactory = nil) =
  gtk_column_view_set_row_factory(cast[ptr ColumnView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc gtk_list_view_new(model: ptr SelectionModel00; factory: ptr ListItemFactory00): ptr ListView00 {.
    importc, libprag.}

proc newListView*(model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil);
    factory: ListItemFactory = nil): ListView =
  let gobj = gtk_list_view_new(if model.isNil: nil else: cast[ptr SelectionModel00](g_object_ref(model.impl)), if factory.isNil: nil else: cast[ptr ListItemFactory00](g_object_ref(factory.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newListView*(tdesc: typedesc; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil);
    factory: ListItemFactory = nil): tdesc =
  assert(result is ListView)
  let gobj = gtk_list_view_new(if model.isNil: nil else: cast[ptr SelectionModel00](g_object_ref(model.impl)), if factory.isNil: nil else: cast[ptr ListItemFactory00](g_object_ref(factory.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListView*[T](result: var T; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil);
    factory: ListItemFactory = nil) {.deprecated.} =
  assert(result is ListView)
  let gobj = gtk_list_view_new(if model.isNil: nil else: cast[ptr SelectionModel00](g_object_ref(model.impl)), if factory.isNil: nil else: cast[ptr ListItemFactory00](g_object_ref(factory.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_view_get_factory(self: ptr ListView00): ptr ListItemFactory00 {.
    importc, libprag.}

proc getFactory*(self: ListView): ListItemFactory =
  let gobj = gtk_list_view_get_factory(cast[ptr ListView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc factory*(self: ListView): ListItemFactory =
  let gobj = gtk_list_view_get_factory(cast[ptr ListView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_view_get_header_factory(self: ptr ListView00): ptr ListItemFactory00 {.
    importc, libprag.}

proc getHeaderFactory*(self: ListView): ListItemFactory =
  let gobj = gtk_list_view_get_header_factory(cast[ptr ListView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc headerFactory*(self: ListView): ListItemFactory =
  let gobj = gtk_list_view_get_header_factory(cast[ptr ListView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_view_set_factory(self: ptr ListView00; factory: ptr ListItemFactory00) {.
    importc, libprag.}

proc setFactory*(self: ListView; factory: ListItemFactory = nil) =
  gtk_list_view_set_factory(cast[ptr ListView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc `factory=`*(self: ListView; factory: ListItemFactory = nil) =
  gtk_list_view_set_factory(cast[ptr ListView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc gtk_list_view_set_header_factory(self: ptr ListView00; factory: ptr ListItemFactory00) {.
    importc, libprag.}

proc setHeaderFactory*(self: ListView; factory: ListItemFactory = nil) =
  gtk_list_view_set_header_factory(cast[ptr ListView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc `headerFactory=`*(self: ListView; factory: ListItemFactory = nil) =
  gtk_list_view_set_header_factory(cast[ptr ListView00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc gtk_column_view_column_new(title: cstring; factory: ptr ListItemFactory00): ptr ColumnViewColumn00 {.
    importc, libprag.}

proc newColumnViewColumn*(title: cstring = nil; factory: ListItemFactory = nil): ColumnViewColumn =
  let gobj = gtk_column_view_column_new(title, if factory.isNil: nil else: cast[ptr ListItemFactory00](g_object_ref(factory.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColumnViewColumn*(tdesc: typedesc; title: cstring = nil; factory: ListItemFactory = nil): tdesc =
  assert(result is ColumnViewColumn)
  let gobj = gtk_column_view_column_new(title, if factory.isNil: nil else: cast[ptr ListItemFactory00](g_object_ref(factory.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColumnViewColumn*[T](result: var T; title: cstring = nil; factory: ListItemFactory = nil) {.deprecated.} =
  assert(result is ColumnViewColumn)
  let gobj = gtk_column_view_column_new(title, if factory.isNil: nil else: cast[ptr ListItemFactory00](g_object_ref(factory.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_column_get_factory(self: ptr ColumnViewColumn00): ptr ListItemFactory00 {.
    importc, libprag.}

proc getFactory*(self: ColumnViewColumn): ListItemFactory =
  let gobj = gtk_column_view_column_get_factory(cast[ptr ColumnViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc factory*(self: ColumnViewColumn): ListItemFactory =
  let gobj = gtk_column_view_column_get_factory(cast[ptr ColumnViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_column_set_factory(self: ptr ColumnViewColumn00; factory: ptr ListItemFactory00) {.
    importc, libprag.}

proc setFactory*(self: ColumnViewColumn; factory: ListItemFactory = nil) =
  gtk_column_view_column_set_factory(cast[ptr ColumnViewColumn00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

proc `factory=`*(self: ColumnViewColumn; factory: ListItemFactory = nil) =
  gtk_column_view_column_set_factory(cast[ptr ColumnViewColumn00](self.impl), if factory.isNil: nil else: cast[ptr ListItemFactory00](factory.impl))

type
  StringFilterMatchMode* {.size: sizeof(cint), pure.} = enum
    exact = 0
    substring = 1
    prefix = 2

proc gtk_drop_down_get_search_match_mode(self: ptr DropDown00): StringFilterMatchMode {.
    importc, libprag.}

proc getSearchMatchMode*(self: DropDown): StringFilterMatchMode =
  gtk_drop_down_get_search_match_mode(cast[ptr DropDown00](self.impl))

proc searchMatchMode*(self: DropDown): StringFilterMatchMode =
  gtk_drop_down_get_search_match_mode(cast[ptr DropDown00](self.impl))

proc gtk_drop_down_set_search_match_mode(self: ptr DropDown00; searchMatchMode: StringFilterMatchMode) {.
    importc, libprag.}

proc setSearchMatchMode*(self: DropDown; searchMatchMode: StringFilterMatchMode) =
  gtk_drop_down_set_search_match_mode(cast[ptr DropDown00](self.impl), searchMatchMode)

proc `searchMatchMode=`*(self: DropDown; searchMatchMode: StringFilterMatchMode) =
  gtk_drop_down_set_search_match_mode(cast[ptr DropDown00](self.impl), searchMatchMode)

type
  FileChooserAction* {.size: sizeof(cint), pure.} = enum
    open = 0
    save = 1
    selectFolder = 2

proc gtk_file_chooser_widget_new(action: FileChooserAction): ptr FileChooserWidget00 {.
    importc, libprag.}

proc newFileChooserWidget*(action: FileChooserAction): FileChooserWidget {.deprecated.}  =
  let gobj = gtk_file_chooser_widget_new(action)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileChooserWidget*(tdesc: typedesc; action: FileChooserAction): tdesc {.deprecated.}  =
  assert(result is FileChooserWidget)
  let gobj = gtk_file_chooser_widget_new(action)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserWidget*[T](result: var T; action: FileChooserAction) {.deprecated.} =
  assert(result is FileChooserWidget)
  let gobj = gtk_file_chooser_widget_new(action)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  InputHintsFlag* {.size: sizeof(cint), pure.} = enum
    spellcheck = 0
    noSpellcheck = 1
    wordCompletion = 2
    lowercase = 3
    uppercaseChars = 4
    uppercaseWords = 5
    uppercaseSentences = 6
    inhibitOsk = 7
    verticalWriting = 8
    emoji = 9
    noEmoji = 10
    private = 11

  InputHints* = set[InputHintsFlag]

const
  InputHintsNone* = InputHints({})
proc none*(t: typedesc[InputHints]): InputHints = InputHints({})

proc gtk_text_view_get_input_hints(self: ptr TextView00): InputHints {.
    importc, libprag.}

proc getInputHints*(self: TextView): InputHints =
  gtk_text_view_get_input_hints(cast[ptr TextView00](self.impl))

proc inputHints*(self: TextView): InputHints =
  gtk_text_view_get_input_hints(cast[ptr TextView00](self.impl))

proc gtk_text_view_set_input_hints(self: ptr TextView00; hints: InputHints) {.
    importc, libprag.}

proc setInputHints*(self: TextView; hints: InputHints) =
  gtk_text_view_set_input_hints(cast[ptr TextView00](self.impl), hints)

proc `inputHints=`*(self: TextView; hints: InputHints) =
  gtk_text_view_set_input_hints(cast[ptr TextView00](self.impl), hints)

proc gtk_entry_get_input_hints(self: ptr Entry00): InputHints {.
    importc, libprag.}

proc getInputHints*(self: Entry): InputHints =
  gtk_entry_get_input_hints(cast[ptr Entry00](self.impl))

proc inputHints*(self: Entry): InputHints =
  gtk_entry_get_input_hints(cast[ptr Entry00](self.impl))

proc gtk_entry_set_input_hints(self: ptr Entry00; hints: InputHints) {.
    importc, libprag.}

proc setInputHints*(self: Entry; hints: InputHints) =
  gtk_entry_set_input_hints(cast[ptr Entry00](self.impl), hints)

proc `inputHints=`*(self: Entry; hints: InputHints) =
  gtk_entry_set_input_hints(cast[ptr Entry00](self.impl), hints)

proc gtk_text_get_input_hints(self: ptr Text00): InputHints {.
    importc, libprag.}

proc getInputHints*(self: Text): InputHints =
  gtk_text_get_input_hints(cast[ptr Text00](self.impl))

proc inputHints*(self: Text): InputHints =
  gtk_text_get_input_hints(cast[ptr Text00](self.impl))

proc gtk_text_set_input_hints(self: ptr Text00; hints: InputHints) {.
    importc, libprag.}

proc setInputHints*(self: Text; hints: InputHints) =
  gtk_text_set_input_hints(cast[ptr Text00](self.impl), hints)

proc `inputHints=`*(self: Text; hints: InputHints) =
  gtk_text_set_input_hints(cast[ptr Text00](self.impl), hints)

proc gtk_search_entry_get_input_hints(self: ptr SearchEntry00): InputHints {.
    importc, libprag.}

proc getInputHints*(self: SearchEntry): InputHints =
  gtk_search_entry_get_input_hints(cast[ptr SearchEntry00](self.impl))

proc inputHints*(self: SearchEntry): InputHints =
  gtk_search_entry_get_input_hints(cast[ptr SearchEntry00](self.impl))

proc gtk_search_entry_set_input_hints(self: ptr SearchEntry00; hints: InputHints) {.
    importc, libprag.}

proc setInputHints*(self: SearchEntry; hints: InputHints) =
  gtk_search_entry_set_input_hints(cast[ptr SearchEntry00](self.impl), hints)

proc `inputHints=`*(self: SearchEntry; hints: InputHints) =
  gtk_search_entry_set_input_hints(cast[ptr SearchEntry00](self.impl), hints)

type
  InputPurpose* {.size: sizeof(cint), pure.} = enum
    freeForm = 0
    alpha = 1
    digits = 2
    number = 3
    phone = 4
    url = 5
    email = 6
    name = 7
    password = 8
    pin = 9
    terminal = 10

proc gtk_text_view_get_input_purpose(self: ptr TextView00): InputPurpose {.
    importc, libprag.}

proc getInputPurpose*(self: TextView): InputPurpose =
  gtk_text_view_get_input_purpose(cast[ptr TextView00](self.impl))

proc inputPurpose*(self: TextView): InputPurpose =
  gtk_text_view_get_input_purpose(cast[ptr TextView00](self.impl))

proc gtk_text_view_set_input_purpose(self: ptr TextView00; purpose: InputPurpose) {.
    importc, libprag.}

proc setInputPurpose*(self: TextView; purpose: InputPurpose) =
  gtk_text_view_set_input_purpose(cast[ptr TextView00](self.impl), purpose)

proc `inputPurpose=`*(self: TextView; purpose: InputPurpose) =
  gtk_text_view_set_input_purpose(cast[ptr TextView00](self.impl), purpose)

proc gtk_entry_get_input_purpose(self: ptr Entry00): InputPurpose {.
    importc, libprag.}

proc getInputPurpose*(self: Entry): InputPurpose =
  gtk_entry_get_input_purpose(cast[ptr Entry00](self.impl))

proc inputPurpose*(self: Entry): InputPurpose =
  gtk_entry_get_input_purpose(cast[ptr Entry00](self.impl))

proc gtk_entry_set_input_purpose(self: ptr Entry00; purpose: InputPurpose) {.
    importc, libprag.}

proc setInputPurpose*(self: Entry; purpose: InputPurpose) =
  gtk_entry_set_input_purpose(cast[ptr Entry00](self.impl), purpose)

proc `inputPurpose=`*(self: Entry; purpose: InputPurpose) =
  gtk_entry_set_input_purpose(cast[ptr Entry00](self.impl), purpose)

proc gtk_text_get_input_purpose(self: ptr Text00): InputPurpose {.
    importc, libprag.}

proc getInputPurpose*(self: Text): InputPurpose =
  gtk_text_get_input_purpose(cast[ptr Text00](self.impl))

proc inputPurpose*(self: Text): InputPurpose =
  gtk_text_get_input_purpose(cast[ptr Text00](self.impl))

proc gtk_text_set_input_purpose(self: ptr Text00; purpose: InputPurpose) {.
    importc, libprag.}

proc setInputPurpose*(self: Text; purpose: InputPurpose) =
  gtk_text_set_input_purpose(cast[ptr Text00](self.impl), purpose)

proc `inputPurpose=`*(self: Text; purpose: InputPurpose) =
  gtk_text_set_input_purpose(cast[ptr Text00](self.impl), purpose)

proc gtk_search_entry_get_input_purpose(self: ptr SearchEntry00): InputPurpose {.
    importc, libprag.}

proc getInputPurpose*(self: SearchEntry): InputPurpose =
  gtk_search_entry_get_input_purpose(cast[ptr SearchEntry00](self.impl))

proc inputPurpose*(self: SearchEntry): InputPurpose =
  gtk_search_entry_get_input_purpose(cast[ptr SearchEntry00](self.impl))

proc gtk_search_entry_set_input_purpose(self: ptr SearchEntry00; purpose: InputPurpose) {.
    importc, libprag.}

proc setInputPurpose*(self: SearchEntry; purpose: InputPurpose) =
  gtk_search_entry_set_input_purpose(cast[ptr SearchEntry00](self.impl), purpose)

proc `inputPurpose=`*(self: SearchEntry; purpose: InputPurpose) =
  gtk_search_entry_set_input_purpose(cast[ptr SearchEntry00](self.impl), purpose)

type
  Justification* {.size: sizeof(cint), pure.} = enum
    left = 0
    right = 1
    center = 2
    fill = 3

proc gtk_text_view_get_justification(self: ptr TextView00): Justification {.
    importc, libprag.}

proc getJustification*(self: TextView): Justification =
  gtk_text_view_get_justification(cast[ptr TextView00](self.impl))

proc justification*(self: TextView): Justification =
  gtk_text_view_get_justification(cast[ptr TextView00](self.impl))

proc gtk_text_view_set_justification(self: ptr TextView00; justification: Justification) {.
    importc, libprag.}

proc setJustification*(self: TextView; justification: Justification) =
  gtk_text_view_set_justification(cast[ptr TextView00](self.impl), justification)

proc `justification=`*(self: TextView; justification: Justification) =
  gtk_text_view_set_justification(cast[ptr TextView00](self.impl), justification)

proc gtk_label_get_justify(self: ptr Label00): Justification {.
    importc, libprag.}

proc getJustify*(self: Label): Justification =
  gtk_label_get_justify(cast[ptr Label00](self.impl))

proc justify*(self: Label): Justification =
  gtk_label_get_justify(cast[ptr Label00](self.impl))

proc gtk_label_set_justify(self: ptr Label00; jtype: Justification) {.
    importc, libprag.}

proc setJustify*(self: Label; jtype: Justification) =
  gtk_label_set_justify(cast[ptr Label00](self.impl), jtype)

proc `justify=`*(self: Label; jtype: Justification) =
  gtk_label_set_justify(cast[ptr Label00](self.impl), jtype)

type
  WrapMode* {.size: sizeof(cint), pure.} = enum
    none = 0
    char = 1
    word = 2
    wordChar = 3

proc gtk_text_view_get_wrap_mode(self: ptr TextView00): WrapMode {.
    importc, libprag.}

proc getWrapMode*(self: TextView): WrapMode =
  gtk_text_view_get_wrap_mode(cast[ptr TextView00](self.impl))

proc wrapMode*(self: TextView): WrapMode =
  gtk_text_view_get_wrap_mode(cast[ptr TextView00](self.impl))

proc gtk_text_view_set_wrap_mode(self: ptr TextView00; wrapMode: WrapMode) {.
    importc, libprag.}

proc setWrapMode*(self: TextView; wrapMode: WrapMode) =
  gtk_text_view_set_wrap_mode(cast[ptr TextView00](self.impl), wrapMode)

proc `wrapMode=`*(self: TextView; wrapMode: WrapMode) =
  gtk_text_view_set_wrap_mode(cast[ptr TextView00](self.impl), wrapMode)

type
  TextWindowType* {.size: sizeof(cint), pure.} = enum
    widget = 1
    text = 2
    left = 3
    right = 4
    top = 5
    bottom = 6

proc gtk_text_view_buffer_to_window_coords(self: ptr TextView00; win: TextWindowType;
    bufferX: int32; bufferY: int32; windowX: var int32; windowY: var int32) {.
    importc, libprag.}

proc bufferToWindowCoords*(self: TextView; win: TextWindowType;
    bufferX: int; bufferY: int; windowX: var int = cast[var int](nil); windowY: var int = cast[var int](nil)) =
  var windowX_00: int32
  var windowY_00: int32
  gtk_text_view_buffer_to_window_coords(cast[ptr TextView00](self.impl), win, int32(bufferX), int32(bufferY), windowX_00, windowY_00)
  if windowX.addr != nil:
    windowX = int(windowX_00)
  if windowY.addr != nil:
    windowY = int(windowY_00)

proc gtk_text_view_get_gutter(self: ptr TextView00; win: TextWindowType): ptr Widget00 {.
    importc, libprag.}

proc getGutter*(self: TextView; win: TextWindowType): Widget =
  let gobj = gtk_text_view_get_gutter(cast[ptr TextView00](self.impl), win)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_set_gutter(self: ptr TextView00; win: TextWindowType;
    widget: ptr Widget00) {.
    importc, libprag.}

proc setGutter*(self: TextView; win: TextWindowType; widget: Widget = nil) =
  gtk_text_view_set_gutter(cast[ptr TextView00](self.impl), win, if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_text_view_window_to_buffer_coords(self: ptr TextView00; win: TextWindowType;
    windowX: int32; windowY: int32; bufferX: var int32; bufferY: var int32) {.
    importc, libprag.}

proc windowToBufferCoords*(self: TextView; win: TextWindowType;
    windowX: int; windowY: int; bufferX: var int = cast[var int](nil); bufferY: var int = cast[var int](nil)) =
  var bufferY_00: int32
  var bufferX_00: int32
  gtk_text_view_window_to_buffer_coords(cast[ptr TextView00](self.impl), win, int32(windowX), int32(windowY), bufferX_00, bufferY_00)
  if bufferY.addr != nil:
    bufferY = int(bufferY_00)
  if bufferX.addr != nil:
    bufferX = int(bufferX_00)

type
  TextSearchFlag* {.size: sizeof(cint), pure.} = enum
    visibleOnly = 0
    textOnly = 1
    caseInsensitive = 2

  TextSearchFlags* = set[TextSearchFlag]

proc gtk_text_iter_backward_search(self: TextIter; str: cstring; flags: TextSearchFlags;
    matchStart: var TextIter; matchEnd: var TextIter; limit: TextIter): gboolean {.
    importc, libprag.}

proc backwardSearch*(self: TextIter; str: cstring; flags: TextSearchFlags;
    matchStart: var TextIter = cast[var TextIter](nil); matchEnd: var TextIter = cast[var TextIter](nil);
    limit: TextIter = cast[var TextIter](nil)): bool =
  toBool(gtk_text_iter_backward_search(self, str, flags, matchStart, matchEnd, limit))

proc gtk_text_iter_forward_search(self: TextIter; str: cstring; flags: TextSearchFlags;
    matchStart: var TextIter; matchEnd: var TextIter; limit: TextIter): gboolean {.
    importc, libprag.}

proc forwardSearch*(self: TextIter; str: cstring; flags: TextSearchFlags;
    matchStart: var TextIter = cast[var TextIter](nil); matchEnd: var TextIter = cast[var TextIter](nil);
    limit: TextIter = cast[var TextIter](nil)): bool =
  toBool(gtk_text_iter_forward_search(self, str, flags, matchStart, matchEnd, limit))

type
  TextChildAnchor* = ref object of gobject.Object
  TextChildAnchor00* = object of gobject.Object00

proc gtk_text_child_anchor_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextChildAnchor()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_text_child_anchor_new(): ptr TextChildAnchor00 {.
    importc, libprag.}

proc newTextChildAnchor*(): TextChildAnchor =
  let gobj = gtk_text_child_anchor_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextChildAnchor*(tdesc: typedesc): tdesc =
  assert(result is TextChildAnchor)
  let gobj = gtk_text_child_anchor_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextChildAnchor*[T](result: var T) {.deprecated.} =
  assert(result is TextChildAnchor)
  let gobj = gtk_text_child_anchor_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_child_anchor_new_with_replacement(character: cstring): ptr TextChildAnchor00 {.
    importc, libprag.}

proc newTextChildAnchorWithReplacement*(character: cstring): TextChildAnchor =
  let gobj = gtk_text_child_anchor_new_with_replacement(character)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextChildAnchorWithReplacement*(tdesc: typedesc; character: cstring): tdesc =
  assert(result is TextChildAnchor)
  let gobj = gtk_text_child_anchor_new_with_replacement(character)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextChildAnchorWithReplacement*[T](result: var T; character: cstring) {.deprecated.} =
  assert(result is TextChildAnchor)
  let gobj = gtk_text_child_anchor_new_with_replacement(character)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_child_anchor_get_deleted(self: ptr TextChildAnchor00): gboolean {.
    importc, libprag.}

proc getDeleted*(self: TextChildAnchor): bool =
  toBool(gtk_text_child_anchor_get_deleted(cast[ptr TextChildAnchor00](self.impl)))

proc deleted*(self: TextChildAnchor): bool =
  toBool(gtk_text_child_anchor_get_deleted(cast[ptr TextChildAnchor00](self.impl)))

proc gtk_text_child_anchor_get_widgets(self: ptr TextChildAnchor00; outLen: var uint32): ptr ptr Widget00 {.
    importc, libprag.}

proc getWidgets*(self: TextChildAnchor; outLen: var int): ptr ptr Widget00 =
  var outLen_00: uint32
  result = gtk_text_child_anchor_get_widgets(cast[ptr TextChildAnchor00](self.impl), outLen_00)
  if outLen.addr != nil:
    outLen = int(outLen_00)

proc gtk_text_iter_get_child_anchor(self: TextIter): ptr TextChildAnchor00 {.
    importc, libprag.}

proc getChildAnchor*(self: TextIter): TextChildAnchor =
  let gobj = gtk_text_iter_get_child_anchor(self)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc childAnchor*(self: TextIter): TextChildAnchor =
  let gobj = gtk_text_iter_get_child_anchor(self)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_add_child_at_anchor(self: ptr TextView00; child: ptr Widget00;
    anchor: ptr TextChildAnchor00) {.
    importc, libprag.}

proc addChildAtAnchor*(self: TextView; child: Widget; anchor: TextChildAnchor) =
  gtk_text_view_add_child_at_anchor(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl), cast[ptr TextChildAnchor00](anchor.impl))

type
  TextMark* = ref object of gobject.Object
  TextMark00* = object of gobject.Object00

proc gtk_text_mark_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextMark()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_text_mark_new(name: cstring; leftGravity: gboolean): ptr TextMark00 {.
    importc, libprag.}

proc newTextMark*(name: cstring = nil; leftGravity: bool): TextMark =
  let gobj = gtk_text_mark_new(name, gboolean(leftGravity))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextMark*(tdesc: typedesc; name: cstring = nil; leftGravity: bool): tdesc =
  assert(result is TextMark)
  let gobj = gtk_text_mark_new(name, gboolean(leftGravity))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextMark*[T](result: var T; name: cstring = nil; leftGravity: bool) {.deprecated.} =
  assert(result is TextMark)
  let gobj = gtk_text_mark_new(name, gboolean(leftGravity))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_mark_get_deleted(self: ptr TextMark00): gboolean {.
    importc, libprag.}

proc getDeleted*(self: TextMark): bool =
  toBool(gtk_text_mark_get_deleted(cast[ptr TextMark00](self.impl)))

proc deleted*(self: TextMark): bool =
  toBool(gtk_text_mark_get_deleted(cast[ptr TextMark00](self.impl)))

proc gtk_text_mark_get_left_gravity(self: ptr TextMark00): gboolean {.
    importc, libprag.}

proc getLeftGravity*(self: TextMark): bool =
  toBool(gtk_text_mark_get_left_gravity(cast[ptr TextMark00](self.impl)))

proc leftGravity*(self: TextMark): bool =
  toBool(gtk_text_mark_get_left_gravity(cast[ptr TextMark00](self.impl)))

proc gtk_text_mark_get_name(self: ptr TextMark00): cstring {.
    importc, libprag.}

proc getName*(self: TextMark): string =
  let resul0 = gtk_text_mark_get_name(cast[ptr TextMark00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc name*(self: TextMark): string =
  let resul0 = gtk_text_mark_get_name(cast[ptr TextMark00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_text_mark_get_visible(self: ptr TextMark00): gboolean {.
    importc, libprag.}

proc getVisible*(self: TextMark): bool =
  toBool(gtk_text_mark_get_visible(cast[ptr TextMark00](self.impl)))

proc visible*(self: TextMark): bool =
  toBool(gtk_text_mark_get_visible(cast[ptr TextMark00](self.impl)))

proc gtk_text_mark_set_visible(self: ptr TextMark00; setting: gboolean) {.
    importc, libprag.}

proc setVisible*(self: TextMark; setting: bool = true) =
  gtk_text_mark_set_visible(cast[ptr TextMark00](self.impl), gboolean(setting))

proc `visible=`*(self: TextMark; setting: bool) =
  gtk_text_mark_set_visible(cast[ptr TextMark00](self.impl), gboolean(setting))

proc gtk_text_iter_get_marks(self: TextIter): ptr glib.SList {.
    importc, libprag.}

proc getMarks*(self: TextIter): seq[TextMark] =
  let resul0 = gtk_text_iter_get_marks(self)
  result = gslistObjects2seq(TextMark, resul0, false)
  g_slist_free(resul0)

proc marks*(self: TextIter): seq[TextMark] =
  let resul0 = gtk_text_iter_get_marks(self)
  result = gslistObjects2seq(TextMark, resul0, false)
  g_slist_free(resul0)

proc gtk_text_view_move_mark_onscreen(self: ptr TextView00; mark: ptr TextMark00): gboolean {.
    importc, libprag.}

proc moveMarkOnscreen*(self: TextView; mark: TextMark): bool =
  toBool(gtk_text_view_move_mark_onscreen(cast[ptr TextView00](self.impl), cast[ptr TextMark00](mark.impl)))

proc gtk_text_view_scroll_mark_onscreen(self: ptr TextView00; mark: ptr TextMark00) {.
    importc, libprag.}

proc scrollMarkOnscreen*(self: TextView; mark: TextMark) =
  gtk_text_view_scroll_mark_onscreen(cast[ptr TextView00](self.impl), cast[ptr TextMark00](mark.impl))

proc gtk_text_view_scroll_to_mark(self: ptr TextView00; mark: ptr TextMark00;
    withinMargin: cdouble; useAlign: gboolean; xalign: cdouble; yalign: cdouble) {.
    importc, libprag.}

proc scrollToMark*(self: TextView; mark: TextMark; withinMargin: cdouble;
    useAlign: bool; xalign: cdouble; yalign: cdouble) =
  gtk_text_view_scroll_to_mark(cast[ptr TextView00](self.impl), cast[ptr TextMark00](mark.impl), withinMargin, gboolean(useAlign), xalign, yalign)

type
  TextTag* = ref object of gobject.Object
  TextTag00* = object of gobject.Object00

proc gtk_text_tag_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextTag()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_text_tag_new(name: cstring): ptr TextTag00 {.
    importc, libprag.}

proc newTextTag*(name: cstring = nil): TextTag =
  let gobj = gtk_text_tag_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextTag*(tdesc: typedesc; name: cstring = nil): tdesc =
  assert(result is TextTag)
  let gobj = gtk_text_tag_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextTag*[T](result: var T; name: cstring = nil) {.deprecated.} =
  assert(result is TextTag)
  let gobj = gtk_text_tag_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_tag_changed(self: ptr TextTag00; sizeChanged: gboolean) {.
    importc, libprag.}

proc changed*(self: TextTag; sizeChanged: bool) =
  gtk_text_tag_changed(cast[ptr TextTag00](self.impl), gboolean(sizeChanged))

proc gtk_text_tag_get_priority(self: ptr TextTag00): int32 {.
    importc, libprag.}

proc getPriority*(self: TextTag): int =
  int(gtk_text_tag_get_priority(cast[ptr TextTag00](self.impl)))

proc priority*(self: TextTag): int =
  int(gtk_text_tag_get_priority(cast[ptr TextTag00](self.impl)))

proc gtk_text_tag_set_priority(self: ptr TextTag00; priority: int32) {.
    importc, libprag.}

proc setPriority*(self: TextTag; priority: int) =
  gtk_text_tag_set_priority(cast[ptr TextTag00](self.impl), int32(priority))

proc `priority=`*(self: TextTag; priority: int) =
  gtk_text_tag_set_priority(cast[ptr TextTag00](self.impl), int32(priority))

type
  TextBuffer* = ref object of gobject.Object
  TextBuffer00* = object of gobject.Object00

proc gtk_text_buffer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextBuffer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scApplyTag*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; tag: ptr TextTag00; start: TextIter; `end`: TextIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "apply-tag", cast[GCallback](p), xdata, nil, cf)

proc scBeginUserAction*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "begin-user-action", cast[GCallback](p), xdata, nil, cf)

proc scChanged*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scDeleteRange*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; start: TextIter; `end`: TextIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-range", cast[GCallback](p), xdata, nil, cf)

proc scEndUserAction*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "end-user-action", cast[GCallback](p), xdata, nil, cf)

proc scInsertChildAnchor*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; location: TextIter; anchor: ptr TextChildAnchor00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-child-anchor", cast[GCallback](p), xdata, nil, cf)

proc scInsertPaintable*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; location: TextIter; paintable: ptr gdk4.Paintable00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-paintable", cast[GCallback](p), xdata, nil, cf)

proc scInsertText*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; location: TextIter; text: cstring; len: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-text", cast[GCallback](p), xdata, nil, cf)

proc scMarkDeleted*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; mark: ptr TextMark00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "mark-deleted", cast[GCallback](p), xdata, nil, cf)

proc scMarkSet*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; location: TextIter; mark: ptr TextMark00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "mark-set", cast[GCallback](p), xdata, nil, cf)

proc scModifiedChanged*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "modified-changed", cast[GCallback](p), xdata, nil, cf)

proc scPasteDone*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; clipboard: ptr gdk4.Clipboard00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "paste-done", cast[GCallback](p), xdata, nil, cf)

proc scRedo*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "redo", cast[GCallback](p), xdata, nil, cf)

proc scRemoveTag*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; tag: ptr TextTag00; start: TextIter; `end`: TextIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "remove-tag", cast[GCallback](p), xdata, nil, cf)

proc scUndo*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "undo", cast[GCallback](p), xdata, nil, cf)

proc gtk_text_buffer_add_mark(self: ptr TextBuffer00; mark: ptr TextMark00;
    where: TextIter) {.
    importc, libprag.}

proc addMark*(self: TextBuffer; mark: TextMark; where: TextIter) =
  gtk_text_buffer_add_mark(cast[ptr TextBuffer00](self.impl), cast[ptr TextMark00](mark.impl), where)

proc gtk_text_buffer_add_selection_clipboard(self: ptr TextBuffer00; clipboard: ptr gdk4.Clipboard00) {.
    importc, libprag.}

proc addSelectionClipboard*(self: TextBuffer; clipboard: gdk4.Clipboard) =
  gtk_text_buffer_add_selection_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr gdk4.Clipboard00](clipboard.impl))

proc gtk_text_buffer_apply_tag(self: ptr TextBuffer00; tag: ptr TextTag00;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc applyTag*(self: TextBuffer; tag: TextTag; start: TextIter;
    `end`: TextIter) =
  gtk_text_buffer_apply_tag(cast[ptr TextBuffer00](self.impl), cast[ptr TextTag00](tag.impl), start, `end`)

proc gtk_text_buffer_apply_tag_by_name(self: ptr TextBuffer00; name: cstring;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc applyTagByName*(self: TextBuffer; name: cstring; start: TextIter;
    `end`: TextIter) =
  gtk_text_buffer_apply_tag_by_name(cast[ptr TextBuffer00](self.impl), name, start, `end`)

proc gtk_text_buffer_backspace(self: ptr TextBuffer00; iter: TextIter; interactive: gboolean;
    defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc backspace*(self: TextBuffer; iter: TextIter; interactive: bool;
    defaultEditable: bool): bool =
  toBool(gtk_text_buffer_backspace(cast[ptr TextBuffer00](self.impl), iter, gboolean(interactive), gboolean(defaultEditable)))

proc gtk_text_buffer_begin_irreversible_action(self: ptr TextBuffer00) {.
    importc, libprag.}

proc beginIrreversibleAction*(self: TextBuffer) =
  gtk_text_buffer_begin_irreversible_action(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_begin_user_action(self: ptr TextBuffer00) {.
    importc, libprag.}

proc beginUserAction*(self: TextBuffer) =
  gtk_text_buffer_begin_user_action(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_copy_clipboard(self: ptr TextBuffer00; clipboard: ptr gdk4.Clipboard00) {.
    importc, libprag.}

proc copyClipboard*(self: TextBuffer; clipboard: gdk4.Clipboard) =
  gtk_text_buffer_copy_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr gdk4.Clipboard00](clipboard.impl))

proc gtk_text_buffer_create_child_anchor(self: ptr TextBuffer00; iter: TextIter): ptr TextChildAnchor00 {.
    importc, libprag.}

proc createChildAnchor*(self: TextBuffer; iter: TextIter): TextChildAnchor =
  let gobj = gtk_text_buffer_create_child_anchor(cast[ptr TextBuffer00](self.impl), iter)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_create_mark(self: ptr TextBuffer00; markName: cstring;
    where: TextIter; leftGravity: gboolean): ptr TextMark00 {.
    importc, libprag.}

proc createMark*(self: TextBuffer; markName: cstring = nil;
    where: TextIter; leftGravity: bool): TextMark =
  let gobj = gtk_text_buffer_create_mark(cast[ptr TextBuffer00](self.impl), markName, where, gboolean(leftGravity))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_cut_clipboard(self: ptr TextBuffer00; clipboard: ptr gdk4.Clipboard00;
    defaultEditable: gboolean) {.
    importc, libprag.}

proc cutClipboard*(self: TextBuffer; clipboard: gdk4.Clipboard;
    defaultEditable: bool) =
  gtk_text_buffer_cut_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr gdk4.Clipboard00](clipboard.impl), gboolean(defaultEditable))

proc gtk_text_buffer_delete(self: ptr TextBuffer00; start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc delete*(self: TextBuffer; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_delete(cast[ptr TextBuffer00](self.impl), start, `end`)

proc gtk_text_buffer_delete_interactive(self: ptr TextBuffer00; startIter: TextIter;
    endIter: TextIter; defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc deleteInteractive*(self: TextBuffer; startIter: TextIter;
    endIter: TextIter; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_delete_interactive(cast[ptr TextBuffer00](self.impl), startIter, endIter, gboolean(defaultEditable)))

proc gtk_text_buffer_delete_mark(self: ptr TextBuffer00; mark: ptr TextMark00) {.
    importc, libprag.}

proc deleteMark*(self: TextBuffer; mark: TextMark) =
  gtk_text_buffer_delete_mark(cast[ptr TextBuffer00](self.impl), cast[ptr TextMark00](mark.impl))

proc gtk_text_buffer_delete_mark_by_name(self: ptr TextBuffer00; name: cstring) {.
    importc, libprag.}

proc deleteMarkByName*(self: TextBuffer; name: cstring) =
  gtk_text_buffer_delete_mark_by_name(cast[ptr TextBuffer00](self.impl), name)

proc gtk_text_buffer_delete_selection(self: ptr TextBuffer00; interactive: gboolean;
    defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc deleteSelection*(self: TextBuffer; interactive: bool;
    defaultEditable: bool): bool =
  toBool(gtk_text_buffer_delete_selection(cast[ptr TextBuffer00](self.impl), gboolean(interactive), gboolean(defaultEditable)))

proc gtk_text_buffer_end_irreversible_action(self: ptr TextBuffer00) {.
    importc, libprag.}

proc endIrreversibleAction*(self: TextBuffer) =
  gtk_text_buffer_end_irreversible_action(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_end_user_action(self: ptr TextBuffer00) {.
    importc, libprag.}

proc endUserAction*(self: TextBuffer) =
  gtk_text_buffer_end_user_action(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_get_bounds(self: ptr TextBuffer00; start: var TextIter;
    `end`: var TextIter) {.
    importc, libprag.}

proc getBounds*(self: TextBuffer; start: var TextIter; `end`: var TextIter) =
  gtk_text_buffer_get_bounds(cast[ptr TextBuffer00](self.impl), start, `end`)

proc gtk_text_buffer_get_can_redo(self: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc getCanRedo*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_can_redo(cast[ptr TextBuffer00](self.impl)))

proc canRedo*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_can_redo(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_can_undo(self: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc getCanUndo*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_can_undo(cast[ptr TextBuffer00](self.impl)))

proc canUndo*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_can_undo(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_char_count(self: ptr TextBuffer00): int32 {.
    importc, libprag.}

proc getCharCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_char_count(cast[ptr TextBuffer00](self.impl)))

proc charCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_char_count(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_enable_undo(self: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc getEnableUndo*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_enable_undo(cast[ptr TextBuffer00](self.impl)))

proc enableUndo*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_enable_undo(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_end_iter(self: ptr TextBuffer00; iter: var TextIter) {.
    importc, libprag.}

proc getEndIter*(self: TextBuffer; iter: var TextIter) =
  gtk_text_buffer_get_end_iter(cast[ptr TextBuffer00](self.impl), iter)

proc getEndIter*(self: TextBuffer): TextIter =
  gtk_text_buffer_get_end_iter(cast[ptr TextBuffer00](self.impl), result)

proc gtk_text_buffer_get_has_selection(self: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc getHasSelection*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_has_selection(cast[ptr TextBuffer00](self.impl)))

proc hasSelection*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_has_selection(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_insert(self: ptr TextBuffer00): ptr TextMark00 {.
    importc, libprag.}

proc getInsert*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_insert(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc insert*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_insert(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_iter_at_child_anchor(self: ptr TextBuffer00; iter: var TextIter;
    anchor: ptr TextChildAnchor00) {.
    importc, libprag.}

proc getIterAtChildAnchor*(self: TextBuffer; iter: var TextIter;
    anchor: TextChildAnchor) =
  gtk_text_buffer_get_iter_at_child_anchor(cast[ptr TextBuffer00](self.impl), iter, cast[ptr TextChildAnchor00](anchor.impl))

proc gtk_text_buffer_get_iter_at_line(self: ptr TextBuffer00; iter: var TextIter;
    lineNumber: int32): gboolean {.
    importc, libprag.}

proc getIterAtLine*(self: TextBuffer; iter: var TextIter;
    lineNumber: int): bool =
  toBool(gtk_text_buffer_get_iter_at_line(cast[ptr TextBuffer00](self.impl), iter, int32(lineNumber)))

proc gtk_text_buffer_get_iter_at_line_index(self: ptr TextBuffer00; iter: var TextIter;
    lineNumber: int32; byteIndex: int32): gboolean {.
    importc, libprag.}

proc getIterAtLineIndex*(self: TextBuffer; iter: var TextIter;
    lineNumber: int; byteIndex: int): bool =
  toBool(gtk_text_buffer_get_iter_at_line_index(cast[ptr TextBuffer00](self.impl), iter, int32(lineNumber), int32(byteIndex)))

proc gtk_text_buffer_get_iter_at_line_offset(self: ptr TextBuffer00; iter: var TextIter;
    lineNumber: int32; charOffset: int32): gboolean {.
    importc, libprag.}

proc getIterAtLineOffset*(self: TextBuffer; iter: var TextIter;
    lineNumber: int; charOffset: int): bool =
  toBool(gtk_text_buffer_get_iter_at_line_offset(cast[ptr TextBuffer00](self.impl), iter, int32(lineNumber), int32(charOffset)))

proc gtk_text_buffer_get_iter_at_mark(self: ptr TextBuffer00; iter: var TextIter;
    mark: ptr TextMark00) {.
    importc, libprag.}

proc getIterAtMark*(self: TextBuffer; iter: var TextIter;
    mark: TextMark) =
  gtk_text_buffer_get_iter_at_mark(cast[ptr TextBuffer00](self.impl), iter, cast[ptr TextMark00](mark.impl))

proc gtk_text_buffer_get_iter_at_offset(self: ptr TextBuffer00; iter: var TextIter;
    charOffset: int32) {.
    importc, libprag.}

proc getIterAtOffset*(self: TextBuffer; iter: var TextIter;
    charOffset: int) =
  gtk_text_buffer_get_iter_at_offset(cast[ptr TextBuffer00](self.impl), iter, int32(charOffset))

proc gtk_text_buffer_get_line_count(self: ptr TextBuffer00): int32 {.
    importc, libprag.}

proc getLineCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_line_count(cast[ptr TextBuffer00](self.impl)))

proc lineCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_line_count(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_mark(self: ptr TextBuffer00; name: cstring): ptr TextMark00 {.
    importc, libprag.}

proc getMark*(self: TextBuffer; name: cstring): TextMark =
  let gobj = gtk_text_buffer_get_mark(cast[ptr TextBuffer00](self.impl), name)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_max_undo_levels(self: ptr TextBuffer00): uint32 {.
    importc, libprag.}

proc getMaxUndoLevels*(self: TextBuffer): int =
  int(gtk_text_buffer_get_max_undo_levels(cast[ptr TextBuffer00](self.impl)))

proc maxUndoLevels*(self: TextBuffer): int =
  int(gtk_text_buffer_get_max_undo_levels(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_modified(self: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc getModified*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_modified(cast[ptr TextBuffer00](self.impl)))

proc modified*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_modified(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_selection_bound(self: ptr TextBuffer00): ptr TextMark00 {.
    importc, libprag.}

proc getSelectionBound*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_selection_bound(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectionBound*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_selection_bound(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_selection_bounds(self: ptr TextBuffer00; start: var TextIter;
    `end`: var TextIter): gboolean {.
    importc, libprag.}

proc getSelectionBounds*(self: TextBuffer; start: var TextIter;
    `end`: var TextIter): bool =
  toBool(gtk_text_buffer_get_selection_bounds(cast[ptr TextBuffer00](self.impl), start, `end`))

proc gtk_text_buffer_get_selection_content(self: ptr TextBuffer00): ptr gdk4.ContentProvider00 {.
    importc, libprag.}

proc getSelectionContent*(self: TextBuffer): gdk4.ContentProvider =
  let gobj = gtk_text_buffer_get_selection_content(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectionContent*(self: TextBuffer): gdk4.ContentProvider =
  let gobj = gtk_text_buffer_get_selection_content(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_slice(self: ptr TextBuffer00; start: TextIter; `end`: TextIter;
    includeHiddenChars: gboolean): cstring {.
    importc, libprag.}

proc getSlice*(self: TextBuffer; start: TextIter; `end`: TextIter;
    includeHiddenChars: bool): string =
  let resul0 = gtk_text_buffer_get_slice(cast[ptr TextBuffer00](self.impl), start, `end`, gboolean(includeHiddenChars))
  result = $resul0
  cogfree(resul0)

proc gtk_text_buffer_get_start_iter(self: ptr TextBuffer00; iter: var TextIter) {.
    importc, libprag.}

proc getStartIter*(self: TextBuffer; iter: var TextIter) =
  gtk_text_buffer_get_start_iter(cast[ptr TextBuffer00](self.impl), iter)

proc getStartIter*(self: TextBuffer): TextIter =
  gtk_text_buffer_get_start_iter(cast[ptr TextBuffer00](self.impl), result)

proc gtk_text_buffer_get_text(self: ptr TextBuffer00; start: TextIter; `end`: TextIter;
    includeHiddenChars: gboolean): cstring {.
    importc, libprag.}

proc getText*(self: TextBuffer; start: TextIter; `end`: TextIter;
    includeHiddenChars: bool): string =
  let resul0 = gtk_text_buffer_get_text(cast[ptr TextBuffer00](self.impl), start, `end`, gboolean(includeHiddenChars))
  result = $resul0
  cogfree(resul0)

proc gtk_text_buffer_insert(self: ptr TextBuffer00; iter: TextIter; text: cstring;
    len: int32) {.
    importc, libprag.}

proc insert*(self: TextBuffer; iter: TextIter; text: cstring;
    len: int) =
  gtk_text_buffer_insert(cast[ptr TextBuffer00](self.impl), iter, text, int32(len))

proc gtk_text_buffer_insert_at_cursor(self: ptr TextBuffer00; text: cstring;
    len: int32) {.
    importc, libprag.}

proc insertAtCursor*(self: TextBuffer; text: cstring; len: int) =
  gtk_text_buffer_insert_at_cursor(cast[ptr TextBuffer00](self.impl), text, int32(len))

proc gtk_text_buffer_insert_child_anchor(self: ptr TextBuffer00; iter: TextIter;
    anchor: ptr TextChildAnchor00) {.
    importc, libprag.}

proc insertChildAnchor*(self: TextBuffer; iter: TextIter;
    anchor: TextChildAnchor) =
  gtk_text_buffer_insert_child_anchor(cast[ptr TextBuffer00](self.impl), iter, cast[ptr TextChildAnchor00](anchor.impl))

proc gtk_text_buffer_insert_interactive(self: ptr TextBuffer00; iter: TextIter;
    text: cstring; len: int32; defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc insertInteractive*(self: TextBuffer; iter: TextIter;
    text: cstring; len: int; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_insert_interactive(cast[ptr TextBuffer00](self.impl), iter, text, int32(len), gboolean(defaultEditable)))

proc gtk_text_buffer_insert_interactive_at_cursor(self: ptr TextBuffer00;
    text: cstring; len: int32; defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc insertInteractiveAtCursor*(self: TextBuffer; text: cstring;
    len: int; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_insert_interactive_at_cursor(cast[ptr TextBuffer00](self.impl), text, int32(len), gboolean(defaultEditable)))

proc gtk_text_buffer_insert_markup(self: ptr TextBuffer00; iter: TextIter;
    markup: cstring; len: int32) {.
    importc, libprag.}

proc insertMarkup*(self: TextBuffer; iter: TextIter; markup: cstring;
    len: int) =
  gtk_text_buffer_insert_markup(cast[ptr TextBuffer00](self.impl), iter, markup, int32(len))

proc gtk_text_buffer_insert_paintable(self: ptr TextBuffer00; iter: TextIter;
    paintable: ptr gdk4.Paintable00) {.
    importc, libprag.}

proc insertPaintable*(self: TextBuffer; iter: TextIter; paintable: gdk4.Paintable) =
  gtk_text_buffer_insert_paintable(cast[ptr TextBuffer00](self.impl), iter, cast[ptr gdk4.Paintable00](paintable.impl))

proc gtk_text_buffer_insert_range(self: ptr TextBuffer00; iter: TextIter;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc insertRange*(self: TextBuffer; iter: TextIter; start: TextIter;
    `end`: TextIter) =
  gtk_text_buffer_insert_range(cast[ptr TextBuffer00](self.impl), iter, start, `end`)

proc gtk_text_buffer_insert_range_interactive(self: ptr TextBuffer00; iter: TextIter;
    start: TextIter; `end`: TextIter; defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc insertRangeInteractive*(self: TextBuffer; iter: TextIter;
    start: TextIter; `end`: TextIter; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_insert_range_interactive(cast[ptr TextBuffer00](self.impl), iter, start, `end`, gboolean(defaultEditable)))

proc gtk_text_buffer_move_mark(self: ptr TextBuffer00; mark: ptr TextMark00;
    where: TextIter) {.
    importc, libprag.}

proc moveMark*(self: TextBuffer; mark: TextMark; where: TextIter) =
  gtk_text_buffer_move_mark(cast[ptr TextBuffer00](self.impl), cast[ptr TextMark00](mark.impl), where)

proc gtk_text_buffer_move_mark_by_name(self: ptr TextBuffer00; name: cstring;
    where: TextIter) {.
    importc, libprag.}

proc moveMarkByName*(self: TextBuffer; name: cstring; where: TextIter) =
  gtk_text_buffer_move_mark_by_name(cast[ptr TextBuffer00](self.impl), name, where)

proc gtk_text_buffer_paste_clipboard(self: ptr TextBuffer00; clipboard: ptr gdk4.Clipboard00;
    overrideLocation: TextIter; defaultEditable: gboolean) {.
    importc, libprag.}

proc pasteClipboard*(self: TextBuffer; clipboard: gdk4.Clipboard;
    overrideLocation: TextIter = cast[var TextIter](nil); defaultEditable: bool) =
  gtk_text_buffer_paste_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr gdk4.Clipboard00](clipboard.impl), overrideLocation, gboolean(defaultEditable))

proc gtk_text_buffer_place_cursor(self: ptr TextBuffer00; where: TextIter) {.
    importc, libprag.}

proc placeCursor*(self: TextBuffer; where: TextIter) =
  gtk_text_buffer_place_cursor(cast[ptr TextBuffer00](self.impl), where)

proc gtk_text_buffer_redo(self: ptr TextBuffer00) {.
    importc, libprag.}

proc redo*(self: TextBuffer) =
  gtk_text_buffer_redo(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_remove_all_tags(self: ptr TextBuffer00; start: TextIter;
    `end`: TextIter) {.
    importc, libprag.}

proc removeAllTags*(self: TextBuffer; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_remove_all_tags(cast[ptr TextBuffer00](self.impl), start, `end`)

proc gtk_text_buffer_remove_selection_clipboard(self: ptr TextBuffer00; clipboard: ptr gdk4.Clipboard00) {.
    importc, libprag.}

proc removeSelectionClipboard*(self: TextBuffer; clipboard: gdk4.Clipboard) =
  gtk_text_buffer_remove_selection_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr gdk4.Clipboard00](clipboard.impl))

proc gtk_text_buffer_remove_tag(self: ptr TextBuffer00; tag: ptr TextTag00;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc removeTag*(self: TextBuffer; tag: TextTag; start: TextIter;
    `end`: TextIter) =
  gtk_text_buffer_remove_tag(cast[ptr TextBuffer00](self.impl), cast[ptr TextTag00](tag.impl), start, `end`)

proc gtk_text_buffer_remove_tag_by_name(self: ptr TextBuffer00; name: cstring;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc removeTagByName*(self: TextBuffer; name: cstring;
    start: TextIter; `end`: TextIter) =
  gtk_text_buffer_remove_tag_by_name(cast[ptr TextBuffer00](self.impl), name, start, `end`)

proc gtk_text_buffer_select_range(self: ptr TextBuffer00; ins: TextIter;
    bound: TextIter) {.
    importc, libprag.}

proc selectRange*(self: TextBuffer; ins: TextIter; bound: TextIter) =
  gtk_text_buffer_select_range(cast[ptr TextBuffer00](self.impl), ins, bound)

proc gtk_text_buffer_set_enable_undo(self: ptr TextBuffer00; enableUndo: gboolean) {.
    importc, libprag.}

proc setEnableUndo*(self: TextBuffer; enableUndo: bool = true) =
  gtk_text_buffer_set_enable_undo(cast[ptr TextBuffer00](self.impl), gboolean(enableUndo))

proc `enableUndo=`*(self: TextBuffer; enableUndo: bool) =
  gtk_text_buffer_set_enable_undo(cast[ptr TextBuffer00](self.impl), gboolean(enableUndo))

proc gtk_text_buffer_set_max_undo_levels(self: ptr TextBuffer00; maxUndoLevels: uint32) {.
    importc, libprag.}

proc setMaxUndoLevels*(self: TextBuffer; maxUndoLevels: int) =
  gtk_text_buffer_set_max_undo_levels(cast[ptr TextBuffer00](self.impl), uint32(maxUndoLevels))

proc `maxUndoLevels=`*(self: TextBuffer; maxUndoLevels: int) =
  gtk_text_buffer_set_max_undo_levels(cast[ptr TextBuffer00](self.impl), uint32(maxUndoLevels))

proc gtk_text_buffer_set_modified(self: ptr TextBuffer00; setting: gboolean) {.
    importc, libprag.}

proc setModified*(self: TextBuffer; setting: bool = true) =
  gtk_text_buffer_set_modified(cast[ptr TextBuffer00](self.impl), gboolean(setting))

proc `modified=`*(self: TextBuffer; setting: bool) =
  gtk_text_buffer_set_modified(cast[ptr TextBuffer00](self.impl), gboolean(setting))

proc gtk_text_buffer_set_text(self: ptr TextBuffer00; text: cstring; len: int32) {.
    importc, libprag.}

proc setText*(self: TextBuffer; text: cstring; len: int) =
  gtk_text_buffer_set_text(cast[ptr TextBuffer00](self.impl), text, int32(len))

proc gtk_text_buffer_undo(self: ptr TextBuffer00) {.
    importc, libprag.}

proc undo*(self: TextBuffer) =
  gtk_text_buffer_undo(cast[ptr TextBuffer00](self.impl))

proc gtk_text_iter_backward_to_tag_toggle(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc backwardToTagToggle*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_backward_to_tag_toggle(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_ends_tag(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc endsTag*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_ends_tag(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_forward_to_tag_toggle(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc forwardToTagToggle*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_forward_to_tag_toggle(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_get_buffer(self: TextIter): ptr TextBuffer00 {.
    importc, libprag.}

proc getBuffer*(self: TextIter): TextBuffer =
  let gobj = gtk_text_iter_get_buffer(self)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: TextIter): TextBuffer =
  let gobj = gtk_text_iter_get_buffer(self)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_iter_get_tags(self: TextIter): ptr glib.SList {.
    importc, libprag.}

proc getTags*(self: TextIter): seq[TextTag] =
  let resul0 = gtk_text_iter_get_tags(self)
  result = gslistObjects2seq(TextTag, resul0, false)
  g_slist_free(resul0)

proc tags*(self: TextIter): seq[TextTag] =
  let resul0 = gtk_text_iter_get_tags(self)
  result = gslistObjects2seq(TextTag, resul0, false)
  g_slist_free(resul0)

proc gtk_text_iter_get_toggled_tags(self: TextIter; toggledOn: gboolean): ptr glib.SList {.
    importc, libprag.}

proc getToggledTags*(self: TextIter; toggledOn: bool): seq[TextTag] =
  let resul0 = gtk_text_iter_get_toggled_tags(self, gboolean(toggledOn))
  result = gslistObjects2seq(TextTag, resul0, false)
  g_slist_free(resul0)

proc gtk_text_iter_has_tag(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc hasTag*(self: TextIter; tag: TextTag): bool =
  toBool(gtk_text_iter_has_tag(self, cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_starts_tag(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc startsTag*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_starts_tag(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_toggles_tag(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc togglesTag*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_toggles_tag(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_view_new_with_buffer(buffer: ptr TextBuffer00): ptr TextView00 {.
    importc, libprag.}

proc newTextViewWithBuffer*(buffer: TextBuffer): TextView =
  let gobj = gtk_text_view_new_with_buffer(cast[ptr TextBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextViewWithBuffer*(tdesc: typedesc; buffer: TextBuffer): tdesc =
  assert(result is TextView)
  let gobj = gtk_text_view_new_with_buffer(cast[ptr TextBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextViewWithBuffer*[T](result: var T; buffer: TextBuffer) {.deprecated.} =
  assert(result is TextView)
  let gobj = gtk_text_view_new_with_buffer(cast[ptr TextBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_buffer(self: ptr TextView00): ptr TextBuffer00 {.
    importc, libprag.}

proc getBuffer*(self: TextView): TextBuffer =
  let gobj = gtk_text_view_get_buffer(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: TextView): TextBuffer =
  let gobj = gtk_text_view_get_buffer(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_set_buffer(self: ptr TextView00; buffer: ptr TextBuffer00) {.
    importc, libprag.}

proc setBuffer*(self: TextView; buffer: TextBuffer = nil) =
  gtk_text_view_set_buffer(cast[ptr TextView00](self.impl), if buffer.isNil: nil else: cast[ptr TextBuffer00](buffer.impl))

proc `buffer=`*(self: TextView; buffer: TextBuffer = nil) =
  gtk_text_view_set_buffer(cast[ptr TextView00](self.impl), if buffer.isNil: nil else: cast[ptr TextBuffer00](buffer.impl))

proc gtk_text_mark_get_buffer(self: ptr TextMark00): ptr TextBuffer00 {.
    importc, libprag.}

proc getBuffer*(self: TextMark): TextBuffer =
  let gobj = gtk_text_mark_get_buffer(cast[ptr TextMark00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: TextMark): TextBuffer =
  let gobj = gtk_text_mark_get_buffer(cast[ptr TextMark00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TextTagTable* = ref object of gobject.Object
  TextTagTable00* = object of gobject.Object00

proc gtk_text_tag_table_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextTagTable()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scTagAdded*(self: TextTagTable;  p: proc (self: ptr TextTagTable00; tag: ptr TextTag00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "tag-added", cast[GCallback](p), xdata, nil, cf)

proc scTagChanged*(self: TextTagTable;  p: proc (self: ptr TextTagTable00; tag: ptr TextTag00; sizeChanged: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "tag-changed", cast[GCallback](p), xdata, nil, cf)

proc scTagRemoved*(self: TextTagTable;  p: proc (self: ptr TextTagTable00; tag: ptr TextTag00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "tag-removed", cast[GCallback](p), xdata, nil, cf)

proc gtk_text_tag_table_new(): ptr TextTagTable00 {.
    importc, libprag.}

proc newTextTagTable*(): TextTagTable =
  let gobj = gtk_text_tag_table_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextTagTable*(tdesc: typedesc): tdesc =
  assert(result is TextTagTable)
  let gobj = gtk_text_tag_table_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextTagTable*[T](result: var T) {.deprecated.} =
  assert(result is TextTagTable)
  let gobj = gtk_text_tag_table_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_tag_table_add(self: ptr TextTagTable00; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc add*(self: TextTagTable; tag: TextTag): bool =
  toBool(gtk_text_tag_table_add(cast[ptr TextTagTable00](self.impl), cast[ptr TextTag00](tag.impl)))

proc gtk_text_tag_table_get_size(self: ptr TextTagTable00): int32 {.
    importc, libprag.}

proc getSize*(self: TextTagTable): int =
  int(gtk_text_tag_table_get_size(cast[ptr TextTagTable00](self.impl)))

proc size*(self: TextTagTable): int =
  int(gtk_text_tag_table_get_size(cast[ptr TextTagTable00](self.impl)))

proc gtk_text_tag_table_lookup(self: ptr TextTagTable00; name: cstring): ptr TextTag00 {.
    importc, libprag.}

proc lookup*(self: TextTagTable; name: cstring): TextTag =
  let gobj = gtk_text_tag_table_lookup(cast[ptr TextTagTable00](self.impl), name)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_tag_table_remove(self: ptr TextTagTable00; tag: ptr TextTag00) {.
    importc, libprag.}

proc remove*(self: TextTagTable; tag: TextTag) =
  gtk_text_tag_table_remove(cast[ptr TextTagTable00](self.impl), cast[ptr TextTag00](tag.impl))

proc gtk_text_buffer_new(table: ptr TextTagTable00): ptr TextBuffer00 {.
    importc, libprag.}

proc newTextBuffer*(table: TextTagTable = nil): TextBuffer =
  let gobj = gtk_text_buffer_new(if table.isNil: nil else: cast[ptr TextTagTable00](table.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextBuffer*(tdesc: typedesc; table: TextTagTable = nil): tdesc =
  assert(result is TextBuffer)
  let gobj = gtk_text_buffer_new(if table.isNil: nil else: cast[ptr TextTagTable00](table.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextBuffer*[T](result: var T; table: TextTagTable = nil) {.deprecated.} =
  assert(result is TextBuffer)
  let gobj = gtk_text_buffer_new(if table.isNil: nil else: cast[ptr TextTagTable00](table.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_tag_table(self: ptr TextBuffer00): ptr TextTagTable00 {.
    importc, libprag.}

proc getTagTable*(self: TextBuffer): TextTagTable =
  let gobj = gtk_text_buffer_get_tag_table(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc tagTable*(self: TextBuffer): TextTagTable =
  let gobj = gtk_text_buffer_get_tag_table(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CornerType* {.size: sizeof(cint), pure.} = enum
    topLeft = 0
    bottomLeft = 1
    topRight = 2
    bottomRight = 3

proc gtk_scrolled_window_get_placement(self: ptr ScrolledWindow00): CornerType {.
    importc, libprag.}

proc getPlacement*(self: ScrolledWindow): CornerType =
  gtk_scrolled_window_get_placement(cast[ptr ScrolledWindow00](self.impl))

proc placement*(self: ScrolledWindow): CornerType =
  gtk_scrolled_window_get_placement(cast[ptr ScrolledWindow00](self.impl))

proc gtk_scrolled_window_set_placement(self: ptr ScrolledWindow00; windowPlacement: CornerType) {.
    importc, libprag.}

proc setPlacement*(self: ScrolledWindow; windowPlacement: CornerType) =
  gtk_scrolled_window_set_placement(cast[ptr ScrolledWindow00](self.impl), windowPlacement)

proc `placement=`*(self: ScrolledWindow; windowPlacement: CornerType) =
  gtk_scrolled_window_set_placement(cast[ptr ScrolledWindow00](self.impl), windowPlacement)

type
  PolicyType* {.size: sizeof(cint), pure.} = enum
    always = 0
    automatic = 1
    never = 2
    external = 3

proc gtk_scrolled_window_get_policy(self: ptr ScrolledWindow00; hscrollbarPolicy: var PolicyType;
    vscrollbarPolicy: var PolicyType) {.
    importc, libprag.}

proc getPolicy*(self: ScrolledWindow; hscrollbarPolicy: var PolicyType = cast[var PolicyType](nil);
    vscrollbarPolicy: var PolicyType = cast[var PolicyType](nil)) =
  gtk_scrolled_window_get_policy(cast[ptr ScrolledWindow00](self.impl), hscrollbarPolicy, vscrollbarPolicy)

proc gtk_scrolled_window_set_policy(self: ptr ScrolledWindow00; hscrollbarPolicy: PolicyType;
    vscrollbarPolicy: PolicyType) {.
    importc, libprag.}

proc setPolicy*(self: ScrolledWindow; hscrollbarPolicy: PolicyType;
    vscrollbarPolicy: PolicyType) =
  gtk_scrolled_window_set_policy(cast[ptr ScrolledWindow00](self.impl), hscrollbarPolicy, vscrollbarPolicy)

type
  SelectionMode* {.size: sizeof(cint), pure.} = enum
    none = 0
    single = 1
    browse = 2
    multiple = 3

proc gtk_flow_box_get_selection_mode(self: ptr FlowBox00): SelectionMode {.
    importc, libprag.}

proc getSelectionMode*(self: FlowBox): SelectionMode =
  gtk_flow_box_get_selection_mode(cast[ptr FlowBox00](self.impl))

proc selectionMode*(self: FlowBox): SelectionMode =
  gtk_flow_box_get_selection_mode(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_set_selection_mode(self: ptr FlowBox00; mode: SelectionMode) {.
    importc, libprag.}

proc setSelectionMode*(self: FlowBox; mode: SelectionMode) =
  gtk_flow_box_set_selection_mode(cast[ptr FlowBox00](self.impl), mode)

proc `selectionMode=`*(self: FlowBox; mode: SelectionMode) =
  gtk_flow_box_set_selection_mode(cast[ptr FlowBox00](self.impl), mode)

proc gtk_list_box_get_selection_mode(self: ptr ListBox00): SelectionMode {.
    importc, libprag.}

proc getSelectionMode*(self: ListBox): SelectionMode =
  gtk_list_box_get_selection_mode(cast[ptr ListBox00](self.impl))

proc selectionMode*(self: ListBox): SelectionMode =
  gtk_list_box_get_selection_mode(cast[ptr ListBox00](self.impl))

proc gtk_list_box_set_selection_mode(self: ptr ListBox00; mode: SelectionMode) {.
    importc, libprag.}

proc setSelectionMode*(self: ListBox; mode: SelectionMode) =
  gtk_list_box_set_selection_mode(cast[ptr ListBox00](self.impl), mode)

proc `selectionMode=`*(self: ListBox; mode: SelectionMode) =
  gtk_list_box_set_selection_mode(cast[ptr ListBox00](self.impl), mode)

proc gtk_icon_view_get_selection_mode(self: ptr IconView00): SelectionMode {.
    importc, libprag.}

proc getSelectionMode*(self: IconView): SelectionMode =
  gtk_icon_view_get_selection_mode(cast[ptr IconView00](self.impl))

proc selectionMode*(self: IconView): SelectionMode =
  gtk_icon_view_get_selection_mode(cast[ptr IconView00](self.impl))

proc gtk_icon_view_set_selection_mode(self: ptr IconView00; mode: SelectionMode) {.
    importc, libprag.}

proc setSelectionMode*(self: IconView; mode: SelectionMode) =
  gtk_icon_view_set_selection_mode(cast[ptr IconView00](self.impl), mode)

proc `selectionMode=`*(self: IconView; mode: SelectionMode) =
  gtk_icon_view_set_selection_mode(cast[ptr IconView00](self.impl), mode)

proc gtk_tree_selection_get_mode(self: ptr TreeSelection00): SelectionMode {.
    importc, libprag.}

proc getMode*(self: TreeSelection): SelectionMode =
  gtk_tree_selection_get_mode(cast[ptr TreeSelection00](self.impl))

proc mode*(self: TreeSelection): SelectionMode =
  gtk_tree_selection_get_mode(cast[ptr TreeSelection00](self.impl))

proc gtk_tree_selection_set_mode(self: ptr TreeSelection00; `type`: SelectionMode) {.
    importc, libprag.}

proc setMode*(self: TreeSelection; `type`: SelectionMode) =
  gtk_tree_selection_set_mode(cast[ptr TreeSelection00](self.impl), `type`)

proc `mode=`*(self: TreeSelection; `type`: SelectionMode) =
  gtk_tree_selection_set_mode(cast[ptr TreeSelection00](self.impl), `type`)

type
  Adjustment* = ref object of gobject.InitiallyUnowned
  Adjustment00* = object of gobject.InitiallyUnowned00

proc gtk_adjustment_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Adjustment()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: Adjustment;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scValueChanged*(self: Adjustment;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_adjustment_new(value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble;
    pageIncrement: cdouble; pageSize: cdouble): ptr Adjustment00 {.
    importc, libprag.}

proc newAdjustment*(value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble;
    pageIncrement: cdouble; pageSize: cdouble = 1.0): Adjustment =
  let gobj = gtk_adjustment_new(value, lower, upper, stepIncrement, pageIncrement, pageSize)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAdjustment*(tdesc: typedesc; value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble;
    pageIncrement: cdouble; pageSize: cdouble = 1.0): tdesc =
  assert(result is Adjustment)
  let gobj = gtk_adjustment_new(value, lower, upper, stepIncrement, pageIncrement, pageSize)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAdjustment*[T](result: var T; value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble;
    pageIncrement: cdouble; pageSize: cdouble = 1.0) {.deprecated.} =
  assert(result is Adjustment)
  let gobj = gtk_adjustment_new(value, lower, upper, stepIncrement, pageIncrement, pageSize)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_adjustment_clamp_page(self: ptr Adjustment00; lower: cdouble; upper: cdouble) {.
    importc, libprag.}

proc clampPage*(self: Adjustment; lower: cdouble; upper: cdouble) =
  gtk_adjustment_clamp_page(cast[ptr Adjustment00](self.impl), lower, upper)

proc gtk_adjustment_configure(self: ptr Adjustment00; value: cdouble; lower: cdouble;
    upper: cdouble; stepIncrement: cdouble; pageIncrement: cdouble; pageSize: cdouble) {.
    importc, libprag.}

proc configure*(self: Adjustment; value: cdouble; lower: cdouble;
    upper: cdouble; stepIncrement: cdouble; pageIncrement: cdouble; pageSize: cdouble) =
  gtk_adjustment_configure(cast[ptr Adjustment00](self.impl), value, lower, upper, stepIncrement, pageIncrement, pageSize)

proc gtk_adjustment_get_lower(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getLower*(self: Adjustment): cdouble =
  gtk_adjustment_get_lower(cast[ptr Adjustment00](self.impl))

proc lower*(self: Adjustment): cdouble =
  gtk_adjustment_get_lower(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_minimum_increment(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getMinimumIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_minimum_increment(cast[ptr Adjustment00](self.impl))

proc minimumIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_minimum_increment(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_page_increment(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getPageIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_increment(cast[ptr Adjustment00](self.impl))

proc pageIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_increment(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_page_size(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getPageSize*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_size(cast[ptr Adjustment00](self.impl))

proc pageSize*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_size(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_step_increment(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getStepIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_step_increment(cast[ptr Adjustment00](self.impl))

proc stepIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_step_increment(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_upper(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getUpper*(self: Adjustment): cdouble =
  gtk_adjustment_get_upper(cast[ptr Adjustment00](self.impl))

proc upper*(self: Adjustment): cdouble =
  gtk_adjustment_get_upper(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_value(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getValue*(self: Adjustment): cdouble =
  gtk_adjustment_get_value(cast[ptr Adjustment00](self.impl))

proc value*(self: Adjustment): cdouble =
  gtk_adjustment_get_value(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_set_lower(self: ptr Adjustment00; lower: cdouble) {.
    importc, libprag.}

proc setLower*(self: Adjustment; lower: cdouble) =
  gtk_adjustment_set_lower(cast[ptr Adjustment00](self.impl), lower)

proc `lower=`*(self: Adjustment; lower: cdouble) =
  gtk_adjustment_set_lower(cast[ptr Adjustment00](self.impl), lower)

proc gtk_adjustment_set_page_increment(self: ptr Adjustment00; pageIncrement: cdouble) {.
    importc, libprag.}

proc setPageIncrement*(self: Adjustment; pageIncrement: cdouble) =
  gtk_adjustment_set_page_increment(cast[ptr Adjustment00](self.impl), pageIncrement)

proc `pageIncrement=`*(self: Adjustment; pageIncrement: cdouble) =
  gtk_adjustment_set_page_increment(cast[ptr Adjustment00](self.impl), pageIncrement)

proc gtk_adjustment_set_page_size(self: ptr Adjustment00; pageSize: cdouble) {.
    importc, libprag.}

proc setPageSize*(self: Adjustment; pageSize: cdouble) =
  gtk_adjustment_set_page_size(cast[ptr Adjustment00](self.impl), pageSize)

proc `pageSize=`*(self: Adjustment; pageSize: cdouble) =
  gtk_adjustment_set_page_size(cast[ptr Adjustment00](self.impl), pageSize)

proc gtk_adjustment_set_step_increment(self: ptr Adjustment00; stepIncrement: cdouble) {.
    importc, libprag.}

proc setStepIncrement*(self: Adjustment; stepIncrement: cdouble) =
  gtk_adjustment_set_step_increment(cast[ptr Adjustment00](self.impl), stepIncrement)

proc `stepIncrement=`*(self: Adjustment; stepIncrement: cdouble) =
  gtk_adjustment_set_step_increment(cast[ptr Adjustment00](self.impl), stepIncrement)

proc gtk_adjustment_set_upper(self: ptr Adjustment00; upper: cdouble) {.
    importc, libprag.}

proc setUpper*(self: Adjustment; upper: cdouble) =
  gtk_adjustment_set_upper(cast[ptr Adjustment00](self.impl), upper)

proc `upper=`*(self: Adjustment; upper: cdouble) =
  gtk_adjustment_set_upper(cast[ptr Adjustment00](self.impl), upper)

proc gtk_adjustment_set_value(self: ptr Adjustment00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: Adjustment; value: cdouble) =
  gtk_adjustment_set_value(cast[ptr Adjustment00](self.impl), value)

proc `value=`*(self: Adjustment; value: cdouble) =
  gtk_adjustment_set_value(cast[ptr Adjustment00](self.impl), value)

proc gtk_flow_box_set_hadjustment(self: ptr FlowBox00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setHadjustment*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_hadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `hadjustment=`*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_hadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_flow_box_set_vadjustment(self: ptr FlowBox00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setVadjustment*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_vadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `vadjustment=`*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_vadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_viewport_new(hadjustment: ptr Adjustment00; vadjustment: ptr Adjustment00): ptr Viewport00 {.
    importc, libprag.}

proc newViewport*(hadjustment: Adjustment = nil; vadjustment: Adjustment = nil): Viewport =
  let gobj = gtk_viewport_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newViewport*(tdesc: typedesc; hadjustment: Adjustment = nil; vadjustment: Adjustment = nil): tdesc =
  assert(result is Viewport)
  let gobj = gtk_viewport_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initViewport*[T](result: var T; hadjustment: Adjustment = nil; vadjustment: Adjustment = nil) {.deprecated.} =
  assert(result is Viewport)
  let gobj = gtk_viewport_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_range_get_adjustment(self: ptr Range00): ptr Adjustment00 {.
    importc, libprag.}

proc getAdjustment*(self: Range): Adjustment =
  let gobj = gtk_range_get_adjustment(cast[ptr Range00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: Range): Adjustment =
  let gobj = gtk_range_get_adjustment(cast[ptr Range00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_range_set_adjustment(self: ptr Range00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setAdjustment*(self: Range; adjustment: Adjustment) =
  gtk_range_set_adjustment(cast[ptr Range00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: Range; adjustment: Adjustment) =
  gtk_range_set_adjustment(cast[ptr Range00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_list_box_get_adjustment(self: ptr ListBox00): ptr Adjustment00 {.
    importc, libprag.}

proc getAdjustment*(self: ListBox): Adjustment =
  let gobj = gtk_list_box_get_adjustment(cast[ptr ListBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: ListBox): Adjustment =
  let gobj = gtk_list_box_get_adjustment(cast[ptr ListBox00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_set_adjustment(self: ptr ListBox00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setAdjustment*(self: ListBox; adjustment: Adjustment = nil) =
  gtk_list_box_set_adjustment(cast[ptr ListBox00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: ListBox; adjustment: Adjustment = nil) =
  gtk_list_box_set_adjustment(cast[ptr ListBox00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc gtk_scrolled_window_get_hadjustment(self: ptr ScrolledWindow00): ptr Adjustment00 {.
    importc, libprag.}

proc getHadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_hadjustment(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_hadjustment(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_vadjustment(self: ptr ScrolledWindow00): ptr Adjustment00 {.
    importc, libprag.}

proc getVadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_vadjustment(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_vadjustment(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_set_hadjustment(self: ptr ScrolledWindow00; hadjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setHadjustment*(self: ScrolledWindow; hadjustment: Adjustment = nil) =
  gtk_scrolled_window_set_hadjustment(cast[ptr ScrolledWindow00](self.impl), if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl))

proc `hadjustment=`*(self: ScrolledWindow; hadjustment: Adjustment = nil) =
  gtk_scrolled_window_set_hadjustment(cast[ptr ScrolledWindow00](self.impl), if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl))

proc gtk_scrolled_window_set_vadjustment(self: ptr ScrolledWindow00; vadjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setVadjustment*(self: ScrolledWindow; vadjustment: Adjustment = nil) =
  gtk_scrolled_window_set_vadjustment(cast[ptr ScrolledWindow00](self.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))

proc `vadjustment=`*(self: ScrolledWindow; vadjustment: Adjustment = nil) =
  gtk_scrolled_window_set_vadjustment(cast[ptr ScrolledWindow00](self.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))

proc gtk_scale_button_get_adjustment(self: ptr ScaleButton00): ptr Adjustment00 {.
    importc, libprag.}

proc getAdjustment*(self: ScaleButton): Adjustment =
  let gobj = gtk_scale_button_get_adjustment(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: ScaleButton): Adjustment =
  let gobj = gtk_scale_button_get_adjustment(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_set_adjustment(self: ptr ScaleButton00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setAdjustment*(self: ScaleButton; adjustment: Adjustment) =
  gtk_scale_button_set_adjustment(cast[ptr ScaleButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: ScaleButton; adjustment: Adjustment) =
  gtk_scale_button_set_adjustment(cast[ptr ScaleButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_spin_button_new(adjustment: ptr Adjustment00; climbRate: cdouble;
    digits: uint32): ptr SpinButton00 {.
    importc, libprag.}

proc newSpinButton*(adjustment: Adjustment = nil; climbRate: cdouble;
    digits: int): SpinButton =
  let gobj = gtk_spin_button_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSpinButton*(tdesc: typedesc; adjustment: Adjustment = nil; climbRate: cdouble;
    digits: int): tdesc =
  assert(result is SpinButton)
  let gobj = gtk_spin_button_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSpinButton*[T](result: var T; adjustment: Adjustment = nil; climbRate: cdouble;
    digits: int) {.deprecated.} =
  assert(result is SpinButton)
  let gobj = gtk_spin_button_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spin_button_configure(self: ptr SpinButton00; adjustment: ptr Adjustment00;
    climbRate: cdouble; digits: uint32) {.
    importc, libprag.}

proc configure*(self: SpinButton; adjustment: Adjustment = nil;
    climbRate: cdouble; digits: int) =
  gtk_spin_button_configure(cast[ptr SpinButton00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))

proc gtk_spin_button_get_adjustment(self: ptr SpinButton00): ptr Adjustment00 {.
    importc, libprag.}

proc getAdjustment*(self: SpinButton): Adjustment =
  let gobj = gtk_spin_button_get_adjustment(cast[ptr SpinButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: SpinButton): Adjustment =
  let gobj = gtk_spin_button_get_adjustment(cast[ptr SpinButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spin_button_set_adjustment(self: ptr SpinButton00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setAdjustment*(self: SpinButton; adjustment: Adjustment) =
  gtk_spin_button_set_adjustment(cast[ptr SpinButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: SpinButton; adjustment: Adjustment) =
  gtk_spin_button_set_adjustment(cast[ptr SpinButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_scrollbar_get_adjustment(self: ptr Scrollbar00): ptr Adjustment00 {.
    importc, libprag.}

proc getAdjustment*(self: Scrollbar): Adjustment =
  let gobj = gtk_scrollbar_get_adjustment(cast[ptr Scrollbar00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: Scrollbar): Adjustment =
  let gobj = gtk_scrollbar_get_adjustment(cast[ptr Scrollbar00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrollbar_set_adjustment(self: ptr Scrollbar00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setAdjustment*(self: Scrollbar; adjustment: Adjustment = nil) =
  gtk_scrollbar_set_adjustment(cast[ptr Scrollbar00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: Scrollbar; adjustment: Adjustment = nil) =
  gtk_scrollbar_set_adjustment(cast[ptr Scrollbar00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

type
  Native00* = object of gobject.Object00
  Native* = ref object of gobject.Object

proc gtk_native_get_for_surface(surface: ptr gdk4.Surface00): ptr Native00 {.
    importc, libprag.}

proc getForSurface*(surface: gdk4.Surface): Native =
  let gobj = gtk_native_get_for_surface(cast[ptr gdk4.Surface00](surface.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc forSurface*(surface: gdk4.Surface): Native =
  let gobj = gtk_native_get_for_surface(cast[ptr gdk4.Surface00](surface.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_native_get_renderer(self: ptr Native00): ptr gsk.Renderer00 {.
    importc, libprag.}

proc getRenderer*(self: Native | EmojiChooser | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | PopoverMenu | Window | MessageDialog | Popover): gsk.Renderer =
  let gobj = gtk_native_get_renderer(cast[ptr Native00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gsk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc renderer*(self: Native | EmojiChooser | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | PopoverMenu | Window | MessageDialog | Popover): gsk.Renderer =
  let gobj = gtk_native_get_renderer(cast[ptr Native00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gsk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_native_get_surface(self: ptr Native00): ptr gdk4.Surface00 {.
    importc, libprag.}

proc getSurface*(self: Native | EmojiChooser | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | PopoverMenu | Window | MessageDialog | Popover): gdk4.Surface =
  let gobj = gtk_native_get_surface(cast[ptr Native00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc surface*(self: Native | EmojiChooser | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | PopoverMenu | Window | MessageDialog | Popover): gdk4.Surface =
  let gobj = gtk_native_get_surface(cast[ptr Native00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_native_get_surface_transform(self: ptr Native00; x: var cdouble;
    y: var cdouble) {.
    importc, libprag.}

proc getSurfaceTransform*(self: Native | EmojiChooser | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | PopoverMenu | Window | MessageDialog | Popover;
    x: var cdouble; y: var cdouble) =
  gtk_native_get_surface_transform(cast[ptr Native00](self.impl), x, y)

proc gtk_native_realize(self: ptr Native00) {.
    importc, libprag.}

proc realize*(self: Native | EmojiChooser | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | PopoverMenu | Window | MessageDialog | Popover) =
  gtk_native_realize(cast[ptr Native00](self.impl))

proc gtk_native_unrealize(self: ptr Native00) {.
    importc, libprag.}

proc unrealize*(self: Native | EmojiChooser | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | PopoverMenu | Window | MessageDialog | Popover) =
  gtk_native_unrealize(cast[ptr Native00](self.impl))

proc gtk_widget_get_native(self: ptr Widget00): ptr Native00 {.
    importc, libprag.}

proc getNative*(self: Widget): Native =
  let gobj = gtk_widget_get_native(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc native*(self: Widget): Native =
  let gobj = gtk_widget_get_native(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Requisition* {.pure, byRef.} = object
    width*: int32
    height*: int32

proc gtk_requisition_get_type*(): GType {.importc, libprag.}

proc gtk_requisition_free(self: Requisition) {.
    importc, libprag.}

proc free*(self: Requisition) =
  gtk_requisition_free(self)

proc gtk_requisition_copy(self: Requisition): ptr Requisition {.
    importc, libprag.}

proc copy*(self: Requisition): ptr Requisition =
  gtk_requisition_copy(self)

proc newRequisition*(): ptr Requisition {.
    importc: "gtk_requisition_new", libprag.}

proc gtk_widget_get_preferred_size(self: ptr Widget00; minimumSize: var Requisition;
    naturalSize: var Requisition) {.
    importc, libprag.}

proc getPreferredSize*(self: Widget; minimumSize: var Requisition = cast[var Requisition](nil);
    naturalSize: var Requisition = cast[var Requisition](nil)) =
  gtk_widget_get_preferred_size(cast[ptr Widget00](self.impl), minimumSize, naturalSize)

proc gtk_cell_renderer_get_preferred_size(self: ptr CellRenderer00; widget: ptr Widget00;
    minimumSize: var Requisition; naturalSize: var Requisition) {.
    importc, libprag.}

proc getPreferredSize*(self: CellRenderer; widget: Widget;
    minimumSize: var Requisition = cast[var Requisition](nil); naturalSize: var Requisition = cast[var Requisition](nil)) =
  gtk_cell_renderer_get_preferred_size(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize, naturalSize)

type
  SizeRequestMode* {.size: sizeof(cint), pure.} = enum
    heightForWidth = 0
    widthForHeight = 1
    constantSize = 2

proc gtk_widget_get_request_mode(self: ptr Widget00): SizeRequestMode {.
    importc, libprag.}

proc getRequestMode*(self: Widget): SizeRequestMode =
  gtk_widget_get_request_mode(cast[ptr Widget00](self.impl))

proc requestMode*(self: Widget): SizeRequestMode =
  gtk_widget_get_request_mode(cast[ptr Widget00](self.impl))

proc gtk_cell_renderer_get_request_mode(self: ptr CellRenderer00): SizeRequestMode {.
    importc, libprag.}

proc getRequestMode*(self: CellRenderer): SizeRequestMode =
  gtk_cell_renderer_get_request_mode(cast[ptr CellRenderer00](self.impl))

proc requestMode*(self: CellRenderer): SizeRequestMode =
  gtk_cell_renderer_get_request_mode(cast[ptr CellRenderer00](self.impl))

proc gtk_cell_area_get_request_mode(self: ptr CellArea00): SizeRequestMode {.
    importc, libprag.}

proc getRequestMode*(self: CellArea): SizeRequestMode =
  gtk_cell_area_get_request_mode(cast[ptr CellArea00](self.impl))

proc requestMode*(self: CellArea): SizeRequestMode =
  gtk_cell_area_get_request_mode(cast[ptr CellArea00](self.impl))

type
  Root00* = object of gobject.Object00
  Root* = ref object of gobject.Object

proc gtk_root_get_display(self: ptr Root00): ptr gdk4.Display00 {.
    importc, libprag.}

proc getDisplay*(self: Root | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | Window | MessageDialog): gdk4.Display =
  let gobj = gtk_root_get_display(cast[ptr Root00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: Root | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | Window | MessageDialog): gdk4.Display =
  let gobj = gtk_root_get_display(cast[ptr Root00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_root_get_focus(self: ptr Root00): ptr Widget00 {.
    importc, libprag.}

proc getFocus*(self: Root | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | Window | MessageDialog): Widget =
  let gobj = gtk_root_get_focus(cast[ptr Root00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focus*(self: Root | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | Window | MessageDialog): Widget =
  let gobj = gtk_root_get_focus(cast[ptr Root00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_root_set_focus(self: ptr Root00; focus: ptr Widget00) {.
    importc, libprag.}

proc setFocus*(self: Root | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | Window | MessageDialog;
    focus: Widget = nil) =
  gtk_root_set_focus(cast[ptr Root00](self.impl), if focus.isNil: nil else: cast[ptr Widget00](focus.impl))

proc `focus=`*(self: Root | FontChooserDialog | ShortcutsWindow | Dialog | FileChooserDialog | AboutDialog | DragIcon | AppChooserDialog | Assistant | ColorChooserDialog | PrintUnixDialog | ApplicationWindow | PageSetupUnixDialog | Window | MessageDialog;
    focus: Widget = nil) =
  gtk_root_set_focus(cast[ptr Root00](self.impl), if focus.isNil: nil else: cast[ptr Widget00](focus.impl))

proc gtk_widget_get_root(self: ptr Widget00): ptr Root00 {.
    importc, libprag.}

proc getRoot*(self: Widget): Root =
  let gobj = gtk_widget_get_root(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc root*(self: Widget): Root =
  let gobj = gtk_widget_get_root(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Settings* = ref object of gobject.Object
  Settings00* = object of gobject.Object00

proc gtk_settings_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Settings()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_settings_get_default(): ptr Settings00 {.
    importc, libprag.}

proc getDefaultSettings*(): Settings =
  let gobj = gtk_settings_get_default()
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_settings_get_for_display(display: ptr gdk4.Display00): ptr Settings00 {.
    importc, libprag.}

proc getSettingsForDisplay*(display: gdk4.Display): Settings =
  let gobj = gtk_settings_get_for_display(cast[ptr gdk4.Display00](display.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_settings_reset_property(self: ptr Settings00; name: cstring) {.
    importc, libprag.}

proc resetProperty*(self: Settings; name: cstring) =
  gtk_settings_reset_property(cast[ptr Settings00](self.impl), name)

proc gtk_widget_get_settings(self: ptr Widget00): ptr Settings00 {.
    importc, libprag.}

proc getSettings*(self: Widget): Settings =
  let gobj = gtk_widget_get_settings(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  StyleContext* = ref object of gobject.Object
  StyleContext00* = object of gobject.Object00

proc gtk_style_context_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StyleContext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_style_context_add_class(self: ptr StyleContext00; className: cstring) {.
    importc, libprag.}

proc addClass*(self: StyleContext; className: cstring) =
  gtk_style_context_add_class(cast[ptr StyleContext00](self.impl), className)

proc gtk_style_context_get_color(self: ptr StyleContext00; color: var gdk4.RGBA) {.
    importc, libprag.}

proc getColor*(self: StyleContext; color: var gdk4.RGBA) =
  gtk_style_context_get_color(cast[ptr StyleContext00](self.impl), color)

proc getColor*(self: StyleContext): gdk4.RGBA =
  gtk_style_context_get_color(cast[ptr StyleContext00](self.impl), result)

proc gtk_style_context_get_display(self: ptr StyleContext00): ptr gdk4.Display00 {.
    importc, libprag.}

proc getDisplay*(self: StyleContext): gdk4.Display =
  let gobj = gtk_style_context_get_display(cast[ptr StyleContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: StyleContext): gdk4.Display =
  let gobj = gtk_style_context_get_display(cast[ptr StyleContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_context_get_scale(self: ptr StyleContext00): int32 {.
    importc, libprag.}

proc getScale*(self: StyleContext): int =
  int(gtk_style_context_get_scale(cast[ptr StyleContext00](self.impl)))

proc scale*(self: StyleContext): int =
  int(gtk_style_context_get_scale(cast[ptr StyleContext00](self.impl)))

proc gtk_style_context_get_state(self: ptr StyleContext00): StateFlags {.
    importc, libprag.}

proc getState*(self: StyleContext): StateFlags =
  gtk_style_context_get_state(cast[ptr StyleContext00](self.impl))

proc state*(self: StyleContext): StateFlags =
  gtk_style_context_get_state(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_has_class(self: ptr StyleContext00; className: cstring): gboolean {.
    importc, libprag.}

proc hasClass*(self: StyleContext; className: cstring): bool =
  toBool(gtk_style_context_has_class(cast[ptr StyleContext00](self.impl), className))

proc gtk_style_context_lookup_color(self: ptr StyleContext00; colorName: cstring;
    color: var gdk4.RGBA): gboolean {.
    importc, libprag.}

proc lookupColor*(self: StyleContext; colorName: cstring;
    color: var gdk4.RGBA): bool =
  toBool(gtk_style_context_lookup_color(cast[ptr StyleContext00](self.impl), colorName, color))

proc gtk_style_context_remove_class(self: ptr StyleContext00; className: cstring) {.
    importc, libprag.}

proc removeClass*(self: StyleContext; className: cstring) =
  gtk_style_context_remove_class(cast[ptr StyleContext00](self.impl), className)

proc gtk_style_context_restore(self: ptr StyleContext00) {.
    importc, libprag.}

proc restore*(self: StyleContext) =
  gtk_style_context_restore(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_save(self: ptr StyleContext00) {.
    importc, libprag.}

proc save*(self: StyleContext) =
  gtk_style_context_save(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_set_display(self: ptr StyleContext00; display: ptr gdk4.Display00) {.
    importc, libprag.}

proc setDisplay*(self: StyleContext; display: gdk4.Display) =
  gtk_style_context_set_display(cast[ptr StyleContext00](self.impl), cast[ptr gdk4.Display00](display.impl))

proc `display=`*(self: StyleContext; display: gdk4.Display) =
  gtk_style_context_set_display(cast[ptr StyleContext00](self.impl), cast[ptr gdk4.Display00](display.impl))

proc gtk_style_context_set_scale(self: ptr StyleContext00; scale: int32) {.
    importc, libprag.}

proc setScale*(self: StyleContext; scale: int) =
  gtk_style_context_set_scale(cast[ptr StyleContext00](self.impl), int32(scale))

proc `scale=`*(self: StyleContext; scale: int) =
  gtk_style_context_set_scale(cast[ptr StyleContext00](self.impl), int32(scale))

proc gtk_style_context_set_state(self: ptr StyleContext00; flags: StateFlags) {.
    importc, libprag.}

proc setState*(self: StyleContext; flags: StateFlags) =
  gtk_style_context_set_state(cast[ptr StyleContext00](self.impl), flags)

proc `state=`*(self: StyleContext; flags: StateFlags) =
  gtk_style_context_set_state(cast[ptr StyleContext00](self.impl), flags)

proc gtk_widget_get_style_context(self: ptr Widget00): ptr StyleContext00 {.
    importc, libprag.}

proc getStyleContext*(self: Widget): StyleContext =
  let gobj = gtk_widget_get_style_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc styleContext*(self: Widget): StyleContext =
  let gobj = gtk_widget_get_style_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Border* {.pure, byRef.} = object
    left*: int16
    right*: int16
    top*: int16
    bottom*: int16

proc gtk_border_get_type*(): GType {.importc, libprag.}

proc gtk_border_free(self: Border) {.
    importc, libprag.}

proc free*(self: Border) =
  gtk_border_free(self)

proc gtk_border_copy(self: Border): ptr Border {.
    importc, libprag.}

proc copy*(self: Border): ptr Border =
  gtk_border_copy(self)

proc new*(): ptr Border {.
    importc: "gtk_border_new", libprag.}

proc gtk_style_context_get_border(self: ptr StyleContext00; border: var Border) {.
    importc, libprag.}

proc getBorder*(self: StyleContext; border: var Border) =
  gtk_style_context_get_border(cast[ptr StyleContext00](self.impl), border)

proc getBorder*(self: StyleContext): Border =
  gtk_style_context_get_border(cast[ptr StyleContext00](self.impl), result)

proc gtk_style_context_get_margin(self: ptr StyleContext00; margin: var Border) {.
    importc, libprag.}

proc getMargin*(self: StyleContext; margin: var Border) =
  gtk_style_context_get_margin(cast[ptr StyleContext00](self.impl), margin)

proc getMargin*(self: StyleContext): Border =
  gtk_style_context_get_margin(cast[ptr StyleContext00](self.impl), result)

proc gtk_style_context_get_padding(self: ptr StyleContext00; padding: var Border) {.
    importc, libprag.}

proc getPadding*(self: StyleContext; padding: var Border) =
  gtk_style_context_get_padding(cast[ptr StyleContext00](self.impl), padding)

proc getPadding*(self: StyleContext): Border =
  gtk_style_context_get_padding(cast[ptr StyleContext00](self.impl), result)

type
  CssSection00* {.pure.} = object
  CssSection* = ref object
    impl*: ptr CssSection00
    ignoreFinalizer*: bool

proc gtk_css_section_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkCssSection*(self: CssSection) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_css_section_get_type(), cast[ptr CssSection00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CssSection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_css_section_get_type(), cast[ptr CssSection00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var CssSection) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkCssSection)

proc gtk_css_section_unref(self: ptr CssSection00) {.
    importc, libprag.}

proc unref*(self: CssSection) =
  gtk_css_section_unref(cast[ptr CssSection00](g_boxed_copy(gtk_css_section_get_type(), self.impl)))

proc finalizerunref*(self: CssSection) =
  if not self.ignoreFinalizer:
    gtk_css_section_unref(cast[ptr CssSection00](self.impl))

proc gtk_css_section_get_file(self: ptr CssSection00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: CssSection): gio.GFile =
  let gobj = gtk_css_section_get_file(cast[ptr CssSection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: CssSection): gio.GFile =
  let gobj = gtk_css_section_get_file(cast[ptr CssSection00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_css_section_get_parent(self: ptr CssSection00): ptr CssSection00 {.
    importc, libprag.}

proc getParent*(self: CssSection): CssSection =
  let impl0 = gtk_css_section_get_parent(cast[ptr CssSection00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_css_section_get_type(), impl0))

proc parent*(self: CssSection): CssSection =
  let impl0 = gtk_css_section_get_parent(cast[ptr CssSection00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_css_section_get_type(), impl0))

proc gtk_css_section_print(self: ptr CssSection00; string: glib.String) {.
    importc, libprag.}

proc print*(self: CssSection; string: glib.String) =
  gtk_css_section_print(cast[ptr CssSection00](self.impl), string)

proc gtk_css_section_ref(self: ptr CssSection00): ptr CssSection00 {.
    importc, libprag.}

proc `ref`*(self: CssSection): CssSection =
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = gtk_css_section_ref(cast[ptr CssSection00](self.impl))

proc gtk_css_section_to_string(self: ptr CssSection00): cstring {.
    importc, libprag.}

proc toString*(self: CssSection): string =
  let resul0 = gtk_css_section_to_string(cast[ptr CssSection00](self.impl))
  result = $resul0
  cogfree(resul0)

type
  CssProvider* = ref object of gobject.Object
  CssProvider00* = object of gobject.Object00

proc gtk_css_provider_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CssProvider()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scParsingError*(self: CssProvider;  p: proc (self: ptr CssProvider00; section: ptr CssSection00; error: ptr glib.Error; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "parsing-error", cast[GCallback](p), xdata, nil, cf)

proc gtk_css_provider_new(): ptr CssProvider00 {.
    importc, libprag.}

proc newCssProvider*(): CssProvider =
  let gobj = gtk_css_provider_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCssProvider*(tdesc: typedesc): tdesc =
  assert(result is CssProvider)
  let gobj = gtk_css_provider_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCssProvider*[T](result: var T) {.deprecated.} =
  assert(result is CssProvider)
  let gobj = gtk_css_provider_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_css_provider_load_from_bytes(self: ptr CssProvider00; data: ptr glib.Bytes00) {.
    importc, libprag.}

proc loadFromBytes*(self: CssProvider; data: glib.Bytes) =
  gtk_css_provider_load_from_bytes(cast[ptr CssProvider00](self.impl), cast[ptr glib.Bytes00](data.impl))

proc gtk_css_provider_load_from_data(self: ptr CssProvider00; data: cstring;
    length: int64) {.
    importc, libprag.}

proc loadFromData*(self: CssProvider; data: cstring; length: int64) =
  gtk_css_provider_load_from_data(cast[ptr CssProvider00](self.impl), data, length)

proc gtk_css_provider_load_from_file(self: ptr CssProvider00; file: ptr gio.GFile00) {.
    importc, libprag.}

proc loadFromFile*(self: CssProvider; file: gio.GFile) =
  gtk_css_provider_load_from_file(cast[ptr CssProvider00](self.impl), cast[ptr gio.GFile00](file.impl))

proc gtk_css_provider_load_from_path(self: ptr CssProvider00; path: cstring) {.
    importc, libprag.}

proc loadFromPath*(self: CssProvider; path: cstring) =
  gtk_css_provider_load_from_path(cast[ptr CssProvider00](self.impl), path)

proc gtk_css_provider_load_from_resource(self: ptr CssProvider00; resourcePath: cstring) {.
    importc, libprag.}

proc loadFromResource*(self: CssProvider; resourcePath: cstring) =
  gtk_css_provider_load_from_resource(cast[ptr CssProvider00](self.impl), resourcePath)

proc gtk_css_provider_load_from_string(self: ptr CssProvider00; string: cstring) {.
    importc, libprag.}

proc loadFromString*(self: CssProvider; string: cstring) =
  gtk_css_provider_load_from_string(cast[ptr CssProvider00](self.impl), string)

proc gtk_css_provider_load_named(self: ptr CssProvider00; name: cstring;
    variant: cstring) {.
    importc, libprag.}

proc loadNamed*(self: CssProvider; name: cstring; variant: cstring = nil) =
  gtk_css_provider_load_named(cast[ptr CssProvider00](self.impl), name, variant)

proc gtk_css_provider_to_string(self: ptr CssProvider00): cstring {.
    importc, libprag.}

proc toString*(self: CssProvider): string =
  let resul0 = gtk_css_provider_to_string(cast[ptr CssProvider00](self.impl))
  result = $resul0
  cogfree(resul0)

type
  StyleProvider00* = object of gobject.Object00
  StyleProvider* = ref object of gobject.Object

proc scGtkPrivateChanged*(self: StyleProvider | Settings | CssProvider;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "gtk-private-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_style_context_add_provider_for_display(display: ptr gdk4.Display00;
    provider: ptr StyleProvider00; priority: uint32) {.
    importc, libprag.}

proc addProviderForDisplay*(display: gdk4.Display; provider: StyleProvider | Settings | CssProvider;
    priority: int) =
  gtk_style_context_add_provider_for_display(cast[ptr gdk4.Display00](display.impl), cast[ptr StyleProvider00](provider.impl), uint32(priority))

proc gtk_style_context_remove_provider_for_display(display: ptr gdk4.Display00;
    provider: ptr StyleProvider00) {.
    importc, libprag.}

proc removeProviderForDisplay*(display: gdk4.Display;
    provider: StyleProvider | Settings | CssProvider) =
  gtk_style_context_remove_provider_for_display(cast[ptr gdk4.Display00](display.impl), cast[ptr StyleProvider00](provider.impl))

proc gtk_style_context_add_provider(self: ptr StyleContext00; provider: ptr StyleProvider00;
    priority: uint32) {.
    importc, libprag.}

proc addProvider*(self: StyleContext; provider: StyleProvider | Settings | CssProvider;
    priority: int) =
  gtk_style_context_add_provider(cast[ptr StyleContext00](self.impl), cast[ptr StyleProvider00](provider.impl), uint32(priority))

proc gtk_style_context_remove_provider(self: ptr StyleContext00; provider: ptr StyleProvider00) {.
    importc, libprag.}

proc removeProvider*(self: StyleContext; provider: StyleProvider | Settings | CssProvider) =
  gtk_style_context_remove_provider(cast[ptr StyleContext00](self.impl), cast[ptr StyleProvider00](provider.impl))

type
  CssLocation* {.pure, byRef.} = object
    bytes*: uint64
    chars*: uint64
    lines*: uint64
    lineBytes*: uint64
    lineChars*: uint64

proc gtk_css_section_get_end_location(self: ptr CssSection00): ptr CssLocation {.
    importc, libprag.}

proc getEndLocation*(self: CssSection): ptr CssLocation =
  gtk_css_section_get_end_location(cast[ptr CssSection00](self.impl))

proc endLocation*(self: CssSection): ptr CssLocation =
  gtk_css_section_get_end_location(cast[ptr CssSection00](self.impl))

proc gtk_css_section_get_start_location(self: ptr CssSection00): ptr CssLocation {.
    importc, libprag.}

proc getStartLocation*(self: CssSection): ptr CssLocation =
  gtk_css_section_get_start_location(cast[ptr CssSection00](self.impl))

proc startLocation*(self: CssSection): ptr CssLocation =
  gtk_css_section_get_start_location(cast[ptr CssSection00](self.impl))

proc gtk_css_section_new(file: ptr gio.GFile00; start: CssLocation; `end`: CssLocation): ptr CssSection00 {.
    importc, libprag.}

proc newCssSection*(file: gio.GFile = nil; start: CssLocation; `end`: CssLocation): CssSection =
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = gtk_css_section_new(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl), start, `end`)

proc newCssSection*(tdesc: typedesc; file: gio.GFile = nil; start: CssLocation; `end`: CssLocation): tdesc =
  assert(result is CssSection)
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = gtk_css_section_new(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl), start, `end`)

proc initCssSection*[T](result: var T; file: gio.GFile = nil; start: CssLocation; `end`: CssLocation) {.deprecated.} =
  assert(result is CssSection)
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = gtk_css_section_new(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl), start, `end`)

type
  StyleContextPrintFlag* {.size: sizeof(cint), pure.} = enum
    recurse = 0
    showStyle = 1
    showChange = 2

  StyleContextPrintFlags* = set[StyleContextPrintFlag]

const
  StyleContextPrintFlagsNone* = StyleContextPrintFlags({})
proc none*(t: typedesc[StyleContextPrintFlags]): StyleContextPrintFlags = StyleContextPrintFlags({})

proc gtk_style_context_to_string(self: ptr StyleContext00; flags: StyleContextPrintFlags): cstring {.
    importc, libprag.}

proc toString*(self: StyleContext; flags: StyleContextPrintFlags): string =
  let resul0 = gtk_style_context_to_string(cast[ptr StyleContext00](self.impl), flags)
  result = $resul0
  cogfree(resul0)

type
  Orientation* {.size: sizeof(cint), pure.} = enum
    horizontal = 0
    vertical = 1

proc gtk_widget_compute_expand(self: ptr Widget00; orientation: Orientation): gboolean {.
    importc, libprag.}

proc computeExpand*(self: Widget; orientation: Orientation): bool =
  toBool(gtk_widget_compute_expand(cast[ptr Widget00](self.impl), orientation))

proc gtk_widget_get_size(self: ptr Widget00; orientation: Orientation): int32 {.
    importc, libprag.}

proc getSize*(self: Widget; orientation: Orientation): int =
  int(gtk_widget_get_size(cast[ptr Widget00](self.impl), orientation))

proc gtk_widget_measure(self: ptr Widget00; orientation: Orientation; forSize: int32;
    minimum: var int32; natural: var int32; minimumBaseline: var int32; naturalBaseline: var int32) {.
    importc, libprag.}

proc measure*(self: Widget; orientation: Orientation; forSize: int;
    minimum: var int = cast[var int](nil); natural: var int = cast[var int](nil);
    minimumBaseline: var int = cast[var int](nil); naturalBaseline: var int = cast[var int](nil)) =
  var natural_00: int32
  var minimum_00: int32
  var naturalBaseline_00: int32
  var minimumBaseline_00: int32
  gtk_widget_measure(cast[ptr Widget00](self.impl), orientation, int32(forSize), minimum_00, natural_00, minimumBaseline_00, naturalBaseline_00)
  if natural.addr != nil:
    natural = int(natural_00)
  if minimum.addr != nil:
    minimum = int(minimum_00)
  if naturalBaseline.addr != nil:
    naturalBaseline = int(naturalBaseline_00)
  if minimumBaseline.addr != nil:
    minimumBaseline = int(minimumBaseline_00)

proc gtk_scale_new(orientation: Orientation; adjustment: ptr Adjustment00): ptr Scale00 {.
    importc, libprag.}

proc newScale*(orientation: Orientation; adjustment: Adjustment = nil): Scale =
  let gobj = gtk_scale_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScale*(tdesc: typedesc; orientation: Orientation; adjustment: Adjustment = nil): tdesc =
  assert(result is Scale)
  let gobj = gtk_scale_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScale*[T](result: var T; orientation: Orientation; adjustment: Adjustment = nil) {.deprecated.} =
  assert(result is Scale)
  let gobj = gtk_scale_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_new_with_range(orientation: Orientation; min: cdouble; max: cdouble;
    step: cdouble): ptr Scale00 {.
    importc, libprag.}

proc newScaleWithRange*(orientation: Orientation; min: cdouble; max: cdouble;
    step: cdouble): Scale =
  let gobj = gtk_scale_new_with_range(orientation, min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScaleWithRange*(tdesc: typedesc; orientation: Orientation; min: cdouble; max: cdouble;
    step: cdouble): tdesc =
  assert(result is Scale)
  let gobj = gtk_scale_new_with_range(orientation, min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScaleWithRange*[T](result: var T; orientation: Orientation; min: cdouble; max: cdouble;
    step: cdouble) {.deprecated.} =
  assert(result is Scale)
  let gobj = gtk_scale_new_with_range(orientation, min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_box_new(orientation: Orientation; spacing: int32): ptr Box00 {.
    importc, libprag.}

proc newBox*(orientation: Orientation; spacing: int = 0): Box =
  let gobj = gtk_box_new(orientation, int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBox*(tdesc: typedesc; orientation: Orientation; spacing: int = 0): tdesc =
  assert(result is Box)
  let gobj = gtk_box_new(orientation, int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBox*[T](result: var T; orientation: Orientation; spacing: int = 0) {.deprecated.} =
  assert(result is Box)
  let gobj = gtk_box_new(orientation, int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_get_item_orientation(self: ptr IconView00): Orientation {.
    importc, libprag.}

proc getItemOrientation*(self: IconView): Orientation =
  gtk_icon_view_get_item_orientation(cast[ptr IconView00](self.impl))

proc itemOrientation*(self: IconView): Orientation =
  gtk_icon_view_get_item_orientation(cast[ptr IconView00](self.impl))

proc gtk_icon_view_set_item_orientation(self: ptr IconView00; orientation: Orientation) {.
    importc, libprag.}

proc setItemOrientation*(self: IconView; orientation: Orientation) =
  gtk_icon_view_set_item_orientation(cast[ptr IconView00](self.impl), orientation)

proc `itemOrientation=`*(self: IconView; orientation: Orientation) =
  gtk_icon_view_set_item_orientation(cast[ptr IconView00](self.impl), orientation)

proc gtk_paned_new(orientation: Orientation): ptr Paned00 {.
    importc, libprag.}

proc newPaned*(orientation: Orientation): Paned =
  let gobj = gtk_paned_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPaned*(tdesc: typedesc; orientation: Orientation): tdesc =
  assert(result is Paned)
  let gobj = gtk_paned_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPaned*[T](result: var T; orientation: Orientation) {.deprecated.} =
  assert(result is Paned)
  let gobj = gtk_paned_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrollbar_new(orientation: Orientation; adjustment: ptr Adjustment00): ptr Scrollbar00 {.
    importc, libprag.}

proc newScrollbar*(orientation: Orientation; adjustment: Adjustment = nil): Scrollbar =
  let gobj = gtk_scrollbar_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScrollbar*(tdesc: typedesc; orientation: Orientation; adjustment: Adjustment = nil): tdesc =
  assert(result is Scrollbar)
  let gobj = gtk_scrollbar_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScrollbar*[T](result: var T; orientation: Orientation; adjustment: Adjustment = nil) {.deprecated.} =
  assert(result is Scrollbar)
  let gobj = gtk_scrollbar_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_separator_new(orientation: Orientation): ptr Separator00 {.
    importc, libprag.}

proc newSeparator*(orientation: Orientation): Separator =
  let gobj = gtk_separator_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSeparator*(tdesc: typedesc; orientation: Orientation): tdesc =
  assert(result is Separator)
  let gobj = gtk_separator_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSeparator*[T](result: var T; orientation: Orientation) {.deprecated.} =
  assert(result is Separator)
  let gobj = gtk_separator_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_request_renderer(self: ptr CellArea00; renderer: ptr CellRenderer00;
    orientation: Orientation; widget: ptr Widget00; forSize: int32; minimumSize: var int32;
    naturalSize: var int32) {.
    importc, libprag.}

proc requestRenderer*(self: CellArea; renderer: CellRenderer;
    orientation: Orientation; widget: Widget; forSize: int; minimumSize: var int = cast[var int](nil);
    naturalSize: var int = cast[var int](nil)) =
  var minimumSize_00: int32
  var naturalSize_00: int32
  gtk_cell_area_request_renderer(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), orientation, cast[ptr Widget00](widget.impl), int32(forSize), minimumSize_00, naturalSize_00)
  if minimumSize.addr != nil:
    minimumSize = int(minimumSize_00)
  if naturalSize.addr != nil:
    naturalSize = int(naturalSize_00)

type
  PickFlag* {.size: sizeof(cint), pure.} = enum
    insensitive = 0
    nonTargetable = 1

  PickFlags* = set[PickFlag]

const
  PickFlagsDefault* = PickFlags({})
proc default*(t: typedesc[PickFlags]): PickFlags = PickFlags({})

proc gtk_widget_pick(self: ptr Widget00; x: cdouble; y: cdouble; flags: PickFlags): ptr Widget00 {.
    importc, libprag.}

proc pick*(self: Widget; x: cdouble; y: cdouble; flags: PickFlags): Widget =
  let gobj = gtk_widget_pick(cast[ptr Widget00](self.impl), x, y, flags)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  EventController* = ref object of gobject.Object
  EventController00* = object of gobject.Object00

proc gtk_event_controller_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventController()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_event_controller_get_current_event(self: ptr EventController00): ptr gdk4.Event00 {.
    importc, libprag.}

proc getCurrentEvent*(self: EventController): gdk4.Event =
  let impl0 = gtk_event_controller_get_current_event(cast[ptr EventController00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gdk_event_unref)
  result.impl = cast[typeof(result.impl)](gdk_event_ref(impl0))

proc currentEvent*(self: EventController): gdk4.Event =
  let impl0 = gtk_event_controller_get_current_event(cast[ptr EventController00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gdk_event_unref)
  result.impl = cast[typeof(result.impl)](gdk_event_ref(impl0))

proc gtk_event_controller_get_current_event_device(self: ptr EventController00): ptr gdk4.Device00 {.
    importc, libprag.}

proc getCurrentEventDevice*(self: EventController): gdk4.Device =
  let gobj = gtk_event_controller_get_current_event_device(cast[ptr EventController00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc currentEventDevice*(self: EventController): gdk4.Device =
  let gobj = gtk_event_controller_get_current_event_device(cast[ptr EventController00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_get_current_event_state(self: ptr EventController00): gdk4.ModifierType {.
    importc, libprag.}

proc getCurrentEventState*(self: EventController): gdk4.ModifierType =
  gtk_event_controller_get_current_event_state(cast[ptr EventController00](self.impl))

proc currentEventState*(self: EventController): gdk4.ModifierType =
  gtk_event_controller_get_current_event_state(cast[ptr EventController00](self.impl))

proc gtk_event_controller_get_current_event_time(self: ptr EventController00): uint32 {.
    importc, libprag.}

proc getCurrentEventTime*(self: EventController): int =
  int(gtk_event_controller_get_current_event_time(cast[ptr EventController00](self.impl)))

proc currentEventTime*(self: EventController): int =
  int(gtk_event_controller_get_current_event_time(cast[ptr EventController00](self.impl)))

proc gtk_event_controller_get_name(self: ptr EventController00): cstring {.
    importc, libprag.}

proc getName*(self: EventController): string =
  let resul0 = gtk_event_controller_get_name(cast[ptr EventController00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc name*(self: EventController): string =
  let resul0 = gtk_event_controller_get_name(cast[ptr EventController00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_event_controller_get_widget(self: ptr EventController00): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: EventController): Widget =
  let gobj = gtk_event_controller_get_widget(cast[ptr EventController00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: EventController): Widget =
  let gobj = gtk_event_controller_get_widget(cast[ptr EventController00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_reset(self: ptr EventController00) {.
    importc, libprag.}

proc reset*(self: EventController) =
  gtk_event_controller_reset(cast[ptr EventController00](self.impl))

proc gtk_event_controller_set_name(self: ptr EventController00; name: cstring) {.
    importc, libprag.}

proc setName*(self: EventController; name: cstring = nil) =
  gtk_event_controller_set_name(cast[ptr EventController00](self.impl), name)

proc `name=`*(self: EventController; name: cstring = nil) =
  gtk_event_controller_set_name(cast[ptr EventController00](self.impl), name)

proc gtk_event_controller_set_static_name(self: ptr EventController00; name: cstring) {.
    importc, libprag.}

proc setStaticName*(self: EventController; name: cstring = nil) =
  gtk_event_controller_set_static_name(cast[ptr EventController00](self.impl), name)

proc `staticName=`*(self: EventController; name: cstring = nil) =
  gtk_event_controller_set_static_name(cast[ptr EventController00](self.impl), name)

proc gtk_widget_add_controller(self: ptr Widget00; controller: ptr EventController00) {.
    importc, libprag.}

proc addController*(self: Widget; controller: EventController) =
  gtk_widget_add_controller(cast[ptr Widget00](self.impl), cast[ptr EventController00](g_object_ref(controller.impl)))

proc gtk_widget_remove_controller(self: ptr Widget00; controller: ptr EventController00) {.
    importc, libprag.}

proc removeController*(self: Widget; controller: EventController) =
  gtk_widget_remove_controller(cast[ptr Widget00](self.impl), cast[ptr EventController00](controller.impl))

type
  PropagationLimit* {.size: sizeof(cint), pure.} = enum
    none = 0
    sameNative = 1

proc gtk_event_controller_get_propagation_limit(self: ptr EventController00): PropagationLimit {.
    importc, libprag.}

proc getPropagationLimit*(self: EventController): PropagationLimit =
  gtk_event_controller_get_propagation_limit(cast[ptr EventController00](self.impl))

proc propagationLimit*(self: EventController): PropagationLimit =
  gtk_event_controller_get_propagation_limit(cast[ptr EventController00](self.impl))

proc gtk_event_controller_set_propagation_limit(self: ptr EventController00;
    limit: PropagationLimit) {.
    importc, libprag.}

proc setPropagationLimit*(self: EventController; limit: PropagationLimit) =
  gtk_event_controller_set_propagation_limit(cast[ptr EventController00](self.impl), limit)

proc `propagationLimit=`*(self: EventController; limit: PropagationLimit) =
  gtk_event_controller_set_propagation_limit(cast[ptr EventController00](self.impl), limit)

type
  PropagationPhase* {.size: sizeof(cint), pure.} = enum
    none = 0
    capture = 1
    bubble = 2
    target = 3

proc gtk_event_controller_get_propagation_phase(self: ptr EventController00): PropagationPhase {.
    importc, libprag.}

proc getPropagationPhase*(self: EventController): PropagationPhase =
  gtk_event_controller_get_propagation_phase(cast[ptr EventController00](self.impl))

proc propagationPhase*(self: EventController): PropagationPhase =
  gtk_event_controller_get_propagation_phase(cast[ptr EventController00](self.impl))

proc gtk_event_controller_set_propagation_phase(self: ptr EventController00;
    phase: PropagationPhase) {.
    importc, libprag.}

proc setPropagationPhase*(self: EventController; phase: PropagationPhase) =
  gtk_event_controller_set_propagation_phase(cast[ptr EventController00](self.impl), phase)

proc `propagationPhase=`*(self: EventController; phase: PropagationPhase) =
  gtk_event_controller_set_propagation_phase(cast[ptr EventController00](self.impl), phase)

type
  LayoutManager* = ref object of gobject.Object
  LayoutManager00* = object of gobject.Object00

proc gtk_layout_manager_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LayoutManager()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_layout_manager_allocate(self: ptr LayoutManager00; widget: ptr Widget00;
    width: int32; height: int32; baseline: int32) {.
    importc, libprag.}

proc allocate*(self: LayoutManager; widget: Widget; width: int;
    height: int; baseline: int) =
  gtk_layout_manager_allocate(cast[ptr LayoutManager00](self.impl), cast[ptr Widget00](widget.impl), int32(width), int32(height), int32(baseline))

proc gtk_layout_manager_get_request_mode(self: ptr LayoutManager00): SizeRequestMode {.
    importc, libprag.}

proc getRequestMode*(self: LayoutManager): SizeRequestMode =
  gtk_layout_manager_get_request_mode(cast[ptr LayoutManager00](self.impl))

proc requestMode*(self: LayoutManager): SizeRequestMode =
  gtk_layout_manager_get_request_mode(cast[ptr LayoutManager00](self.impl))

proc gtk_layout_manager_get_widget(self: ptr LayoutManager00): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: LayoutManager): Widget =
  let gobj = gtk_layout_manager_get_widget(cast[ptr LayoutManager00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: LayoutManager): Widget =
  let gobj = gtk_layout_manager_get_widget(cast[ptr LayoutManager00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_manager_layout_changed(self: ptr LayoutManager00) {.
    importc, libprag.}

proc layoutChanged*(self: LayoutManager) =
  gtk_layout_manager_layout_changed(cast[ptr LayoutManager00](self.impl))

proc gtk_layout_manager_measure(self: ptr LayoutManager00; widget: ptr Widget00;
    orientation: Orientation; forSize: int32; minimum: var int32; natural: var int32;
    minimumBaseline: var int32; naturalBaseline: var int32) {.
    importc, libprag.}

proc measure*(self: LayoutManager; widget: Widget; orientation: Orientation;
    forSize: int; minimum: var int = cast[var int](nil); natural: var int = cast[var int](nil);
    minimumBaseline: var int = cast[var int](nil); naturalBaseline: var int = cast[var int](nil)) =
  var natural_00: int32
  var minimum_00: int32
  var naturalBaseline_00: int32
  var minimumBaseline_00: int32
  gtk_layout_manager_measure(cast[ptr LayoutManager00](self.impl), cast[ptr Widget00](widget.impl), orientation, int32(forSize), minimum_00, natural_00, minimumBaseline_00, naturalBaseline_00)
  if natural.addr != nil:
    natural = int(natural_00)
  if minimum.addr != nil:
    minimum = int(minimum_00)
  if naturalBaseline.addr != nil:
    naturalBaseline = int(naturalBaseline_00)
  if minimumBaseline.addr != nil:
    minimumBaseline = int(minimumBaseline_00)

proc gtk_widget_get_layout_manager(self: ptr Widget00): ptr LayoutManager00 {.
    importc, libprag.}

proc getLayoutManager*(self: Widget): LayoutManager =
  let gobj = gtk_widget_get_layout_manager(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layoutManager*(self: Widget): LayoutManager =
  let gobj = gtk_widget_get_layout_manager(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_set_layout_manager(self: ptr Widget00; layoutManager: ptr LayoutManager00) {.
    importc, libprag.}

proc setLayoutManager*(self: Widget; layoutManager: LayoutManager = nil) =
  gtk_widget_set_layout_manager(cast[ptr Widget00](self.impl), if layoutManager.isNil: nil else: cast[ptr LayoutManager00](g_object_ref(layoutManager.impl)))

proc `layoutManager=`*(self: Widget; layoutManager: LayoutManager = nil) =
  gtk_widget_set_layout_manager(cast[ptr Widget00](self.impl), if layoutManager.isNil: nil else: cast[ptr LayoutManager00](g_object_ref(layoutManager.impl)))

type
  LayoutChild* = ref object of gobject.Object
  LayoutChild00* = object of gobject.Object00

proc gtk_layout_child_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LayoutChild()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_layout_child_get_child_widget(self: ptr LayoutChild00): ptr Widget00 {.
    importc, libprag.}

proc getChildWidget*(self: LayoutChild): Widget =
  let gobj = gtk_layout_child_get_child_widget(cast[ptr LayoutChild00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc childWidget*(self: LayoutChild): Widget =
  let gobj = gtk_layout_child_get_child_widget(cast[ptr LayoutChild00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_child_get_layout_manager(self: ptr LayoutChild00): ptr LayoutManager00 {.
    importc, libprag.}

proc getLayoutManager*(self: LayoutChild): LayoutManager =
  let gobj = gtk_layout_child_get_layout_manager(cast[ptr LayoutChild00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layoutManager*(self: LayoutChild): LayoutManager =
  let gobj = gtk_layout_child_get_layout_manager(cast[ptr LayoutChild00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_manager_get_layout_child(self: ptr LayoutManager00; child: ptr Widget00): ptr LayoutChild00 {.
    importc, libprag.}

proc getLayoutChild*(self: LayoutManager; child: Widget): LayoutChild =
  let gobj = gtk_layout_manager_get_layout_child(cast[ptr LayoutManager00](self.impl), cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Overflow* {.size: sizeof(cint), pure.} = enum
    visible = 0
    hidden = 1

proc gtk_widget_get_overflow(self: ptr Widget00): Overflow {.
    importc, libprag.}

proc getOverflow*(self: Widget): Overflow =
  gtk_widget_get_overflow(cast[ptr Widget00](self.impl))

proc overflow*(self: Widget): Overflow =
  gtk_widget_get_overflow(cast[ptr Widget00](self.impl))

proc gtk_widget_set_overflow(self: ptr Widget00; overflow: Overflow) {.
    importc, libprag.}

proc setOverflow*(self: Widget; overflow: Overflow) =
  gtk_widget_set_overflow(cast[ptr Widget00](self.impl), overflow)

proc `overflow=`*(self: Widget; overflow: Overflow) =
  gtk_widget_set_overflow(cast[ptr Widget00](self.impl), overflow)

type
  Align* {.size: sizeof(cint), pure.} = enum
    fill = 0
    start = 1
    `end` = 2
    center = 3
    baseline = 4
    baselineCenter = 5

const
  AlignBaselineFill* = Align.baseline

proc gtk_widget_get_halign(self: ptr Widget00): Align {.
    importc, libprag.}

proc getHalign*(self: Widget): Align =
  gtk_widget_get_halign(cast[ptr Widget00](self.impl))

proc halign*(self: Widget): Align =
  gtk_widget_get_halign(cast[ptr Widget00](self.impl))

proc gtk_widget_get_valign(self: ptr Widget00): Align {.
    importc, libprag.}

proc getValign*(self: Widget): Align =
  gtk_widget_get_valign(cast[ptr Widget00](self.impl))

proc valign*(self: Widget): Align =
  gtk_widget_get_valign(cast[ptr Widget00](self.impl))

proc gtk_widget_set_halign(self: ptr Widget00; align: Align) {.
    importc, libprag.}

proc setHalign*(self: Widget; align: Align) =
  gtk_widget_set_halign(cast[ptr Widget00](self.impl), align)

proc `halign=`*(self: Widget; align: Align) =
  gtk_widget_set_halign(cast[ptr Widget00](self.impl), align)

proc gtk_widget_set_valign(self: ptr Widget00; align: Align) {.
    importc, libprag.}

proc setValign*(self: Widget; align: Align) =
  gtk_widget_set_valign(cast[ptr Widget00](self.impl), align)

proc `valign=`*(self: Widget; align: Align) =
  gtk_widget_set_valign(cast[ptr Widget00](self.impl), align)

type
  Snapshot* = ref object of gdk4.Snapshot
  Snapshot00* = object of gdk4.Snapshot00

proc gtk_snapshot_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Snapshot()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_snapshot_new(): ptr Snapshot00 {.
    importc, libprag.}

proc newSnapshot*(): Snapshot =
  let gobj = gtk_snapshot_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSnapshot*(tdesc: typedesc): tdesc =
  assert(result is Snapshot)
  let gobj = gtk_snapshot_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSnapshot*[T](result: var T) {.deprecated.} =
  assert(result is Snapshot)
  let gobj = gtk_snapshot_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_snapshot_append_border(self: ptr Snapshot00; outline: gsk.RoundedRect;
    borderWidth: ptr array[4, cfloat]; borderColor: ptr array[4, gdk4.RGBA]) {.
    importc, libprag.}

proc appendBorder*(self: Snapshot; outline: gsk.RoundedRect;
    borderWidth: ptr array[4, cfloat]; borderColor: ptr array[4, gdk4.RGBA]) =
  gtk_snapshot_append_border(cast[ptr Snapshot00](self.impl), outline, borderWidth, borderColor)

proc gtk_snapshot_append_cairo(self: ptr Snapshot00; bounds: graphene.Rect): ptr cairo.Context00 {.
    importc, libprag.}

proc appendCairo*(self: Snapshot; bounds: graphene.Rect): cairo.Context =
  fnew(result, gBoxedFreeCairoContext)
  result.impl = gtk_snapshot_append_cairo(cast[ptr Snapshot00](self.impl), bounds)

proc gtk_snapshot_append_color(self: ptr Snapshot00; color: gdk4.RGBA; bounds: graphene.Rect) {.
    importc, libprag.}

proc appendColor*(self: Snapshot; color: gdk4.RGBA; bounds: graphene.Rect) =
  gtk_snapshot_append_color(cast[ptr Snapshot00](self.impl), color, bounds)

proc gtk_snapshot_append_conic_gradient(self: ptr Snapshot00; bounds: graphene.Rect;
    center: graphene.Point; rotation: cfloat; stops: ptr gsk.ColorStop; nStops: uint64) {.
    importc, libprag.}

proc appendConicGradient*(self: Snapshot; bounds: graphene.Rect;
    center: graphene.Point; rotation: cfloat; stops: ptr gsk.ColorStop; nStops: uint64) =
  gtk_snapshot_append_conic_gradient(cast[ptr Snapshot00](self.impl), bounds, center, rotation, stops, nStops)

proc gtk_snapshot_append_fill(self: ptr Snapshot00; path: ptr gsk.Path00;
    fillRule: gsk.FillRule; color: gdk4.RGBA) {.
    importc, libprag.}

proc appendFill*(self: Snapshot; path: gsk.Path; fillRule: gsk.FillRule;
    color: gdk4.RGBA) =
  gtk_snapshot_append_fill(cast[ptr Snapshot00](self.impl), cast[ptr gsk.Path00](path.impl), fillRule, color)

proc gtk_snapshot_append_inset_shadow(self: ptr Snapshot00; outline: gsk.RoundedRect;
    color: gdk4.RGBA; dx: cfloat; dy: cfloat; spread: cfloat; blurRadius: cfloat) {.
    importc, libprag.}

proc appendInsetShadow*(self: Snapshot; outline: gsk.RoundedRect;
    color: gdk4.RGBA; dx: cfloat; dy: cfloat; spread: cfloat; blurRadius: cfloat) =
  gtk_snapshot_append_inset_shadow(cast[ptr Snapshot00](self.impl), outline, color, dx, dy, spread, blurRadius)

proc gtk_snapshot_append_layout(self: ptr Snapshot00; layout: ptr pango.Layout00;
    color: gdk4.RGBA) {.
    importc, libprag.}

proc appendLayout*(self: Snapshot; layout: pango.Layout; color: gdk4.RGBA) =
  gtk_snapshot_append_layout(cast[ptr Snapshot00](self.impl), cast[ptr pango.Layout00](layout.impl), color)

proc gtk_snapshot_append_linear_gradient(self: ptr Snapshot00; bounds: graphene.Rect;
    startPoint: graphene.Point; endPoint: graphene.Point; stops: ptr gsk.ColorStop;
    nStops: uint64) {.
    importc, libprag.}

proc appendLinearGradient*(self: Snapshot; bounds: graphene.Rect;
    startPoint: graphene.Point; endPoint: graphene.Point; stops: ptr gsk.ColorStop;
    nStops: uint64) =
  gtk_snapshot_append_linear_gradient(cast[ptr Snapshot00](self.impl), bounds, startPoint, endPoint, stops, nStops)

proc gtk_snapshot_append_node(self: ptr Snapshot00; node: ptr gsk.RenderNode00) {.
    importc, libprag.}

proc appendNode*(self: Snapshot; node: gsk.RenderNode) =
  gtk_snapshot_append_node(cast[ptr Snapshot00](self.impl), cast[ptr gsk.RenderNode00](node.impl))

proc gtk_snapshot_append_outset_shadow(self: ptr Snapshot00; outline: gsk.RoundedRect;
    color: gdk4.RGBA; dx: cfloat; dy: cfloat; spread: cfloat; blurRadius: cfloat) {.
    importc, libprag.}

proc appendOutsetShadow*(self: Snapshot; outline: gsk.RoundedRect;
    color: gdk4.RGBA; dx: cfloat; dy: cfloat; spread: cfloat; blurRadius: cfloat) =
  gtk_snapshot_append_outset_shadow(cast[ptr Snapshot00](self.impl), outline, color, dx, dy, spread, blurRadius)

proc gtk_snapshot_append_radial_gradient(self: ptr Snapshot00; bounds: graphene.Rect;
    center: graphene.Point; hradius: cfloat; vradius: cfloat; start: cfloat;
    `end`: cfloat; stops: ptr gsk.ColorStop; nStops: uint64) {.
    importc, libprag.}

proc appendRadialGradient*(self: Snapshot; bounds: graphene.Rect;
    center: graphene.Point; hradius: cfloat; vradius: cfloat; start: cfloat;
    `end`: cfloat; stops: ptr gsk.ColorStop; nStops: uint64) =
  gtk_snapshot_append_radial_gradient(cast[ptr Snapshot00](self.impl), bounds, center, hradius, vradius, start, `end`, stops, nStops)

proc gtk_snapshot_append_repeating_linear_gradient(self: ptr Snapshot00;
    bounds: graphene.Rect; startPoint: graphene.Point; endPoint: graphene.Point;
    stops: ptr gsk.ColorStop; nStops: uint64) {.
    importc, libprag.}

proc appendRepeatingLinearGradient*(self: Snapshot; bounds: graphene.Rect;
    startPoint: graphene.Point; endPoint: graphene.Point; stops: ptr gsk.ColorStop;
    nStops: uint64) =
  gtk_snapshot_append_repeating_linear_gradient(cast[ptr Snapshot00](self.impl), bounds, startPoint, endPoint, stops, nStops)

proc gtk_snapshot_append_repeating_radial_gradient(self: ptr Snapshot00;
    bounds: graphene.Rect; center: graphene.Point; hradius: cfloat; vradius: cfloat;
    start: cfloat; `end`: cfloat; stops: ptr gsk.ColorStop; nStops: uint64) {.
    importc, libprag.}

proc appendRepeatingRadialGradient*(self: Snapshot; bounds: graphene.Rect;
    center: graphene.Point; hradius: cfloat; vradius: cfloat; start: cfloat;
    `end`: cfloat; stops: ptr gsk.ColorStop; nStops: uint64) =
  gtk_snapshot_append_repeating_radial_gradient(cast[ptr Snapshot00](self.impl), bounds, center, hradius, vradius, start, `end`, stops, nStops)

proc gtk_snapshot_append_scaled_texture(self: ptr Snapshot00; texture: ptr gdk4.Texture00;
    filter: gsk.ScalingFilter; bounds: graphene.Rect) {.
    importc, libprag.}

proc appendScaledTexture*(self: Snapshot; texture: gdk4.Texture;
    filter: gsk.ScalingFilter; bounds: graphene.Rect) =
  gtk_snapshot_append_scaled_texture(cast[ptr Snapshot00](self.impl), cast[ptr gdk4.Texture00](texture.impl), filter, bounds)

proc gtk_snapshot_append_stroke(self: ptr Snapshot00; path: ptr gsk.Path00;
    stroke: ptr gsk.Stroke00; color: gdk4.RGBA) {.
    importc, libprag.}

proc appendStroke*(self: Snapshot; path: gsk.Path; stroke: gsk.Stroke;
    color: gdk4.RGBA) =
  gtk_snapshot_append_stroke(cast[ptr Snapshot00](self.impl), cast[ptr gsk.Path00](path.impl), cast[ptr gsk.Stroke00](stroke.impl), color)

proc gtk_snapshot_append_texture(self: ptr Snapshot00; texture: ptr gdk4.Texture00;
    bounds: graphene.Rect) {.
    importc, libprag.}

proc appendTexture*(self: Snapshot; texture: gdk4.Texture; bounds: graphene.Rect) =
  gtk_snapshot_append_texture(cast[ptr Snapshot00](self.impl), cast[ptr gdk4.Texture00](texture.impl), bounds)

proc gtk_snapshot_gl_shader_pop_texture(self: ptr Snapshot00) {.
    importc, libprag.}

proc glShaderPopTexture*(self: Snapshot) =
  gtk_snapshot_gl_shader_pop_texture(cast[ptr Snapshot00](self.impl))

proc gtk_snapshot_perspective(self: ptr Snapshot00; depth: cfloat) {.
    importc, libprag.}

proc perspective*(self: Snapshot; depth: cfloat) =
  gtk_snapshot_perspective(cast[ptr Snapshot00](self.impl), depth)

proc gtk_snapshot_pop(self: ptr Snapshot00) {.
    importc, libprag.}

proc pop*(self: Snapshot) =
  gtk_snapshot_pop(cast[ptr Snapshot00](self.impl))

proc gtk_snapshot_push_blend(self: ptr Snapshot00; blendMode: gsk.BlendMode) {.
    importc, libprag.}

proc pushBlend*(self: Snapshot; blendMode: gsk.BlendMode) =
  gtk_snapshot_push_blend(cast[ptr Snapshot00](self.impl), blendMode)

proc gtk_snapshot_push_blur(self: ptr Snapshot00; radius: cdouble) {.
    importc, libprag.}

proc pushBlur*(self: Snapshot; radius: cdouble) =
  gtk_snapshot_push_blur(cast[ptr Snapshot00](self.impl), radius)

proc gtk_snapshot_push_clip(self: ptr Snapshot00; bounds: graphene.Rect) {.
    importc, libprag.}

proc pushClip*(self: Snapshot; bounds: graphene.Rect) =
  gtk_snapshot_push_clip(cast[ptr Snapshot00](self.impl), bounds)

proc gtk_snapshot_push_color_matrix(self: ptr Snapshot00; colorMatrix: graphene.Matrix;
    colorOffset: graphene.Vec4) {.
    importc, libprag.}

proc pushColorMatrix*(self: Snapshot; colorMatrix: graphene.Matrix;
    colorOffset: graphene.Vec4) =
  gtk_snapshot_push_color_matrix(cast[ptr Snapshot00](self.impl), colorMatrix, colorOffset)

proc gtk_snapshot_push_cross_fade(self: ptr Snapshot00; progress: cdouble) {.
    importc, libprag.}

proc pushCrossFade*(self: Snapshot; progress: cdouble) =
  gtk_snapshot_push_cross_fade(cast[ptr Snapshot00](self.impl), progress)

proc gtk_snapshot_push_fill(self: ptr Snapshot00; path: ptr gsk.Path00; fillRule: gsk.FillRule) {.
    importc, libprag.}

proc pushFill*(self: Snapshot; path: gsk.Path; fillRule: gsk.FillRule) =
  gtk_snapshot_push_fill(cast[ptr Snapshot00](self.impl), cast[ptr gsk.Path00](path.impl), fillRule)

proc gtk_snapshot_push_gl_shader(self: ptr Snapshot00; shader: ptr gsk.GLShader00;
    bounds: graphene.Rect; takeArgs: ptr glib.Bytes00) {.
    importc, libprag.}

proc pushGlShader*(self: Snapshot; shader: gsk.GLShader; bounds: graphene.Rect;
    takeArgs: glib.Bytes) =
  gtk_snapshot_push_gl_shader(cast[ptr Snapshot00](self.impl), cast[ptr gsk.GLShader00](shader.impl), bounds, cast[ptr glib.Bytes00](g_boxed_copy(g_bytes_get_type(), takeArgs.impl)))

proc gtk_snapshot_push_mask(self: ptr Snapshot00; maskMode: gsk.MaskMode) {.
    importc, libprag.}

proc pushMask*(self: Snapshot; maskMode: gsk.MaskMode) =
  gtk_snapshot_push_mask(cast[ptr Snapshot00](self.impl), maskMode)

proc gtk_snapshot_push_opacity(self: ptr Snapshot00; opacity: cdouble) {.
    importc, libprag.}

proc pushOpacity*(self: Snapshot; opacity: cdouble) =
  gtk_snapshot_push_opacity(cast[ptr Snapshot00](self.impl), opacity)

proc gtk_snapshot_push_repeat(self: ptr Snapshot00; bounds: graphene.Rect;
    childBounds: graphene.Rect) {.
    importc, libprag.}

proc pushRepeat*(self: Snapshot; bounds: graphene.Rect; childBounds: graphene.Rect = cast[var graphene.Rect](nil)) =
  gtk_snapshot_push_repeat(cast[ptr Snapshot00](self.impl), bounds, childBounds)

proc gtk_snapshot_push_rounded_clip(self: ptr Snapshot00; bounds: gsk.RoundedRect) {.
    importc, libprag.}

proc pushRoundedClip*(self: Snapshot; bounds: gsk.RoundedRect) =
  gtk_snapshot_push_rounded_clip(cast[ptr Snapshot00](self.impl), bounds)

proc gtk_snapshot_push_shadow(self: ptr Snapshot00; shadow: ptr gsk.Shadow;
    nShadows: uint64) {.
    importc, libprag.}

proc pushShadow*(self: Snapshot; shadow: ptr gsk.Shadow; nShadows: uint64) =
  gtk_snapshot_push_shadow(cast[ptr Snapshot00](self.impl), shadow, nShadows)

proc gtk_snapshot_push_stroke(self: ptr Snapshot00; path: ptr gsk.Path00;
    stroke: ptr gsk.Stroke00) {.
    importc, libprag.}

proc pushStroke*(self: Snapshot; path: gsk.Path; stroke: gsk.Stroke) =
  gtk_snapshot_push_stroke(cast[ptr Snapshot00](self.impl), cast[ptr gsk.Path00](path.impl), cast[ptr gsk.Stroke00](stroke.impl))

proc gtk_snapshot_render_background(self: ptr Snapshot00; context: ptr StyleContext00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderBackground*(self: Snapshot; context: StyleContext;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) =
  gtk_snapshot_render_background(cast[ptr Snapshot00](self.impl), cast[ptr StyleContext00](context.impl), x, y, width, height)

proc gtk_snapshot_render_focus(self: ptr Snapshot00; context: ptr StyleContext00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderFocus*(self: Snapshot; context: StyleContext; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_snapshot_render_focus(cast[ptr Snapshot00](self.impl), cast[ptr StyleContext00](context.impl), x, y, width, height)

proc gtk_snapshot_render_frame(self: ptr Snapshot00; context: ptr StyleContext00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderFrame*(self: Snapshot; context: StyleContext; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_snapshot_render_frame(cast[ptr Snapshot00](self.impl), cast[ptr StyleContext00](context.impl), x, y, width, height)

proc gtk_snapshot_render_insertion_cursor(self: ptr Snapshot00; context: ptr StyleContext00;
    x: cdouble; y: cdouble; layout: ptr pango.Layout00; index: int32; direction: pango.Direction) {.
    importc, libprag.}

proc renderInsertionCursor*(self: Snapshot; context: StyleContext;
    x: cdouble; y: cdouble; layout: pango.Layout; index: int; direction: pango.Direction) =
  gtk_snapshot_render_insertion_cursor(cast[ptr Snapshot00](self.impl), cast[ptr StyleContext00](context.impl), x, y, cast[ptr pango.Layout00](layout.impl), int32(index), direction)

proc gtk_snapshot_render_layout(self: ptr Snapshot00; context: ptr StyleContext00;
    x: cdouble; y: cdouble; layout: ptr pango.Layout00) {.
    importc, libprag.}

proc renderLayout*(self: Snapshot; context: StyleContext; x: cdouble;
    y: cdouble; layout: pango.Layout) =
  gtk_snapshot_render_layout(cast[ptr Snapshot00](self.impl), cast[ptr StyleContext00](context.impl), x, y, cast[ptr pango.Layout00](layout.impl))

proc gtk_snapshot_restore(self: ptr Snapshot00) {.
    importc, libprag.}

proc restore*(self: Snapshot) =
  gtk_snapshot_restore(cast[ptr Snapshot00](self.impl))

proc gtk_snapshot_rotate(self: ptr Snapshot00; angle: cfloat) {.
    importc, libprag.}

proc rotate*(self: Snapshot; angle: cfloat) =
  gtk_snapshot_rotate(cast[ptr Snapshot00](self.impl), angle)

proc gtk_snapshot_rotate_3d(self: ptr Snapshot00; angle: cfloat; axis: graphene.Vec3) {.
    importc, libprag.}

proc rotate_3d*(self: Snapshot; angle: cfloat; axis: graphene.Vec3) =
  gtk_snapshot_rotate_3d(cast[ptr Snapshot00](self.impl), angle, axis)

proc gtk_snapshot_save(self: ptr Snapshot00) {.
    importc, libprag.}

proc save*(self: Snapshot) =
  gtk_snapshot_save(cast[ptr Snapshot00](self.impl))

proc gtk_snapshot_scale(self: ptr Snapshot00; factorX: cfloat; factorY: cfloat) {.
    importc, libprag.}

proc scale*(self: Snapshot; factorX: cfloat; factorY: cfloat) =
  gtk_snapshot_scale(cast[ptr Snapshot00](self.impl), factorX, factorY)

proc gtk_snapshot_scale_3d(self: ptr Snapshot00; factorX: cfloat; factorY: cfloat;
    factorZ: cfloat) {.
    importc, libprag.}

proc scale_3d*(self: Snapshot; factorX: cfloat; factorY: cfloat;
    factorZ: cfloat) =
  gtk_snapshot_scale_3d(cast[ptr Snapshot00](self.impl), factorX, factorY, factorZ)

proc gtk_snapshot_to_node(self: ptr Snapshot00): ptr gsk.RenderNode00 {.
    importc, libprag.}

proc toNode*(self: Snapshot): gsk.RenderNode =
  let impl0 = gtk_snapshot_to_node(cast[ptr Snapshot00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gsk_render_node_unref)
  result.impl = impl0

proc gtk_snapshot_to_paintable(self: ptr Snapshot00; size: graphene.Size): ptr gdk4.Paintable00 {.
    importc, libprag.}

proc toPaintable*(self: Snapshot; size: graphene.Size = cast[var graphene.Size](nil)): gdk4.Paintable =
  let gobj = gtk_snapshot_to_paintable(cast[ptr Snapshot00](self.impl), size)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_snapshot_transform(self: ptr Snapshot00; transform: ptr gsk.Transform00) {.
    importc, libprag.}

proc transform*(self: Snapshot; transform: gsk.Transform = nil) =
  gtk_snapshot_transform(cast[ptr Snapshot00](self.impl), if transform.isNil: nil else: cast[ptr gsk.Transform00](transform.impl))

proc gtk_snapshot_transform_matrix(self: ptr Snapshot00; matrix: graphene.Matrix) {.
    importc, libprag.}

proc transformMatrix*(self: Snapshot; matrix: graphene.Matrix) =
  gtk_snapshot_transform_matrix(cast[ptr Snapshot00](self.impl), matrix)

proc gtk_snapshot_translate(self: ptr Snapshot00; point: graphene.Point) {.
    importc, libprag.}

proc translate*(self: Snapshot; point: graphene.Point) =
  gtk_snapshot_translate(cast[ptr Snapshot00](self.impl), point)

proc gtk_snapshot_translate_3d(self: ptr Snapshot00; point: graphene.Point3D) {.
    importc, libprag.}

proc translate_3d*(self: Snapshot; point: graphene.Point3D) =
  gtk_snapshot_translate_3d(cast[ptr Snapshot00](self.impl), point)

proc gtk_widget_snapshot_child(self: ptr Widget00; child: ptr Widget00; snapshot: ptr Snapshot00) {.
    importc, libprag.}

proc snapshotChild*(self: Widget; child: Widget; snapshot: Snapshot) =
  gtk_widget_snapshot_child(cast[ptr Widget00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Snapshot00](snapshot.impl))

proc gtk_cell_renderer_snapshot(self: ptr CellRenderer00; snapshot: ptr Snapshot00;
    widget: ptr Widget00; backgroundArea: gdk4.Rectangle; cellArea: gdk4.Rectangle;
    flags: CellRendererState) {.
    importc, libprag.}

proc snapshot*(self: CellRenderer; snapshot: Snapshot; widget: Widget;
    backgroundArea: gdk4.Rectangle; cellArea: gdk4.Rectangle; flags: CellRendererState) =
  gtk_cell_renderer_snapshot(cast[ptr CellRenderer00](self.impl), cast[ptr Snapshot00](snapshot.impl), cast[ptr Widget00](widget.impl), backgroundArea, cellArea, flags)

proc gtk_cell_area_snapshot(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; snapshot: ptr Snapshot00; backgroundArea: gdk4.Rectangle;
    cellArea: gdk4.Rectangle; flags: CellRendererState; paintFocus: gboolean) {.
    importc, libprag.}

proc snapshot*(self: CellArea; context: CellAreaContext; widget: Widget;
    snapshot: Snapshot; backgroundArea: gdk4.Rectangle; cellArea: gdk4.Rectangle;
    flags: CellRendererState; paintFocus: bool) =
  gtk_cell_area_snapshot(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr Snapshot00](snapshot.impl), backgroundArea, cellArea, flags, gboolean(paintFocus))

type
  AccessibleProperty* {.size: sizeof(cint), pure.} = enum
    autocomplete = 0
    description = 1
    hasPopup = 2
    keyShortcuts = 3
    label = 4
    level = 5
    modal = 6
    multiLine = 7
    multiSelectable = 8
    orientation = 9
    placeholder = 10
    readOnly = 11
    required = 12
    roleDescription = 13
    sort = 14
    valueMax = 15
    valueMin = 16
    valueNow = 17
    valueText = 18

proc initValue*(property: AccessibleProperty; value: gobject.Value) {.
    importc: "gtk_accessible_property_init_value", libprag.}

proc gtk_accessible_reset_property(self: ptr Accessible00; property: AccessibleProperty) {.
    importc, libprag.}

proc resetProperty*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    property: AccessibleProperty) =
  gtk_accessible_reset_property(cast[ptr Accessible00](self.impl), property)

proc gtk_accessible_update_property_value(self: ptr Accessible00; nProperties: int32;
    properties: ptr AccessibleProperty; values: ptr gobject.Value) {.
    importc, libprag.}

proc updateProperty*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    nProperties: int; properties: ptr AccessibleProperty; values: ptr gobject.Value) =
  gtk_accessible_update_property_value(cast[ptr Accessible00](self.impl), int32(nProperties), properties, values)

type
  AccessibleRelation* {.size: sizeof(cint), pure.} = enum
    activeDescendant = 0
    colCount = 1
    colIndex = 2
    colIndexText = 3
    colSpan = 4
    controls = 5
    describedBy = 6
    details = 7
    errorMessage = 8
    flowTo = 9
    labelledBy = 10
    owns = 11
    posInSet = 12
    rowCount = 13
    rowIndex = 14
    rowIndexText = 15
    rowSpan = 16
    setSize = 17

proc initValue*(relation: AccessibleRelation; value: gobject.Value) {.
    importc: "gtk_accessible_relation_init_value", libprag.}

proc gtk_accessible_reset_relation(self: ptr Accessible00; relation: AccessibleRelation) {.
    importc, libprag.}

proc resetRelation*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    relation: AccessibleRelation) =
  gtk_accessible_reset_relation(cast[ptr Accessible00](self.impl), relation)

proc gtk_accessible_update_relation_value(self: ptr Accessible00; nRelations: int32;
    relations: ptr AccessibleRelation; values: ptr gobject.Value) {.
    importc, libprag.}

proc updateRelation*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    nRelations: int; relations: ptr AccessibleRelation; values: ptr gobject.Value) =
  gtk_accessible_update_relation_value(cast[ptr Accessible00](self.impl), int32(nRelations), relations, values)

type
  AccessibleState* {.size: sizeof(cint), pure.} = enum
    busy = 0
    checked = 1
    disabled = 2
    expanded = 3
    hidden = 4
    invalid = 5
    pressed = 6
    selected = 7
    visited = 8

proc initValue*(state: AccessibleState; value: gobject.Value) {.
    importc: "gtk_accessible_state_init_value", libprag.}

proc gtk_accessible_reset_state(self: ptr Accessible00; state: AccessibleState) {.
    importc, libprag.}

proc resetState*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    state: AccessibleState) =
  gtk_accessible_reset_state(cast[ptr Accessible00](self.impl), state)

proc gtk_accessible_update_state_value(self: ptr Accessible00; nStates: int32;
    states: ptr AccessibleState; values: ptr gobject.Value) {.
    importc, libprag.}

proc updateState*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    nStates: int; states: ptr AccessibleState; values: ptr gobject.Value) =
  gtk_accessible_update_state_value(cast[ptr Accessible00](self.impl), int32(nStates), states, values)

type
  AccessibleRole* {.size: sizeof(cint), pure.} = enum
    alert = 0
    alertDialog = 1
    banner = 2
    button = 3
    caption = 4
    cell = 5
    checkbox = 6
    columnHeader = 7
    comboBox = 8
    command = 9
    composite = 10
    dialog = 11
    document = 12
    feed = 13
    form = 14
    generic = 15
    grid = 16
    gridCell = 17
    group = 18
    heading = 19
    img = 20
    input = 21
    label = 22
    landmark = 23
    legend = 24
    link = 25
    list = 26
    listBox = 27
    listItem = 28
    log = 29
    main = 30
    marquee = 31
    math = 32
    meter = 33
    menu = 34
    menuBar = 35
    menuItem = 36
    menuItemCheckbox = 37
    menuItemRadio = 38
    navigation = 39
    none = 40
    note = 41
    option = 42
    presentation = 43
    progressBar = 44
    radio = 45
    radioGroup = 46
    range = 47
    region = 48
    row = 49
    rowGroup = 50
    rowHeader = 51
    scrollbar = 52
    search = 53
    searchBox = 54
    section = 55
    sectionHead = 56
    select = 57
    separator = 58
    slider = 59
    spinButton = 60
    status = 61
    structure = 62
    switch = 63
    tab = 64
    table = 65
    tabList = 66
    tabPanel = 67
    textBox = 68
    time = 69
    timer = 70
    toolbar = 71
    tooltip = 72
    tree = 73
    treeGrid = 74
    treeItem = 75
    widget = 76
    window = 77
    toggleButton = 78
    application = 79
    paragraph = 80
    blockQuote = 81
    article = 82
    comment = 83
    terminal = 84

proc gtk_at_context_create(accessibleRole: AccessibleRole; accessible: ptr Accessible00;
    display: ptr gdk4.Display00): ptr ATContext00 {.
    importc, libprag.}

proc create*(accessibleRole: AccessibleRole; accessible: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    display: gdk4.Display): ATContext =
  let gobj = gtk_at_context_create(accessibleRole, cast[ptr Accessible00](accessible.impl), cast[ptr gdk4.Display00](display.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc create*(tdesc: typedesc; accessibleRole: AccessibleRole; accessible: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    display: gdk4.Display): tdesc =
  assert(result is ATContext)
  let gobj = gtk_at_context_create(accessibleRole, cast[ptr Accessible00](accessible.impl), cast[ptr gdk4.Display00](display.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc create*[T](result: var T; accessibleRole: AccessibleRole; accessible: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    display: gdk4.Display) {.deprecated.} =
  assert(result is ATContext)
  let gobj = gtk_at_context_create(accessibleRole, cast[ptr Accessible00](accessible.impl), cast[ptr gdk4.Display00](display.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_at_context_get_accessible_role(self: ptr ATContext00): AccessibleRole {.
    importc, libprag.}

proc getAccessibleRole*(self: ATContext): AccessibleRole =
  gtk_at_context_get_accessible_role(cast[ptr ATContext00](self.impl))

proc accessibleRole*(self: ATContext): AccessibleRole =
  gtk_at_context_get_accessible_role(cast[ptr ATContext00](self.impl))

proc gtk_accessible_get_accessible_role(self: ptr Accessible00): AccessibleRole {.
    importc, libprag.}

proc getAccessibleRole*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): AccessibleRole =
  gtk_accessible_get_accessible_role(cast[ptr Accessible00](self.impl))

proc accessibleRole*(self: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): AccessibleRole =
  gtk_accessible_get_accessible_role(cast[ptr Accessible00](self.impl))

type
  AccessibleAutocomplete* {.size: sizeof(cint), pure.} = enum
    none = 0
    inline = 1
    list = 2
    both = 3

type
  AccessibleInvalidState* {.size: sizeof(cint), pure.} = enum
    false0 = 0
    true1 = 1
    grammar = 2
    spelling = 3

type
  AccessibleList00* {.pure.} = object
  AccessibleList* = ref object
    impl*: ptr AccessibleList00
    ignoreFinalizer*: bool

proc gtk_accessible_list_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkAccessibleList*(self: AccessibleList) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_accessible_list_get_type(), cast[ptr AccessibleList00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AccessibleList()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_accessible_list_get_type(), cast[ptr AccessibleList00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var AccessibleList) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkAccessibleList)

proc gtk_accessible_list_new_from_array(accessibles: ptr ptr Accessible00;
    nAccessibles: uint64): ptr AccessibleList00 {.
    importc, libprag.}

proc newAccessibleListFromArray*(accessibles: ptr ptr Accessible00;
    nAccessibles: uint64): AccessibleList =
  fnew(result, gBoxedFreeGtkAccessibleList)
  result.impl = gtk_accessible_list_new_from_array(accessibles, nAccessibles)

proc newAccessibleListFromArray*(tdesc: typedesc; accessibles: ptr ptr Accessible00;
    nAccessibles: uint64): tdesc =
  assert(result is AccessibleList)
  fnew(result, gBoxedFreeGtkAccessibleList)
  result.impl = gtk_accessible_list_new_from_array(accessibles, nAccessibles)

proc initAccessibleListFromArray*[T](result: var T; accessibles: ptr ptr Accessible00;
    nAccessibles: uint64) {.deprecated.} =
  assert(result is AccessibleList)
  fnew(result, gBoxedFreeGtkAccessibleList)
  result.impl = gtk_accessible_list_new_from_array(accessibles, nAccessibles)

proc gtk_accessible_list_new_from_list(list: ptr glib.List): ptr AccessibleList00 {.
    importc, libprag.}

proc newAccessibleListFromList*(list: seq[Accessible]): AccessibleList =
  var tempResGL = seq2GList(list)
  fnew(result, gBoxedFreeGtkAccessibleList)
  result.impl = gtk_accessible_list_new_from_list(tempResGL)

proc newAccessibleListFromList*(tdesc: typedesc; list: seq[Accessible]): tdesc =
  var tempResGL = seq2GList(list)
  assert(result is AccessibleList)
  fnew(result, gBoxedFreeGtkAccessibleList)
  result.impl = gtk_accessible_list_new_from_list(tempResGL)

proc initAccessibleListFromList*[T](result: var T; list: seq[Accessible]) {.deprecated.} =
  var tempResGL = seq2GList(list)
  assert(result is AccessibleList)
  fnew(result, gBoxedFreeGtkAccessibleList)
  result.impl = gtk_accessible_list_new_from_list(tempResGL)

proc gtk_accessible_list_get_objects(self: ptr AccessibleList00): ptr glib.List {.
    importc, libprag.}

proc getObjects*(self: AccessibleList): seq[Accessible] =
  let resul0 = gtk_accessible_list_get_objects(cast[ptr AccessibleList00](self.impl))
  result = glistObjects2seq(Accessible, resul0, false)
  g_list_free(resul0)

proc objects*(self: AccessibleList): seq[Accessible] =
  let resul0 = gtk_accessible_list_get_objects(cast[ptr AccessibleList00](self.impl))
  result = glistObjects2seq(Accessible, resul0, false)
  g_list_free(resul0)

type
  AccessibleRange00* = object of gobject.Object00
  AccessibleRange* = ref object of gobject.Object

type
  AccessibleSort* {.size: sizeof(cint), pure.} = enum
    none = 0
    ascending = 1
    descending = 2
    other = 3

type
  AccessibleText00* = object of gobject.Object00
  AccessibleText* = ref object of gobject.Object

proc gtk_accessible_text_update_caret_position(self: ptr AccessibleText00) {.
    importc, libprag.}

proc updateCaretPosition*(self: AccessibleText | Inscription | TextView | Label | Text) =
  gtk_accessible_text_update_caret_position(cast[ptr AccessibleText00](self.impl))

proc gtk_accessible_text_update_selection_bound(self: ptr AccessibleText00) {.
    importc, libprag.}

proc updateSelectionBound*(self: AccessibleText | Inscription | TextView | Label | Text) =
  gtk_accessible_text_update_selection_bound(cast[ptr AccessibleText00](self.impl))

type
  AccessibleTextContentChange* {.size: sizeof(cint), pure.} = enum
    insert = 0
    remove = 1

proc gtk_accessible_text_update_contents(self: ptr AccessibleText00; change: AccessibleTextContentChange;
    start: uint32; `end`: uint32) {.
    importc, libprag.}

proc updateContents*(self: AccessibleText | Inscription | TextView | Label | Text;
    change: AccessibleTextContentChange; start: int; `end`: int) =
  gtk_accessible_text_update_contents(cast[ptr AccessibleText00](self.impl), change, uint32(start), uint32(`end`))

type
  AccessibleTextGranularity* {.size: sizeof(cint), pure.} = enum
    character = 0
    word = 1
    sentence = 2
    line = 3
    paragraph = 4

type
  AccessibleTextRange00* {.pure.} = object
  AccessibleTextRange* = ref object
    impl*: ptr AccessibleTextRange00
    ignoreFinalizer*: bool

type
  AccessibleTristate* {.size: sizeof(cint), pure.} = enum
    false0 = 0
    true1 = 1
    mixed = 2

type
  Actionable00* = object of gobject.Object00
  Actionable* = ref object of gobject.Object

proc gtk_actionable_get_action_name(self: ptr Actionable00): cstring {.
    importc, libprag.}

proc getActionName*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch): string =
  let resul0 = gtk_actionable_get_action_name(cast[ptr Actionable00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc actionName*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch): string =
  let resul0 = gtk_actionable_get_action_name(cast[ptr Actionable00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_actionable_get_action_target_value(self: ptr Actionable00): ptr glib.Variant00 {.
    importc, libprag.}

proc getActionTargetValue*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch): glib.Variant =
  let impl0 = gtk_actionable_get_action_target_value(cast[ptr Actionable00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, finalizerunref)
  result.impl = impl0
  result.ignoreFinalizer = true # GVariant

proc actionTargetValue*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch): glib.Variant =
  let impl0 = gtk_actionable_get_action_target_value(cast[ptr Actionable00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, finalizerunref)
  result.impl = impl0
  result.ignoreFinalizer = true # GVariant

proc gtk_actionable_set_action_name(self: ptr Actionable00; actionName: cstring) {.
    importc, libprag.}

proc setActionName*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch;
    actionName: cstring = nil) =
  gtk_actionable_set_action_name(cast[ptr Actionable00](self.impl), actionName)

proc `actionName=`*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch;
    actionName: cstring = nil) =
  gtk_actionable_set_action_name(cast[ptr Actionable00](self.impl), actionName)

proc gtk_actionable_set_action_target_value(self: ptr Actionable00; targetValue: ptr glib.Variant00) {.
    importc, libprag.}

proc setActionTargetValue*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch;
    targetValue: glib.Variant = nil) =
  gtk_actionable_set_action_target_value(cast[ptr Actionable00](self.impl), if targetValue.isNil: nil else: cast[ptr glib.Variant00](targetValue.impl))

proc `actionTargetValue=`*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch;
    targetValue: glib.Variant = nil) =
  gtk_actionable_set_action_target_value(cast[ptr Actionable00](self.impl), if targetValue.isNil: nil else: cast[ptr glib.Variant00](targetValue.impl))

proc gtk_actionable_set_detailed_action_name(self: ptr Actionable00; detailedActionName: cstring) {.
    importc, libprag.}

proc setDetailedActionName*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch;
    detailedActionName: cstring) =
  gtk_actionable_set_detailed_action_name(cast[ptr Actionable00](self.impl), detailedActionName)

proc `detailedActionName=`*(self: Actionable | LinkButton | ListBoxRow | LockButton | Button | ToggleButton | CheckButton | Switch;
    detailedActionName: cstring) =
  gtk_actionable_set_detailed_action_name(cast[ptr Actionable00](self.impl), detailedActionName)

type
  ShortcutAction* = ref object of gobject.Object
  ShortcutAction00* = object of gobject.Object00

proc gtk_shortcut_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_shortcut_action_parse_string(string: cstring): ptr ShortcutAction00 {.
    importc, libprag.}

proc shortcutActionParseString*(string: cstring): ShortcutAction =
  let gobj = gtk_shortcut_action_parse_string(string)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc shortcutActionParseString*(tdesc: typedesc; string: cstring): tdesc =
  assert(result is ShortcutAction)
  let gobj = gtk_shortcut_action_parse_string(string)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc shortcutActionParseString*[T](result: var T; string: cstring) {.deprecated.} =
  assert(result is ShortcutAction)
  let gobj = gtk_shortcut_action_parse_string(string)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_action_print(self: ptr ShortcutAction00; string: glib.String) {.
    importc, libprag.}

proc print*(self: ShortcutAction; string: glib.String) =
  gtk_shortcut_action_print(cast[ptr ShortcutAction00](self.impl), string)

proc gtk_shortcut_action_to_string(self: ptr ShortcutAction00): cstring {.
    importc, libprag.}

proc toString*(self: ShortcutAction): string =
  let resul0 = gtk_shortcut_action_to_string(cast[ptr ShortcutAction00](self.impl))
  result = $resul0
  cogfree(resul0)

type
  ActivateAction* = ref object of ShortcutAction
  ActivateAction00* = object of ShortcutAction00

proc gtk_activate_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ActivateAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_activate_action_get(): ptr ActivateAction00 {.
    importc, libprag.}

proc getActivateAction*(): ActivateAction =
  let gobj = gtk_activate_action_get()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ShortcutActionFlags* {.size: sizeof(cint), pure.} = enum
    exclusive = 1

proc gtk_shortcut_action_activate(self: ptr ShortcutAction00; flags: ShortcutActionFlags;
    widget: ptr Widget00; args: ptr glib.Variant00): gboolean {.
    importc, libprag.}

proc activate*(self: ShortcutAction; flags: ShortcutActionFlags;
    widget: Widget; args: glib.Variant = nil): bool =
  toBool(gtk_shortcut_action_activate(cast[ptr ShortcutAction00](self.impl), flags, cast[ptr Widget00](widget.impl), if args.isNil: nil else: cast[ptr glib.Variant00](args.impl)))

type
  AlertDialog* = ref object of gobject.Object
  AlertDialog00* = object of gobject.Object00

proc gtk_alert_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AlertDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_alert_dialog_choose(self: ptr AlertDialog00; parent: ptr Window00;
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc choose*(self: AlertDialog; parent: Window = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_alert_dialog_choose(cast[ptr AlertDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_alert_dialog_choose_finish(self: ptr AlertDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): int32 {.
    importc, libprag.}

proc chooseFinish*(self: AlertDialog; resu: gio.AsyncResult): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_alert_dialog_choose_finish(cast[ptr AlertDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_alert_dialog_get_buttons(self: ptr AlertDialog00): ptr cstring {.
    importc, libprag.}

proc getButtons*(self: AlertDialog): seq[string] =
  let resul0 = gtk_alert_dialog_get_buttons(cast[ptr AlertDialog00](self.impl))
  if resul0.isNil:
    return
  cstringArrayToSeq(resul0)

proc buttons*(self: AlertDialog): seq[string] =
  let resul0 = gtk_alert_dialog_get_buttons(cast[ptr AlertDialog00](self.impl))
  if resul0.isNil:
    return
  cstringArrayToSeq(resul0)

proc gtk_alert_dialog_get_cancel_button(self: ptr AlertDialog00): int32 {.
    importc, libprag.}

proc getCancelButton*(self: AlertDialog): int =
  int(gtk_alert_dialog_get_cancel_button(cast[ptr AlertDialog00](self.impl)))

proc cancelButton*(self: AlertDialog): int =
  int(gtk_alert_dialog_get_cancel_button(cast[ptr AlertDialog00](self.impl)))

proc gtk_alert_dialog_get_default_button(self: ptr AlertDialog00): int32 {.
    importc, libprag.}

proc getDefaultButton*(self: AlertDialog): int =
  int(gtk_alert_dialog_get_default_button(cast[ptr AlertDialog00](self.impl)))

proc defaultButton*(self: AlertDialog): int =
  int(gtk_alert_dialog_get_default_button(cast[ptr AlertDialog00](self.impl)))

proc gtk_alert_dialog_get_detail(self: ptr AlertDialog00): cstring {.
    importc, libprag.}

proc getDetail*(self: AlertDialog): string =
  result = $gtk_alert_dialog_get_detail(cast[ptr AlertDialog00](self.impl))

proc detail*(self: AlertDialog): string =
  result = $gtk_alert_dialog_get_detail(cast[ptr AlertDialog00](self.impl))

proc gtk_alert_dialog_get_message(self: ptr AlertDialog00): cstring {.
    importc, libprag.}

proc getMessage*(self: AlertDialog): string =
  result = $gtk_alert_dialog_get_message(cast[ptr AlertDialog00](self.impl))

proc message*(self: AlertDialog): string =
  result = $gtk_alert_dialog_get_message(cast[ptr AlertDialog00](self.impl))

proc gtk_alert_dialog_get_modal(self: ptr AlertDialog00): gboolean {.
    importc, libprag.}

proc getModal*(self: AlertDialog): bool =
  toBool(gtk_alert_dialog_get_modal(cast[ptr AlertDialog00](self.impl)))

proc modal*(self: AlertDialog): bool =
  toBool(gtk_alert_dialog_get_modal(cast[ptr AlertDialog00](self.impl)))

proc gtk_alert_dialog_set_buttons(self: ptr AlertDialog00; labels: ptr cstring) {.
    importc, libprag.}

proc setButtons*(self: AlertDialog; labels: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_alert_dialog_set_buttons(cast[ptr AlertDialog00](self.impl), seq2CstringArray(labels, fs469n23))

proc `buttons=`*(self: AlertDialog; labels: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_alert_dialog_set_buttons(cast[ptr AlertDialog00](self.impl), seq2CstringArray(labels, fs469n23))

proc gtk_alert_dialog_set_cancel_button(self: ptr AlertDialog00; button: int32) {.
    importc, libprag.}

proc setCancelButton*(self: AlertDialog; button: int) =
  gtk_alert_dialog_set_cancel_button(cast[ptr AlertDialog00](self.impl), int32(button))

proc `cancelButton=`*(self: AlertDialog; button: int) =
  gtk_alert_dialog_set_cancel_button(cast[ptr AlertDialog00](self.impl), int32(button))

proc gtk_alert_dialog_set_default_button(self: ptr AlertDialog00; button: int32) {.
    importc, libprag.}

proc setDefaultButton*(self: AlertDialog; button: int) =
  gtk_alert_dialog_set_default_button(cast[ptr AlertDialog00](self.impl), int32(button))

proc `defaultButton=`*(self: AlertDialog; button: int) =
  gtk_alert_dialog_set_default_button(cast[ptr AlertDialog00](self.impl), int32(button))

proc gtk_alert_dialog_set_detail(self: ptr AlertDialog00; detail: cstring) {.
    importc, libprag.}

proc setDetail*(self: AlertDialog; detail: cstring) =
  gtk_alert_dialog_set_detail(cast[ptr AlertDialog00](self.impl), detail)

proc `detail=`*(self: AlertDialog; detail: cstring) =
  gtk_alert_dialog_set_detail(cast[ptr AlertDialog00](self.impl), detail)

proc gtk_alert_dialog_set_message(self: ptr AlertDialog00; message: cstring) {.
    importc, libprag.}

proc setMessage*(self: AlertDialog; message: cstring) =
  gtk_alert_dialog_set_message(cast[ptr AlertDialog00](self.impl), message)

proc `message=`*(self: AlertDialog; message: cstring) =
  gtk_alert_dialog_set_message(cast[ptr AlertDialog00](self.impl), message)

proc gtk_alert_dialog_set_modal(self: ptr AlertDialog00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: AlertDialog; modal: bool = true) =
  gtk_alert_dialog_set_modal(cast[ptr AlertDialog00](self.impl), gboolean(modal))

proc `modal=`*(self: AlertDialog; modal: bool) =
  gtk_alert_dialog_set_modal(cast[ptr AlertDialog00](self.impl), gboolean(modal))

proc gtk_alert_dialog_show(self: ptr AlertDialog00; parent: ptr Window00) {.
    importc, libprag.}

proc show*(self: AlertDialog; parent: Window = nil) =
  gtk_alert_dialog_show(cast[ptr AlertDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

type
  ShortcutTrigger* = ref object of gobject.Object
  ShortcutTrigger00* = object of gobject.Object00

proc gtk_shortcut_trigger_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutTrigger()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_shortcut_trigger_parse_string(string: cstring): ptr ShortcutTrigger00 {.
    importc, libprag.}

proc shortcutTriggerParseString*(string: cstring): ShortcutTrigger =
  let gobj = gtk_shortcut_trigger_parse_string(string)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc shortcutTriggerParseString*(tdesc: typedesc; string: cstring): tdesc =
  assert(result is ShortcutTrigger)
  let gobj = gtk_shortcut_trigger_parse_string(string)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc shortcutTriggerParseString*[T](result: var T; string: cstring) {.deprecated.} =
  assert(result is ShortcutTrigger)
  let gobj = gtk_shortcut_trigger_parse_string(string)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_trigger_compare(self: ptr ShortcutTrigger00; trigger2: ptr ShortcutTrigger00): int32 {.
    importc, libprag.}

proc compare*(self: ShortcutTrigger; trigger2: ShortcutTrigger): int =
  int(gtk_shortcut_trigger_compare(cast[ptr ShortcutTrigger00](self.impl), cast[ptr ShortcutTrigger00](trigger2.impl)))

proc gtk_shortcut_trigger_equal(self: ptr ShortcutTrigger00; trigger2: ptr ShortcutTrigger00): gboolean {.
    importc, libprag.}

proc equal*(self: ShortcutTrigger; trigger2: ShortcutTrigger): bool =
  toBool(gtk_shortcut_trigger_equal(cast[ptr ShortcutTrigger00](self.impl), cast[ptr ShortcutTrigger00](trigger2.impl)))

proc gtk_shortcut_trigger_hash(self: ptr ShortcutTrigger00): uint32 {.
    importc, libprag.}

proc hash*(self: ShortcutTrigger): int =
  int(gtk_shortcut_trigger_hash(cast[ptr ShortcutTrigger00](self.impl)))

proc gtk_shortcut_trigger_print(self: ptr ShortcutTrigger00; string: glib.String) {.
    importc, libprag.}

proc print*(self: ShortcutTrigger; string: glib.String) =
  gtk_shortcut_trigger_print(cast[ptr ShortcutTrigger00](self.impl), string)

proc gtk_shortcut_trigger_print_label(self: ptr ShortcutTrigger00; display: ptr gdk4.Display00;
    string: glib.String): gboolean {.
    importc, libprag.}

proc printLabel*(self: ShortcutTrigger; display: gdk4.Display;
    string: glib.String): bool =
  toBool(gtk_shortcut_trigger_print_label(cast[ptr ShortcutTrigger00](self.impl), cast[ptr gdk4.Display00](display.impl), string))

proc gtk_shortcut_trigger_to_label(self: ptr ShortcutTrigger00; display: ptr gdk4.Display00): cstring {.
    importc, libprag.}

proc toLabel*(self: ShortcutTrigger; display: gdk4.Display): string =
  let resul0 = gtk_shortcut_trigger_to_label(cast[ptr ShortcutTrigger00](self.impl), cast[ptr gdk4.Display00](display.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_shortcut_trigger_to_string(self: ptr ShortcutTrigger00): cstring {.
    importc, libprag.}

proc toString*(self: ShortcutTrigger): string =
  let resul0 = gtk_shortcut_trigger_to_string(cast[ptr ShortcutTrigger00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_shortcut_trigger_trigger(self: ptr ShortcutTrigger00; event: ptr gdk4.Event00;
    enableMnemonics: gboolean): gdk4.KeyMatch {.
    importc, libprag.}

proc trigger*(self: ShortcutTrigger; event: gdk4.Event;
    enableMnemonics: bool): gdk4.KeyMatch =
  gtk_shortcut_trigger_trigger(cast[ptr ShortcutTrigger00](self.impl), cast[ptr gdk4.Event00](event.impl), gboolean(enableMnemonics))

type
  AlternativeTrigger* = ref object of ShortcutTrigger
  AlternativeTrigger00* = object of ShortcutTrigger00

proc gtk_alternative_trigger_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AlternativeTrigger()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_alternative_trigger_new(first: ptr ShortcutTrigger00; second: ptr ShortcutTrigger00): ptr AlternativeTrigger00 {.
    importc, libprag.}

proc newAlternativeTrigger*(first: ShortcutTrigger; second: ShortcutTrigger): AlternativeTrigger =
  let gobj = gtk_alternative_trigger_new(cast[ptr ShortcutTrigger00](g_object_ref(first.impl)), cast[ptr ShortcutTrigger00](g_object_ref(second.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAlternativeTrigger*(tdesc: typedesc; first: ShortcutTrigger; second: ShortcutTrigger): tdesc =
  assert(result is AlternativeTrigger)
  let gobj = gtk_alternative_trigger_new(cast[ptr ShortcutTrigger00](g_object_ref(first.impl)), cast[ptr ShortcutTrigger00](g_object_ref(second.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAlternativeTrigger*[T](result: var T; first: ShortcutTrigger; second: ShortcutTrigger) {.deprecated.} =
  assert(result is AlternativeTrigger)
  let gobj = gtk_alternative_trigger_new(cast[ptr ShortcutTrigger00](g_object_ref(first.impl)), cast[ptr ShortcutTrigger00](g_object_ref(second.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_alternative_trigger_get_first(self: ptr AlternativeTrigger00): ptr ShortcutTrigger00 {.
    importc, libprag.}

proc getFirst*(self: AlternativeTrigger): ShortcutTrigger =
  let gobj = gtk_alternative_trigger_get_first(cast[ptr AlternativeTrigger00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc first*(self: AlternativeTrigger): ShortcutTrigger =
  let gobj = gtk_alternative_trigger_get_first(cast[ptr AlternativeTrigger00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_alternative_trigger_get_second(self: ptr AlternativeTrigger00): ptr ShortcutTrigger00 {.
    importc, libprag.}

proc getSecond*(self: AlternativeTrigger): ShortcutTrigger =
  let gobj = gtk_alternative_trigger_get_second(cast[ptr AlternativeTrigger00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc second*(self: AlternativeTrigger): ShortcutTrigger =
  let gobj = gtk_alternative_trigger_get_second(cast[ptr AlternativeTrigger00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  MultiFilter* = ref object of Filter
  MultiFilter00* = object of Filter00

proc gtk_multi_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MultiFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_multi_filter_append(self: ptr MultiFilter00; filter: ptr Filter00) {.
    importc, libprag.}

proc append*(self: MultiFilter; filter: Filter) =
  gtk_multi_filter_append(cast[ptr MultiFilter00](self.impl), cast[ptr Filter00](g_object_ref(filter.impl)))

proc gtk_multi_filter_remove(self: ptr MultiFilter00; position: uint32) {.
    importc, libprag.}

proc remove*(self: MultiFilter; position: int) =
  gtk_multi_filter_remove(cast[ptr MultiFilter00](self.impl), uint32(position))

type
  AnyFilter* = ref object of MultiFilter
  AnyFilter00* = object of MultiFilter00

proc gtk_any_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AnyFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_any_filter_new(): ptr AnyFilter00 {.
    importc, libprag.}

proc newAnyFilter*(): AnyFilter =
  let gobj = gtk_any_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAnyFilter*(tdesc: typedesc): tdesc =
  assert(result is AnyFilter)
  let gobj = gtk_any_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAnyFilter*[T](result: var T) {.deprecated.} =
  assert(result is AnyFilter)
  let gobj = gtk_any_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  AppChooser00* = object of gobject.Object00
  AppChooser* = ref object of gobject.Object

proc gtk_app_chooser_get_app_info(self: ptr AppChooser00): ptr gio.AppInfo00 {.
    importc, libprag.}

proc getAppInfo*(self: AppChooser | AppChooserDialog | AppChooserButton | AppChooserWidget): gio.AppInfo =
  let gobj = gtk_app_chooser_get_app_info(cast[ptr AppChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc appInfo*(self: AppChooser | AppChooserDialog | AppChooserButton | AppChooserWidget): gio.AppInfo =
  let gobj = gtk_app_chooser_get_app_info(cast[ptr AppChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_get_content_type(self: ptr AppChooser00): cstring {.
    importc, libprag.}

proc getContentType*(self: AppChooser | AppChooserDialog | AppChooserButton | AppChooserWidget): string =
  let resul0 = gtk_app_chooser_get_content_type(cast[ptr AppChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc contentType*(self: AppChooser | AppChooserDialog | AppChooserButton | AppChooserWidget): string =
  let resul0 = gtk_app_chooser_get_content_type(cast[ptr AppChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_app_chooser_refresh(self: ptr AppChooser00) {.
    importc, libprag.}

proc refresh*(self: AppChooser | AppChooserDialog | AppChooserButton | AppChooserWidget) =
  gtk_app_chooser_refresh(cast[ptr AppChooser00](self.impl))

type
  AssistantPageFunc* = proc (currentPage: int32; data: pointer): int32 {.cdecl.}

proc gtk_assistant_set_forward_page_func(self: ptr Assistant00; pageFunc: AssistantPageFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setForwardPageFunc*(self: Assistant; pageFunc: AssistantPageFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_assistant_set_forward_page_func(cast[ptr Assistant00](self.impl), pageFunc, data, destroy)

const BINARY_AGE* = 1405'i32

type
  BinLayout* = ref object of LayoutManager
  BinLayout00* = object of LayoutManager00

proc gtk_bin_layout_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(BinLayout()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_bin_layout_new(): ptr BinLayout00 {.
    importc, libprag.}

proc newBinLayout*(): BinLayout =
  let gobj = gtk_bin_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBinLayout*(tdesc: typedesc): tdesc =
  assert(result is BinLayout)
  let gobj = gtk_bin_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBinLayout*[T](result: var T) {.deprecated.} =
  assert(result is BinLayout)
  let gobj = gtk_bin_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  BitsetIter* {.pure, byRef.} = object
    privateData*: array[10, pointer]

proc gtk_bitset_iter_get_type*(): GType {.importc, libprag.}

proc gtk_bitset_iter_get_value(self: BitsetIter): uint32 {.
    importc, libprag.}

proc getValue*(self: BitsetIter): int =
  int(gtk_bitset_iter_get_value(self))

proc value*(self: BitsetIter): int =
  int(gtk_bitset_iter_get_value(self))

proc gtk_bitset_iter_is_valid(self: BitsetIter): gboolean {.
    importc, libprag.}

proc isValid*(self: BitsetIter): bool =
  toBool(gtk_bitset_iter_is_valid(self))

proc gtk_bitset_iter_next(self: BitsetIter; value: var uint32): gboolean {.
    importc, libprag.}

proc next*(self: BitsetIter; value: var int = cast[var int](nil)): bool =
  var value_00: uint32
  result = toBool(gtk_bitset_iter_next(self, value_00))
  if value.addr != nil:
    value = int(value_00)

proc gtk_bitset_iter_previous(self: BitsetIter; value: var uint32): gboolean {.
    importc, libprag.}

proc previous*(self: BitsetIter; value: var int = cast[var int](nil)): bool =
  var value_00: uint32
  result = toBool(gtk_bitset_iter_previous(self, value_00))
  if value.addr != nil:
    value = int(value_00)

proc gtk_bitset_iter_init_at(iter: var BitsetIter; set: ptr Bitset00; target: uint32;
    value: var uint32): gboolean {.
    importc, libprag.}

proc initAt*(iter: var BitsetIter; set: Bitset; target: int;
    value: var int = cast[var int](nil)): bool =
  var value_00: uint32
  result = toBool(gtk_bitset_iter_init_at(iter, cast[ptr Bitset00](set.impl), uint32(target), value_00))
  if value.addr != nil:
    value = int(value_00)

proc gtk_bitset_iter_init_first(iter: var BitsetIter; set: ptr Bitset00;
    value: var uint32): gboolean {.
    importc, libprag.}

proc initFirst*(iter: var BitsetIter; set: Bitset; value: var int = cast[var int](nil)): bool =
  var value_00: uint32
  result = toBool(gtk_bitset_iter_init_first(iter, cast[ptr Bitset00](set.impl), value_00))
  if value.addr != nil:
    value = int(value_00)

proc gtk_bitset_iter_init_last(iter: var BitsetIter; set: ptr Bitset00; value: var uint32): gboolean {.
    importc, libprag.}

proc initLast*(iter: var BitsetIter; set: Bitset; value: var int = cast[var int](nil)): bool =
  var value_00: uint32
  result = toBool(gtk_bitset_iter_init_last(iter, cast[ptr Bitset00](set.impl), value_00))
  if value.addr != nil:
    value = int(value_00)

type
  BookmarkList* = ref object of gobject.Object
  BookmarkList00* = object of gobject.Object00

proc gtk_bookmark_list_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(BookmarkList()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_bookmark_list_new(filename: cstring; attributes: cstring): ptr BookmarkList00 {.
    importc, libprag.}

proc newBookmarkList*(filename: cstring = nil; attributes: cstring = nil): BookmarkList =
  let gobj = gtk_bookmark_list_new(filename, attributes)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBookmarkList*(tdesc: typedesc; filename: cstring = nil; attributes: cstring = nil): tdesc =
  assert(result is BookmarkList)
  let gobj = gtk_bookmark_list_new(filename, attributes)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBookmarkList*[T](result: var T; filename: cstring = nil; attributes: cstring = nil) {.deprecated.} =
  assert(result is BookmarkList)
  let gobj = gtk_bookmark_list_new(filename, attributes)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_bookmark_list_get_attributes(self: ptr BookmarkList00): cstring {.
    importc, libprag.}

proc getAttributes*(self: BookmarkList): string =
  let resul0 = gtk_bookmark_list_get_attributes(cast[ptr BookmarkList00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc attributes*(self: BookmarkList): string =
  let resul0 = gtk_bookmark_list_get_attributes(cast[ptr BookmarkList00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_bookmark_list_get_filename(self: ptr BookmarkList00): cstring {.
    importc, libprag.}

proc getFilename*(self: BookmarkList): string =
  result = $gtk_bookmark_list_get_filename(cast[ptr BookmarkList00](self.impl))

proc filename*(self: BookmarkList): string =
  result = $gtk_bookmark_list_get_filename(cast[ptr BookmarkList00](self.impl))

proc gtk_bookmark_list_get_io_priority(self: ptr BookmarkList00): int32 {.
    importc, libprag.}

proc getIoPriority*(self: BookmarkList): int =
  int(gtk_bookmark_list_get_io_priority(cast[ptr BookmarkList00](self.impl)))

proc ioPriority*(self: BookmarkList): int =
  int(gtk_bookmark_list_get_io_priority(cast[ptr BookmarkList00](self.impl)))

proc gtk_bookmark_list_is_loading(self: ptr BookmarkList00): gboolean {.
    importc, libprag.}

proc isLoading*(self: BookmarkList): bool =
  toBool(gtk_bookmark_list_is_loading(cast[ptr BookmarkList00](self.impl)))

proc gtk_bookmark_list_set_attributes(self: ptr BookmarkList00; attributes: cstring) {.
    importc, libprag.}

proc setAttributes*(self: BookmarkList; attributes: cstring = nil) =
  gtk_bookmark_list_set_attributes(cast[ptr BookmarkList00](self.impl), attributes)

proc `attributes=`*(self: BookmarkList; attributes: cstring = nil) =
  gtk_bookmark_list_set_attributes(cast[ptr BookmarkList00](self.impl), attributes)

proc gtk_bookmark_list_set_io_priority(self: ptr BookmarkList00; ioPriority: int32) {.
    importc, libprag.}

proc setIoPriority*(self: BookmarkList; ioPriority: int) =
  gtk_bookmark_list_set_io_priority(cast[ptr BookmarkList00](self.impl), int32(ioPriority))

proc `ioPriority=`*(self: BookmarkList; ioPriority: int) =
  gtk_bookmark_list_set_io_priority(cast[ptr BookmarkList00](self.impl), int32(ioPriority))

type
  BoolFilter* = ref object of Filter
  BoolFilter00* = object of Filter00

proc gtk_bool_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(BoolFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_bool_filter_new(expression: ptr Expression00): ptr BoolFilter00 {.
    importc, libprag.}

proc newBoolFilter*(expression: Expression = nil): BoolFilter =
  let gobj = gtk_bool_filter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBoolFilter*(tdesc: typedesc; expression: Expression = nil): tdesc =
  assert(result is BoolFilter)
  let gobj = gtk_bool_filter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBoolFilter*[T](result: var T; expression: Expression = nil) {.deprecated.} =
  assert(result is BoolFilter)
  let gobj = gtk_bool_filter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_bool_filter_get_expression(self: ptr BoolFilter00): ptr Expression00 {.
    importc, libprag.}

proc getExpression*(self: BoolFilter): Expression =
  let impl0 = gtk_bool_filter_get_expression(cast[ptr BoolFilter00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc expression*(self: BoolFilter): Expression =
  let impl0 = gtk_bool_filter_get_expression(cast[ptr BoolFilter00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc gtk_bool_filter_get_invert(self: ptr BoolFilter00): gboolean {.
    importc, libprag.}

proc getInvert*(self: BoolFilter): bool =
  toBool(gtk_bool_filter_get_invert(cast[ptr BoolFilter00](self.impl)))

proc invert*(self: BoolFilter): bool =
  toBool(gtk_bool_filter_get_invert(cast[ptr BoolFilter00](self.impl)))

proc gtk_bool_filter_set_expression(self: ptr BoolFilter00; expression: ptr Expression00) {.
    importc, libprag.}

proc setExpression*(self: BoolFilter; expression: Expression = nil) =
  gtk_bool_filter_set_expression(cast[ptr BoolFilter00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

proc `expression=`*(self: BoolFilter; expression: Expression = nil) =
  gtk_bool_filter_set_expression(cast[ptr BoolFilter00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

proc gtk_bool_filter_set_invert(self: ptr BoolFilter00; invert: gboolean) {.
    importc, libprag.}

proc setInvert*(self: BoolFilter; invert: bool = true) =
  gtk_bool_filter_set_invert(cast[ptr BoolFilter00](self.impl), gboolean(invert))

proc `invert=`*(self: BoolFilter; invert: bool) =
  gtk_bool_filter_set_invert(cast[ptr BoolFilter00](self.impl), gboolean(invert))

type
  BorderStyle* {.size: sizeof(cint), pure.} = enum
    none = 0
    hidden = 1
    solid = 2
    inset = 3
    outset = 4
    dotted = 5
    dashed = 6
    double = 7
    groove = 8
    ridge = 9

type
  BoxLayout* = ref object of LayoutManager
  BoxLayout00* = object of LayoutManager00

proc gtk_box_layout_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(BoxLayout()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_box_layout_new(orientation: Orientation): ptr BoxLayout00 {.
    importc, libprag.}

proc newBoxLayout*(orientation: Orientation): BoxLayout =
  let gobj = gtk_box_layout_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBoxLayout*(tdesc: typedesc; orientation: Orientation): tdesc =
  assert(result is BoxLayout)
  let gobj = gtk_box_layout_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBoxLayout*[T](result: var T; orientation: Orientation) {.deprecated.} =
  assert(result is BoxLayout)
  let gobj = gtk_box_layout_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_box_layout_get_baseline_child(self: ptr BoxLayout00): int32 {.
    importc, libprag.}

proc getBaselineChild*(self: BoxLayout): int =
  int(gtk_box_layout_get_baseline_child(cast[ptr BoxLayout00](self.impl)))

proc baselineChild*(self: BoxLayout): int =
  int(gtk_box_layout_get_baseline_child(cast[ptr BoxLayout00](self.impl)))

proc gtk_box_layout_get_baseline_position(self: ptr BoxLayout00): BaselinePosition {.
    importc, libprag.}

proc getBaselinePosition*(self: BoxLayout): BaselinePosition =
  gtk_box_layout_get_baseline_position(cast[ptr BoxLayout00](self.impl))

proc baselinePosition*(self: BoxLayout): BaselinePosition =
  gtk_box_layout_get_baseline_position(cast[ptr BoxLayout00](self.impl))

proc gtk_box_layout_get_homogeneous(self: ptr BoxLayout00): gboolean {.
    importc, libprag.}

proc getHomogeneous*(self: BoxLayout): bool =
  toBool(gtk_box_layout_get_homogeneous(cast[ptr BoxLayout00](self.impl)))

proc homogeneous*(self: BoxLayout): bool =
  toBool(gtk_box_layout_get_homogeneous(cast[ptr BoxLayout00](self.impl)))

proc gtk_box_layout_get_spacing(self: ptr BoxLayout00): uint32 {.
    importc, libprag.}

proc getSpacing*(self: BoxLayout): int =
  int(gtk_box_layout_get_spacing(cast[ptr BoxLayout00](self.impl)))

proc spacing*(self: BoxLayout): int =
  int(gtk_box_layout_get_spacing(cast[ptr BoxLayout00](self.impl)))

proc gtk_box_layout_set_baseline_child(self: ptr BoxLayout00; child: int32) {.
    importc, libprag.}

proc setBaselineChild*(self: BoxLayout; child: int) =
  gtk_box_layout_set_baseline_child(cast[ptr BoxLayout00](self.impl), int32(child))

proc `baselineChild=`*(self: BoxLayout; child: int) =
  gtk_box_layout_set_baseline_child(cast[ptr BoxLayout00](self.impl), int32(child))

proc gtk_box_layout_set_baseline_position(self: ptr BoxLayout00; position: BaselinePosition) {.
    importc, libprag.}

proc setBaselinePosition*(self: BoxLayout; position: BaselinePosition) =
  gtk_box_layout_set_baseline_position(cast[ptr BoxLayout00](self.impl), position)

proc `baselinePosition=`*(self: BoxLayout; position: BaselinePosition) =
  gtk_box_layout_set_baseline_position(cast[ptr BoxLayout00](self.impl), position)

proc gtk_box_layout_set_homogeneous(self: ptr BoxLayout00; homogeneous: gboolean) {.
    importc, libprag.}

proc setHomogeneous*(self: BoxLayout; homogeneous: bool = true) =
  gtk_box_layout_set_homogeneous(cast[ptr BoxLayout00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: BoxLayout; homogeneous: bool) =
  gtk_box_layout_set_homogeneous(cast[ptr BoxLayout00](self.impl), gboolean(homogeneous))

proc gtk_box_layout_set_spacing(self: ptr BoxLayout00; spacing: uint32) {.
    importc, libprag.}

proc setSpacing*(self: BoxLayout; spacing: int) =
  gtk_box_layout_set_spacing(cast[ptr BoxLayout00](self.impl), uint32(spacing))

proc `spacing=`*(self: BoxLayout; spacing: int) =
  gtk_box_layout_set_spacing(cast[ptr BoxLayout00](self.impl), uint32(spacing))

type
  Buildable00* = object of gobject.Object00
  Buildable* = ref object of gobject.Object

type
  ShortcutController* = ref object of EventController
  ShortcutController00* = object of EventController00

proc gtk_shortcut_controller_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutController()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_shortcut_controller_new(): ptr ShortcutController00 {.
    importc, libprag.}

proc newShortcutController*(): ShortcutController =
  let gobj = gtk_shortcut_controller_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newShortcutController*(tdesc: typedesc): tdesc =
  assert(result is ShortcutController)
  let gobj = gtk_shortcut_controller_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initShortcutController*[T](result: var T) {.deprecated.} =
  assert(result is ShortcutController)
  let gobj = gtk_shortcut_controller_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_controller_new_for_model(model: ptr gio.ListModel00): ptr ShortcutController00 {.
    importc, libprag.}

proc newShortcutControllerForModel*(model: gio.ListModel): ShortcutController =
  let gobj = gtk_shortcut_controller_new_for_model(cast[ptr gio.ListModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newShortcutControllerForModel*(tdesc: typedesc; model: gio.ListModel): tdesc =
  assert(result is ShortcutController)
  let gobj = gtk_shortcut_controller_new_for_model(cast[ptr gio.ListModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initShortcutControllerForModel*[T](result: var T; model: gio.ListModel) {.deprecated.} =
  assert(result is ShortcutController)
  let gobj = gtk_shortcut_controller_new_for_model(cast[ptr gio.ListModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_controller_get_mnemonics_modifiers(self: ptr ShortcutController00): gdk4.ModifierType {.
    importc, libprag.}

proc getMnemonicsModifiers*(self: ShortcutController): gdk4.ModifierType =
  gtk_shortcut_controller_get_mnemonics_modifiers(cast[ptr ShortcutController00](self.impl))

proc mnemonicsModifiers*(self: ShortcutController): gdk4.ModifierType =
  gtk_shortcut_controller_get_mnemonics_modifiers(cast[ptr ShortcutController00](self.impl))

proc gtk_shortcut_controller_set_mnemonics_modifiers(self: ptr ShortcutController00;
    modifiers: gdk4.ModifierType) {.
    importc, libprag.}

proc setMnemonicsModifiers*(self: ShortcutController;
    modifiers: gdk4.ModifierType) =
  gtk_shortcut_controller_set_mnemonics_modifiers(cast[ptr ShortcutController00](self.impl), modifiers)

proc `mnemonicsModifiers=`*(self: ShortcutController;
    modifiers: gdk4.ModifierType) =
  gtk_shortcut_controller_set_mnemonics_modifiers(cast[ptr ShortcutController00](self.impl), modifiers)

type
  StringList* = ref object of gobject.Object
  StringList00* = object of gobject.Object00

proc gtk_string_list_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StringList()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_string_list_new(strings: ptr cstring): ptr StringList00 {.
    importc, libprag.}

proc newStringList*(strings: varargs[string, `$`]): StringList =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  let gobj = gtk_string_list_new(seq2CstringArray(strings, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStringList*(tdesc: typedesc; strings: varargs[string, `$`]): tdesc =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is StringList)
  let gobj = gtk_string_list_new(seq2CstringArray(strings, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStringList*[T](result: var T; strings: varargs[string, `$`]) {.deprecated.} =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is StringList)
  let gobj = gtk_string_list_new(seq2CstringArray(strings, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_string_list_append(self: ptr StringList00; string: cstring) {.
    importc, libprag.}

proc append*(self: StringList; string: cstring) =
  gtk_string_list_append(cast[ptr StringList00](self.impl), string)

proc gtk_string_list_get_string(self: ptr StringList00; position: uint32): cstring {.
    importc, libprag.}

proc getString*(self: StringList; position: int): string =
  let resul0 = gtk_string_list_get_string(cast[ptr StringList00](self.impl), uint32(position))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_string_list_remove(self: ptr StringList00; position: uint32) {.
    importc, libprag.}

proc remove*(self: StringList; position: int) =
  gtk_string_list_remove(cast[ptr StringList00](self.impl), uint32(position))

proc gtk_string_list_splice(self: ptr StringList00; position: uint32; nRemovals: uint32;
    additions: ptr cstring) {.
    importc, libprag.}

proc splice*(self: StringList; position: int; nRemovals: int;
    additions: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_string_list_splice(cast[ptr StringList00](self.impl), uint32(position), uint32(nRemovals), seq2CstringArray(additions, fs469n23))

proc gtk_string_list_take(self: ptr StringList00; string: cstring) {.
    importc, libprag.}

proc take*(self: StringList; string: cstring) =
  gtk_string_list_take(cast[ptr StringList00](self.impl), string)

type
  ConstraintLayout* = ref object of LayoutManager
  ConstraintLayout00* = object of LayoutManager00

proc gtk_constraint_layout_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ConstraintLayout()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_constraint_layout_new(): ptr ConstraintLayout00 {.
    importc, libprag.}

proc newConstraintLayout*(): ConstraintLayout =
  let gobj = gtk_constraint_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newConstraintLayout*(tdesc: typedesc): tdesc =
  assert(result is ConstraintLayout)
  let gobj = gtk_constraint_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initConstraintLayout*[T](result: var T) {.deprecated.} =
  assert(result is ConstraintLayout)
  let gobj = gtk_constraint_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_constraint_layout_observe_constraints(self: ptr ConstraintLayout00): ptr gio.ListModel00 {.
    importc, libprag.}

proc observeConstraints*(self: ConstraintLayout): gio.ListModel =
  let gobj = gtk_constraint_layout_observe_constraints(cast[ptr ConstraintLayout00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_constraint_layout_observe_guides(self: ptr ConstraintLayout00): ptr gio.ListModel00 {.
    importc, libprag.}

proc observeGuides*(self: ConstraintLayout): gio.ListModel =
  let gobj = gtk_constraint_layout_observe_guides(cast[ptr ConstraintLayout00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_constraint_layout_remove_all_constraints(self: ptr ConstraintLayout00) {.
    importc, libprag.}

proc removeAllConstraints*(self: ConstraintLayout) =
  gtk_constraint_layout_remove_all_constraints(cast[ptr ConstraintLayout00](self.impl))

type
  EveryFilter* = ref object of MultiFilter
  EveryFilter00* = object of MultiFilter00

proc gtk_every_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EveryFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_every_filter_new(): ptr EveryFilter00 {.
    importc, libprag.}

proc newEveryFilter*(): EveryFilter =
  let gobj = gtk_every_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEveryFilter*(tdesc: typedesc): tdesc =
  assert(result is EveryFilter)
  let gobj = gtk_every_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEveryFilter*[T](result: var T) {.deprecated.} =
  assert(result is EveryFilter)
  let gobj = gtk_every_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SizeGroup* = ref object of gobject.Object
  SizeGroup00* = object of gobject.Object00

proc gtk_size_group_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SizeGroup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_size_group_add_widget(self: ptr SizeGroup00; widget: ptr Widget00) {.
    importc, libprag.}

proc addWidget*(self: SizeGroup; widget: Widget) =
  gtk_size_group_add_widget(cast[ptr SizeGroup00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_size_group_get_widgets(self: ptr SizeGroup00): ptr glib.SList {.
    importc, libprag.}

proc getWidgets*(self: SizeGroup): seq[Widget] =
  result = gslistObjects2seq(Widget, gtk_size_group_get_widgets(cast[ptr SizeGroup00](self.impl)), false)

proc widgets*(self: SizeGroup): seq[Widget] =
  result = gslistObjects2seq(Widget, gtk_size_group_get_widgets(cast[ptr SizeGroup00](self.impl)), false)

proc gtk_size_group_remove_widget(self: ptr SizeGroup00; widget: ptr Widget00) {.
    importc, libprag.}

proc removeWidget*(self: SizeGroup; widget: Widget) =
  gtk_size_group_remove_widget(cast[ptr SizeGroup00](self.impl), cast[ptr Widget00](widget.impl))

type
  MultiSorter* = ref object of Sorter
  MultiSorter00* = object of Sorter00

proc gtk_multi_sorter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MultiSorter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_multi_sorter_new(): ptr MultiSorter00 {.
    importc, libprag.}

proc newMultiSorter*(): MultiSorter =
  let gobj = gtk_multi_sorter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMultiSorter*(tdesc: typedesc): tdesc =
  assert(result is MultiSorter)
  let gobj = gtk_multi_sorter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMultiSorter*[T](result: var T) {.deprecated.} =
  assert(result is MultiSorter)
  let gobj = gtk_multi_sorter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_multi_sorter_append(self: ptr MultiSorter00; sorter: ptr Sorter00) {.
    importc, libprag.}

proc append*(self: MultiSorter; sorter: Sorter) =
  gtk_multi_sorter_append(cast[ptr MultiSorter00](self.impl), cast[ptr Sorter00](g_object_ref(sorter.impl)))

proc gtk_multi_sorter_remove(self: ptr MultiSorter00; position: uint32) {.
    importc, libprag.}

proc remove*(self: MultiSorter; position: int) =
  gtk_multi_sorter_remove(cast[ptr MultiSorter00](self.impl), uint32(position))

type
  CellAreaBox* = ref object of CellArea
  CellAreaBox00* = object of CellArea00

proc gtk_cell_area_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellAreaBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_area_box_new(): ptr CellAreaBox00 {.
    importc, libprag.}

proc newCellAreaBox*(): CellAreaBox {.deprecated.}  =
  let gobj = gtk_cell_area_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellAreaBox*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellAreaBox)
  let gobj = gtk_cell_area_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellAreaBox*[T](result: var T) {.deprecated.} =
  assert(result is CellAreaBox)
  let gobj = gtk_cell_area_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_box_get_spacing(self: ptr CellAreaBox00): int32 {.
    importc, libprag.}

proc getSpacing*(self: CellAreaBox): int =
  int(gtk_cell_area_box_get_spacing(cast[ptr CellAreaBox00](self.impl)))

proc spacing*(self: CellAreaBox): int =
  int(gtk_cell_area_box_get_spacing(cast[ptr CellAreaBox00](self.impl)))

proc gtk_cell_area_box_pack_end(self: ptr CellAreaBox00; renderer: ptr CellRenderer00;
    expand: gboolean; align: gboolean; fixed: gboolean) {.
    importc, libprag.}

proc packEnd*(self: CellAreaBox; renderer: CellRenderer;
    expand: bool; align: bool; fixed: bool) =
  gtk_cell_area_box_pack_end(cast[ptr CellAreaBox00](self.impl), cast[ptr CellRenderer00](renderer.impl), gboolean(expand), gboolean(align), gboolean(fixed))

proc gtk_cell_area_box_pack_start(self: ptr CellAreaBox00; renderer: ptr CellRenderer00;
    expand: gboolean; align: gboolean; fixed: gboolean) {.
    importc, libprag.}

proc packStart*(self: CellAreaBox; renderer: CellRenderer;
    expand: bool; align: bool; fixed: bool) =
  gtk_cell_area_box_pack_start(cast[ptr CellAreaBox00](self.impl), cast[ptr CellRenderer00](renderer.impl), gboolean(expand), gboolean(align), gboolean(fixed))

proc gtk_cell_area_box_set_spacing(self: ptr CellAreaBox00; spacing: int32) {.
    importc, libprag.}

proc setSpacing*(self: CellAreaBox; spacing: int) =
  gtk_cell_area_box_set_spacing(cast[ptr CellAreaBox00](self.impl), int32(spacing))

proc `spacing=`*(self: CellAreaBox; spacing: int) =
  gtk_cell_area_box_set_spacing(cast[ptr CellAreaBox00](self.impl), int32(spacing))

type
  FileFilter* = ref object of Filter
  FileFilter00* = object of Filter00

proc gtk_file_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_file_filter_new(): ptr FileFilter00 {.
    importc, libprag.}

proc newFileFilter*(): FileFilter =
  let gobj = gtk_file_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileFilter*(tdesc: typedesc): tdesc =
  assert(result is FileFilter)
  let gobj = gtk_file_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileFilter*[T](result: var T) {.deprecated.} =
  assert(result is FileFilter)
  let gobj = gtk_file_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_filter_new_from_gvariant(variant: ptr glib.Variant00): ptr FileFilter00 {.
    importc, libprag.}

proc newFileFilterFromGvariant*(variant: glib.Variant): FileFilter =
  let gobj = gtk_file_filter_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileFilterFromGvariant*(tdesc: typedesc; variant: glib.Variant): tdesc =
  assert(result is FileFilter)
  let gobj = gtk_file_filter_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileFilterFromGvariant*[T](result: var T; variant: glib.Variant) {.deprecated.} =
  assert(result is FileFilter)
  let gobj = gtk_file_filter_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_filter_add_mime_type(self: ptr FileFilter00; mimeType: cstring) {.
    importc, libprag.}

proc addMimeType*(self: FileFilter; mimeType: cstring) =
  gtk_file_filter_add_mime_type(cast[ptr FileFilter00](self.impl), mimeType)

proc gtk_file_filter_add_pattern(self: ptr FileFilter00; pattern: cstring) {.
    importc, libprag.}

proc addPattern*(self: FileFilter; pattern: cstring) =
  gtk_file_filter_add_pattern(cast[ptr FileFilter00](self.impl), pattern)

proc gtk_file_filter_add_pixbuf_formats(self: ptr FileFilter00) {.
    importc, libprag.}

proc addPixbufFormats*(self: FileFilter) =
  gtk_file_filter_add_pixbuf_formats(cast[ptr FileFilter00](self.impl))

proc gtk_file_filter_add_suffix(self: ptr FileFilter00; suffix: cstring) {.
    importc, libprag.}

proc addSuffix*(self: FileFilter; suffix: cstring) =
  gtk_file_filter_add_suffix(cast[ptr FileFilter00](self.impl), suffix)

proc gtk_file_filter_get_attributes(self: ptr FileFilter00): ptr cstring {.
    importc, libprag.}

proc getAttributes*(self: FileFilter): seq[string] =
  cstringArrayToSeq(gtk_file_filter_get_attributes(cast[ptr FileFilter00](self.impl)))

proc attributes*(self: FileFilter): seq[string] =
  cstringArrayToSeq(gtk_file_filter_get_attributes(cast[ptr FileFilter00](self.impl)))

proc gtk_file_filter_get_name(self: ptr FileFilter00): cstring {.
    importc, libprag.}

proc getName*(self: FileFilter): string =
  let resul0 = gtk_file_filter_get_name(cast[ptr FileFilter00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc name*(self: FileFilter): string =
  let resul0 = gtk_file_filter_get_name(cast[ptr FileFilter00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_file_filter_set_name(self: ptr FileFilter00; name: cstring) {.
    importc, libprag.}

proc setName*(self: FileFilter; name: cstring = nil) =
  gtk_file_filter_set_name(cast[ptr FileFilter00](self.impl), name)

proc `name=`*(self: FileFilter; name: cstring = nil) =
  gtk_file_filter_set_name(cast[ptr FileFilter00](self.impl), name)

proc gtk_file_filter_to_gvariant(self: ptr FileFilter00): ptr glib.Variant00 {.
    importc, libprag.}

proc toGvariant*(self: FileFilter): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_file_filter_to_gvariant(cast[ptr FileFilter00](self.impl))
  result.ignoreFinalizer = true # GVariant

proc gtk_buildable_get_buildable_id(self: ptr Buildable00): cstring {.
    importc, libprag.}

proc getBuildableId*(self: Buildable | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | MultiFilter | Scale | Inscription | GLArea | Dialog | MediaControls | ShortcutController | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | AnyFilter | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | StringList | TextView | FileChooserWidget | ListBoxRow | Widget | TreeViewColumn | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | ConstraintLayout | DragIcon | AppChooserDialog | StackSwitcher | TextTagTable | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | EveryFilter | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | SizeGroup | InfoBar | IconView | TreeStore | MultiSorter | EntryCompletion | HeaderBar | PageSetupUnixDialog | AppChooserWidget | ListStore | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | CellAreaBox | PopoverMenu | AspectFrame | FileFilter | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | CellArea | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): string =
  let resul0 = gtk_buildable_get_buildable_id(cast[ptr Buildable00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc buildableId*(self: Buildable | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | MultiFilter | Scale | Inscription | GLArea | Dialog | MediaControls | ShortcutController | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | AnyFilter | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | StringList | TextView | FileChooserWidget | ListBoxRow | Widget | TreeViewColumn | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | ConstraintLayout | DragIcon | AppChooserDialog | StackSwitcher | TextTagTable | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | EveryFilter | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | SizeGroup | InfoBar | IconView | TreeStore | MultiSorter | EntryCompletion | HeaderBar | PageSetupUnixDialog | AppChooserWidget | ListStore | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | CellAreaBox | PopoverMenu | AspectFrame | FileFilter | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | CellArea | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload): string =
  let resul0 = gtk_buildable_get_buildable_id(cast[ptr Buildable00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

type
  SizeGroupMode* {.size: sizeof(cint), pure.} = enum
    none = 0
    horizontal = 1
    vertical = 2
    both = 3

proc gtk_size_group_new(mode: SizeGroupMode): ptr SizeGroup00 {.
    importc, libprag.}

proc newSizeGroup*(mode: SizeGroupMode): SizeGroup =
  let gobj = gtk_size_group_new(mode)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSizeGroup*(tdesc: typedesc; mode: SizeGroupMode): tdesc =
  assert(result is SizeGroup)
  let gobj = gtk_size_group_new(mode)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSizeGroup*[T](result: var T; mode: SizeGroupMode) {.deprecated.} =
  assert(result is SizeGroup)
  let gobj = gtk_size_group_new(mode)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_size_group_get_mode(self: ptr SizeGroup00): SizeGroupMode {.
    importc, libprag.}

proc getMode*(self: SizeGroup): SizeGroupMode =
  gtk_size_group_get_mode(cast[ptr SizeGroup00](self.impl))

proc mode*(self: SizeGroup): SizeGroupMode =
  gtk_size_group_get_mode(cast[ptr SizeGroup00](self.impl))

proc gtk_size_group_set_mode(self: ptr SizeGroup00; mode: SizeGroupMode) {.
    importc, libprag.}

proc setMode*(self: SizeGroup; mode: SizeGroupMode) =
  gtk_size_group_set_mode(cast[ptr SizeGroup00](self.impl), mode)

proc `mode=`*(self: SizeGroup; mode: SizeGroupMode) =
  gtk_size_group_set_mode(cast[ptr SizeGroup00](self.impl), mode)

type
  Constraint* = ref object of gobject.Object
  Constraint00* = object of gobject.Object00

proc gtk_constraint_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Constraint()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_constraint_get_constant(self: ptr Constraint00): cdouble {.
    importc, libprag.}

proc getConstant*(self: Constraint): cdouble =
  gtk_constraint_get_constant(cast[ptr Constraint00](self.impl))

proc constant*(self: Constraint): cdouble =
  gtk_constraint_get_constant(cast[ptr Constraint00](self.impl))

proc gtk_constraint_get_multiplier(self: ptr Constraint00): cdouble {.
    importc, libprag.}

proc getMultiplier*(self: Constraint): cdouble =
  gtk_constraint_get_multiplier(cast[ptr Constraint00](self.impl))

proc multiplier*(self: Constraint): cdouble =
  gtk_constraint_get_multiplier(cast[ptr Constraint00](self.impl))

proc gtk_constraint_get_strength(self: ptr Constraint00): int32 {.
    importc, libprag.}

proc getStrength*(self: Constraint): int =
  int(gtk_constraint_get_strength(cast[ptr Constraint00](self.impl)))

proc strength*(self: Constraint): int =
  int(gtk_constraint_get_strength(cast[ptr Constraint00](self.impl)))

proc gtk_constraint_is_attached(self: ptr Constraint00): gboolean {.
    importc, libprag.}

proc isAttached*(self: Constraint): bool =
  toBool(gtk_constraint_is_attached(cast[ptr Constraint00](self.impl)))

proc gtk_constraint_is_constant(self: ptr Constraint00): gboolean {.
    importc, libprag.}

proc isConstant*(self: Constraint): bool =
  toBool(gtk_constraint_is_constant(cast[ptr Constraint00](self.impl)))

proc gtk_constraint_is_required(self: ptr Constraint00): gboolean {.
    importc, libprag.}

proc isRequired*(self: Constraint): bool =
  toBool(gtk_constraint_is_required(cast[ptr Constraint00](self.impl)))

proc gtk_constraint_layout_add_constraint(self: ptr ConstraintLayout00; constraint: ptr Constraint00) {.
    importc, libprag.}

proc addConstraint*(self: ConstraintLayout; constraint: Constraint) =
  gtk_constraint_layout_add_constraint(cast[ptr ConstraintLayout00](self.impl), cast[ptr Constraint00](g_object_ref(constraint.impl)))

proc gtk_constraint_layout_add_constraints_from_descriptionv(self: ptr ConstraintLayout00;
    lines: ptr cstring; nLines: uint64; hspacing: int32; vspacing: int32; views: ptr HashTable00;
    error: ptr ptr glib.Error = nil): ptr glib.List {.
    importc, libprag.}

proc addConstraintsFromDescription*(self: ConstraintLayout;
    lines: openArray[string]; nLines: uint64; hspacing: int; vspacing: int;
    views: ptr HashTable00): seq[Constraint] =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var gerror: ptr glib.Error
  let resul0 = gtk_constraint_layout_add_constraints_from_descriptionv(cast[ptr ConstraintLayout00](self.impl), seq2CstringArray(lines, fs469n23), nLines, int32(hspacing), int32(vspacing), views, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = glistObjects2seq(Constraint, resul0, false)
  g_list_free(resul0)

proc gtk_constraint_layout_remove_constraint(self: ptr ConstraintLayout00;
    constraint: ptr Constraint00) {.
    importc, libprag.}

proc removeConstraint*(self: ConstraintLayout; constraint: Constraint) =
  gtk_constraint_layout_remove_constraint(cast[ptr ConstraintLayout00](self.impl), cast[ptr Constraint00](constraint.impl))

type
  ConstraintRelation* {.size: sizeof(cint), pure.} = enum
    le = -1
    eq = 0
    ge = 1

proc gtk_constraint_get_relation(self: ptr Constraint00): ConstraintRelation {.
    importc, libprag.}

proc getRelation*(self: Constraint): ConstraintRelation =
  gtk_constraint_get_relation(cast[ptr Constraint00](self.impl))

proc relation*(self: Constraint): ConstraintRelation =
  gtk_constraint_get_relation(cast[ptr Constraint00](self.impl))

type
  ConstraintTarget00* = object of gobject.Object00
  ConstraintTarget* = ref object of gobject.Object

proc gtk_constraint_get_source(self: ptr Constraint00): ptr ConstraintTarget00 {.
    importc, libprag.}

proc getSource*(self: Constraint): ConstraintTarget =
  let gobj = gtk_constraint_get_source(cast[ptr Constraint00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc source*(self: Constraint): ConstraintTarget =
  let gobj = gtk_constraint_get_source(cast[ptr Constraint00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_constraint_get_target(self: ptr Constraint00): ptr ConstraintTarget00 {.
    importc, libprag.}

proc getTarget*(self: Constraint): ConstraintTarget =
  let gobj = gtk_constraint_get_target(cast[ptr Constraint00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc target*(self: Constraint): ConstraintTarget =
  let gobj = gtk_constraint_get_target(cast[ptr Constraint00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ConstraintAttribute* {.size: sizeof(cint), pure.} = enum
    none = 0
    left = 1
    right = 2
    top = 3
    bottom = 4
    start = 5
    `end` = 6
    width = 7
    height = 8
    centerX = 9
    centerY = 10
    baseline = 11

proc gtk_constraint_get_source_attribute(self: ptr Constraint00): ConstraintAttribute {.
    importc, libprag.}

proc getSourceAttribute*(self: Constraint): ConstraintAttribute =
  gtk_constraint_get_source_attribute(cast[ptr Constraint00](self.impl))

proc sourceAttribute*(self: Constraint): ConstraintAttribute =
  gtk_constraint_get_source_attribute(cast[ptr Constraint00](self.impl))

proc gtk_constraint_get_target_attribute(self: ptr Constraint00): ConstraintAttribute {.
    importc, libprag.}

proc getTargetAttribute*(self: Constraint): ConstraintAttribute =
  gtk_constraint_get_target_attribute(cast[ptr Constraint00](self.impl))

proc targetAttribute*(self: Constraint): ConstraintAttribute =
  gtk_constraint_get_target_attribute(cast[ptr Constraint00](self.impl))

type
  ConstraintGuide* = ref object of gobject.Object
  ConstraintGuide00* = object of gobject.Object00

proc gtk_constraint_guide_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ConstraintGuide()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_constraint_guide_new(): ptr ConstraintGuide00 {.
    importc, libprag.}

proc newConstraintGuide*(): ConstraintGuide =
  let gobj = gtk_constraint_guide_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newConstraintGuide*(tdesc: typedesc): tdesc =
  assert(result is ConstraintGuide)
  let gobj = gtk_constraint_guide_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initConstraintGuide*[T](result: var T) {.deprecated.} =
  assert(result is ConstraintGuide)
  let gobj = gtk_constraint_guide_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_constraint_guide_get_max_size(self: ptr ConstraintGuide00; width: var int32;
    height: var int32) {.
    importc, libprag.}

proc getMaxSize*(self: ConstraintGuide; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var height_00: int32
  var width_00: int32
  gtk_constraint_guide_get_max_size(cast[ptr ConstraintGuide00](self.impl), width_00, height_00)
  if height.addr != nil:
    height = int(height_00)
  if width.addr != nil:
    width = int(width_00)

proc gtk_constraint_guide_get_min_size(self: ptr ConstraintGuide00; width: var int32;
    height: var int32) {.
    importc, libprag.}

proc getMinSize*(self: ConstraintGuide; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var height_00: int32
  var width_00: int32
  gtk_constraint_guide_get_min_size(cast[ptr ConstraintGuide00](self.impl), width_00, height_00)
  if height.addr != nil:
    height = int(height_00)
  if width.addr != nil:
    width = int(width_00)

proc gtk_constraint_guide_get_name(self: ptr ConstraintGuide00): cstring {.
    importc, libprag.}

proc getName*(self: ConstraintGuide): string =
  let resul0 = gtk_constraint_guide_get_name(cast[ptr ConstraintGuide00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc name*(self: ConstraintGuide): string =
  let resul0 = gtk_constraint_guide_get_name(cast[ptr ConstraintGuide00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_constraint_guide_get_nat_size(self: ptr ConstraintGuide00; width: var int32;
    height: var int32) {.
    importc, libprag.}

proc getNatSize*(self: ConstraintGuide; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var height_00: int32
  var width_00: int32
  gtk_constraint_guide_get_nat_size(cast[ptr ConstraintGuide00](self.impl), width_00, height_00)
  if height.addr != nil:
    height = int(height_00)
  if width.addr != nil:
    width = int(width_00)

proc gtk_constraint_guide_set_max_size(self: ptr ConstraintGuide00; width: int32;
    height: int32) {.
    importc, libprag.}

proc setMaxSize*(self: ConstraintGuide; width: int;
    height: int) =
  gtk_constraint_guide_set_max_size(cast[ptr ConstraintGuide00](self.impl), int32(width), int32(height))

proc gtk_constraint_guide_set_min_size(self: ptr ConstraintGuide00; width: int32;
    height: int32) {.
    importc, libprag.}

proc setMinSize*(self: ConstraintGuide; width: int;
    height: int) =
  gtk_constraint_guide_set_min_size(cast[ptr ConstraintGuide00](self.impl), int32(width), int32(height))

proc gtk_constraint_guide_set_name(self: ptr ConstraintGuide00; name: cstring) {.
    importc, libprag.}

proc setName*(self: ConstraintGuide; name: cstring = nil) =
  gtk_constraint_guide_set_name(cast[ptr ConstraintGuide00](self.impl), name)

proc `name=`*(self: ConstraintGuide; name: cstring = nil) =
  gtk_constraint_guide_set_name(cast[ptr ConstraintGuide00](self.impl), name)

proc gtk_constraint_guide_set_nat_size(self: ptr ConstraintGuide00; width: int32;
    height: int32) {.
    importc, libprag.}

proc setNatSize*(self: ConstraintGuide; width: int;
    height: int) =
  gtk_constraint_guide_set_nat_size(cast[ptr ConstraintGuide00](self.impl), int32(width), int32(height))

proc gtk_constraint_layout_add_guide(self: ptr ConstraintLayout00; guide: ptr ConstraintGuide00) {.
    importc, libprag.}

proc addGuide*(self: ConstraintLayout; guide: ConstraintGuide) =
  gtk_constraint_layout_add_guide(cast[ptr ConstraintLayout00](self.impl), cast[ptr ConstraintGuide00](g_object_ref(guide.impl)))

proc gtk_constraint_layout_remove_guide(self: ptr ConstraintLayout00; guide: ptr ConstraintGuide00) {.
    importc, libprag.}

proc removeGuide*(self: ConstraintLayout; guide: ConstraintGuide) =
  gtk_constraint_layout_remove_guide(cast[ptr ConstraintLayout00](self.impl), cast[ptr ConstraintGuide00](guide.impl))

proc gtk_constraint_new(target: ptr ConstraintTarget00; targetAttribute: ConstraintAttribute;
    relation: ConstraintRelation; source: ptr ConstraintTarget00; sourceAttribute: ConstraintAttribute;
    multiplier: cdouble; constant: cdouble; strength: int32): ptr Constraint00 {.
    importc, libprag.}

proc newConstraint*(target: ConstraintTarget | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | ConstraintGuide | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = ConstraintTarget(nil);
    targetAttribute: ConstraintAttribute; relation: ConstraintRelation; source: ConstraintTarget | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | ConstraintGuide | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = ConstraintTarget(nil);
    sourceAttribute: ConstraintAttribute; multiplier: cdouble; constant: cdouble;
    strength: int): Constraint =
  let gobj = gtk_constraint_new(if target.isNil: nil else: cast[ptr ConstraintTarget00](target.impl), targetAttribute, relation, if source.isNil: nil else: cast[ptr ConstraintTarget00](source.impl), sourceAttribute, multiplier, constant, int32(strength))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newConstraint*(tdesc: typedesc; target: ConstraintTarget | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | ConstraintGuide | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = ConstraintTarget(nil);
    targetAttribute: ConstraintAttribute; relation: ConstraintRelation; source: ConstraintTarget | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | ConstraintGuide | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = ConstraintTarget(nil);
    sourceAttribute: ConstraintAttribute; multiplier: cdouble; constant: cdouble;
    strength: int): tdesc =
  assert(result is Constraint)
  let gobj = gtk_constraint_new(if target.isNil: nil else: cast[ptr ConstraintTarget00](target.impl), targetAttribute, relation, if source.isNil: nil else: cast[ptr ConstraintTarget00](source.impl), sourceAttribute, multiplier, constant, int32(strength))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initConstraint*[T](result: var T; target: ConstraintTarget | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | ConstraintGuide | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = ConstraintTarget(nil);
    targetAttribute: ConstraintAttribute; relation: ConstraintRelation; source: ConstraintTarget | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | ConstraintGuide | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = ConstraintTarget(nil);
    sourceAttribute: ConstraintAttribute; multiplier: cdouble; constant: cdouble;
    strength: int) {.deprecated.} =
  assert(result is Constraint)
  let gobj = gtk_constraint_new(if target.isNil: nil else: cast[ptr ConstraintTarget00](target.impl), targetAttribute, relation, if source.isNil: nil else: cast[ptr ConstraintTarget00](source.impl), sourceAttribute, multiplier, constant, int32(strength))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_constraint_new_constant(target: ptr ConstraintTarget00; targetAttribute: ConstraintAttribute;
    relation: ConstraintRelation; constant: cdouble; strength: int32): ptr Constraint00 {.
    importc, libprag.}

proc newConstraintConstant*(target: ConstraintTarget | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | ConstraintGuide | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = ConstraintTarget(nil);
    targetAttribute: ConstraintAttribute; relation: ConstraintRelation; constant: cdouble;
    strength: int): Constraint =
  let gobj = gtk_constraint_new_constant(if target.isNil: nil else: cast[ptr ConstraintTarget00](target.impl), targetAttribute, relation, constant, int32(strength))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newConstraintConstant*(tdesc: typedesc; target: ConstraintTarget | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | ConstraintGuide | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = ConstraintTarget(nil);
    targetAttribute: ConstraintAttribute; relation: ConstraintRelation; constant: cdouble;
    strength: int): tdesc =
  assert(result is Constraint)
  let gobj = gtk_constraint_new_constant(if target.isNil: nil else: cast[ptr ConstraintTarget00](target.impl), targetAttribute, relation, constant, int32(strength))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initConstraintConstant*[T](result: var T; target: ConstraintTarget | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | ConstraintGuide | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload = ConstraintTarget(nil);
    targetAttribute: ConstraintAttribute; relation: ConstraintRelation; constant: cdouble;
    strength: int) {.deprecated.} =
  assert(result is Constraint)
  let gobj = gtk_constraint_new_constant(if target.isNil: nil else: cast[ptr ConstraintTarget00](target.impl), targetAttribute, relation, constant, int32(strength))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ConstraintStrength* {.size: sizeof(cint), pure.} = enum
    weak = 1
    medium = 1000
    strong = 1000000000
    required = 1001001000

proc gtk_constraint_guide_get_strength(self: ptr ConstraintGuide00): ConstraintStrength {.
    importc, libprag.}

proc getStrength*(self: ConstraintGuide): ConstraintStrength =
  gtk_constraint_guide_get_strength(cast[ptr ConstraintGuide00](self.impl))

proc strength*(self: ConstraintGuide): ConstraintStrength =
  gtk_constraint_guide_get_strength(cast[ptr ConstraintGuide00](self.impl))

proc gtk_constraint_guide_set_strength(self: ptr ConstraintGuide00; strength: ConstraintStrength) {.
    importc, libprag.}

proc setStrength*(self: ConstraintGuide; strength: ConstraintStrength) =
  gtk_constraint_guide_set_strength(cast[ptr ConstraintGuide00](self.impl), strength)

proc `strength=`*(self: ConstraintGuide; strength: ConstraintStrength) =
  gtk_constraint_guide_set_strength(cast[ptr ConstraintGuide00](self.impl), strength)

type
  Shortcut* = ref object of gobject.Object
  Shortcut00* = object of gobject.Object00

proc gtk_shortcut_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Shortcut()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_shortcut_new(trigger: ptr ShortcutTrigger00; action: ptr ShortcutAction00): ptr Shortcut00 {.
    importc, libprag.}

proc newShortcut*(trigger: ShortcutTrigger = nil; action: ShortcutAction = nil): Shortcut =
  let gobj = gtk_shortcut_new(if trigger.isNil: nil else: cast[ptr ShortcutTrigger00](g_object_ref(trigger.impl)), if action.isNil: nil else: cast[ptr ShortcutAction00](g_object_ref(action.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newShortcut*(tdesc: typedesc; trigger: ShortcutTrigger = nil; action: ShortcutAction = nil): tdesc =
  assert(result is Shortcut)
  let gobj = gtk_shortcut_new(if trigger.isNil: nil else: cast[ptr ShortcutTrigger00](g_object_ref(trigger.impl)), if action.isNil: nil else: cast[ptr ShortcutAction00](g_object_ref(action.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initShortcut*[T](result: var T; trigger: ShortcutTrigger = nil; action: ShortcutAction = nil) {.deprecated.} =
  assert(result is Shortcut)
  let gobj = gtk_shortcut_new(if trigger.isNil: nil else: cast[ptr ShortcutTrigger00](g_object_ref(trigger.impl)), if action.isNil: nil else: cast[ptr ShortcutAction00](g_object_ref(action.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_get_action(self: ptr Shortcut00): ptr ShortcutAction00 {.
    importc, libprag.}

proc getAction*(self: Shortcut): ShortcutAction =
  let gobj = gtk_shortcut_get_action(cast[ptr Shortcut00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc action*(self: Shortcut): ShortcutAction =
  let gobj = gtk_shortcut_get_action(cast[ptr Shortcut00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_get_arguments(self: ptr Shortcut00): ptr glib.Variant00 {.
    importc, libprag.}

proc getArguments*(self: Shortcut): glib.Variant =
  let impl0 = gtk_shortcut_get_arguments(cast[ptr Shortcut00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, finalizerunref)
  result.impl = impl0
  result.ignoreFinalizer = true # GVariant

proc arguments*(self: Shortcut): glib.Variant =
  let impl0 = gtk_shortcut_get_arguments(cast[ptr Shortcut00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, finalizerunref)
  result.impl = impl0
  result.ignoreFinalizer = true # GVariant

proc gtk_shortcut_get_trigger(self: ptr Shortcut00): ptr ShortcutTrigger00 {.
    importc, libprag.}

proc getTrigger*(self: Shortcut): ShortcutTrigger =
  let gobj = gtk_shortcut_get_trigger(cast[ptr Shortcut00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc trigger*(self: Shortcut): ShortcutTrigger =
  let gobj = gtk_shortcut_get_trigger(cast[ptr Shortcut00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_set_action(self: ptr Shortcut00; action: ptr ShortcutAction00) {.
    importc, libprag.}

proc setAction*(self: Shortcut; action: ShortcutAction = nil) =
  gtk_shortcut_set_action(cast[ptr Shortcut00](self.impl), if action.isNil: nil else: cast[ptr ShortcutAction00](g_object_ref(action.impl)))

proc `action=`*(self: Shortcut; action: ShortcutAction = nil) =
  gtk_shortcut_set_action(cast[ptr Shortcut00](self.impl), if action.isNil: nil else: cast[ptr ShortcutAction00](g_object_ref(action.impl)))

proc gtk_shortcut_set_arguments(self: ptr Shortcut00; args: ptr glib.Variant00) {.
    importc, libprag.}

proc setArguments*(self: Shortcut; args: glib.Variant = nil) =
  gtk_shortcut_set_arguments(cast[ptr Shortcut00](self.impl), if args.isNil: nil else: cast[ptr glib.Variant00](args.impl))

proc `arguments=`*(self: Shortcut; args: glib.Variant = nil) =
  gtk_shortcut_set_arguments(cast[ptr Shortcut00](self.impl), if args.isNil: nil else: cast[ptr glib.Variant00](args.impl))

proc gtk_shortcut_set_trigger(self: ptr Shortcut00; trigger: ptr ShortcutTrigger00) {.
    importc, libprag.}

proc setTrigger*(self: Shortcut; trigger: ShortcutTrigger = nil) =
  gtk_shortcut_set_trigger(cast[ptr Shortcut00](self.impl), if trigger.isNil: nil else: cast[ptr ShortcutTrigger00](g_object_ref(trigger.impl)))

proc `trigger=`*(self: Shortcut; trigger: ShortcutTrigger = nil) =
  gtk_shortcut_set_trigger(cast[ptr Shortcut00](self.impl), if trigger.isNil: nil else: cast[ptr ShortcutTrigger00](g_object_ref(trigger.impl)))

proc gtk_shortcut_controller_add_shortcut(self: ptr ShortcutController00;
    shortcut: ptr Shortcut00) {.
    importc, libprag.}

proc addShortcut*(self: ShortcutController; shortcut: Shortcut) =
  gtk_shortcut_controller_add_shortcut(cast[ptr ShortcutController00](self.impl), cast[ptr Shortcut00](g_object_ref(shortcut.impl)))

proc gtk_shortcut_controller_remove_shortcut(self: ptr ShortcutController00;
    shortcut: ptr Shortcut00) {.
    importc, libprag.}

proc removeShortcut*(self: ShortcutController; shortcut: Shortcut) =
  gtk_shortcut_controller_remove_shortcut(cast[ptr ShortcutController00](self.impl), cast[ptr Shortcut00](shortcut.impl))

type
  ShortcutScope* {.size: sizeof(cint), pure.} = enum
    local = 0
    managed = 1
    global = 2

proc gtk_shortcut_controller_get_scope(self: ptr ShortcutController00): ShortcutScope {.
    importc, libprag.}

proc getScope*(self: ShortcutController): ShortcutScope =
  gtk_shortcut_controller_get_scope(cast[ptr ShortcutController00](self.impl))

proc scope*(self: ShortcutController): ShortcutScope =
  gtk_shortcut_controller_get_scope(cast[ptr ShortcutController00](self.impl))

proc gtk_shortcut_controller_set_scope(self: ptr ShortcutController00; scope: ShortcutScope) {.
    importc, libprag.}

proc setScope*(self: ShortcutController; scope: ShortcutScope) =
  gtk_shortcut_controller_set_scope(cast[ptr ShortcutController00](self.impl), scope)

proc `scope=`*(self: ShortcutController; scope: ShortcutScope) =
  gtk_shortcut_controller_set_scope(cast[ptr ShortcutController00](self.impl), scope)

type
  BuildableParseContext00* {.pure.} = object
  BuildableParseContext* = ref object
    impl*: ptr BuildableParseContext00
    ignoreFinalizer*: bool

proc gtk_buildable_parse_context_get_element(self: ptr BuildableParseContext00): cstring {.
    importc, libprag.}

proc getElement*(self: BuildableParseContext): string =
  let resul0 = gtk_buildable_parse_context_get_element(cast[ptr BuildableParseContext00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc element*(self: BuildableParseContext): string =
  let resul0 = gtk_buildable_parse_context_get_element(cast[ptr BuildableParseContext00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_buildable_parse_context_get_element_stack(self: ptr BuildableParseContext00): ptr PtrArray00 {.
    importc, libprag.}

proc getElementStack*(self: BuildableParseContext): ptr PtrArray00 =
  gtk_buildable_parse_context_get_element_stack(cast[ptr BuildableParseContext00](self.impl))

proc elementStack*(self: BuildableParseContext): ptr PtrArray00 =
  gtk_buildable_parse_context_get_element_stack(cast[ptr BuildableParseContext00](self.impl))

proc gtk_buildable_parse_context_get_position(self: ptr BuildableParseContext00;
    lineNumber: var int32; charNumber: var int32) {.
    importc, libprag.}

proc getPosition*(self: BuildableParseContext;
    lineNumber: var int = cast[var int](nil); charNumber: var int = cast[var int](nil)) =
  var charNumber_00: int32
  var lineNumber_00: int32
  gtk_buildable_parse_context_get_position(cast[ptr BuildableParseContext00](self.impl), lineNumber_00, charNumber_00)
  if charNumber.addr != nil:
    charNumber = int(charNumber_00)
  if lineNumber.addr != nil:
    lineNumber = int(lineNumber_00)

proc gtk_buildable_parse_context_pop(self: ptr BuildableParseContext00): pointer {.
    importc, libprag.}

proc pop*(self: BuildableParseContext): pointer =
  gtk_buildable_parse_context_pop(cast[ptr BuildableParseContext00](self.impl))

type
  BuildableParser00* {.pure.} = object
  BuildableParser* = ref object
    impl*: ptr BuildableParser00
    ignoreFinalizer*: bool

proc gtk_buildable_parse_context_push(self: ptr BuildableParseContext00;
    parser: ptr BuildableParser00; userData: pointer) {.
    importc, libprag.}

proc push*(self: BuildableParseContext; parser: BuildableParser;
    userData: pointer) =
  gtk_buildable_parse_context_push(cast[ptr BuildableParseContext00](self.impl), cast[ptr BuildableParser00](parser.impl), userData)

type
  Builder* = ref object of gobject.Object
  Builder00* = object of gobject.Object00

proc gtk_builder_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Builder()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_builder_new(): ptr Builder00 {.
    importc, libprag.}

proc newBuilder*(): Builder =
  let gobj = gtk_builder_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilder*(tdesc: typedesc): tdesc =
  assert(result is Builder)
  let gobj = gtk_builder_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilder*[T](result: var T) {.deprecated.} =
  assert(result is Builder)
  let gobj = gtk_builder_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_new_from_file(filename: cstring): ptr Builder00 {.
    importc, libprag.}

proc newBuilderFromFile*(filename: cstring): Builder =
  let gobj = gtk_builder_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilderFromFile*(tdesc: typedesc; filename: cstring): tdesc =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderFromFile*[T](result: var T; filename: cstring) {.deprecated.} =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_new_from_resource(resourcePath: cstring): ptr Builder00 {.
    importc, libprag.}

proc newBuilderFromResource*(resourcePath: cstring): Builder =
  let gobj = gtk_builder_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilderFromResource*(tdesc: typedesc; resourcePath: cstring): tdesc =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderFromResource*[T](result: var T; resourcePath: cstring) {.deprecated.} =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_new_from_string(string: cstring; length: int64): ptr Builder00 {.
    importc, libprag.}

proc newBuilderFromString*(string: cstring; length: int64 = -1): Builder =
  let gobj = gtk_builder_new_from_string(string, length)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilderFromString*(tdesc: typedesc; string: cstring; length: int64 = -1): tdesc =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_string(string, length)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderFromString*[T](result: var T; string: cstring; length: int64 = -1) {.deprecated.} =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_string(string, length)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_add_from_file(self: ptr Builder00; filename: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc addFromFile*(self: Builder; filename: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_from_file(cast[ptr Builder00](self.impl), filename, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_builder_add_from_resource(self: ptr Builder00; resourcePath: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc addFromResource*(self: Builder; resourcePath: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_from_resource(cast[ptr Builder00](self.impl), resourcePath, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_builder_add_from_string(self: ptr Builder00; buffer: cstring; length: int64;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc addFromString*(self: Builder; buffer: cstring; length: int64): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_from_string(cast[ptr Builder00](self.impl), buffer, length, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_builder_add_objects_from_file(self: ptr Builder00; filename: cstring;
    objectIds: ptr cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc addObjectsFromFile*(self: Builder; filename: cstring;
    objectIds: varargs[string, `$`]): bool =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_objects_from_file(cast[ptr Builder00](self.impl), filename, seq2CstringArray(objectIds, fs469n23), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_builder_add_objects_from_resource(self: ptr Builder00; resourcePath: cstring;
    objectIds: ptr cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc addObjectsFromResource*(self: Builder; resourcePath: cstring;
    objectIds: varargs[string, `$`]): bool =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_objects_from_resource(cast[ptr Builder00](self.impl), resourcePath, seq2CstringArray(objectIds, fs469n23), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_builder_add_objects_from_string(self: ptr Builder00; buffer: cstring;
    length: int64; objectIds: ptr cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc addObjectsFromString*(self: Builder; buffer: cstring;
    length: int64; objectIds: varargs[string, `$`]): bool =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_objects_from_string(cast[ptr Builder00](self.impl), buffer, length, seq2CstringArray(objectIds, fs469n23), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_builder_expose_object(self: ptr Builder00; name: cstring; obj: ptr gobject.Object00) {.
    importc, libprag.}

proc exposeObject*(self: Builder; name: cstring; obj: gobject.Object) =
  gtk_builder_expose_object(cast[ptr Builder00](self.impl), name, cast[ptr gobject.Object00](obj.impl))

proc gtk_builder_extend_with_template(self: ptr Builder00; obj: ptr gobject.Object00;
    templateType: GType; buffer: cstring; length: int64; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc extendWithTemplate*(self: Builder; obj: gobject.Object;
    templateType: GType; buffer: cstring; length: int64): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_extend_with_template(cast[ptr Builder00](self.impl), cast[ptr gobject.Object00](obj.impl), templateType, buffer, length, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_builder_get_current_object(self: ptr Builder00): ptr gobject.Object00 {.
    importc, libprag.}

proc getCurrentObject*(self: Builder): gobject.Object =
  let gobj = gtk_builder_get_current_object(cast[ptr Builder00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc currentObject*(self: Builder): gobject.Object =
  let gobj = gtk_builder_get_current_object(cast[ptr Builder00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_get_object*(self: ptr Builder00; name: cstring): ptr gobject.Object00 {.
    importc, libprag.}

proc getObject*(self: Builder; name: cstring): gobject.Object =
  let gobj = gtk_builder_get_object(cast[ptr Builder00](self.impl), name)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_get_objects(self: ptr Builder00): ptr glib.SList {.
    importc, libprag.}

proc getObjects*(self: Builder): seq[gobject.Object] =
  let resul0 = gtk_builder_get_objects(cast[ptr Builder00](self.impl))
  result = gslistObjects2seq(gobject.Object, resul0, false)
  g_slist_free(resul0)

proc objects*(self: Builder): seq[gobject.Object] =
  let resul0 = gtk_builder_get_objects(cast[ptr Builder00](self.impl))
  result = gslistObjects2seq(gobject.Object, resul0, false)
  g_slist_free(resul0)

proc gtk_builder_get_translation_domain(self: ptr Builder00): cstring {.
    importc, libprag.}

proc getTranslationDomain*(self: Builder): string =
  let resul0 = gtk_builder_get_translation_domain(cast[ptr Builder00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc translationDomain*(self: Builder): string =
  let resul0 = gtk_builder_get_translation_domain(cast[ptr Builder00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_builder_get_type_from_name(self: ptr Builder00; typeName: cstring): GType {.
    importc, libprag.}

proc getTypeFromName*(self: Builder; typeName: cstring): GType =
  gtk_builder_get_type_from_name(cast[ptr Builder00](self.impl), typeName)

proc gtk_builder_set_current_object(self: ptr Builder00; currentObject: ptr gobject.Object00) {.
    importc, libprag.}

proc setCurrentObject*(self: Builder; currentObject: gobject.Object = nil) =
  gtk_builder_set_current_object(cast[ptr Builder00](self.impl), if currentObject.isNil: nil else: cast[ptr gobject.Object00](currentObject.impl))

proc `currentObject=`*(self: Builder; currentObject: gobject.Object = nil) =
  gtk_builder_set_current_object(cast[ptr Builder00](self.impl), if currentObject.isNil: nil else: cast[ptr gobject.Object00](currentObject.impl))

proc gtk_builder_set_translation_domain(self: ptr Builder00; domain: cstring) {.
    importc, libprag.}

proc setTranslationDomain*(self: Builder; domain: cstring = nil) =
  gtk_builder_set_translation_domain(cast[ptr Builder00](self.impl), domain)

proc `translationDomain=`*(self: Builder; domain: cstring = nil) =
  gtk_builder_set_translation_domain(cast[ptr Builder00](self.impl), domain)

proc gtk_builder_value_from_string(self: ptr Builder00; pspec: ptr gobject.ParamSpec00;
    string: cstring; value: var gobject.Value; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc valueFromString*(self: Builder; pspec: gobject.ParamSpec;
    string: cstring; value: var gobject.Value): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_value_from_string(cast[ptr Builder00](self.impl), cast[ptr gobject.ParamSpec00](pspec.impl), string, value, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_builder_value_from_string_type(self: ptr Builder00; `type`: GType;
    string: cstring; value: var gobject.Value; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc valueFromStringType*(self: Builder; `type`: GType; string: cstring;
    value: var gobject.Value): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_value_from_string_type(cast[ptr Builder00](self.impl), `type`, string, value, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

type
  BuilderClosureFlags* {.size: sizeof(cint), pure.} = enum
    swapped = 1

proc gtk_builder_create_closure(self: ptr Builder00; functionName: cstring;
    flags: BuilderClosureFlags; obj: ptr gobject.Object00; error: ptr ptr glib.Error = nil): ptr gobject.Closure00 {.
    importc, libprag.}

proc createClosure*(self: Builder; functionName: cstring; flags: BuilderClosureFlags;
    obj: gobject.Object = nil): gobject.Closure =
  var gerror: ptr glib.Error
  let impl0 = gtk_builder_create_closure(cast[ptr Builder00](self.impl), functionName, flags, if obj.isNil: nil else: cast[ptr gobject.Object00](obj.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGClosure)
  result.impl = impl0

type
  BuilderScope00* = object of gobject.Object00
  BuilderScope* = ref object of gobject.Object

proc gtk_builder_get_scope(self: ptr Builder00): ptr BuilderScope00 {.
    importc, libprag.}

proc getScope*(self: Builder): BuilderScope =
  let gobj = gtk_builder_get_scope(cast[ptr Builder00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc scope*(self: Builder): BuilderScope =
  let gobj = gtk_builder_get_scope(cast[ptr Builder00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  BuilderCScope* = ref object of gobject.Object
  BuilderCScope00* = object of gobject.Object00

proc gtk_builder_cscope_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(BuilderCScope()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_builder_cscope_new(): ptr BuilderCScope00 {.
    importc, libprag.}

proc newBuilderCScope*(): BuilderCScope =
  let gobj = gtk_builder_cscope_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilderCScope*(tdesc: typedesc): tdesc =
  assert(result is BuilderCScope)
  let gobj = gtk_builder_cscope_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderCScope*[T](result: var T) {.deprecated.} =
  assert(result is BuilderCScope)
  let gobj = gtk_builder_cscope_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_cscope_add_callback_symbol(self: ptr BuilderCScope00; callbackName: cstring;
    callbackSymbol: Callback) {.
    importc, libprag.}

proc addCallbackSymbol*(self: BuilderCScope; callbackName: cstring;
    callbackSymbol: Callback) =
  gtk_builder_cscope_add_callback_symbol(cast[ptr BuilderCScope00](self.impl), callbackName, callbackSymbol)

proc gtk_builder_set_scope(self: ptr Builder00; scope: ptr BuilderScope00) {.
    importc, libprag.}

proc setScope*(self: Builder; scope: BuilderScope | BuilderCScope = BuilderScope(nil)) =
  gtk_builder_set_scope(cast[ptr Builder00](self.impl), if scope.isNil: nil else: cast[ptr BuilderScope00](scope.impl))

proc `scope=`*(self: Builder; scope: BuilderScope | BuilderCScope = BuilderScope(nil)) =
  gtk_builder_set_scope(cast[ptr Builder00](self.impl), if scope.isNil: nil else: cast[ptr BuilderScope00](scope.impl))

type
  BuilderError* {.size: sizeof(cint), pure.} = enum
    invalidTypeFunction = 0
    unhandledTag = 1
    missingAttribute = 2
    invalidAttribute = 3
    invalidTag = 4
    missingPropertyValue = 5
    invalidValue = 6
    versionMismatch = 7
    duplicateId = 8
    objectTypeRefused = 9
    templateMismatch = 10
    invalidProperty = 11
    invalidSignal = 12
    invalidId = 13
    invalidFunction = 14

type
  BuilderListItemFactory* = ref object of ListItemFactory
  BuilderListItemFactory00* = object of ListItemFactory00

proc gtk_builder_list_item_factory_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(BuilderListItemFactory()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_builder_list_item_factory_new_from_bytes(scope: ptr BuilderScope00;
    bytes: ptr glib.Bytes00): ptr BuilderListItemFactory00 {.
    importc, libprag.}

proc newBuilderListItemFactoryFromBytes*(scope: BuilderScope | BuilderCScope = BuilderScope(nil);
    bytes: glib.Bytes): BuilderListItemFactory =
  let gobj = gtk_builder_list_item_factory_new_from_bytes(if scope.isNil: nil else: cast[ptr BuilderScope00](scope.impl), cast[ptr glib.Bytes00](bytes.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilderListItemFactoryFromBytes*(tdesc: typedesc; scope: BuilderScope | BuilderCScope = BuilderScope(nil);
    bytes: glib.Bytes): tdesc =
  assert(result is BuilderListItemFactory)
  let gobj = gtk_builder_list_item_factory_new_from_bytes(if scope.isNil: nil else: cast[ptr BuilderScope00](scope.impl), cast[ptr glib.Bytes00](bytes.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderListItemFactoryFromBytes*[T](result: var T; scope: BuilderScope | BuilderCScope = BuilderScope(nil);
    bytes: glib.Bytes) {.deprecated.} =
  assert(result is BuilderListItemFactory)
  let gobj = gtk_builder_list_item_factory_new_from_bytes(if scope.isNil: nil else: cast[ptr BuilderScope00](scope.impl), cast[ptr glib.Bytes00](bytes.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_list_item_factory_new_from_resource(scope: ptr BuilderScope00;
    resourcePath: cstring): ptr BuilderListItemFactory00 {.
    importc, libprag.}

proc newBuilderListItemFactoryFromResource*(scope: BuilderScope | BuilderCScope = BuilderScope(nil);
    resourcePath: cstring): BuilderListItemFactory =
  let gobj = gtk_builder_list_item_factory_new_from_resource(if scope.isNil: nil else: cast[ptr BuilderScope00](scope.impl), resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilderListItemFactoryFromResource*(tdesc: typedesc; scope: BuilderScope | BuilderCScope = BuilderScope(nil);
    resourcePath: cstring): tdesc =
  assert(result is BuilderListItemFactory)
  let gobj = gtk_builder_list_item_factory_new_from_resource(if scope.isNil: nil else: cast[ptr BuilderScope00](scope.impl), resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderListItemFactoryFromResource*[T](result: var T; scope: BuilderScope | BuilderCScope = BuilderScope(nil);
    resourcePath: cstring) {.deprecated.} =
  assert(result is BuilderListItemFactory)
  let gobj = gtk_builder_list_item_factory_new_from_resource(if scope.isNil: nil else: cast[ptr BuilderScope00](scope.impl), resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_list_item_factory_get_bytes(self: ptr BuilderListItemFactory00): ptr glib.Bytes00 {.
    importc, libprag.}

proc getBytes*(self: BuilderListItemFactory): glib.Bytes =
  fnew(result, gBoxedFreeGBytes)
  result.impl = gtk_builder_list_item_factory_get_bytes(cast[ptr BuilderListItemFactory00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_bytes_get_type(), result.impl))

proc bytes*(self: BuilderListItemFactory): glib.Bytes =
  fnew(result, gBoxedFreeGBytes)
  result.impl = gtk_builder_list_item_factory_get_bytes(cast[ptr BuilderListItemFactory00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_bytes_get_type(), result.impl))

proc gtk_builder_list_item_factory_get_resource(self: ptr BuilderListItemFactory00): cstring {.
    importc, libprag.}

proc getResource*(self: BuilderListItemFactory): string =
  let resul0 = gtk_builder_list_item_factory_get_resource(cast[ptr BuilderListItemFactory00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc resource*(self: BuilderListItemFactory): string =
  let resul0 = gtk_builder_list_item_factory_get_resource(cast[ptr BuilderListItemFactory00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_builder_list_item_factory_get_scope(self: ptr BuilderListItemFactory00): ptr BuilderScope00 {.
    importc, libprag.}

proc getScope*(self: BuilderListItemFactory): BuilderScope =
  let gobj = gtk_builder_list_item_factory_get_scope(cast[ptr BuilderListItemFactory00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc scope*(self: BuilderListItemFactory): BuilderScope =
  let gobj = gtk_builder_list_item_factory_get_scope(cast[ptr BuilderListItemFactory00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ButtonsType* {.size: sizeof(cint), pure.} = enum
    none = 0
    ok = 1
    close = 2
    cancel = 3
    yesNo = 4
    okCancel = 5

type
  CClosureExpression* = ref object of Expression
  CClosureExpression00* = object of Expression00

proc gtk_cclosure_expression_get_type*(): GType {.importc, libprag.}

proc gtk_expression_unref*(self: ptr CClosureExpression00) {.importc, libprag.}

proc generic_gtk_expression_unref*(self: CClosureExpression) =
  if not self.ignoreFinalizer:
    gtk_expression_unref(self.impl)

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CClosureExpression()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      gtk_expression_unref(self.impl)
      self.impl = nil

proc gtk_cclosure_expression_new(valueType: GType; marshal: ClosureMarshal;
    nParams: uint32; params: ptr ptr Expression00; callbackFunc: Callback;
    userData: pointer; userDestroy: ClosureNotify): ptr CClosureExpression00 {.
    importc, libprag.}

proc newCClosureExpression*(valueType: GType; marshal: ClosureMarshal;
    nParams: int; params: ptr ptr Expression00; callbackFunc: Callback; userData: pointer;
    userDestroy: ClosureNotify): CClosureExpression =
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_cclosure_expression_new(valueType, marshal, uint32(nParams), params, callbackFunc, userData, userDestroy)

proc newCClosureExpression*(tdesc: typedesc; valueType: GType; marshal: ClosureMarshal;
    nParams: int; params: ptr ptr Expression00; callbackFunc: Callback; userData: pointer;
    userDestroy: ClosureNotify): tdesc =
  assert(result is CClosureExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_cclosure_expression_new(valueType, marshal, uint32(nParams), params, callbackFunc, userData, userDestroy)

proc initCClosureExpression*[T](result: var T; valueType: GType; marshal: ClosureMarshal;
    nParams: int; params: ptr ptr Expression00; callbackFunc: Callback; userData: pointer;
    userDestroy: ClosureNotify) {.deprecated.} =
  assert(result is CClosureExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_cclosure_expression_new(valueType, marshal, uint32(nParams), params, callbackFunc, userData, userDestroy)

type
  CallbackAction* = ref object of ShortcutAction
  CallbackAction00* = object of ShortcutAction00

proc gtk_callback_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CallbackAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  CellAllocCallback* = proc (renderer: ptr CellRenderer00; cellArea: gdk4.Rectangle; cellBackground: gdk4.Rectangle;
    data: pointer): gboolean {.cdecl.}

proc gtk_cell_area_foreach_alloc(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; cellArea: gdk4.Rectangle; backgroundArea: gdk4.Rectangle;
    callback: CellAllocCallback; callbackData: pointer) {.
    importc, libprag.}

proc foreachAlloc*(self: CellArea; context: CellAreaContext;
    widget: Widget; cellArea: gdk4.Rectangle; backgroundArea: gdk4.Rectangle;
    callback: CellAllocCallback; callbackData: pointer) =
  gtk_cell_area_foreach_alloc(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cellArea, backgroundArea, callback, callbackData)

type
  CellCallback* = proc (renderer: ptr CellRenderer00; data: pointer): gboolean {.cdecl.}

proc gtk_cell_area_foreach(self: ptr CellArea00; callback: CellCallback;
    callbackData: pointer) {.
    importc, libprag.}

proc foreach*(self: CellArea; callback: CellCallback; callbackData: pointer) =
  gtk_cell_area_foreach(cast[ptr CellArea00](self.impl), callback, callbackData)

type
  CellLayout00* = object of gobject.Object00
  CellLayout* = ref object of gobject.Object

proc gtk_cell_layout_add_attribute(self: ptr CellLayout00; cell: ptr CellRenderer00;
    attribute: cstring; column: int32) {.
    importc, libprag.}

proc addAttribute*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea;
    cell: CellRenderer; attribute: cstring; column: int) =
  gtk_cell_layout_add_attribute(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), attribute, int32(column))

proc gtk_cell_layout_clear(self: ptr CellLayout00) {.
    importc, libprag.}

proc clear*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea) =
  gtk_cell_layout_clear(cast[ptr CellLayout00](self.impl))

proc gtk_cell_layout_clear_attributes(self: ptr CellLayout00; cell: ptr CellRenderer00) {.
    importc, libprag.}

proc clearAttributes*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea;
    cell: CellRenderer) =
  gtk_cell_layout_clear_attributes(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl))

proc gtk_cell_layout_get_area(self: ptr CellLayout00): ptr CellArea00 {.
    importc, libprag.}

proc getArea*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea): CellArea =
  let gobj = gtk_cell_layout_get_area(cast[ptr CellLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc area*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea): CellArea =
  let gobj = gtk_cell_layout_get_area(cast[ptr CellLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_layout_get_cells(self: ptr CellLayout00): ptr glib.List {.
    importc, libprag.}

proc getCells*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea): seq[CellRenderer] =
  let resul0 = gtk_cell_layout_get_cells(cast[ptr CellLayout00](self.impl))
  result = glistObjects2seq(CellRenderer, resul0, false)
  g_list_free(resul0)

proc cells*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea): seq[CellRenderer] =
  let resul0 = gtk_cell_layout_get_cells(cast[ptr CellLayout00](self.impl))
  result = glistObjects2seq(CellRenderer, resul0, false)
  g_list_free(resul0)

proc gtk_cell_layout_pack_end(self: ptr CellLayout00; cell: ptr CellRenderer00;
    expand: gboolean) {.
    importc, libprag.}

proc packEnd*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea;
    cell: CellRenderer; expand: bool) =
  gtk_cell_layout_pack_end(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_cell_layout_pack_start(self: ptr CellLayout00; cell: ptr CellRenderer00;
    expand: gboolean) {.
    importc, libprag.}

proc packStart*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea;
    cell: CellRenderer; expand: bool) =
  gtk_cell_layout_pack_start(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_cell_layout_reorder(self: ptr CellLayout00; cell: ptr CellRenderer00;
    position: int32) {.
    importc, libprag.}

proc reorder*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea;
    cell: CellRenderer; position: int) =
  gtk_cell_layout_reorder(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), int32(position))

type
  CellLayoutDataFunc* = proc (cellLayout: ptr CellLayout00; cell: ptr CellRenderer00; treeModel: ptr TreeModel00;
    iter: TreeIter; data: pointer) {.cdecl.}

proc gtk_cell_layout_set_cell_data_func(self: ptr CellLayout00; cell: ptr CellRenderer00;
    `func`: CellLayoutDataFunc; funcData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setCellDataFunc*(self: CellLayout | ComboBox | TreeViewColumn | ComboBoxText | CellView | IconView | EntryCompletion | CellAreaBox | CellArea;
    cell: CellRenderer; `func`: CellLayoutDataFunc; funcData: pointer; destroy: DestroyNotify) =
  gtk_cell_layout_set_cell_data_func(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), `func`, funcData, destroy)

type
  CellRendererText* = ref object of CellRenderer
  CellRendererText00* = object of CellRenderer00

proc gtk_cell_renderer_text_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererText()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEdited*(self: CellRendererText;  p: proc (self: ptr CellRendererText00; path: cstring; newText: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "edited", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_text_new(): ptr CellRendererText00 {.
    importc, libprag.}

proc newCellRendererText*(): CellRendererText {.deprecated.}  =
  let gobj = gtk_cell_renderer_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererText*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellRendererText)
  let gobj = gtk_cell_renderer_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererText*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererText)
  let gobj = gtk_cell_renderer_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_renderer_text_set_fixed_height_from_font(self: ptr CellRendererText00;
    numberOfRows: int32) {.
    importc, libprag.}

proc setFixedHeightFromFont*(self: CellRendererText;
    numberOfRows: int) =
  gtk_cell_renderer_text_set_fixed_height_from_font(cast[ptr CellRendererText00](self.impl), int32(numberOfRows))

proc `fixedHeightFromFont=`*(self: CellRendererText;
    numberOfRows: int) =
  gtk_cell_renderer_text_set_fixed_height_from_font(cast[ptr CellRendererText00](self.impl), int32(numberOfRows))

type
  CellRendererAccel* = ref object of CellRendererText
  CellRendererAccel00* = object of CellRendererText00

proc gtk_cell_renderer_accel_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererAccel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAccelCleared*(self: CellRendererAccel;  p: proc (self: ptr CellRendererAccel00; pathString: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accel-cleared", cast[GCallback](p), xdata, nil, cf)

proc scAccelEdited*(self: CellRendererAccel;  p: proc (self: ptr CellRendererAccel00; pathString: cstring; accelKey: uint32; accelMods: gdk4.ModifierType;
    hardwareKeycode: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accel-edited", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_accel_new(): ptr CellRendererAccel00 {.
    importc, libprag.}

proc newCellRendererAccel*(): CellRendererAccel {.deprecated.}  =
  let gobj = gtk_cell_renderer_accel_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererAccel*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellRendererAccel)
  let gobj = gtk_cell_renderer_accel_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererAccel*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererAccel)
  let gobj = gtk_cell_renderer_accel_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererAccelMode* {.size: sizeof(cint), pure.} = enum
    gtk = 0
    other = 1

type
  CellRendererCombo* = ref object of CellRendererText
  CellRendererCombo00* = object of CellRendererText00

proc gtk_cell_renderer_combo_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererCombo()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: CellRendererCombo;  p: proc (self: ptr CellRendererCombo00; pathString: cstring; newIter: TreeIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_combo_new(): ptr CellRendererCombo00 {.
    importc, libprag.}

proc newCellRendererCombo*(): CellRendererCombo {.deprecated.}  =
  let gobj = gtk_cell_renderer_combo_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererCombo*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellRendererCombo)
  let gobj = gtk_cell_renderer_combo_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererCombo*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererCombo)
  let gobj = gtk_cell_renderer_combo_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererMode* {.size: sizeof(cint), pure.} = enum
    inert = 0
    activatable = 1
    editable = 2

type
  CellRendererPixbuf* = ref object of CellRenderer
  CellRendererPixbuf00* = object of CellRenderer00

proc gtk_cell_renderer_pixbuf_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererPixbuf()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_renderer_pixbuf_new(): ptr CellRendererPixbuf00 {.
    importc, libprag.}

proc newCellRendererPixbuf*(): CellRendererPixbuf {.deprecated.}  =
  let gobj = gtk_cell_renderer_pixbuf_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererPixbuf*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellRendererPixbuf)
  let gobj = gtk_cell_renderer_pixbuf_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererPixbuf*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererPixbuf)
  let gobj = gtk_cell_renderer_pixbuf_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererProgress* = ref object of CellRenderer
  CellRendererProgress00* = object of CellRenderer00

proc gtk_cell_renderer_progress_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererProgress()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_renderer_progress_new(): ptr CellRendererProgress00 {.
    importc, libprag.}

proc newCellRendererProgress*(): CellRendererProgress {.deprecated.}  =
  let gobj = gtk_cell_renderer_progress_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererProgress*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellRendererProgress)
  let gobj = gtk_cell_renderer_progress_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererProgress*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererProgress)
  let gobj = gtk_cell_renderer_progress_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererSpin* = ref object of CellRendererText
  CellRendererSpin00* = object of CellRendererText00

proc gtk_cell_renderer_spin_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererSpin()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_renderer_spin_new(): ptr CellRendererSpin00 {.
    importc, libprag.}

proc newCellRendererSpin*(): CellRendererSpin {.deprecated.}  =
  let gobj = gtk_cell_renderer_spin_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererSpin*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellRendererSpin)
  let gobj = gtk_cell_renderer_spin_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererSpin*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererSpin)
  let gobj = gtk_cell_renderer_spin_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererSpinner* = ref object of CellRenderer
  CellRendererSpinner00* = object of CellRenderer00

proc gtk_cell_renderer_spinner_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererSpinner()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_renderer_spinner_new(): ptr CellRendererSpinner00 {.
    importc, libprag.}

proc newCellRendererSpinner*(): CellRendererSpinner {.deprecated.}  =
  let gobj = gtk_cell_renderer_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererSpinner*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellRendererSpinner)
  let gobj = gtk_cell_renderer_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererSpinner*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererSpinner)
  let gobj = gtk_cell_renderer_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererToggle* = ref object of CellRenderer
  CellRendererToggle00* = object of CellRenderer00

proc gtk_cell_renderer_toggle_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererToggle()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scToggled*(self: CellRendererToggle;  p: proc (self: ptr CellRendererToggle00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_toggle_new(): ptr CellRendererToggle00 {.
    importc, libprag.}

proc newCellRendererToggle*(): CellRendererToggle {.deprecated.}  =
  let gobj = gtk_cell_renderer_toggle_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererToggle*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is CellRendererToggle)
  let gobj = gtk_cell_renderer_toggle_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererToggle*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererToggle)
  let gobj = gtk_cell_renderer_toggle_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_renderer_toggle_get_activatable(self: ptr CellRendererToggle00): gboolean {.
    importc, libprag.}

proc getActivatable*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_activatable(cast[ptr CellRendererToggle00](self.impl)))

proc activatable*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_activatable(cast[ptr CellRendererToggle00](self.impl)))

proc gtk_cell_renderer_toggle_get_active(self: ptr CellRendererToggle00): gboolean {.
    importc, libprag.}

proc getActive*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_active(cast[ptr CellRendererToggle00](self.impl)))

proc active*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_active(cast[ptr CellRendererToggle00](self.impl)))

proc gtk_cell_renderer_toggle_get_radio(self: ptr CellRendererToggle00): gboolean {.
    importc, libprag.}

proc getRadio*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_radio(cast[ptr CellRendererToggle00](self.impl)))

proc radio*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_radio(cast[ptr CellRendererToggle00](self.impl)))

proc gtk_cell_renderer_toggle_set_activatable(self: ptr CellRendererToggle00;
    setting: gboolean) {.
    importc, libprag.}

proc setActivatable*(self: CellRendererToggle; setting: bool = true) =
  gtk_cell_renderer_toggle_set_activatable(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc `activatable=`*(self: CellRendererToggle; setting: bool) =
  gtk_cell_renderer_toggle_set_activatable(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc gtk_cell_renderer_toggle_set_active(self: ptr CellRendererToggle00;
    setting: gboolean) {.
    importc, libprag.}

proc setActive*(self: CellRendererToggle; setting: bool = true) =
  gtk_cell_renderer_toggle_set_active(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc `active=`*(self: CellRendererToggle; setting: bool) =
  gtk_cell_renderer_toggle_set_active(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc gtk_cell_renderer_toggle_set_radio(self: ptr CellRendererToggle00; radio: gboolean) {.
    importc, libprag.}

proc setRadio*(self: CellRendererToggle; radio: bool = true) =
  gtk_cell_renderer_toggle_set_radio(cast[ptr CellRendererToggle00](self.impl), gboolean(radio))

proc `radio=`*(self: CellRendererToggle; radio: bool) =
  gtk_cell_renderer_toggle_set_radio(cast[ptr CellRendererToggle00](self.impl), gboolean(radio))

type
  CenterLayout* = ref object of LayoutManager
  CenterLayout00* = object of LayoutManager00

proc gtk_center_layout_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CenterLayout()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_center_layout_new(): ptr CenterLayout00 {.
    importc, libprag.}

proc newCenterLayout*(): CenterLayout =
  let gobj = gtk_center_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCenterLayout*(tdesc: typedesc): tdesc =
  assert(result is CenterLayout)
  let gobj = gtk_center_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCenterLayout*[T](result: var T) {.deprecated.} =
  assert(result is CenterLayout)
  let gobj = gtk_center_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_center_layout_get_baseline_position(self: ptr CenterLayout00): BaselinePosition {.
    importc, libprag.}

proc getBaselinePosition*(self: CenterLayout): BaselinePosition =
  gtk_center_layout_get_baseline_position(cast[ptr CenterLayout00](self.impl))

proc baselinePosition*(self: CenterLayout): BaselinePosition =
  gtk_center_layout_get_baseline_position(cast[ptr CenterLayout00](self.impl))

proc gtk_center_layout_get_center_widget(self: ptr CenterLayout00): ptr Widget00 {.
    importc, libprag.}

proc getCenterWidget*(self: CenterLayout): Widget =
  let gobj = gtk_center_layout_get_center_widget(cast[ptr CenterLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc centerWidget*(self: CenterLayout): Widget =
  let gobj = gtk_center_layout_get_center_widget(cast[ptr CenterLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_center_layout_get_end_widget(self: ptr CenterLayout00): ptr Widget00 {.
    importc, libprag.}

proc getEndWidget*(self: CenterLayout): Widget =
  let gobj = gtk_center_layout_get_end_widget(cast[ptr CenterLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc endWidget*(self: CenterLayout): Widget =
  let gobj = gtk_center_layout_get_end_widget(cast[ptr CenterLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_center_layout_get_orientation(self: ptr CenterLayout00): Orientation {.
    importc, libprag.}

proc getOrientation*(self: CenterLayout): Orientation =
  gtk_center_layout_get_orientation(cast[ptr CenterLayout00](self.impl))

proc orientation*(self: CenterLayout): Orientation =
  gtk_center_layout_get_orientation(cast[ptr CenterLayout00](self.impl))

proc gtk_center_layout_get_shrink_center_last(self: ptr CenterLayout00): gboolean {.
    importc, libprag.}

proc getShrinkCenterLast*(self: CenterLayout): bool =
  toBool(gtk_center_layout_get_shrink_center_last(cast[ptr CenterLayout00](self.impl)))

proc shrinkCenterLast*(self: CenterLayout): bool =
  toBool(gtk_center_layout_get_shrink_center_last(cast[ptr CenterLayout00](self.impl)))

proc gtk_center_layout_get_start_widget(self: ptr CenterLayout00): ptr Widget00 {.
    importc, libprag.}

proc getStartWidget*(self: CenterLayout): Widget =
  let gobj = gtk_center_layout_get_start_widget(cast[ptr CenterLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc startWidget*(self: CenterLayout): Widget =
  let gobj = gtk_center_layout_get_start_widget(cast[ptr CenterLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_center_layout_set_baseline_position(self: ptr CenterLayout00; baselinePosition: BaselinePosition) {.
    importc, libprag.}

proc setBaselinePosition*(self: CenterLayout; baselinePosition: BaselinePosition) =
  gtk_center_layout_set_baseline_position(cast[ptr CenterLayout00](self.impl), baselinePosition)

proc `baselinePosition=`*(self: CenterLayout; baselinePosition: BaselinePosition) =
  gtk_center_layout_set_baseline_position(cast[ptr CenterLayout00](self.impl), baselinePosition)

proc gtk_center_layout_set_center_widget(self: ptr CenterLayout00; widget: ptr Widget00) {.
    importc, libprag.}

proc setCenterWidget*(self: CenterLayout; widget: Widget = nil) =
  gtk_center_layout_set_center_widget(cast[ptr CenterLayout00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `centerWidget=`*(self: CenterLayout; widget: Widget = nil) =
  gtk_center_layout_set_center_widget(cast[ptr CenterLayout00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_center_layout_set_end_widget(self: ptr CenterLayout00; widget: ptr Widget00) {.
    importc, libprag.}

proc setEndWidget*(self: CenterLayout; widget: Widget = nil) =
  gtk_center_layout_set_end_widget(cast[ptr CenterLayout00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `endWidget=`*(self: CenterLayout; widget: Widget = nil) =
  gtk_center_layout_set_end_widget(cast[ptr CenterLayout00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_center_layout_set_orientation(self: ptr CenterLayout00; orientation: Orientation) {.
    importc, libprag.}

proc setOrientation*(self: CenterLayout; orientation: Orientation) =
  gtk_center_layout_set_orientation(cast[ptr CenterLayout00](self.impl), orientation)

proc `orientation=`*(self: CenterLayout; orientation: Orientation) =
  gtk_center_layout_set_orientation(cast[ptr CenterLayout00](self.impl), orientation)

proc gtk_center_layout_set_shrink_center_last(self: ptr CenterLayout00; shrinkCenterLast: gboolean) {.
    importc, libprag.}

proc setShrinkCenterLast*(self: CenterLayout; shrinkCenterLast: bool = true) =
  gtk_center_layout_set_shrink_center_last(cast[ptr CenterLayout00](self.impl), gboolean(shrinkCenterLast))

proc `shrinkCenterLast=`*(self: CenterLayout; shrinkCenterLast: bool) =
  gtk_center_layout_set_shrink_center_last(cast[ptr CenterLayout00](self.impl), gboolean(shrinkCenterLast))

proc gtk_center_layout_set_start_widget(self: ptr CenterLayout00; widget: ptr Widget00) {.
    importc, libprag.}

proc setStartWidget*(self: CenterLayout; widget: Widget = nil) =
  gtk_center_layout_set_start_widget(cast[ptr CenterLayout00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `startWidget=`*(self: CenterLayout; widget: Widget = nil) =
  gtk_center_layout_set_start_widget(cast[ptr CenterLayout00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

type
  ClosureExpression* = ref object of Expression
  ClosureExpression00* = object of Expression00

proc gtk_closure_expression_get_type*(): GType {.importc, libprag.}

proc gtk_expression_unref*(self: ptr ClosureExpression00) {.importc, libprag.}

proc generic_gtk_expression_unref*(self: ClosureExpression) =
  if not self.ignoreFinalizer:
    gtk_expression_unref(self.impl)

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ClosureExpression()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      gtk_expression_unref(self.impl)
      self.impl = nil

proc gtk_closure_expression_new(valueType: GType; closure: ptr gobject.Closure00;
    nParams: uint32; params: ptr ptr Expression00): ptr ClosureExpression00 {.
    importc, libprag.}

proc newClosureExpression*(valueType: GType; closure: gobject.Closure;
    nParams: int; params: ptr ptr Expression00): ClosureExpression =
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_closure_expression_new(valueType, cast[ptr gobject.Closure00](closure.impl), uint32(nParams), params)

proc newClosureExpression*(tdesc: typedesc; valueType: GType; closure: gobject.Closure;
    nParams: int; params: ptr ptr Expression00): tdesc =
  assert(result is ClosureExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_closure_expression_new(valueType, cast[ptr gobject.Closure00](closure.impl), uint32(nParams), params)

proc initClosureExpression*[T](result: var T; valueType: GType; closure: gobject.Closure;
    nParams: int; params: ptr ptr Expression00) {.deprecated.} =
  assert(result is ClosureExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_closure_expression_new(valueType, cast[ptr gobject.Closure00](closure.impl), uint32(nParams), params)

type
  Collation* {.size: sizeof(cint), pure.} = enum
    none = 0
    unicode = 1
    filename = 2

type
  ColorChooser00* = object of gobject.Object00
  ColorChooser* = ref object of gobject.Object

proc scColorActivated*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton;  p: proc (self: ptr ColorChooser00; color: gdk4.RGBA; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "color-activated", cast[GCallback](p), xdata, nil, cf)

proc gtk_color_chooser_add_palette(self: ptr ColorChooser00; orientation: Orientation;
    colorsPerLine: int32; nColors: int32; colors: ptr gdk4.RGBA) {.
    importc, libprag.}

proc addPalette*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton;
    orientation: Orientation; colorsPerLine: int; nColors: int; colors: ptr gdk4.RGBA) =
  gtk_color_chooser_add_palette(cast[ptr ColorChooser00](self.impl), orientation, int32(colorsPerLine), int32(nColors), colors)

proc gtk_color_chooser_get_rgba(self: ptr ColorChooser00; color: var gdk4.RGBA) {.
    importc, libprag.}

proc getRgba*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton;
    color: var gdk4.RGBA) =
  gtk_color_chooser_get_rgba(cast[ptr ColorChooser00](self.impl), color)

proc getRgba*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton): gdk4.RGBA =
  gtk_color_chooser_get_rgba(cast[ptr ColorChooser00](self.impl), result)

proc gtk_color_chooser_get_use_alpha(self: ptr ColorChooser00): gboolean {.
    importc, libprag.}

proc getUseAlpha*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton): bool =
  toBool(gtk_color_chooser_get_use_alpha(cast[ptr ColorChooser00](self.impl)))

proc useAlpha*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton): bool =
  toBool(gtk_color_chooser_get_use_alpha(cast[ptr ColorChooser00](self.impl)))

proc gtk_color_chooser_set_rgba(self: ptr ColorChooser00; color: gdk4.RGBA) {.
    importc, libprag.}

proc setRgba*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton;
    color: gdk4.RGBA) =
  gtk_color_chooser_set_rgba(cast[ptr ColorChooser00](self.impl), color)

proc `rgba=`*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton;
    color: gdk4.RGBA) =
  gtk_color_chooser_set_rgba(cast[ptr ColorChooser00](self.impl), color)

proc gtk_color_chooser_set_use_alpha(self: ptr ColorChooser00; useAlpha: gboolean) {.
    importc, libprag.}

proc setUseAlpha*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton;
    useAlpha: bool = true) =
  gtk_color_chooser_set_use_alpha(cast[ptr ColorChooser00](self.impl), gboolean(useAlpha))

proc `useAlpha=`*(self: ColorChooser | ColorChooserWidget | ColorChooserDialog | ColorButton;
    useAlpha: bool) =
  gtk_color_chooser_set_use_alpha(cast[ptr ColorChooser00](self.impl), gboolean(useAlpha))

type
  ListItem* = ref object of gobject.Object
  ListItem00* = object of gobject.Object00

proc gtk_list_item_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListItem()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_list_item_get_accessible_description(self: ptr ListItem00): cstring {.
    importc, libprag.}

proc getAccessibleDescription*(self: ListItem): string =
  result = $gtk_list_item_get_accessible_description(cast[ptr ListItem00](self.impl))

proc accessibleDescription*(self: ListItem): string =
  result = $gtk_list_item_get_accessible_description(cast[ptr ListItem00](self.impl))

proc gtk_list_item_get_accessible_label(self: ptr ListItem00): cstring {.
    importc, libprag.}

proc getAccessibleLabel*(self: ListItem): string =
  result = $gtk_list_item_get_accessible_label(cast[ptr ListItem00](self.impl))

proc accessibleLabel*(self: ListItem): string =
  result = $gtk_list_item_get_accessible_label(cast[ptr ListItem00](self.impl))

proc gtk_list_item_get_activatable(self: ptr ListItem00): gboolean {.
    importc, libprag.}

proc getActivatable*(self: ListItem): bool =
  toBool(gtk_list_item_get_activatable(cast[ptr ListItem00](self.impl)))

proc activatable*(self: ListItem): bool =
  toBool(gtk_list_item_get_activatable(cast[ptr ListItem00](self.impl)))

proc gtk_list_item_get_child(self: ptr ListItem00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: ListItem): Widget =
  let gobj = gtk_list_item_get_child(cast[ptr ListItem00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: ListItem): Widget =
  let gobj = gtk_list_item_get_child(cast[ptr ListItem00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_item_get_focusable(self: ptr ListItem00): gboolean {.
    importc, libprag.}

proc getFocusable*(self: ListItem): bool =
  toBool(gtk_list_item_get_focusable(cast[ptr ListItem00](self.impl)))

proc focusable*(self: ListItem): bool =
  toBool(gtk_list_item_get_focusable(cast[ptr ListItem00](self.impl)))

proc gtk_list_item_get_item(self: ptr ListItem00): ptr gobject.Object00 {.
    importc, libprag.}

proc getItem*(self: ListItem): gobject.Object =
  let gobj = gtk_list_item_get_item(cast[ptr ListItem00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc item*(self: ListItem): gobject.Object =
  let gobj = gtk_list_item_get_item(cast[ptr ListItem00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_item_get_position(self: ptr ListItem00): uint32 {.
    importc, libprag.}

proc getPosition*(self: ListItem): int =
  int(gtk_list_item_get_position(cast[ptr ListItem00](self.impl)))

proc position*(self: ListItem): int =
  int(gtk_list_item_get_position(cast[ptr ListItem00](self.impl)))

proc gtk_list_item_get_selectable(self: ptr ListItem00): gboolean {.
    importc, libprag.}

proc getSelectable*(self: ListItem): bool =
  toBool(gtk_list_item_get_selectable(cast[ptr ListItem00](self.impl)))

proc selectable*(self: ListItem): bool =
  toBool(gtk_list_item_get_selectable(cast[ptr ListItem00](self.impl)))

proc gtk_list_item_get_selected(self: ptr ListItem00): gboolean {.
    importc, libprag.}

proc getSelected*(self: ListItem): bool =
  toBool(gtk_list_item_get_selected(cast[ptr ListItem00](self.impl)))

proc selected*(self: ListItem): bool =
  toBool(gtk_list_item_get_selected(cast[ptr ListItem00](self.impl)))

proc gtk_list_item_set_accessible_description(self: ptr ListItem00; description: cstring) {.
    importc, libprag.}

proc setAccessibleDescription*(self: ListItem; description: cstring) =
  gtk_list_item_set_accessible_description(cast[ptr ListItem00](self.impl), description)

proc `accessibleDescription=`*(self: ListItem; description: cstring) =
  gtk_list_item_set_accessible_description(cast[ptr ListItem00](self.impl), description)

proc gtk_list_item_set_accessible_label(self: ptr ListItem00; label: cstring) {.
    importc, libprag.}

proc setAccessibleLabel*(self: ListItem; label: cstring) =
  gtk_list_item_set_accessible_label(cast[ptr ListItem00](self.impl), label)

proc `accessibleLabel=`*(self: ListItem; label: cstring) =
  gtk_list_item_set_accessible_label(cast[ptr ListItem00](self.impl), label)

proc gtk_list_item_set_activatable(self: ptr ListItem00; activatable: gboolean) {.
    importc, libprag.}

proc setActivatable*(self: ListItem; activatable: bool = true) =
  gtk_list_item_set_activatable(cast[ptr ListItem00](self.impl), gboolean(activatable))

proc `activatable=`*(self: ListItem; activatable: bool) =
  gtk_list_item_set_activatable(cast[ptr ListItem00](self.impl), gboolean(activatable))

proc gtk_list_item_set_child(self: ptr ListItem00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: ListItem; child: Widget = nil) =
  gtk_list_item_set_child(cast[ptr ListItem00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: ListItem; child: Widget = nil) =
  gtk_list_item_set_child(cast[ptr ListItem00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_list_item_set_focusable(self: ptr ListItem00; focusable: gboolean) {.
    importc, libprag.}

proc setFocusable*(self: ListItem; focusable: bool = true) =
  gtk_list_item_set_focusable(cast[ptr ListItem00](self.impl), gboolean(focusable))

proc `focusable=`*(self: ListItem; focusable: bool) =
  gtk_list_item_set_focusable(cast[ptr ListItem00](self.impl), gboolean(focusable))

proc gtk_list_item_set_selectable(self: ptr ListItem00; selectable: gboolean) {.
    importc, libprag.}

proc setSelectable*(self: ListItem; selectable: bool = true) =
  gtk_list_item_set_selectable(cast[ptr ListItem00](self.impl), gboolean(selectable))

proc `selectable=`*(self: ListItem; selectable: bool) =
  gtk_list_item_set_selectable(cast[ptr ListItem00](self.impl), gboolean(selectable))

type
  ColumnViewCell* = ref object of ListItem
  ColumnViewCell00* = object of ListItem00

proc gtk_column_view_cell_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColumnViewCell()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_column_view_cell_get_child(self: ptr ColumnViewCell00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: ColumnViewCell): Widget =
  let gobj = gtk_column_view_cell_get_child(cast[ptr ColumnViewCell00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: ColumnViewCell): Widget =
  let gobj = gtk_column_view_cell_get_child(cast[ptr ColumnViewCell00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_cell_get_focusable(self: ptr ColumnViewCell00): gboolean {.
    importc, libprag.}

proc getFocusable*(self: ColumnViewCell): bool =
  toBool(gtk_column_view_cell_get_focusable(cast[ptr ColumnViewCell00](self.impl)))

proc focusable*(self: ColumnViewCell): bool =
  toBool(gtk_column_view_cell_get_focusable(cast[ptr ColumnViewCell00](self.impl)))

proc gtk_column_view_cell_get_item(self: ptr ColumnViewCell00): ptr gobject.Object00 {.
    importc, libprag.}

proc getItem*(self: ColumnViewCell): gobject.Object =
  let gobj = gtk_column_view_cell_get_item(cast[ptr ColumnViewCell00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc item*(self: ColumnViewCell): gobject.Object =
  let gobj = gtk_column_view_cell_get_item(cast[ptr ColumnViewCell00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_cell_get_position(self: ptr ColumnViewCell00): uint32 {.
    importc, libprag.}

proc getPosition*(self: ColumnViewCell): int =
  int(gtk_column_view_cell_get_position(cast[ptr ColumnViewCell00](self.impl)))

proc position*(self: ColumnViewCell): int =
  int(gtk_column_view_cell_get_position(cast[ptr ColumnViewCell00](self.impl)))

proc gtk_column_view_cell_get_selected(self: ptr ColumnViewCell00): gboolean {.
    importc, libprag.}

proc getSelected*(self: ColumnViewCell): bool =
  toBool(gtk_column_view_cell_get_selected(cast[ptr ColumnViewCell00](self.impl)))

proc selected*(self: ColumnViewCell): bool =
  toBool(gtk_column_view_cell_get_selected(cast[ptr ColumnViewCell00](self.impl)))

proc gtk_column_view_cell_set_child(self: ptr ColumnViewCell00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: ColumnViewCell; child: Widget = nil) =
  gtk_column_view_cell_set_child(cast[ptr ColumnViewCell00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: ColumnViewCell; child: Widget = nil) =
  gtk_column_view_cell_set_child(cast[ptr ColumnViewCell00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_column_view_cell_set_focusable(self: ptr ColumnViewCell00; focusable: gboolean) {.
    importc, libprag.}

proc setFocusable*(self: ColumnViewCell; focusable: bool = true) =
  gtk_column_view_cell_set_focusable(cast[ptr ColumnViewCell00](self.impl), gboolean(focusable))

proc `focusable=`*(self: ColumnViewCell; focusable: bool) =
  gtk_column_view_cell_set_focusable(cast[ptr ColumnViewCell00](self.impl), gboolean(focusable))

type
  ColumnViewRow* = ref object of gobject.Object
  ColumnViewRow00* = object of gobject.Object00

proc gtk_column_view_row_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColumnViewRow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_column_view_row_get_accessible_description(self: ptr ColumnViewRow00): cstring {.
    importc, libprag.}

proc getAccessibleDescription*(self: ColumnViewRow): string =
  result = $gtk_column_view_row_get_accessible_description(cast[ptr ColumnViewRow00](self.impl))

proc accessibleDescription*(self: ColumnViewRow): string =
  result = $gtk_column_view_row_get_accessible_description(cast[ptr ColumnViewRow00](self.impl))

proc gtk_column_view_row_get_accessible_label(self: ptr ColumnViewRow00): cstring {.
    importc, libprag.}

proc getAccessibleLabel*(self: ColumnViewRow): string =
  result = $gtk_column_view_row_get_accessible_label(cast[ptr ColumnViewRow00](self.impl))

proc accessibleLabel*(self: ColumnViewRow): string =
  result = $gtk_column_view_row_get_accessible_label(cast[ptr ColumnViewRow00](self.impl))

proc gtk_column_view_row_get_activatable(self: ptr ColumnViewRow00): gboolean {.
    importc, libprag.}

proc getActivatable*(self: ColumnViewRow): bool =
  toBool(gtk_column_view_row_get_activatable(cast[ptr ColumnViewRow00](self.impl)))

proc activatable*(self: ColumnViewRow): bool =
  toBool(gtk_column_view_row_get_activatable(cast[ptr ColumnViewRow00](self.impl)))

proc gtk_column_view_row_get_focusable(self: ptr ColumnViewRow00): gboolean {.
    importc, libprag.}

proc getFocusable*(self: ColumnViewRow): bool =
  toBool(gtk_column_view_row_get_focusable(cast[ptr ColumnViewRow00](self.impl)))

proc focusable*(self: ColumnViewRow): bool =
  toBool(gtk_column_view_row_get_focusable(cast[ptr ColumnViewRow00](self.impl)))

proc gtk_column_view_row_get_item(self: ptr ColumnViewRow00): ptr gobject.Object00 {.
    importc, libprag.}

proc getItem*(self: ColumnViewRow): gobject.Object =
  let gobj = gtk_column_view_row_get_item(cast[ptr ColumnViewRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc item*(self: ColumnViewRow): gobject.Object =
  let gobj = gtk_column_view_row_get_item(cast[ptr ColumnViewRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_row_get_position(self: ptr ColumnViewRow00): uint32 {.
    importc, libprag.}

proc getPosition*(self: ColumnViewRow): int =
  int(gtk_column_view_row_get_position(cast[ptr ColumnViewRow00](self.impl)))

proc position*(self: ColumnViewRow): int =
  int(gtk_column_view_row_get_position(cast[ptr ColumnViewRow00](self.impl)))

proc gtk_column_view_row_get_selectable(self: ptr ColumnViewRow00): gboolean {.
    importc, libprag.}

proc getSelectable*(self: ColumnViewRow): bool =
  toBool(gtk_column_view_row_get_selectable(cast[ptr ColumnViewRow00](self.impl)))

proc selectable*(self: ColumnViewRow): bool =
  toBool(gtk_column_view_row_get_selectable(cast[ptr ColumnViewRow00](self.impl)))

proc gtk_column_view_row_get_selected(self: ptr ColumnViewRow00): gboolean {.
    importc, libprag.}

proc getSelected*(self: ColumnViewRow): bool =
  toBool(gtk_column_view_row_get_selected(cast[ptr ColumnViewRow00](self.impl)))

proc selected*(self: ColumnViewRow): bool =
  toBool(gtk_column_view_row_get_selected(cast[ptr ColumnViewRow00](self.impl)))

proc gtk_column_view_row_set_accessible_description(self: ptr ColumnViewRow00;
    description: cstring) {.
    importc, libprag.}

proc setAccessibleDescription*(self: ColumnViewRow;
    description: cstring) =
  gtk_column_view_row_set_accessible_description(cast[ptr ColumnViewRow00](self.impl), description)

proc `accessibleDescription=`*(self: ColumnViewRow;
    description: cstring) =
  gtk_column_view_row_set_accessible_description(cast[ptr ColumnViewRow00](self.impl), description)

proc gtk_column_view_row_set_accessible_label(self: ptr ColumnViewRow00;
    label: cstring) {.
    importc, libprag.}

proc setAccessibleLabel*(self: ColumnViewRow; label: cstring) =
  gtk_column_view_row_set_accessible_label(cast[ptr ColumnViewRow00](self.impl), label)

proc `accessibleLabel=`*(self: ColumnViewRow; label: cstring) =
  gtk_column_view_row_set_accessible_label(cast[ptr ColumnViewRow00](self.impl), label)

proc gtk_column_view_row_set_activatable(self: ptr ColumnViewRow00; activatable: gboolean) {.
    importc, libprag.}

proc setActivatable*(self: ColumnViewRow; activatable: bool = true) =
  gtk_column_view_row_set_activatable(cast[ptr ColumnViewRow00](self.impl), gboolean(activatable))

proc `activatable=`*(self: ColumnViewRow; activatable: bool) =
  gtk_column_view_row_set_activatable(cast[ptr ColumnViewRow00](self.impl), gboolean(activatable))

proc gtk_column_view_row_set_focusable(self: ptr ColumnViewRow00; focusable: gboolean) {.
    importc, libprag.}

proc setFocusable*(self: ColumnViewRow; focusable: bool = true) =
  gtk_column_view_row_set_focusable(cast[ptr ColumnViewRow00](self.impl), gboolean(focusable))

proc `focusable=`*(self: ColumnViewRow; focusable: bool) =
  gtk_column_view_row_set_focusable(cast[ptr ColumnViewRow00](self.impl), gboolean(focusable))

proc gtk_column_view_row_set_selectable(self: ptr ColumnViewRow00; selectable: gboolean) {.
    importc, libprag.}

proc setSelectable*(self: ColumnViewRow; selectable: bool = true) =
  gtk_column_view_row_set_selectable(cast[ptr ColumnViewRow00](self.impl), gboolean(selectable))

proc `selectable=`*(self: ColumnViewRow; selectable: bool) =
  gtk_column_view_row_set_selectable(cast[ptr ColumnViewRow00](self.impl), gboolean(selectable))

type
  ColumnViewSorter* = ref object of Sorter
  ColumnViewSorter00* = object of Sorter00

proc gtk_column_view_sorter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColumnViewSorter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_column_view_sorter_get_n_sort_columns(self: ptr ColumnViewSorter00): uint32 {.
    importc, libprag.}

proc getNSortColumns*(self: ColumnViewSorter): int =
  int(gtk_column_view_sorter_get_n_sort_columns(cast[ptr ColumnViewSorter00](self.impl)))

proc nSortColumns*(self: ColumnViewSorter): int =
  int(gtk_column_view_sorter_get_n_sort_columns(cast[ptr ColumnViewSorter00](self.impl)))

proc gtk_column_view_sorter_get_nth_sort_column(self: ptr ColumnViewSorter00;
    position: uint32; sortOrder: var SortType): ptr ColumnViewColumn00 {.
    importc, libprag.}

proc getNthSortColumn*(self: ColumnViewSorter; position: int;
    sortOrder: var SortType): ColumnViewColumn =
  let gobj = gtk_column_view_sorter_get_nth_sort_column(cast[ptr ColumnViewSorter00](self.impl), uint32(position), sortOrder)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_sorter_get_primary_sort_column(self: ptr ColumnViewSorter00): ptr ColumnViewColumn00 {.
    importc, libprag.}

proc getPrimarySortColumn*(self: ColumnViewSorter): ColumnViewColumn =
  let gobj = gtk_column_view_sorter_get_primary_sort_column(cast[ptr ColumnViewSorter00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc primarySortColumn*(self: ColumnViewSorter): ColumnViewColumn =
  let gobj = gtk_column_view_sorter_get_primary_sort_column(cast[ptr ColumnViewSorter00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_column_view_sorter_get_primary_sort_order(self: ptr ColumnViewSorter00): SortType {.
    importc, libprag.}

proc getPrimarySortOrder*(self: ColumnViewSorter): SortType =
  gtk_column_view_sorter_get_primary_sort_order(cast[ptr ColumnViewSorter00](self.impl))

proc primarySortOrder*(self: ColumnViewSorter): SortType =
  gtk_column_view_sorter_get_primary_sort_order(cast[ptr ColumnViewSorter00](self.impl))

type
  ConstantExpression* = ref object of Expression
  ConstantExpression00* = object of Expression00

proc gtk_constant_expression_get_type*(): GType {.importc, libprag.}

proc gtk_expression_unref*(self: ptr ConstantExpression00) {.importc, libprag.}

proc generic_gtk_expression_unref*(self: ConstantExpression) =
  if not self.ignoreFinalizer:
    gtk_expression_unref(self.impl)

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ConstantExpression()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      gtk_expression_unref(self.impl)
      self.impl = nil

proc gtk_constant_expression_new_for_value(value: gobject.Value): ptr ConstantExpression00 {.
    importc, libprag.}

proc newConstantExpressionForValue*(value: gobject.Value): ConstantExpression =
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_constant_expression_new_for_value(value)

proc newConstantExpressionForValue*(tdesc: typedesc; value: gobject.Value): tdesc =
  assert(result is ConstantExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_constant_expression_new_for_value(value)

proc initConstantExpressionForValue*[T](result: var T; value: gobject.Value) {.deprecated.} =
  assert(result is ConstantExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_constant_expression_new_for_value(value)

proc gtk_constant_expression_get_value(self: ptr ConstantExpression00): ptr gobject.Value {.
    importc, libprag.}

proc getValue*(self: ConstantExpression): ptr gobject.Value =
  gtk_constant_expression_get_value(cast[ptr ConstantExpression00](self.impl))

proc value*(self: ConstantExpression): ptr gobject.Value =
  gtk_constant_expression_get_value(cast[ptr ConstantExpression00](self.impl))

type
  ConstraintLayoutChild* = ref object of LayoutChild
  ConstraintLayoutChild00* = object of LayoutChild00

proc gtk_constraint_layout_child_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ConstraintLayoutChild()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ConstraintVflParserError* {.size: sizeof(cint), pure.} = enum
    symbol = 0
    attribute = 1
    view = 2
    metric = 3
    priority = 4
    relation = 5

type
  CssParserError* {.size: sizeof(cint), pure.} = enum
    failed = 0
    syntax = 1
    `import` = 2
    name = 3
    unknownValue = 4

type
  CssParserWarning* {.size: sizeof(cint), pure.} = enum
    deprecated = 0
    syntax = 1
    unimplemented = 2

type
  CssStyleChange00* {.pure.} = object
  CssStyleChange* = ref object
    impl*: ptr CssStyleChange00
    ignoreFinalizer*: bool

type
  CustomAllocateFunc* = proc (widget: ptr Widget00; width: int32; height: int32; baseline: int32) {.cdecl.}

type
  CustomFilter* = ref object of Filter
  CustomFilter00* = object of Filter00

proc gtk_custom_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CustomFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  CustomFilterFunc* = proc (item: ptr gobject.Object00; userData: pointer): gboolean {.cdecl.}

proc gtk_custom_filter_new(matchFunc: CustomFilterFunc; userData: pointer;
    userDestroy: DestroyNotify): ptr CustomFilter00 {.
    importc, libprag.}

proc newCustomFilter*(matchFunc: CustomFilterFunc; userData: pointer;
    userDestroy: DestroyNotify): CustomFilter =
  let gobj = gtk_custom_filter_new(matchFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCustomFilter*(tdesc: typedesc; matchFunc: CustomFilterFunc; userData: pointer;
    userDestroy: DestroyNotify): tdesc =
  assert(result is CustomFilter)
  let gobj = gtk_custom_filter_new(matchFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCustomFilter*[T](result: var T; matchFunc: CustomFilterFunc; userData: pointer;
    userDestroy: DestroyNotify) {.deprecated.} =
  assert(result is CustomFilter)
  let gobj = gtk_custom_filter_new(matchFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_custom_filter_set_filter_func(self: ptr CustomFilter00; matchFunc: CustomFilterFunc;
    userData: pointer; userDestroy: DestroyNotify) {.
    importc, libprag.}

proc setFilterFunc*(self: CustomFilter; matchFunc: CustomFilterFunc;
    userData: pointer; userDestroy: DestroyNotify) =
  gtk_custom_filter_set_filter_func(cast[ptr CustomFilter00](self.impl), matchFunc, userData, userDestroy)

type
  CustomLayout* = ref object of LayoutManager
  CustomLayout00* = object of LayoutManager00

proc gtk_custom_layout_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CustomLayout()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  CustomMeasureFunc* = proc (widget: ptr Widget00; orientation: Orientation; forSize: int32; minimum: var int32;
    natural: var int32; minimumBaseline: var int32; naturalBaseline: var int32) {.cdecl.}

type
  CustomRequestModeFunc* = proc (widget: ptr Widget00): SizeRequestMode {.cdecl.}

proc gtk_custom_layout_new(requestMode: CustomRequestModeFunc; measure: CustomMeasureFunc;
    allocate: CustomAllocateFunc): ptr CustomLayout00 {.
    importc, libprag.}

proc newCustomLayout*(requestMode: CustomRequestModeFunc; measure: CustomMeasureFunc;
    allocate: CustomAllocateFunc): CustomLayout =
  let gobj = gtk_custom_layout_new(requestMode, measure, allocate)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCustomLayout*(tdesc: typedesc; requestMode: CustomRequestModeFunc; measure: CustomMeasureFunc;
    allocate: CustomAllocateFunc): tdesc =
  assert(result is CustomLayout)
  let gobj = gtk_custom_layout_new(requestMode, measure, allocate)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCustomLayout*[T](result: var T; requestMode: CustomRequestModeFunc; measure: CustomMeasureFunc;
    allocate: CustomAllocateFunc) {.deprecated.} =
  assert(result is CustomLayout)
  let gobj = gtk_custom_layout_new(requestMode, measure, allocate)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CustomSorter* = ref object of Sorter
  CustomSorter00* = object of Sorter00

proc gtk_custom_sorter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CustomSorter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_custom_sorter_new(sortFunc: CompareDataFunc; userData: pointer;
    userDestroy: DestroyNotify): ptr CustomSorter00 {.
    importc, libprag.}

proc newCustomSorter*(sortFunc: CompareDataFunc; userData: pointer;
    userDestroy: DestroyNotify): CustomSorter =
  let gobj = gtk_custom_sorter_new(sortFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCustomSorter*(tdesc: typedesc; sortFunc: CompareDataFunc; userData: pointer;
    userDestroy: DestroyNotify): tdesc =
  assert(result is CustomSorter)
  let gobj = gtk_custom_sorter_new(sortFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCustomSorter*[T](result: var T; sortFunc: CompareDataFunc; userData: pointer;
    userDestroy: DestroyNotify) {.deprecated.} =
  assert(result is CustomSorter)
  let gobj = gtk_custom_sorter_new(sortFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_custom_sorter_set_sort_func(self: ptr CustomSorter00; sortFunc: CompareDataFunc;
    userData: pointer; userDestroy: DestroyNotify) {.
    importc, libprag.}

proc setSortFunc*(self: CustomSorter; sortFunc: CompareDataFunc;
    userData: pointer; userDestroy: DestroyNotify) =
  gtk_custom_sorter_set_sort_func(cast[ptr CustomSorter00](self.impl), sortFunc, userData, userDestroy)

type
  DebugFlag* {.size: sizeof(cint), pure.} = enum
    text = 0
    tree = 1
    keybindings = 2
    modules = 3
    geometry = 4
    icontheme = 5
    printing = 6
    builder = 7
    sizeRequest = 8
    noCssCache = 9
    interactive = 10
    actions = 12
    layout = 13
    snapshot = 14
    constraints = 15
    builderObjects = 16
    a11y = 17
    iconfallback = 18
    invertTextDir = 19

  DebugFlags* = set[DebugFlag]

type
  DialogError* {.size: sizeof(cint), pure.} = enum
    failed = 0
    cancelled = 1
    dismissed = 2

type
  DirectoryList* = ref object of gobject.Object
  DirectoryList00* = object of gobject.Object00

proc gtk_directory_list_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(DirectoryList()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_directory_list_new(attributes: cstring; file: ptr gio.GFile00): ptr DirectoryList00 {.
    importc, libprag.}

proc newDirectoryList*(attributes: cstring = nil; file: gio.GFile = nil): DirectoryList =
  let gobj = gtk_directory_list_new(attributes, if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDirectoryList*(tdesc: typedesc; attributes: cstring = nil; file: gio.GFile = nil): tdesc =
  assert(result is DirectoryList)
  let gobj = gtk_directory_list_new(attributes, if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDirectoryList*[T](result: var T; attributes: cstring = nil; file: gio.GFile = nil) {.deprecated.} =
  assert(result is DirectoryList)
  let gobj = gtk_directory_list_new(attributes, if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_directory_list_get_attributes(self: ptr DirectoryList00): cstring {.
    importc, libprag.}

proc getAttributes*(self: DirectoryList): string =
  let resul0 = gtk_directory_list_get_attributes(cast[ptr DirectoryList00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc attributes*(self: DirectoryList): string =
  let resul0 = gtk_directory_list_get_attributes(cast[ptr DirectoryList00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_directory_list_get_error(self: ptr DirectoryList00): ptr glib.Error {.
    importc, libprag.}

proc getError*(self: DirectoryList): ptr glib.Error =
  gtk_directory_list_get_error(cast[ptr DirectoryList00](self.impl))

proc error*(self: DirectoryList): ptr glib.Error =
  gtk_directory_list_get_error(cast[ptr DirectoryList00](self.impl))

proc gtk_directory_list_get_file(self: ptr DirectoryList00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: DirectoryList): gio.GFile =
  let gobj = gtk_directory_list_get_file(cast[ptr DirectoryList00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: DirectoryList): gio.GFile =
  let gobj = gtk_directory_list_get_file(cast[ptr DirectoryList00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_directory_list_get_io_priority(self: ptr DirectoryList00): int32 {.
    importc, libprag.}

proc getIoPriority*(self: DirectoryList): int =
  int(gtk_directory_list_get_io_priority(cast[ptr DirectoryList00](self.impl)))

proc ioPriority*(self: DirectoryList): int =
  int(gtk_directory_list_get_io_priority(cast[ptr DirectoryList00](self.impl)))

proc gtk_directory_list_get_monitored(self: ptr DirectoryList00): gboolean {.
    importc, libprag.}

proc getMonitored*(self: DirectoryList): bool =
  toBool(gtk_directory_list_get_monitored(cast[ptr DirectoryList00](self.impl)))

proc monitored*(self: DirectoryList): bool =
  toBool(gtk_directory_list_get_monitored(cast[ptr DirectoryList00](self.impl)))

proc gtk_directory_list_is_loading(self: ptr DirectoryList00): gboolean {.
    importc, libprag.}

proc isLoading*(self: DirectoryList): bool =
  toBool(gtk_directory_list_is_loading(cast[ptr DirectoryList00](self.impl)))

proc gtk_directory_list_set_attributes(self: ptr DirectoryList00; attributes: cstring) {.
    importc, libprag.}

proc setAttributes*(self: DirectoryList; attributes: cstring = nil) =
  gtk_directory_list_set_attributes(cast[ptr DirectoryList00](self.impl), attributes)

proc `attributes=`*(self: DirectoryList; attributes: cstring = nil) =
  gtk_directory_list_set_attributes(cast[ptr DirectoryList00](self.impl), attributes)

proc gtk_directory_list_set_file(self: ptr DirectoryList00; file: ptr gio.GFile00) {.
    importc, libprag.}

proc setFile*(self: DirectoryList; file: gio.GFile = nil) =
  gtk_directory_list_set_file(cast[ptr DirectoryList00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc `file=`*(self: DirectoryList; file: gio.GFile = nil) =
  gtk_directory_list_set_file(cast[ptr DirectoryList00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc gtk_directory_list_set_io_priority(self: ptr DirectoryList00; ioPriority: int32) {.
    importc, libprag.}

proc setIoPriority*(self: DirectoryList; ioPriority: int) =
  gtk_directory_list_set_io_priority(cast[ptr DirectoryList00](self.impl), int32(ioPriority))

proc `ioPriority=`*(self: DirectoryList; ioPriority: int) =
  gtk_directory_list_set_io_priority(cast[ptr DirectoryList00](self.impl), int32(ioPriority))

proc gtk_directory_list_set_monitored(self: ptr DirectoryList00; monitored: gboolean) {.
    importc, libprag.}

proc setMonitored*(self: DirectoryList; monitored: bool = true) =
  gtk_directory_list_set_monitored(cast[ptr DirectoryList00](self.impl), gboolean(monitored))

proc `monitored=`*(self: DirectoryList; monitored: bool) =
  gtk_directory_list_set_monitored(cast[ptr DirectoryList00](self.impl), gboolean(monitored))

type
  EventSequenceState* {.size: sizeof(cint), pure.} = enum
    none = 0
    claimed = 1
    denied = 2

type
  Gesture* = ref object of EventController
  Gesture00* = object of EventController00

proc gtk_gesture_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Gesture()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scBegin*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk4.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "begin", cast[GCallback](p), xdata, nil, cf)

proc scCancel*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk4.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cancel", cast[GCallback](p), xdata, nil, cf)

proc scEnd*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk4.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "end", cast[GCallback](p), xdata, nil, cf)

proc scSequenceStateChanged*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk4.EventSequence00; state: EventSequenceState; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "sequence-state-changed", cast[GCallback](p), xdata, nil, cf)

proc scUpdate*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk4.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "update", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_get_bounding_box(self: ptr Gesture00; rect: var gdk4.Rectangle): gboolean {.
    importc, libprag.}

proc getBoundingBox*(self: Gesture; rect: var gdk4.Rectangle): bool =
  toBool(gtk_gesture_get_bounding_box(cast[ptr Gesture00](self.impl), rect))

proc gtk_gesture_get_bounding_box_center(self: ptr Gesture00; x: var cdouble;
    y: var cdouble): gboolean {.
    importc, libprag.}

proc getBoundingBoxCenter*(self: Gesture; x: var cdouble; y: var cdouble): bool =
  toBool(gtk_gesture_get_bounding_box_center(cast[ptr Gesture00](self.impl), x, y))

proc gtk_gesture_get_device(self: ptr Gesture00): ptr gdk4.Device00 {.
    importc, libprag.}

proc getDevice*(self: Gesture): gdk4.Device =
  let gobj = gtk_gesture_get_device(cast[ptr Gesture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc device*(self: Gesture): gdk4.Device =
  let gobj = gtk_gesture_get_device(cast[ptr Gesture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_get_group(self: ptr Gesture00): ptr glib.List {.
    importc, libprag.}

proc getGroup*(self: Gesture): seq[Gesture] =
  let resul0 = gtk_gesture_get_group(cast[ptr Gesture00](self.impl))
  result = glistObjects2seq(Gesture, resul0, false)
  g_list_free(resul0)

proc group*(self: Gesture): seq[Gesture] =
  let resul0 = gtk_gesture_get_group(cast[ptr Gesture00](self.impl))
  result = glistObjects2seq(Gesture, resul0, false)
  g_list_free(resul0)

proc gtk_gesture_get_last_event(self: ptr Gesture00; sequence: ptr gdk4.EventSequence00): ptr gdk4.Event00 {.
    importc, libprag.}

proc getLastEvent*(self: Gesture; sequence: gdk4.EventSequence = nil): gdk4.Event =
  let impl0 = gtk_gesture_get_last_event(cast[ptr Gesture00](self.impl), if sequence.isNil: nil else: cast[ptr gdk4.EventSequence00](sequence.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gdk_event_unref)
  result.impl = cast[typeof(result.impl)](gdk_event_ref(impl0))

proc gtk_gesture_get_last_updated_sequence(self: ptr Gesture00): ptr gdk4.EventSequence00 {.
    importc, libprag.}

proc getLastUpdatedSequence*(self: Gesture): gdk4.EventSequence =
  let impl0 = gtk_gesture_get_last_updated_sequence(cast[ptr Gesture00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEventSequence)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gdk_event_sequence_get_type(), impl0))

proc lastUpdatedSequence*(self: Gesture): gdk4.EventSequence =
  let impl0 = gtk_gesture_get_last_updated_sequence(cast[ptr Gesture00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEventSequence)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gdk_event_sequence_get_type(), impl0))

proc gtk_gesture_get_point(self: ptr Gesture00; sequence: ptr gdk4.EventSequence00;
    x: var cdouble; y: var cdouble): gboolean {.
    importc, libprag.}

proc getPoint*(self: Gesture; sequence: gdk4.EventSequence = nil;
    x: var cdouble = cast[var cdouble](nil); y: var cdouble = cast[var cdouble](nil)): bool =
  toBool(gtk_gesture_get_point(cast[ptr Gesture00](self.impl), if sequence.isNil: nil else: cast[ptr gdk4.EventSequence00](sequence.impl), x, y))

proc gtk_gesture_get_sequence_state(self: ptr Gesture00; sequence: ptr gdk4.EventSequence00): EventSequenceState {.
    importc, libprag.}

proc getSequenceState*(self: Gesture; sequence: gdk4.EventSequence): EventSequenceState =
  gtk_gesture_get_sequence_state(cast[ptr Gesture00](self.impl), cast[ptr gdk4.EventSequence00](sequence.impl))

proc gtk_gesture_get_sequences(self: ptr Gesture00): ptr glib.List {.
    importc, libprag.}

proc getSequences*(self: Gesture): seq[gdk4.EventSequence] =
  let resul0 = gtk_gesture_get_sequences(cast[ptr Gesture00](self.impl))
  result = glistStructs2seq[gdk4.EventSequence](resul0, true)
  g_list_free(resul0)

proc sequences*(self: Gesture): seq[gdk4.EventSequence] =
  let resul0 = gtk_gesture_get_sequences(cast[ptr Gesture00](self.impl))
  result = glistStructs2seq[gdk4.EventSequence](resul0, true)
  g_list_free(resul0)

proc gtk_gesture_group(self: ptr Gesture00; gesture: ptr Gesture00) {.
    importc, libprag.}

proc group*(self: Gesture; gesture: Gesture) =
  gtk_gesture_group(cast[ptr Gesture00](self.impl), cast[ptr Gesture00](gesture.impl))

proc gtk_gesture_handles_sequence(self: ptr Gesture00; sequence: ptr gdk4.EventSequence00): gboolean {.
    importc, libprag.}

proc handlesSequence*(self: Gesture; sequence: gdk4.EventSequence = nil): bool =
  toBool(gtk_gesture_handles_sequence(cast[ptr Gesture00](self.impl), if sequence.isNil: nil else: cast[ptr gdk4.EventSequence00](sequence.impl)))

proc gtk_gesture_is_active(self: ptr Gesture00): gboolean {.
    importc, libprag.}

proc isActive*(self: Gesture): bool =
  toBool(gtk_gesture_is_active(cast[ptr Gesture00](self.impl)))

proc gtk_gesture_is_grouped_with(self: ptr Gesture00; other: ptr Gesture00): gboolean {.
    importc, libprag.}

proc isGroupedWith*(self: Gesture; other: Gesture): bool =
  toBool(gtk_gesture_is_grouped_with(cast[ptr Gesture00](self.impl), cast[ptr Gesture00](other.impl)))

proc gtk_gesture_is_recognized(self: ptr Gesture00): gboolean {.
    importc, libprag.}

proc isRecognized*(self: Gesture): bool =
  toBool(gtk_gesture_is_recognized(cast[ptr Gesture00](self.impl)))

proc gtk_gesture_set_sequence_state(self: ptr Gesture00; sequence: ptr gdk4.EventSequence00;
    state: EventSequenceState): gboolean {.
    importc, libprag.}

proc setSequenceState*(self: Gesture; sequence: gdk4.EventSequence;
    state: EventSequenceState): bool =
  toBool(gtk_gesture_set_sequence_state(cast[ptr Gesture00](self.impl), cast[ptr gdk4.EventSequence00](sequence.impl), state))

proc gtk_gesture_set_state(self: ptr Gesture00; state: EventSequenceState): gboolean {.
    importc, libprag.}

proc setState*(self: Gesture; state: EventSequenceState): bool =
  toBool(gtk_gesture_set_state(cast[ptr Gesture00](self.impl), state))

proc gtk_gesture_ungroup(self: ptr Gesture00) {.
    importc, libprag.}

proc ungroup*(self: Gesture) =
  gtk_gesture_ungroup(cast[ptr Gesture00](self.impl))

type
  GestureSingle* = ref object of Gesture
  GestureSingle00* = object of Gesture00

proc gtk_gesture_single_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureSingle()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_gesture_single_get_button(self: ptr GestureSingle00): uint32 {.
    importc, libprag.}

proc getButton*(self: GestureSingle): int =
  int(gtk_gesture_single_get_button(cast[ptr GestureSingle00](self.impl)))

proc button*(self: GestureSingle): int =
  int(gtk_gesture_single_get_button(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_get_current_button(self: ptr GestureSingle00): uint32 {.
    importc, libprag.}

proc getCurrentButton*(self: GestureSingle): int =
  int(gtk_gesture_single_get_current_button(cast[ptr GestureSingle00](self.impl)))

proc currentButton*(self: GestureSingle): int =
  int(gtk_gesture_single_get_current_button(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_get_current_sequence(self: ptr GestureSingle00): ptr gdk4.EventSequence00 {.
    importc, libprag.}

proc getCurrentSequence*(self: GestureSingle): gdk4.EventSequence =
  let impl0 = gtk_gesture_single_get_current_sequence(cast[ptr GestureSingle00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEventSequence)
  result.impl = impl0

proc currentSequence*(self: GestureSingle): gdk4.EventSequence =
  let impl0 = gtk_gesture_single_get_current_sequence(cast[ptr GestureSingle00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEventSequence)
  result.impl = impl0

proc gtk_gesture_single_get_exclusive(self: ptr GestureSingle00): gboolean {.
    importc, libprag.}

proc getExclusive*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_exclusive(cast[ptr GestureSingle00](self.impl)))

proc exclusive*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_exclusive(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_get_touch_only(self: ptr GestureSingle00): gboolean {.
    importc, libprag.}

proc getTouchOnly*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_touch_only(cast[ptr GestureSingle00](self.impl)))

proc touchOnly*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_touch_only(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_set_button(self: ptr GestureSingle00; button: uint32) {.
    importc, libprag.}

proc setButton*(self: GestureSingle; button: int) =
  gtk_gesture_single_set_button(cast[ptr GestureSingle00](self.impl), uint32(button))

proc `button=`*(self: GestureSingle; button: int) =
  gtk_gesture_single_set_button(cast[ptr GestureSingle00](self.impl), uint32(button))

proc gtk_gesture_single_set_exclusive(self: ptr GestureSingle00; exclusive: gboolean) {.
    importc, libprag.}

proc setExclusive*(self: GestureSingle; exclusive: bool = true) =
  gtk_gesture_single_set_exclusive(cast[ptr GestureSingle00](self.impl), gboolean(exclusive))

proc `exclusive=`*(self: GestureSingle; exclusive: bool) =
  gtk_gesture_single_set_exclusive(cast[ptr GestureSingle00](self.impl), gboolean(exclusive))

proc gtk_gesture_single_set_touch_only(self: ptr GestureSingle00; touchOnly: gboolean) {.
    importc, libprag.}

proc setTouchOnly*(self: GestureSingle; touchOnly: bool = true) =
  gtk_gesture_single_set_touch_only(cast[ptr GestureSingle00](self.impl), gboolean(touchOnly))

proc `touchOnly=`*(self: GestureSingle; touchOnly: bool) =
  gtk_gesture_single_set_touch_only(cast[ptr GestureSingle00](self.impl), gboolean(touchOnly))

type
  DragSource* = ref object of GestureSingle
  DragSource00* = object of GestureSingle00

proc gtk_drag_source_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(DragSource()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDragBegin*(self: DragSource;  p: proc (self: ptr DragSource00; drag: ptr gdk4.Drag00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-begin", cast[GCallback](p), xdata, nil, cf)

proc scDragCancel*(self: DragSource;  p: proc (self: ptr DragSource00; drag: ptr gdk4.Drag00; reason: gdk4.DragCancelReason; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-cancel", cast[GCallback](p), xdata, nil, cf)

proc scDragEnd*(self: DragSource;  p: proc (self: ptr DragSource00; drag: ptr gdk4.Drag00; deleteData: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-end", cast[GCallback](p), xdata, nil, cf)

proc scPrepare*(self: DragSource;  p: proc (self: ptr DragSource00; x: cdouble; y: cdouble; xdata: pointer): ptr gdk4.ContentProvider00 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "prepare", cast[GCallback](p), xdata, nil, cf)

proc gtk_drag_source_new(): ptr DragSource00 {.
    importc, libprag.}

proc newDragSource*(): DragSource =
  let gobj = gtk_drag_source_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDragSource*(tdesc: typedesc): tdesc =
  assert(result is DragSource)
  let gobj = gtk_drag_source_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDragSource*[T](result: var T) {.deprecated.} =
  assert(result is DragSource)
  let gobj = gtk_drag_source_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_source_drag_cancel(self: ptr DragSource00) {.
    importc, libprag.}

proc dragCancel*(self: DragSource) =
  gtk_drag_source_drag_cancel(cast[ptr DragSource00](self.impl))

proc gtk_drag_source_get_actions(self: ptr DragSource00): gdk4.DragAction {.
    importc, libprag.}

proc getActions*(self: DragSource): gdk4.DragAction =
  gtk_drag_source_get_actions(cast[ptr DragSource00](self.impl))

proc actions*(self: DragSource): gdk4.DragAction =
  gtk_drag_source_get_actions(cast[ptr DragSource00](self.impl))

proc gtk_drag_source_get_content(self: ptr DragSource00): ptr gdk4.ContentProvider00 {.
    importc, libprag.}

proc getContent*(self: DragSource): gdk4.ContentProvider =
  let gobj = gtk_drag_source_get_content(cast[ptr DragSource00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc content*(self: DragSource): gdk4.ContentProvider =
  let gobj = gtk_drag_source_get_content(cast[ptr DragSource00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_source_get_drag(self: ptr DragSource00): ptr gdk4.Drag00 {.
    importc, libprag.}

proc getDrag*(self: DragSource): gdk4.Drag =
  let gobj = gtk_drag_source_get_drag(cast[ptr DragSource00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc drag*(self: DragSource): gdk4.Drag =
  let gobj = gtk_drag_source_get_drag(cast[ptr DragSource00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_source_set_actions(self: ptr DragSource00; actions: gdk4.DragAction) {.
    importc, libprag.}

proc setActions*(self: DragSource; actions: gdk4.DragAction) =
  gtk_drag_source_set_actions(cast[ptr DragSource00](self.impl), actions)

proc `actions=`*(self: DragSource; actions: gdk4.DragAction) =
  gtk_drag_source_set_actions(cast[ptr DragSource00](self.impl), actions)

proc gtk_drag_source_set_content(self: ptr DragSource00; content: ptr gdk4.ContentProvider00) {.
    importc, libprag.}

proc setContent*(self: DragSource; content: gdk4.ContentProvider = nil) =
  gtk_drag_source_set_content(cast[ptr DragSource00](self.impl), if content.isNil: nil else: cast[ptr gdk4.ContentProvider00](content.impl))

proc `content=`*(self: DragSource; content: gdk4.ContentProvider = nil) =
  gtk_drag_source_set_content(cast[ptr DragSource00](self.impl), if content.isNil: nil else: cast[ptr gdk4.ContentProvider00](content.impl))

proc gtk_drag_source_set_icon(self: ptr DragSource00; paintable: ptr gdk4.Paintable00;
    hotX: int32; hotY: int32) {.
    importc, libprag.}

proc setIcon*(self: DragSource; paintable: gdk4.Paintable = nil;
    hotX: int; hotY: int) =
  gtk_drag_source_set_icon(cast[ptr DragSource00](self.impl), if paintable.isNil: nil else: cast[ptr gdk4.Paintable00](paintable.impl), int32(hotX), int32(hotY))

type
  DrawingAreaDrawFunc* = proc (drawingArea: ptr DrawingArea00; cr: ptr cairo.Context00; width: int32;
    height: int32; userData: pointer) {.cdecl.}

proc gtk_drawing_area_set_draw_func*(self: ptr DrawingArea00; drawFunc: DrawingAreaDrawFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setDrawFunc*(self: DrawingArea; drawFunc: DrawingAreaDrawFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_drawing_area_set_draw_func(cast[ptr DrawingArea00](self.impl), drawFunc, userData, destroy)

type
  DropControllerMotion* = ref object of EventController
  DropControllerMotion00* = object of EventController00

proc gtk_drop_controller_motion_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(DropControllerMotion()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEnter*(self: DropControllerMotion;  p: proc (self: ptr DropControllerMotion00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "enter", cast[GCallback](p), xdata, nil, cf)

proc scLeave*(self: DropControllerMotion;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "leave", cast[GCallback](p), xdata, nil, cf)

proc scMotion*(self: DropControllerMotion;  p: proc (self: ptr DropControllerMotion00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "motion", cast[GCallback](p), xdata, nil, cf)

proc gtk_drop_controller_motion_new(): ptr DropControllerMotion00 {.
    importc, libprag.}

proc newDropControllerMotion*(): DropControllerMotion =
  let gobj = gtk_drop_controller_motion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDropControllerMotion*(tdesc: typedesc): tdesc =
  assert(result is DropControllerMotion)
  let gobj = gtk_drop_controller_motion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDropControllerMotion*[T](result: var T) {.deprecated.} =
  assert(result is DropControllerMotion)
  let gobj = gtk_drop_controller_motion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_controller_motion_contains_pointer(self: ptr DropControllerMotion00): gboolean {.
    importc, libprag.}

proc containsPointer*(self: DropControllerMotion): bool =
  toBool(gtk_drop_controller_motion_contains_pointer(cast[ptr DropControllerMotion00](self.impl)))

proc gtk_drop_controller_motion_get_drop(self: ptr DropControllerMotion00): ptr gdk4.Drop00 {.
    importc, libprag.}

proc getDrop*(self: DropControllerMotion): gdk4.Drop =
  let gobj = gtk_drop_controller_motion_get_drop(cast[ptr DropControllerMotion00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc drop*(self: DropControllerMotion): gdk4.Drop =
  let gobj = gtk_drop_controller_motion_get_drop(cast[ptr DropControllerMotion00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_controller_motion_is_pointer(self: ptr DropControllerMotion00): gboolean {.
    importc, libprag.}

proc isPointer*(self: DropControllerMotion): bool =
  toBool(gtk_drop_controller_motion_is_pointer(cast[ptr DropControllerMotion00](self.impl)))

type
  DropTarget* = ref object of EventController
  DropTarget00* = object of EventController00

proc gtk_drop_target_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(DropTarget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAccept*(self: DropTarget;  p: proc (self: ptr DropTarget00; drop: ptr gdk4.Drop00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accept", cast[GCallback](p), xdata, nil, cf)

proc scDrop*(self: DropTarget;  p: proc (self: ptr DropTarget00; value: gobject.Value; x: cdouble; y: cdouble; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drop", cast[GCallback](p), xdata, nil, cf)

proc scEnter*(self: DropTarget;  p: proc (self: ptr DropTarget00; x: cdouble; y: cdouble; xdata: pointer): gdk4.DragAction {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "enter", cast[GCallback](p), xdata, nil, cf)

proc scLeave*(self: DropTarget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "leave", cast[GCallback](p), xdata, nil, cf)

proc scMotion*(self: DropTarget;  p: proc (self: ptr DropTarget00; x: cdouble; y: cdouble; xdata: pointer): gdk4.DragAction {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "motion", cast[GCallback](p), xdata, nil, cf)

proc gtk_drop_target_new(`type`: GType; actions: gdk4.DragAction): ptr DropTarget00 {.
    importc, libprag.}

proc newDropTarget*(`type`: GType; actions: gdk4.DragAction): DropTarget =
  let gobj = gtk_drop_target_new(`type`, actions)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDropTarget*(tdesc: typedesc; `type`: GType; actions: gdk4.DragAction): tdesc =
  assert(result is DropTarget)
  let gobj = gtk_drop_target_new(`type`, actions)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDropTarget*[T](result: var T; `type`: GType; actions: gdk4.DragAction) {.deprecated.} =
  assert(result is DropTarget)
  let gobj = gtk_drop_target_new(`type`, actions)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_target_get_actions(self: ptr DropTarget00): gdk4.DragAction {.
    importc, libprag.}

proc getActions*(self: DropTarget): gdk4.DragAction =
  gtk_drop_target_get_actions(cast[ptr DropTarget00](self.impl))

proc actions*(self: DropTarget): gdk4.DragAction =
  gtk_drop_target_get_actions(cast[ptr DropTarget00](self.impl))

proc gtk_drop_target_get_current_drop(self: ptr DropTarget00): ptr gdk4.Drop00 {.
    importc, libprag.}

proc getCurrentDrop*(self: DropTarget): gdk4.Drop =
  let gobj = gtk_drop_target_get_current_drop(cast[ptr DropTarget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc currentDrop*(self: DropTarget): gdk4.Drop =
  let gobj = gtk_drop_target_get_current_drop(cast[ptr DropTarget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_target_get_drop(self: ptr DropTarget00): ptr gdk4.Drop00 {.
    importc, libprag.}

proc getDrop*(self: DropTarget): gdk4.Drop =
  let gobj = gtk_drop_target_get_drop(cast[ptr DropTarget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc drop*(self: DropTarget): gdk4.Drop =
  let gobj = gtk_drop_target_get_drop(cast[ptr DropTarget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_target_get_formats(self: ptr DropTarget00): ptr gdk4.ContentFormats00 {.
    importc, libprag.}

proc getFormats*(self: DropTarget): gdk4.ContentFormats =
  let impl0 = gtk_drop_target_get_formats(cast[ptr DropTarget00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkContentFormats)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gdk_content_formats_get_type(), impl0))

proc formats*(self: DropTarget): gdk4.ContentFormats =
  let impl0 = gtk_drop_target_get_formats(cast[ptr DropTarget00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkContentFormats)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gdk_content_formats_get_type(), impl0))

proc gtk_drop_target_get_gtypes(self: ptr DropTarget00; nTypes: var uint64): ptr GType {.
    importc, libprag.}

proc getGtypes*(self: DropTarget; nTypes: var uint64 = cast[var uint64](nil)): ptr GType =
  gtk_drop_target_get_gtypes(cast[ptr DropTarget00](self.impl), nTypes)

proc gtk_drop_target_get_preload(self: ptr DropTarget00): gboolean {.
    importc, libprag.}

proc getPreload*(self: DropTarget): bool =
  toBool(gtk_drop_target_get_preload(cast[ptr DropTarget00](self.impl)))

proc preload*(self: DropTarget): bool =
  toBool(gtk_drop_target_get_preload(cast[ptr DropTarget00](self.impl)))

proc gtk_drop_target_get_value(self: ptr DropTarget00): ptr gobject.Value {.
    importc, libprag.}

proc getValue*(self: DropTarget): ptr gobject.Value =
  gtk_drop_target_get_value(cast[ptr DropTarget00](self.impl))

proc value*(self: DropTarget): ptr gobject.Value =
  gtk_drop_target_get_value(cast[ptr DropTarget00](self.impl))

proc gtk_drop_target_reject(self: ptr DropTarget00) {.
    importc, libprag.}

proc reject*(self: DropTarget) =
  gtk_drop_target_reject(cast[ptr DropTarget00](self.impl))

proc gtk_drop_target_set_actions(self: ptr DropTarget00; actions: gdk4.DragAction) {.
    importc, libprag.}

proc setActions*(self: DropTarget; actions: gdk4.DragAction) =
  gtk_drop_target_set_actions(cast[ptr DropTarget00](self.impl), actions)

proc `actions=`*(self: DropTarget; actions: gdk4.DragAction) =
  gtk_drop_target_set_actions(cast[ptr DropTarget00](self.impl), actions)

proc gtk_drop_target_set_gtypes(self: ptr DropTarget00; types: ptr GType;
    nTypes: uint64) {.
    importc, libprag.}

proc setGtypes*(self: DropTarget; types: ptr GType; nTypes: uint64) =
  gtk_drop_target_set_gtypes(cast[ptr DropTarget00](self.impl), types, nTypes)

proc gtk_drop_target_set_preload(self: ptr DropTarget00; preload: gboolean) {.
    importc, libprag.}

proc setPreload*(self: DropTarget; preload: bool = true) =
  gtk_drop_target_set_preload(cast[ptr DropTarget00](self.impl), gboolean(preload))

proc `preload=`*(self: DropTarget; preload: bool) =
  gtk_drop_target_set_preload(cast[ptr DropTarget00](self.impl), gboolean(preload))

type
  DropTargetAsync* = ref object of EventController
  DropTargetAsync00* = object of EventController00

proc gtk_drop_target_async_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(DropTargetAsync()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAccept*(self: DropTargetAsync;  p: proc (self: ptr DropTargetAsync00; drop: ptr gdk4.Drop00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accept", cast[GCallback](p), xdata, nil, cf)

proc scDragEnter*(self: DropTargetAsync;  p: proc (self: ptr DropTargetAsync00; drop: ptr gdk4.Drop00; x: cdouble; y: cdouble; xdata: pointer): gdk4.DragAction {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-enter", cast[GCallback](p), xdata, nil, cf)

proc scDragLeave*(self: DropTargetAsync;  p: proc (self: ptr DropTargetAsync00; drop: ptr gdk4.Drop00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-leave", cast[GCallback](p), xdata, nil, cf)

proc scDragMotion*(self: DropTargetAsync;  p: proc (self: ptr DropTargetAsync00; drop: ptr gdk4.Drop00; x: cdouble; y: cdouble; xdata: pointer): gdk4.DragAction {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-motion", cast[GCallback](p), xdata, nil, cf)

proc scDrop*(self: DropTargetAsync;  p: proc (self: ptr DropTargetAsync00; drop: ptr gdk4.Drop00; x: cdouble; y: cdouble; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drop", cast[GCallback](p), xdata, nil, cf)

proc gtk_drop_target_async_new(formats: ptr gdk4.ContentFormats00; actions: gdk4.DragAction): ptr DropTargetAsync00 {.
    importc, libprag.}

proc newDropTargetAsync*(formats: gdk4.ContentFormats = nil; actions: gdk4.DragAction): DropTargetAsync =
  let gobj = gtk_drop_target_async_new(if formats.isNil: nil else: cast[ptr gdk4.ContentFormats00](g_boxed_copy(gdk_content_formats_get_type(), formats.impl)), actions)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDropTargetAsync*(tdesc: typedesc; formats: gdk4.ContentFormats = nil; actions: gdk4.DragAction): tdesc =
  assert(result is DropTargetAsync)
  let gobj = gtk_drop_target_async_new(if formats.isNil: nil else: cast[ptr gdk4.ContentFormats00](g_boxed_copy(gdk_content_formats_get_type(), formats.impl)), actions)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDropTargetAsync*[T](result: var T; formats: gdk4.ContentFormats = nil; actions: gdk4.DragAction) {.deprecated.} =
  assert(result is DropTargetAsync)
  let gobj = gtk_drop_target_async_new(if formats.isNil: nil else: cast[ptr gdk4.ContentFormats00](g_boxed_copy(gdk_content_formats_get_type(), formats.impl)), actions)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drop_target_async_get_actions(self: ptr DropTargetAsync00): gdk4.DragAction {.
    importc, libprag.}

proc getActions*(self: DropTargetAsync): gdk4.DragAction =
  gtk_drop_target_async_get_actions(cast[ptr DropTargetAsync00](self.impl))

proc actions*(self: DropTargetAsync): gdk4.DragAction =
  gtk_drop_target_async_get_actions(cast[ptr DropTargetAsync00](self.impl))

proc gtk_drop_target_async_get_formats(self: ptr DropTargetAsync00): ptr gdk4.ContentFormats00 {.
    importc, libprag.}

proc getFormats*(self: DropTargetAsync): gdk4.ContentFormats =
  let impl0 = gtk_drop_target_async_get_formats(cast[ptr DropTargetAsync00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkContentFormats)
  result.impl = impl0

proc formats*(self: DropTargetAsync): gdk4.ContentFormats =
  let impl0 = gtk_drop_target_async_get_formats(cast[ptr DropTargetAsync00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkContentFormats)
  result.impl = impl0

proc gtk_drop_target_async_reject_drop(self: ptr DropTargetAsync00; drop: ptr gdk4.Drop00) {.
    importc, libprag.}

proc rejectDrop*(self: DropTargetAsync; drop: gdk4.Drop) =
  gtk_drop_target_async_reject_drop(cast[ptr DropTargetAsync00](self.impl), cast[ptr gdk4.Drop00](drop.impl))

proc gtk_drop_target_async_set_actions(self: ptr DropTargetAsync00; actions: gdk4.DragAction) {.
    importc, libprag.}

proc setActions*(self: DropTargetAsync; actions: gdk4.DragAction) =
  gtk_drop_target_async_set_actions(cast[ptr DropTargetAsync00](self.impl), actions)

proc `actions=`*(self: DropTargetAsync; actions: gdk4.DragAction) =
  gtk_drop_target_async_set_actions(cast[ptr DropTargetAsync00](self.impl), actions)

proc gtk_drop_target_async_set_formats(self: ptr DropTargetAsync00; formats: ptr gdk4.ContentFormats00) {.
    importc, libprag.}

proc setFormats*(self: DropTargetAsync; formats: gdk4.ContentFormats = nil) =
  gtk_drop_target_async_set_formats(cast[ptr DropTargetAsync00](self.impl), if formats.isNil: nil else: cast[ptr gdk4.ContentFormats00](formats.impl))

proc `formats=`*(self: DropTargetAsync; formats: gdk4.ContentFormats = nil) =
  gtk_drop_target_async_set_formats(cast[ptr DropTargetAsync00](self.impl), if formats.isNil: nil else: cast[ptr gdk4.ContentFormats00](formats.impl))

type
  EditableProperties* {.size: sizeof(cint), pure.} = enum
    propText = 0
    propCursorPosition = 1
    propSelectionBound = 2
    propEditable = 3
    propWidthChars = 4
    propMaxWidthChars = 5
    propXalign = 6
    propEnableUndo = 7
    numProperties = 8

type
  EntryCompletionMatchFunc* = proc (completion: ptr EntryCompletion00; key: cstring; iter: TreeIter; userData: pointer): gboolean {.cdecl.}

proc gtk_entry_completion_set_match_func(self: ptr EntryCompletion00; `func`: EntryCompletionMatchFunc;
    funcData: pointer; funcNotify: DestroyNotify) {.
    importc, libprag.}

proc setMatchFunc*(self: EntryCompletion; `func`: EntryCompletionMatchFunc;
    funcData: pointer; funcNotify: DestroyNotify) =
  gtk_entry_completion_set_match_func(cast[ptr EntryCompletion00](self.impl), `func`, funcData, funcNotify)

type
  EventControllerFocus* = ref object of EventController
  EventControllerFocus00* = object of EventController00

proc gtk_event_controller_focus_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventControllerFocus()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEnter*(self: EventControllerFocus;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "enter", cast[GCallback](p), xdata, nil, cf)

proc scLeave*(self: EventControllerFocus;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "leave", cast[GCallback](p), xdata, nil, cf)

proc gtk_event_controller_focus_new(): ptr EventControllerFocus00 {.
    importc, libprag.}

proc newEventControllerFocus*(): EventControllerFocus =
  let gobj = gtk_event_controller_focus_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEventControllerFocus*(tdesc: typedesc): tdesc =
  assert(result is EventControllerFocus)
  let gobj = gtk_event_controller_focus_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventControllerFocus*[T](result: var T) {.deprecated.} =
  assert(result is EventControllerFocus)
  let gobj = gtk_event_controller_focus_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_focus_contains_focus(self: ptr EventControllerFocus00): gboolean {.
    importc, libprag.}

proc containsFocus*(self: EventControllerFocus): bool =
  toBool(gtk_event_controller_focus_contains_focus(cast[ptr EventControllerFocus00](self.impl)))

proc gtk_event_controller_focus_is_focus(self: ptr EventControllerFocus00): gboolean {.
    importc, libprag.}

proc isFocus*(self: EventControllerFocus): bool =
  toBool(gtk_event_controller_focus_is_focus(cast[ptr EventControllerFocus00](self.impl)))

type
  EventControllerKey* = ref object of EventController
  EventControllerKey00* = object of EventController00

proc gtk_event_controller_key_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventControllerKey()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scImUpdate*(self: EventControllerKey;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "im-update", cast[GCallback](p), xdata, nil, cf)

proc scKeyPressed*(self: EventControllerKey;  p: proc (self: ptr EventControllerKey00; keyval: uint32; keycode: uint32; state: gdk4.ModifierType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "key-pressed", cast[GCallback](p), xdata, nil, cf)

proc scKeyReleased*(self: EventControllerKey;  p: proc (self: ptr EventControllerKey00; keyval: uint32; keycode: uint32; state: gdk4.ModifierType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "key-released", cast[GCallback](p), xdata, nil, cf)

proc scModifiers*(self: EventControllerKey;  p: proc (self: ptr EventControllerKey00; state: gdk4.ModifierType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "modifiers", cast[GCallback](p), xdata, nil, cf)

proc gtk_event_controller_key_new(): ptr EventControllerKey00 {.
    importc, libprag.}

proc newEventControllerKey*(): EventControllerKey =
  let gobj = gtk_event_controller_key_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEventControllerKey*(tdesc: typedesc): tdesc =
  assert(result is EventControllerKey)
  let gobj = gtk_event_controller_key_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventControllerKey*[T](result: var T) {.deprecated.} =
  assert(result is EventControllerKey)
  let gobj = gtk_event_controller_key_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_key_forward(self: ptr EventControllerKey00; widget: ptr Widget00): gboolean {.
    importc, libprag.}

proc forward*(self: EventControllerKey; widget: Widget): bool =
  toBool(gtk_event_controller_key_forward(cast[ptr EventControllerKey00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_event_controller_key_get_group(self: ptr EventControllerKey00): uint32 {.
    importc, libprag.}

proc getGroup*(self: EventControllerKey): int =
  int(gtk_event_controller_key_get_group(cast[ptr EventControllerKey00](self.impl)))

proc group*(self: EventControllerKey): int =
  int(gtk_event_controller_key_get_group(cast[ptr EventControllerKey00](self.impl)))

type
  IMContext* = ref object of gobject.Object
  IMContext00* = object of gobject.Object00

proc gtk_im_context_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IMContext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scCommit*(self: IMContext;  p: proc (self: ptr IMContext00; str: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "commit", cast[GCallback](p), xdata, nil, cf)

proc scDeleteSurrounding*(self: IMContext;  p: proc (self: ptr IMContext00; offset: int32; nChars: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-surrounding", cast[GCallback](p), xdata, nil, cf)

proc scPreeditChanged*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-changed", cast[GCallback](p), xdata, nil, cf)

proc scPreeditEnd*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-end", cast[GCallback](p), xdata, nil, cf)

proc scPreeditStart*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-start", cast[GCallback](p), xdata, nil, cf)

proc scRetrieveSurrounding*(self: IMContext;  p: proc (self: ptr IMContext00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "retrieve-surrounding", cast[GCallback](p), xdata, nil, cf)

proc gtk_im_context_activate_osk(self: ptr IMContext00; event: ptr gdk4.Event00): gboolean {.
    importc, libprag.}

proc activateOsk*(self: IMContext; event: gdk4.Event = nil): bool =
  toBool(gtk_im_context_activate_osk(cast[ptr IMContext00](self.impl), if event.isNil: nil else: cast[ptr gdk4.Event00](event.impl)))

proc gtk_im_context_delete_surrounding(self: ptr IMContext00; offset: int32;
    nChars: int32): gboolean {.
    importc, libprag.}

proc deleteSurrounding*(self: IMContext; offset: int; nChars: int): bool =
  toBool(gtk_im_context_delete_surrounding(cast[ptr IMContext00](self.impl), int32(offset), int32(nChars)))

proc gtk_im_context_filter_key(self: ptr IMContext00; press: gboolean; surface: ptr gdk4.Surface00;
    device: ptr gdk4.Device00; time: uint32; keycode: uint32; state: gdk4.ModifierType;
    group: int32): gboolean {.
    importc, libprag.}

proc filterKey*(self: IMContext; press: bool; surface: gdk4.Surface;
    device: gdk4.Device; time: int; keycode: int; state: gdk4.ModifierType;
    group: int): bool =
  toBool(gtk_im_context_filter_key(cast[ptr IMContext00](self.impl), gboolean(press), cast[ptr gdk4.Surface00](surface.impl), cast[ptr gdk4.Device00](device.impl), uint32(time), uint32(keycode), state, int32(group)))

proc gtk_im_context_filter_keypress(self: ptr IMContext00; event: ptr gdk4.Event00): gboolean {.
    importc, libprag.}

proc filterKeypress*(self: IMContext; event: gdk4.Event): bool =
  toBool(gtk_im_context_filter_keypress(cast[ptr IMContext00](self.impl), cast[ptr gdk4.Event00](event.impl)))

proc gtk_im_context_focus_in(self: ptr IMContext00) {.
    importc, libprag.}

proc focusIn*(self: IMContext) =
  gtk_im_context_focus_in(cast[ptr IMContext00](self.impl))

proc gtk_im_context_focus_out(self: ptr IMContext00) {.
    importc, libprag.}

proc focusOut*(self: IMContext) =
  gtk_im_context_focus_out(cast[ptr IMContext00](self.impl))

proc gtk_im_context_get_preedit_string(self: ptr IMContext00; str: var cstring;
    attrs: var ptr pango.AttrList00; cursorPos: var int32) {.
    importc, libprag.}

proc getPreeditString*(self: IMContext; str: var string;
    attrs: var pango.AttrList; cursorPos: var int) =
  fnew(attrs, gBoxedFreePangoAttrList)
  var cursorPos_00: int32
  var str_00: cstring
  gtk_im_context_get_preedit_string(cast[ptr IMContext00](self.impl), str_00, cast[var ptr pango.AttrList00](addr attrs.impl), cursorPos_00)
  if cursorPos.addr != nil:
    cursorPos = int(cursorPos_00)
  if str.addr != nil:
    str = $(str_00)

proc gtk_im_context_get_surrounding(self: ptr IMContext00; text: var cstring;
    cursorIndex: var int32): gboolean {.
    importc, libprag.}

proc getSurrounding*(self: IMContext; text: var string; cursorIndex: var int): bool =
  var text_00: cstring
  var cursorIndex_00: int32
  result = toBool(gtk_im_context_get_surrounding(cast[ptr IMContext00](self.impl), text_00, cursorIndex_00))
  if text.addr != nil:
    text = $(text_00)
  if cursorIndex.addr != nil:
    cursorIndex = int(cursorIndex_00)

proc gtk_im_context_get_surrounding_with_selection(self: ptr IMContext00;
    text: var cstring; cursorIndex: var int32; anchorIndex: var int32): gboolean {.
    importc, libprag.}

proc getSurroundingWithSelection*(self: IMContext; text: var string;
    cursorIndex: var int; anchorIndex: var int): bool =
  var text_00: cstring
  var anchorIndex_00: int32
  var cursorIndex_00: int32
  result = toBool(gtk_im_context_get_surrounding_with_selection(cast[ptr IMContext00](self.impl), text_00, cursorIndex_00, anchorIndex_00))
  if text.addr != nil:
    text = $(text_00)
  if anchorIndex.addr != nil:
    anchorIndex = int(anchorIndex_00)
  if cursorIndex.addr != nil:
    cursorIndex = int(cursorIndex_00)

proc gtk_im_context_reset(self: ptr IMContext00) {.
    importc, libprag.}

proc reset*(self: IMContext) =
  gtk_im_context_reset(cast[ptr IMContext00](self.impl))

proc gtk_im_context_set_client_widget(self: ptr IMContext00; widget: ptr Widget00) {.
    importc, libprag.}

proc setClientWidget*(self: IMContext; widget: Widget = nil) =
  gtk_im_context_set_client_widget(cast[ptr IMContext00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `clientWidget=`*(self: IMContext; widget: Widget = nil) =
  gtk_im_context_set_client_widget(cast[ptr IMContext00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_im_context_set_cursor_location(self: ptr IMContext00; area: gdk4.Rectangle) {.
    importc, libprag.}

proc setCursorLocation*(self: IMContext; area: gdk4.Rectangle) =
  gtk_im_context_set_cursor_location(cast[ptr IMContext00](self.impl), area)

proc `cursorLocation=`*(self: IMContext; area: gdk4.Rectangle) =
  gtk_im_context_set_cursor_location(cast[ptr IMContext00](self.impl), area)

proc gtk_im_context_set_surrounding(self: ptr IMContext00; text: cstring;
    len: int32; cursorIndex: int32) {.
    importc, libprag.}

proc setSurrounding*(self: IMContext; text: cstring; len: int;
    cursorIndex: int) =
  gtk_im_context_set_surrounding(cast[ptr IMContext00](self.impl), text, int32(len), int32(cursorIndex))

proc gtk_im_context_set_surrounding_with_selection(self: ptr IMContext00;
    text: cstring; len: int32; cursorIndex: int32; anchorIndex: int32) {.
    importc, libprag.}

proc setSurroundingWithSelection*(self: IMContext; text: cstring;
    len: int; cursorIndex: int; anchorIndex: int) =
  gtk_im_context_set_surrounding_with_selection(cast[ptr IMContext00](self.impl), text, int32(len), int32(cursorIndex), int32(anchorIndex))

proc gtk_im_context_set_use_preedit(self: ptr IMContext00; usePreedit: gboolean) {.
    importc, libprag.}

proc setUsePreedit*(self: IMContext; usePreedit: bool = true) =
  gtk_im_context_set_use_preedit(cast[ptr IMContext00](self.impl), gboolean(usePreedit))

proc `usePreedit=`*(self: IMContext; usePreedit: bool) =
  gtk_im_context_set_use_preedit(cast[ptr IMContext00](self.impl), gboolean(usePreedit))

proc gtk_event_controller_key_get_im_context(self: ptr EventControllerKey00): ptr IMContext00 {.
    importc, libprag.}

proc getImContext*(self: EventControllerKey): IMContext =
  let gobj = gtk_event_controller_key_get_im_context(cast[ptr EventControllerKey00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc imContext*(self: EventControllerKey): IMContext =
  let gobj = gtk_event_controller_key_get_im_context(cast[ptr EventControllerKey00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_key_set_im_context(self: ptr EventControllerKey00;
    imContext: ptr IMContext00) {.
    importc, libprag.}

proc setImContext*(self: EventControllerKey; imContext: IMContext = nil) =
  gtk_event_controller_key_set_im_context(cast[ptr EventControllerKey00](self.impl), if imContext.isNil: nil else: cast[ptr IMContext00](imContext.impl))

proc `imContext=`*(self: EventControllerKey; imContext: IMContext = nil) =
  gtk_event_controller_key_set_im_context(cast[ptr EventControllerKey00](self.impl), if imContext.isNil: nil else: cast[ptr IMContext00](imContext.impl))

type
  EventControllerLegacy* = ref object of EventController
  EventControllerLegacy00* = object of EventController00

proc gtk_event_controller_legacy_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventControllerLegacy()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEvent*(self: EventControllerLegacy;  p: proc (self: ptr EventControllerLegacy00; event: ptr gdk4.Event00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "event", cast[GCallback](p), xdata, nil, cf)

proc gtk_event_controller_legacy_new(): ptr EventControllerLegacy00 {.
    importc, libprag.}

proc newEventControllerLegacy*(): EventControllerLegacy =
  let gobj = gtk_event_controller_legacy_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEventControllerLegacy*(tdesc: typedesc): tdesc =
  assert(result is EventControllerLegacy)
  let gobj = gtk_event_controller_legacy_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventControllerLegacy*[T](result: var T) {.deprecated.} =
  assert(result is EventControllerLegacy)
  let gobj = gtk_event_controller_legacy_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  EventControllerMotion* = ref object of EventController
  EventControllerMotion00* = object of EventController00

proc gtk_event_controller_motion_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventControllerMotion()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEnter*(self: EventControllerMotion;  p: proc (self: ptr EventControllerMotion00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "enter", cast[GCallback](p), xdata, nil, cf)

proc scLeave*(self: EventControllerMotion;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "leave", cast[GCallback](p), xdata, nil, cf)

proc scMotion*(self: EventControllerMotion;  p: proc (self: ptr EventControllerMotion00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "motion", cast[GCallback](p), xdata, nil, cf)

proc gtk_event_controller_motion_new(): ptr EventControllerMotion00 {.
    importc, libprag.}

proc newEventControllerMotion*(): EventControllerMotion =
  let gobj = gtk_event_controller_motion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEventControllerMotion*(tdesc: typedesc): tdesc =
  assert(result is EventControllerMotion)
  let gobj = gtk_event_controller_motion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventControllerMotion*[T](result: var T) {.deprecated.} =
  assert(result is EventControllerMotion)
  let gobj = gtk_event_controller_motion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_motion_contains_pointer(self: ptr EventControllerMotion00): gboolean {.
    importc, libprag.}

proc containsPointer*(self: EventControllerMotion): bool =
  toBool(gtk_event_controller_motion_contains_pointer(cast[ptr EventControllerMotion00](self.impl)))

proc gtk_event_controller_motion_is_pointer(self: ptr EventControllerMotion00): gboolean {.
    importc, libprag.}

proc isPointer*(self: EventControllerMotion): bool =
  toBool(gtk_event_controller_motion_is_pointer(cast[ptr EventControllerMotion00](self.impl)))

type
  EventControllerScroll* = ref object of EventController
  EventControllerScroll00* = object of EventController00

proc gtk_event_controller_scroll_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventControllerScroll()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDecelerate*(self: EventControllerScroll;  p: proc (self: ptr EventControllerScroll00; velX: cdouble; velY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "decelerate", cast[GCallback](p), xdata, nil, cf)

proc scScroll*(self: EventControllerScroll;  p: proc (self: ptr EventControllerScroll00; dx: cdouble; dy: cdouble; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll", cast[GCallback](p), xdata, nil, cf)

proc scScrollBegin*(self: EventControllerScroll;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll-begin", cast[GCallback](p), xdata, nil, cf)

proc scScrollEnd*(self: EventControllerScroll;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll-end", cast[GCallback](p), xdata, nil, cf)

proc gtk_event_controller_scroll_get_unit(self: ptr EventControllerScroll00): gdk4.ScrollUnit {.
    importc, libprag.}

proc getUnit*(self: EventControllerScroll): gdk4.ScrollUnit =
  gtk_event_controller_scroll_get_unit(cast[ptr EventControllerScroll00](self.impl))

proc unit*(self: EventControllerScroll): gdk4.ScrollUnit =
  gtk_event_controller_scroll_get_unit(cast[ptr EventControllerScroll00](self.impl))

type
  EventControllerScrollFlags* {.size: sizeof(cint), pure.} = enum
    none = 0
    vertical = 1
    horizontal = 2
    bothAxes = 3
    discrete = 4
    kinetic = 8

proc gtk_event_controller_scroll_new(flags: EventControllerScrollFlags): ptr EventControllerScroll00 {.
    importc, libprag.}

proc newEventControllerScroll*(flags: EventControllerScrollFlags): EventControllerScroll =
  let gobj = gtk_event_controller_scroll_new(flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEventControllerScroll*(tdesc: typedesc; flags: EventControllerScrollFlags): tdesc =
  assert(result is EventControllerScroll)
  let gobj = gtk_event_controller_scroll_new(flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventControllerScroll*[T](result: var T; flags: EventControllerScrollFlags) {.deprecated.} =
  assert(result is EventControllerScroll)
  let gobj = gtk_event_controller_scroll_new(flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_scroll_get_flags(self: ptr EventControllerScroll00): EventControllerScrollFlags {.
    importc, libprag.}

proc getFlags*(self: EventControllerScroll): EventControllerScrollFlags =
  gtk_event_controller_scroll_get_flags(cast[ptr EventControllerScroll00](self.impl))

proc flags*(self: EventControllerScroll): EventControllerScrollFlags =
  gtk_event_controller_scroll_get_flags(cast[ptr EventControllerScroll00](self.impl))

proc gtk_event_controller_scroll_set_flags(self: ptr EventControllerScroll00;
    flags: EventControllerScrollFlags) {.
    importc, libprag.}

proc setFlags*(self: EventControllerScroll; flags: EventControllerScrollFlags) =
  gtk_event_controller_scroll_set_flags(cast[ptr EventControllerScroll00](self.impl), flags)

proc `flags=`*(self: EventControllerScroll; flags: EventControllerScrollFlags) =
  gtk_event_controller_scroll_set_flags(cast[ptr EventControllerScroll00](self.impl), flags)

type
  ExpressionNotify* = proc (userData: pointer) {.cdecl.}

proc gtk_expression_watch(self: ptr Expression00; this: ptr gobject.Object00;
    notify: ExpressionNotify; userData: pointer; userDestroy: DestroyNotify): ptr ExpressionWatch00 {.
    importc, libprag.}

proc watch*(self: Expression; this: gobject.Object = nil; notify: ExpressionNotify;
    userData: pointer; userDestroy: DestroyNotify): ExpressionWatch =
  fnew(result, gBoxedFreeGtkExpressionWatch)
  result.impl = gtk_expression_watch(cast[ptr Expression00](self.impl), if this.isNil: nil else: cast[ptr gobject.Object00](this.impl), notify, userData, userDestroy)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_expression_watch_get_type(), result.impl))

type
  FileChooser00* = object of gobject.Object00
  FileChooser* = ref object of gobject.Object

type
  NativeDialog* = ref object of gobject.Object
  NativeDialog00* = object of gobject.Object00

proc gtk_native_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NativeDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scResponse*(self: NativeDialog;  p: proc (self: ptr NativeDialog00; responseId: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "response", cast[GCallback](p), xdata, nil, cf)

proc gtk_native_dialog_destroy(self: ptr NativeDialog00) {.
    importc, libprag.}

proc destroy*(self: NativeDialog) =
  gtk_native_dialog_destroy(cast[ptr NativeDialog00](self.impl))

proc gtk_native_dialog_get_modal(self: ptr NativeDialog00): gboolean {.
    importc, libprag.}

proc getModal*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_modal(cast[ptr NativeDialog00](self.impl)))

proc modal*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_modal(cast[ptr NativeDialog00](self.impl)))

proc gtk_native_dialog_get_title(self: ptr NativeDialog00): cstring {.
    importc, libprag.}

proc getTitle*(self: NativeDialog): string =
  let resul0 = gtk_native_dialog_get_title(cast[ptr NativeDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc title*(self: NativeDialog): string =
  let resul0 = gtk_native_dialog_get_title(cast[ptr NativeDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_native_dialog_get_transient_for(self: ptr NativeDialog00): ptr Window00 {.
    importc, libprag.}

proc getTransientFor*(self: NativeDialog): Window =
  let gobj = gtk_native_dialog_get_transient_for(cast[ptr NativeDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc transientFor*(self: NativeDialog): Window =
  let gobj = gtk_native_dialog_get_transient_for(cast[ptr NativeDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_native_dialog_get_visible(self: ptr NativeDialog00): gboolean {.
    importc, libprag.}

proc getVisible*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_visible(cast[ptr NativeDialog00](self.impl)))

proc visible*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_visible(cast[ptr NativeDialog00](self.impl)))

proc gtk_native_dialog_hide(self: ptr NativeDialog00) {.
    importc, libprag.}

proc hide*(self: NativeDialog) =
  gtk_native_dialog_hide(cast[ptr NativeDialog00](self.impl))

proc gtk_native_dialog_set_modal(self: ptr NativeDialog00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: NativeDialog; modal: bool = true) =
  gtk_native_dialog_set_modal(cast[ptr NativeDialog00](self.impl), gboolean(modal))

proc `modal=`*(self: NativeDialog; modal: bool) =
  gtk_native_dialog_set_modal(cast[ptr NativeDialog00](self.impl), gboolean(modal))

proc gtk_native_dialog_set_title(self: ptr NativeDialog00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: NativeDialog; title: cstring) =
  gtk_native_dialog_set_title(cast[ptr NativeDialog00](self.impl), title)

proc `title=`*(self: NativeDialog; title: cstring) =
  gtk_native_dialog_set_title(cast[ptr NativeDialog00](self.impl), title)

proc gtk_native_dialog_set_transient_for(self: ptr NativeDialog00; parent: ptr Window00) {.
    importc, libprag.}

proc setTransientFor*(self: NativeDialog; parent: Window = nil) =
  gtk_native_dialog_set_transient_for(cast[ptr NativeDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc `transientFor=`*(self: NativeDialog; parent: Window = nil) =
  gtk_native_dialog_set_transient_for(cast[ptr NativeDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc gtk_native_dialog_show(self: ptr NativeDialog00) {.
    importc, libprag.}

proc show*(self: NativeDialog) =
  gtk_native_dialog_show(cast[ptr NativeDialog00](self.impl))

type
  FileChooserNative* = ref object of NativeDialog
  FileChooserNative00* = object of NativeDialog00

proc gtk_file_chooser_native_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileChooserNative()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_file_chooser_native_new(title: cstring; parent: ptr Window00; action: FileChooserAction;
    acceptLabel: cstring; cancelLabel: cstring): ptr FileChooserNative00 {.
    importc, libprag.}

proc newFileChooserNative*(title: cstring = nil; parent: Window = nil;
    action: FileChooserAction; acceptLabel: cstring = nil; cancelLabel: cstring = nil): FileChooserNative {.deprecated.}  =
  let gobj = gtk_file_chooser_native_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action, acceptLabel, cancelLabel)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileChooserNative*(tdesc: typedesc; title: cstring = nil; parent: Window = nil;
    action: FileChooserAction; acceptLabel: cstring = nil; cancelLabel: cstring = nil): tdesc {.deprecated.}  =
  assert(result is FileChooserNative)
  let gobj = gtk_file_chooser_native_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action, acceptLabel, cancelLabel)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserNative*[T](result: var T; title: cstring = nil; parent: Window = nil;
    action: FileChooserAction; acceptLabel: cstring = nil; cancelLabel: cstring = nil) {.deprecated.} =
  assert(result is FileChooserNative)
  let gobj = gtk_file_chooser_native_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action, acceptLabel, cancelLabel)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_native_get_accept_label(self: ptr FileChooserNative00): cstring {.
    importc, libprag.}

proc getAcceptLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_accept_label(cast[ptr FileChooserNative00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc acceptLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_accept_label(cast[ptr FileChooserNative00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_file_chooser_native_get_cancel_label(self: ptr FileChooserNative00): cstring {.
    importc, libprag.}

proc getCancelLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_cancel_label(cast[ptr FileChooserNative00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc cancelLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_cancel_label(cast[ptr FileChooserNative00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_file_chooser_native_set_accept_label(self: ptr FileChooserNative00;
    acceptLabel: cstring) {.
    importc, libprag.}

proc setAcceptLabel*(self: FileChooserNative; acceptLabel: cstring = nil) =
  gtk_file_chooser_native_set_accept_label(cast[ptr FileChooserNative00](self.impl), acceptLabel)

proc `acceptLabel=`*(self: FileChooserNative; acceptLabel: cstring = nil) =
  gtk_file_chooser_native_set_accept_label(cast[ptr FileChooserNative00](self.impl), acceptLabel)

proc gtk_file_chooser_native_set_cancel_label(self: ptr FileChooserNative00;
    cancelLabel: cstring) {.
    importc, libprag.}

proc setCancelLabel*(self: FileChooserNative; cancelLabel: cstring = nil) =
  gtk_file_chooser_native_set_cancel_label(cast[ptr FileChooserNative00](self.impl), cancelLabel)

proc `cancelLabel=`*(self: FileChooserNative; cancelLabel: cstring = nil) =
  gtk_file_chooser_native_set_cancel_label(cast[ptr FileChooserNative00](self.impl), cancelLabel)

proc gtk_file_chooser_add_choice(self: ptr FileChooser00; id: cstring; label: cstring;
    options: ptr cstring; optionLabels: ptr cstring) {.
    importc, libprag.}

proc addChoice*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    id: cstring; label: cstring; options: openArray[string]; optionLabels: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var fs469n232x: array[256, pointer]
  var fs469n232: cstringArray = cast[cstringArray](addr fs469n232x)
  gtk_file_chooser_add_choice(cast[ptr FileChooser00](self.impl), id, label, seq2CstringArray(options, fs469n23), seq2CstringArray(optionLabels, fs469n232))

proc gtk_file_chooser_add_filter(self: ptr FileChooser00; filter: ptr FileFilter00) {.
    importc, libprag.}

proc addFilter*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    filter: FileFilter) =
  gtk_file_chooser_add_filter(cast[ptr FileChooser00](self.impl), cast[ptr FileFilter00](filter.impl))

proc gtk_file_chooser_add_shortcut_folder(self: ptr FileChooser00; folder: ptr gio.GFile00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc addShortcutFolder*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    folder: gio.GFile): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_add_shortcut_folder(cast[ptr FileChooser00](self.impl), cast[ptr gio.GFile00](folder.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_get_action(self: ptr FileChooser00): FileChooserAction {.
    importc, libprag.}

proc getAction*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): FileChooserAction =
  gtk_file_chooser_get_action(cast[ptr FileChooser00](self.impl))

proc action*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): FileChooserAction =
  gtk_file_chooser_get_action(cast[ptr FileChooser00](self.impl))

proc gtk_file_chooser_get_choice(self: ptr FileChooser00; id: cstring): cstring {.
    importc, libprag.}

proc getChoice*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    id: cstring): string =
  let resul0 = gtk_file_chooser_get_choice(cast[ptr FileChooser00](self.impl), id)
  if resul0.isNil:
    return
  result = $resul0

proc gtk_file_chooser_get_create_folders(self: ptr FileChooser00): gboolean {.
    importc, libprag.}

proc getCreateFolders*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): bool =
  toBool(gtk_file_chooser_get_create_folders(cast[ptr FileChooser00](self.impl)))

proc createFolders*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): bool =
  toBool(gtk_file_chooser_get_create_folders(cast[ptr FileChooser00](self.impl)))

proc gtk_file_chooser_get_current_folder(self: ptr FileChooser00): ptr gio.GFile00 {.
    importc, libprag.}

proc getCurrentFolder*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.GFile =
  let gobj = gtk_file_chooser_get_current_folder(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc currentFolder*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.GFile =
  let gobj = gtk_file_chooser_get_current_folder(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_current_name(self: ptr FileChooser00): cstring {.
    importc, libprag.}

proc getCurrentName*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): string =
  let resul0 = gtk_file_chooser_get_current_name(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc currentName*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): string =
  let resul0 = gtk_file_chooser_get_current_name(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_file_chooser_get_file(self: ptr FileChooser00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.GFile =
  let gobj = gtk_file_chooser_get_file(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.GFile =
  let gobj = gtk_file_chooser_get_file(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_files(self: ptr FileChooser00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getFiles*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.ListModel =
  let gobj = gtk_file_chooser_get_files(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc files*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.ListModel =
  let gobj = gtk_file_chooser_get_files(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_filter(self: ptr FileChooser00): ptr FileFilter00 {.
    importc, libprag.}

proc getFilter*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): FileFilter =
  let gobj = gtk_file_chooser_get_filter(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc filter*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): FileFilter =
  let gobj = gtk_file_chooser_get_filter(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_filters(self: ptr FileChooser00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getFilters*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.ListModel =
  let gobj = gtk_file_chooser_get_filters(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc filters*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.ListModel =
  let gobj = gtk_file_chooser_get_filters(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_select_multiple(self: ptr FileChooser00): gboolean {.
    importc, libprag.}

proc getSelectMultiple*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): bool =
  toBool(gtk_file_chooser_get_select_multiple(cast[ptr FileChooser00](self.impl)))

proc selectMultiple*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): bool =
  toBool(gtk_file_chooser_get_select_multiple(cast[ptr FileChooser00](self.impl)))

proc gtk_file_chooser_get_shortcut_folders(self: ptr FileChooser00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getShortcutFolders*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.ListModel =
  let gobj = gtk_file_chooser_get_shortcut_folders(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc shortcutFolders*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative): gio.ListModel =
  let gobj = gtk_file_chooser_get_shortcut_folders(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_remove_choice(self: ptr FileChooser00; id: cstring) {.
    importc, libprag.}

proc removeChoice*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    id: cstring) =
  gtk_file_chooser_remove_choice(cast[ptr FileChooser00](self.impl), id)

proc gtk_file_chooser_remove_filter(self: ptr FileChooser00; filter: ptr FileFilter00) {.
    importc, libprag.}

proc removeFilter*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    filter: FileFilter) =
  gtk_file_chooser_remove_filter(cast[ptr FileChooser00](self.impl), cast[ptr FileFilter00](filter.impl))

proc gtk_file_chooser_remove_shortcut_folder(self: ptr FileChooser00; folder: ptr gio.GFile00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc removeShortcutFolder*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    folder: gio.GFile): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_remove_shortcut_folder(cast[ptr FileChooser00](self.impl), cast[ptr gio.GFile00](folder.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_set_action(self: ptr FileChooser00; action: FileChooserAction) {.
    importc, libprag.}

proc setAction*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    action: FileChooserAction) =
  gtk_file_chooser_set_action(cast[ptr FileChooser00](self.impl), action)

proc `action=`*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    action: FileChooserAction) =
  gtk_file_chooser_set_action(cast[ptr FileChooser00](self.impl), action)

proc gtk_file_chooser_set_choice(self: ptr FileChooser00; id: cstring; option: cstring) {.
    importc, libprag.}

proc setChoice*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    id: cstring; option: cstring) =
  gtk_file_chooser_set_choice(cast[ptr FileChooser00](self.impl), id, option)

proc gtk_file_chooser_set_create_folders(self: ptr FileChooser00; createFolders: gboolean) {.
    importc, libprag.}

proc setCreateFolders*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    createFolders: bool = true) =
  gtk_file_chooser_set_create_folders(cast[ptr FileChooser00](self.impl), gboolean(createFolders))

proc `createFolders=`*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    createFolders: bool) =
  gtk_file_chooser_set_create_folders(cast[ptr FileChooser00](self.impl), gboolean(createFolders))

proc gtk_file_chooser_set_current_folder(self: ptr FileChooser00; file: ptr gio.GFile00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc setCurrentFolder*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    file: gio.GFile = nil): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_set_current_folder(cast[ptr FileChooser00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_set_current_name(self: ptr FileChooser00; name: cstring) {.
    importc, libprag.}

proc setCurrentName*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    name: cstring) =
  gtk_file_chooser_set_current_name(cast[ptr FileChooser00](self.impl), name)

proc `currentName=`*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    name: cstring) =
  gtk_file_chooser_set_current_name(cast[ptr FileChooser00](self.impl), name)

proc gtk_file_chooser_set_file(self: ptr FileChooser00; file: ptr gio.GFile00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc setFile*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    file: gio.GFile): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_set_file(cast[ptr FileChooser00](self.impl), cast[ptr gio.GFile00](file.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_set_filter(self: ptr FileChooser00; filter: ptr FileFilter00) {.
    importc, libprag.}

proc setFilter*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    filter: FileFilter) =
  gtk_file_chooser_set_filter(cast[ptr FileChooser00](self.impl), cast[ptr FileFilter00](filter.impl))

proc `filter=`*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    filter: FileFilter) =
  gtk_file_chooser_set_filter(cast[ptr FileChooser00](self.impl), cast[ptr FileFilter00](filter.impl))

proc gtk_file_chooser_set_select_multiple(self: ptr FileChooser00; selectMultiple: gboolean) {.
    importc, libprag.}

proc setSelectMultiple*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    selectMultiple: bool = true) =
  gtk_file_chooser_set_select_multiple(cast[ptr FileChooser00](self.impl), gboolean(selectMultiple))

proc `selectMultiple=`*(self: FileChooser | FileChooserDialog | FileChooserWidget | FileChooserNative;
    selectMultiple: bool) =
  gtk_file_chooser_set_select_multiple(cast[ptr FileChooser00](self.impl), gboolean(selectMultiple))

type
  FileChooserError* {.size: sizeof(cint), pure.} = enum
    nonexistent = 0
    badFilename = 1
    alreadyExists = 2
    incompleteHostname = 3

type
  FileDialog* = ref object of gobject.Object
  FileDialog00* = object of gobject.Object00

proc gtk_file_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_file_dialog_new(): ptr FileDialog00 {.
    importc, libprag.}

proc newFileDialog*(): FileDialog =
  let gobj = gtk_file_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileDialog*(tdesc: typedesc): tdesc =
  assert(result is FileDialog)
  let gobj = gtk_file_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileDialog*[T](result: var T) {.deprecated.} =
  assert(result is FileDialog)
  let gobj = gtk_file_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_get_accept_label(self: ptr FileDialog00): cstring {.
    importc, libprag.}

proc getAcceptLabel*(self: FileDialog): string =
  let resul0 = gtk_file_dialog_get_accept_label(cast[ptr FileDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc acceptLabel*(self: FileDialog): string =
  let resul0 = gtk_file_dialog_get_accept_label(cast[ptr FileDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_file_dialog_get_default_filter(self: ptr FileDialog00): ptr FileFilter00 {.
    importc, libprag.}

proc getDefaultFilter*(self: FileDialog): FileFilter =
  let gobj = gtk_file_dialog_get_default_filter(cast[ptr FileDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultFilter*(self: FileDialog): FileFilter =
  let gobj = gtk_file_dialog_get_default_filter(cast[ptr FileDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_get_filters(self: ptr FileDialog00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getFilters*(self: FileDialog): gio.ListModel =
  let gobj = gtk_file_dialog_get_filters(cast[ptr FileDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc filters*(self: FileDialog): gio.ListModel =
  let gobj = gtk_file_dialog_get_filters(cast[ptr FileDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_get_initial_file(self: ptr FileDialog00): ptr gio.GFile00 {.
    importc, libprag.}

proc getInitialFile*(self: FileDialog): gio.GFile =
  let gobj = gtk_file_dialog_get_initial_file(cast[ptr FileDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initialFile*(self: FileDialog): gio.GFile =
  let gobj = gtk_file_dialog_get_initial_file(cast[ptr FileDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_get_initial_folder(self: ptr FileDialog00): ptr gio.GFile00 {.
    importc, libprag.}

proc getInitialFolder*(self: FileDialog): gio.GFile =
  let gobj = gtk_file_dialog_get_initial_folder(cast[ptr FileDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initialFolder*(self: FileDialog): gio.GFile =
  let gobj = gtk_file_dialog_get_initial_folder(cast[ptr FileDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_get_initial_name(self: ptr FileDialog00): cstring {.
    importc, libprag.}

proc getInitialName*(self: FileDialog): string =
  let resul0 = gtk_file_dialog_get_initial_name(cast[ptr FileDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc initialName*(self: FileDialog): string =
  let resul0 = gtk_file_dialog_get_initial_name(cast[ptr FileDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_file_dialog_get_modal(self: ptr FileDialog00): gboolean {.
    importc, libprag.}

proc getModal*(self: FileDialog): bool =
  toBool(gtk_file_dialog_get_modal(cast[ptr FileDialog00](self.impl)))

proc modal*(self: FileDialog): bool =
  toBool(gtk_file_dialog_get_modal(cast[ptr FileDialog00](self.impl)))

proc gtk_file_dialog_get_title(self: ptr FileDialog00): cstring {.
    importc, libprag.}

proc getTitle*(self: FileDialog): string =
  result = $gtk_file_dialog_get_title(cast[ptr FileDialog00](self.impl))

proc title*(self: FileDialog): string =
  result = $gtk_file_dialog_get_title(cast[ptr FileDialog00](self.impl))

proc gtk_file_dialog_open(self: ptr FileDialog00; parent: ptr Window00; cancellable: ptr gio.Cancellable00;
    callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc open*(self: FileDialog; parent: Window = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_file_dialog_open(cast[ptr FileDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_file_dialog_open_finish(self: ptr FileDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr gio.GFile00 {.
    importc, libprag.}

proc openFinish*(self: FileDialog; resu: gio.AsyncResult): gio.GFile =
  var gerror: ptr glib.Error
  let gobj = gtk_file_dialog_open_finish(cast[ptr FileDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_open_multiple(self: ptr FileDialog00; parent: ptr Window00;
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc openMultiple*(self: FileDialog; parent: Window = nil;
    cancellable: gio.Cancellable = nil; callback: AsyncReadyCallback; userData: pointer) =
  gtk_file_dialog_open_multiple(cast[ptr FileDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_file_dialog_open_multiple_finish(self: ptr FileDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr gio.ListModel00 {.
    importc, libprag.}

proc openMultipleFinish*(self: FileDialog; resu: gio.AsyncResult): gio.ListModel =
  var gerror: ptr glib.Error
  let gobj = gtk_file_dialog_open_multiple_finish(cast[ptr FileDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_save(self: ptr FileDialog00; parent: ptr Window00; cancellable: ptr gio.Cancellable00;
    callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc save*(self: FileDialog; parent: Window = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_file_dialog_save(cast[ptr FileDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_file_dialog_save_finish(self: ptr FileDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr gio.GFile00 {.
    importc, libprag.}

proc saveFinish*(self: FileDialog; resu: gio.AsyncResult): gio.GFile =
  var gerror: ptr glib.Error
  let gobj = gtk_file_dialog_save_finish(cast[ptr FileDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_select_folder(self: ptr FileDialog00; parent: ptr Window00;
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc selectFolder*(self: FileDialog; parent: Window = nil;
    cancellable: gio.Cancellable = nil; callback: AsyncReadyCallback; userData: pointer) =
  gtk_file_dialog_select_folder(cast[ptr FileDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_file_dialog_select_folder_finish(self: ptr FileDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr gio.GFile00 {.
    importc, libprag.}

proc selectFolderFinish*(self: FileDialog; resu: gio.AsyncResult): gio.GFile =
  var gerror: ptr glib.Error
  let gobj = gtk_file_dialog_select_folder_finish(cast[ptr FileDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_select_multiple_folders(self: ptr FileDialog00; parent: ptr Window00;
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc selectMultipleFolders*(self: FileDialog; parent: Window = nil;
    cancellable: gio.Cancellable = nil; callback: AsyncReadyCallback; userData: pointer) =
  gtk_file_dialog_select_multiple_folders(cast[ptr FileDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_file_dialog_select_multiple_folders_finish(self: ptr FileDialog00;
    resu: ptr gio.AsyncResult00; error: ptr ptr glib.Error = nil): ptr gio.ListModel00 {.
    importc, libprag.}

proc selectMultipleFoldersFinish*(self: FileDialog; resu: gio.AsyncResult): gio.ListModel =
  var gerror: ptr glib.Error
  let gobj = gtk_file_dialog_select_multiple_folders_finish(cast[ptr FileDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_dialog_set_accept_label(self: ptr FileDialog00; acceptLabel: cstring) {.
    importc, libprag.}

proc setAcceptLabel*(self: FileDialog; acceptLabel: cstring = nil) =
  gtk_file_dialog_set_accept_label(cast[ptr FileDialog00](self.impl), acceptLabel)

proc `acceptLabel=`*(self: FileDialog; acceptLabel: cstring = nil) =
  gtk_file_dialog_set_accept_label(cast[ptr FileDialog00](self.impl), acceptLabel)

proc gtk_file_dialog_set_default_filter(self: ptr FileDialog00; filter: ptr FileFilter00) {.
    importc, libprag.}

proc setDefaultFilter*(self: FileDialog; filter: FileFilter = nil) =
  gtk_file_dialog_set_default_filter(cast[ptr FileDialog00](self.impl), if filter.isNil: nil else: cast[ptr FileFilter00](filter.impl))

proc `defaultFilter=`*(self: FileDialog; filter: FileFilter = nil) =
  gtk_file_dialog_set_default_filter(cast[ptr FileDialog00](self.impl), if filter.isNil: nil else: cast[ptr FileFilter00](filter.impl))

proc gtk_file_dialog_set_filters(self: ptr FileDialog00; filters: ptr gio.ListModel00) {.
    importc, libprag.}

proc setFilters*(self: FileDialog; filters: gio.ListModel = nil) =
  gtk_file_dialog_set_filters(cast[ptr FileDialog00](self.impl), if filters.isNil: nil else: cast[ptr gio.ListModel00](filters.impl))

proc `filters=`*(self: FileDialog; filters: gio.ListModel = nil) =
  gtk_file_dialog_set_filters(cast[ptr FileDialog00](self.impl), if filters.isNil: nil else: cast[ptr gio.ListModel00](filters.impl))

proc gtk_file_dialog_set_initial_file(self: ptr FileDialog00; file: ptr gio.GFile00) {.
    importc, libprag.}

proc setInitialFile*(self: FileDialog; file: gio.GFile = nil) =
  gtk_file_dialog_set_initial_file(cast[ptr FileDialog00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc `initialFile=`*(self: FileDialog; file: gio.GFile = nil) =
  gtk_file_dialog_set_initial_file(cast[ptr FileDialog00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc gtk_file_dialog_set_initial_folder(self: ptr FileDialog00; folder: ptr gio.GFile00) {.
    importc, libprag.}

proc setInitialFolder*(self: FileDialog; folder: gio.GFile = nil) =
  gtk_file_dialog_set_initial_folder(cast[ptr FileDialog00](self.impl), if folder.isNil: nil else: cast[ptr gio.GFile00](folder.impl))

proc `initialFolder=`*(self: FileDialog; folder: gio.GFile = nil) =
  gtk_file_dialog_set_initial_folder(cast[ptr FileDialog00](self.impl), if folder.isNil: nil else: cast[ptr gio.GFile00](folder.impl))

proc gtk_file_dialog_set_initial_name(self: ptr FileDialog00; name: cstring) {.
    importc, libprag.}

proc setInitialName*(self: FileDialog; name: cstring = nil) =
  gtk_file_dialog_set_initial_name(cast[ptr FileDialog00](self.impl), name)

proc `initialName=`*(self: FileDialog; name: cstring = nil) =
  gtk_file_dialog_set_initial_name(cast[ptr FileDialog00](self.impl), name)

proc gtk_file_dialog_set_modal(self: ptr FileDialog00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: FileDialog; modal: bool = true) =
  gtk_file_dialog_set_modal(cast[ptr FileDialog00](self.impl), gboolean(modal))

proc `modal=`*(self: FileDialog; modal: bool) =
  gtk_file_dialog_set_modal(cast[ptr FileDialog00](self.impl), gboolean(modal))

proc gtk_file_dialog_set_title(self: ptr FileDialog00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: FileDialog; title: cstring) =
  gtk_file_dialog_set_title(cast[ptr FileDialog00](self.impl), title)

proc `title=`*(self: FileDialog; title: cstring) =
  gtk_file_dialog_set_title(cast[ptr FileDialog00](self.impl), title)

type
  FileLauncher* = ref object of gobject.Object
  FileLauncher00* = object of gobject.Object00

proc gtk_file_launcher_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileLauncher()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_file_launcher_new(file: ptr gio.GFile00): ptr FileLauncher00 {.
    importc, libprag.}

proc newFileLauncher*(file: gio.GFile = nil): FileLauncher =
  let gobj = gtk_file_launcher_new(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileLauncher*(tdesc: typedesc; file: gio.GFile = nil): tdesc =
  assert(result is FileLauncher)
  let gobj = gtk_file_launcher_new(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileLauncher*[T](result: var T; file: gio.GFile = nil) {.deprecated.} =
  assert(result is FileLauncher)
  let gobj = gtk_file_launcher_new(if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_launcher_get_always_ask(self: ptr FileLauncher00): gboolean {.
    importc, libprag.}

proc getAlwaysAsk*(self: FileLauncher): bool =
  toBool(gtk_file_launcher_get_always_ask(cast[ptr FileLauncher00](self.impl)))

proc alwaysAsk*(self: FileLauncher): bool =
  toBool(gtk_file_launcher_get_always_ask(cast[ptr FileLauncher00](self.impl)))

proc gtk_file_launcher_get_file(self: ptr FileLauncher00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: FileLauncher): gio.GFile =
  let gobj = gtk_file_launcher_get_file(cast[ptr FileLauncher00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: FileLauncher): gio.GFile =
  let gobj = gtk_file_launcher_get_file(cast[ptr FileLauncher00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_launcher_get_writable(self: ptr FileLauncher00): gboolean {.
    importc, libprag.}

proc getWritable*(self: FileLauncher): bool =
  toBool(gtk_file_launcher_get_writable(cast[ptr FileLauncher00](self.impl)))

proc writable*(self: FileLauncher): bool =
  toBool(gtk_file_launcher_get_writable(cast[ptr FileLauncher00](self.impl)))

proc gtk_file_launcher_launch(self: ptr FileLauncher00; parent: ptr Window00;
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc launch*(self: FileLauncher; parent: Window = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_file_launcher_launch(cast[ptr FileLauncher00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_file_launcher_launch_finish(self: ptr FileLauncher00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc launchFinish*(self: FileLauncher; resu: gio.AsyncResult): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_launcher_launch_finish(cast[ptr FileLauncher00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_launcher_open_containing_folder(self: ptr FileLauncher00; parent: ptr Window00;
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc openContainingFolder*(self: FileLauncher; parent: Window = nil;
    cancellable: gio.Cancellable = nil; callback: AsyncReadyCallback; userData: pointer) =
  gtk_file_launcher_open_containing_folder(cast[ptr FileLauncher00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_file_launcher_open_containing_folder_finish(self: ptr FileLauncher00;
    resu: ptr gio.AsyncResult00; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc openContainingFolderFinish*(self: FileLauncher;
    resu: gio.AsyncResult): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_launcher_open_containing_folder_finish(cast[ptr FileLauncher00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_launcher_set_always_ask(self: ptr FileLauncher00; alwaysAsk: gboolean) {.
    importc, libprag.}

proc setAlwaysAsk*(self: FileLauncher; alwaysAsk: bool = true) =
  gtk_file_launcher_set_always_ask(cast[ptr FileLauncher00](self.impl), gboolean(alwaysAsk))

proc `alwaysAsk=`*(self: FileLauncher; alwaysAsk: bool) =
  gtk_file_launcher_set_always_ask(cast[ptr FileLauncher00](self.impl), gboolean(alwaysAsk))

proc gtk_file_launcher_set_file(self: ptr FileLauncher00; file: ptr gio.GFile00) {.
    importc, libprag.}

proc setFile*(self: FileLauncher; file: gio.GFile = nil) =
  gtk_file_launcher_set_file(cast[ptr FileLauncher00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc `file=`*(self: FileLauncher; file: gio.GFile = nil) =
  gtk_file_launcher_set_file(cast[ptr FileLauncher00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc gtk_file_launcher_set_writable(self: ptr FileLauncher00; writable: gboolean) {.
    importc, libprag.}

proc setWritable*(self: FileLauncher; writable: bool = true) =
  gtk_file_launcher_set_writable(cast[ptr FileLauncher00](self.impl), gboolean(writable))

proc `writable=`*(self: FileLauncher; writable: bool) =
  gtk_file_launcher_set_writable(cast[ptr FileLauncher00](self.impl), gboolean(writable))

type
  FilterListModel* = ref object of gobject.Object
  FilterListModel00* = object of gobject.Object00

proc gtk_filter_list_model_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FilterListModel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_filter_list_model_new(model: ptr gio.ListModel00; filter: ptr Filter00): ptr FilterListModel00 {.
    importc, libprag.}

proc newFilterListModel*(model: gio.ListModel = nil; filter: Filter = nil): FilterListModel =
  let gobj = gtk_filter_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), if filter.isNil: nil else: cast[ptr Filter00](g_object_ref(filter.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFilterListModel*(tdesc: typedesc; model: gio.ListModel = nil; filter: Filter = nil): tdesc =
  assert(result is FilterListModel)
  let gobj = gtk_filter_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), if filter.isNil: nil else: cast[ptr Filter00](g_object_ref(filter.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFilterListModel*[T](result: var T; model: gio.ListModel = nil; filter: Filter = nil) {.deprecated.} =
  assert(result is FilterListModel)
  let gobj = gtk_filter_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), if filter.isNil: nil else: cast[ptr Filter00](g_object_ref(filter.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_filter_list_model_get_filter(self: ptr FilterListModel00): ptr Filter00 {.
    importc, libprag.}

proc getFilter*(self: FilterListModel): Filter =
  let gobj = gtk_filter_list_model_get_filter(cast[ptr FilterListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc filter*(self: FilterListModel): Filter =
  let gobj = gtk_filter_list_model_get_filter(cast[ptr FilterListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_filter_list_model_get_incremental(self: ptr FilterListModel00): gboolean {.
    importc, libprag.}

proc getIncremental*(self: FilterListModel): bool =
  toBool(gtk_filter_list_model_get_incremental(cast[ptr FilterListModel00](self.impl)))

proc incremental*(self: FilterListModel): bool =
  toBool(gtk_filter_list_model_get_incremental(cast[ptr FilterListModel00](self.impl)))

proc gtk_filter_list_model_get_model(self: ptr FilterListModel00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: FilterListModel): gio.ListModel =
  let gobj = gtk_filter_list_model_get_model(cast[ptr FilterListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: FilterListModel): gio.ListModel =
  let gobj = gtk_filter_list_model_get_model(cast[ptr FilterListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_filter_list_model_get_pending(self: ptr FilterListModel00): uint32 {.
    importc, libprag.}

proc getPending*(self: FilterListModel): int =
  int(gtk_filter_list_model_get_pending(cast[ptr FilterListModel00](self.impl)))

proc pending*(self: FilterListModel): int =
  int(gtk_filter_list_model_get_pending(cast[ptr FilterListModel00](self.impl)))

proc gtk_filter_list_model_set_filter(self: ptr FilterListModel00; filter: ptr Filter00) {.
    importc, libprag.}

proc setFilter*(self: FilterListModel; filter: Filter = nil) =
  gtk_filter_list_model_set_filter(cast[ptr FilterListModel00](self.impl), if filter.isNil: nil else: cast[ptr Filter00](filter.impl))

proc `filter=`*(self: FilterListModel; filter: Filter = nil) =
  gtk_filter_list_model_set_filter(cast[ptr FilterListModel00](self.impl), if filter.isNil: nil else: cast[ptr Filter00](filter.impl))

proc gtk_filter_list_model_set_incremental(self: ptr FilterListModel00; incremental: gboolean) {.
    importc, libprag.}

proc setIncremental*(self: FilterListModel; incremental: bool = true) =
  gtk_filter_list_model_set_incremental(cast[ptr FilterListModel00](self.impl), gboolean(incremental))

proc `incremental=`*(self: FilterListModel; incremental: bool) =
  gtk_filter_list_model_set_incremental(cast[ptr FilterListModel00](self.impl), gboolean(incremental))

proc gtk_filter_list_model_set_model(self: ptr FilterListModel00; model: ptr gio.ListModel00) {.
    importc, libprag.}

proc setModel*(self: FilterListModel; model: gio.ListModel = nil) =
  gtk_filter_list_model_set_model(cast[ptr FilterListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc `model=`*(self: FilterListModel; model: gio.ListModel = nil) =
  gtk_filter_list_model_set_model(cast[ptr FilterListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

type
  FixedLayout* = ref object of LayoutManager
  FixedLayout00* = object of LayoutManager00

proc gtk_fixed_layout_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FixedLayout()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_fixed_layout_new(): ptr FixedLayout00 {.
    importc, libprag.}

proc newFixedLayout*(): FixedLayout =
  let gobj = gtk_fixed_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFixedLayout*(tdesc: typedesc): tdesc =
  assert(result is FixedLayout)
  let gobj = gtk_fixed_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFixedLayout*[T](result: var T) {.deprecated.} =
  assert(result is FixedLayout)
  let gobj = gtk_fixed_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  FixedLayoutChild* = ref object of LayoutChild
  FixedLayoutChild00* = object of LayoutChild00

proc gtk_fixed_layout_child_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FixedLayoutChild()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_fixed_layout_child_get_transform(self: ptr FixedLayoutChild00): ptr gsk.Transform00 {.
    importc, libprag.}

proc getTransform*(self: FixedLayoutChild): gsk.Transform =
  let impl0 = gtk_fixed_layout_child_get_transform(cast[ptr FixedLayoutChild00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGskTransform)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gsk_transform_get_type(), impl0))

proc transform*(self: FixedLayoutChild): gsk.Transform =
  let impl0 = gtk_fixed_layout_child_get_transform(cast[ptr FixedLayoutChild00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGskTransform)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gsk_transform_get_type(), impl0))

proc gtk_fixed_layout_child_set_transform(self: ptr FixedLayoutChild00; transform: ptr gsk.Transform00) {.
    importc, libprag.}

proc setTransform*(self: FixedLayoutChild; transform: gsk.Transform) =
  gtk_fixed_layout_child_set_transform(cast[ptr FixedLayoutChild00](self.impl), cast[ptr gsk.Transform00](transform.impl))

proc `transform=`*(self: FixedLayoutChild; transform: gsk.Transform) =
  gtk_fixed_layout_child_set_transform(cast[ptr FixedLayoutChild00](self.impl), cast[ptr gsk.Transform00](transform.impl))

type
  FlattenListModel* = ref object of gobject.Object
  FlattenListModel00* = object of gobject.Object00

proc gtk_flatten_list_model_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FlattenListModel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_flatten_list_model_new(model: ptr gio.ListModel00): ptr FlattenListModel00 {.
    importc, libprag.}

proc newFlattenListModel*(model: gio.ListModel = nil): FlattenListModel =
  let gobj = gtk_flatten_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFlattenListModel*(tdesc: typedesc; model: gio.ListModel = nil): tdesc =
  assert(result is FlattenListModel)
  let gobj = gtk_flatten_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFlattenListModel*[T](result: var T; model: gio.ListModel = nil) {.deprecated.} =
  assert(result is FlattenListModel)
  let gobj = gtk_flatten_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flatten_list_model_get_model(self: ptr FlattenListModel00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: FlattenListModel): gio.ListModel =
  let gobj = gtk_flatten_list_model_get_model(cast[ptr FlattenListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: FlattenListModel): gio.ListModel =
  let gobj = gtk_flatten_list_model_get_model(cast[ptr FlattenListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flatten_list_model_get_model_for_item(self: ptr FlattenListModel00;
    position: uint32): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModelForItem*(self: FlattenListModel; position: int): gio.ListModel =
  let gobj = gtk_flatten_list_model_get_model_for_item(cast[ptr FlattenListModel00](self.impl), uint32(position))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flatten_list_model_set_model(self: ptr FlattenListModel00; model: ptr gio.ListModel00) {.
    importc, libprag.}

proc setModel*(self: FlattenListModel; model: gio.ListModel = nil) =
  gtk_flatten_list_model_set_model(cast[ptr FlattenListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc `model=`*(self: FlattenListModel; model: gio.ListModel = nil) =
  gtk_flatten_list_model_set_model(cast[ptr FlattenListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

type
  FlowBoxCreateWidgetFunc* = proc (item: ptr gobject.Object00; userData: pointer): ptr Widget00 {.cdecl.}

proc gtk_flow_box_bind_model(self: ptr FlowBox00; model: ptr gio.ListModel00;
    createWidgetFunc: FlowBoxCreateWidgetFunc; userData: pointer; userDataFreeFunc: DestroyNotify) {.
    importc, libprag.}

proc bindModel*(self: FlowBox; model: gio.ListModel = nil; createWidgetFunc: FlowBoxCreateWidgetFunc;
    userData: pointer; userDataFreeFunc: DestroyNotify) =
  gtk_flow_box_bind_model(cast[ptr FlowBox00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl), createWidgetFunc, userData, userDataFreeFunc)

type
  FlowBoxFilterFunc* = proc (child: ptr FlowBoxChild00; userData: pointer): gboolean {.cdecl.}

proc gtk_flow_box_set_filter_func(self: ptr FlowBox00; filterFunc: FlowBoxFilterFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setFilterFunc*(self: FlowBox; filterFunc: FlowBoxFilterFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_flow_box_set_filter_func(cast[ptr FlowBox00](self.impl), filterFunc, userData, destroy)

type
  FlowBoxForeachFunc* = proc (box: ptr FlowBox00; child: ptr FlowBoxChild00; userData: pointer) {.cdecl.}

proc gtk_flow_box_selected_foreach(self: ptr FlowBox00; `func`: FlowBoxForeachFunc;
    data: pointer) {.
    importc, libprag.}

proc selectedForeach*(self: FlowBox; `func`: FlowBoxForeachFunc;
    data: pointer) =
  gtk_flow_box_selected_foreach(cast[ptr FlowBox00](self.impl), `func`, data)

type
  FlowBoxSortFunc* = proc (child1: ptr FlowBoxChild00; child2: ptr FlowBoxChild00; userData: pointer): int32 {.cdecl.}

proc gtk_flow_box_set_sort_func(self: ptr FlowBox00; sortFunc: FlowBoxSortFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setSortFunc*(self: FlowBox; sortFunc: FlowBoxSortFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_flow_box_set_sort_func(cast[ptr FlowBox00](self.impl), sortFunc, userData, destroy)

type
  FontChooser00* = object of gobject.Object00
  FontChooser* = ref object of gobject.Object

proc scFontActivated*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;  p: proc (self: ptr FontChooser00; fontname: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "font-activated", cast[GCallback](p), xdata, nil, cf)

proc gtk_font_chooser_get_font(self: ptr FontChooser00): cstring {.
    importc, libprag.}

proc getFont*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): string =
  let resul0 = gtk_font_chooser_get_font(cast[ptr FontChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc font*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): string =
  let resul0 = gtk_font_chooser_get_font(cast[ptr FontChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_font_desc(self: ptr FontChooser00): ptr pango.FontDescription00 {.
    importc, libprag.}

proc getFontDesc*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): pango.FontDescription =
  let impl0 = gtk_font_chooser_get_font_desc(cast[ptr FontChooser00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoFontDescription)
  result.impl = impl0

proc fontDesc*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): pango.FontDescription =
  let impl0 = gtk_font_chooser_get_font_desc(cast[ptr FontChooser00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoFontDescription)
  result.impl = impl0

proc gtk_font_chooser_get_font_face(self: ptr FontChooser00): ptr pango.FontFace00 {.
    importc, libprag.}

proc getFontFace*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): pango.FontFace =
  let gobj = gtk_font_chooser_get_font_face(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontFace*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): pango.FontFace =
  let gobj = gtk_font_chooser_get_font_face(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_chooser_get_font_family(self: ptr FontChooser00): ptr pango.FontFamily00 {.
    importc, libprag.}

proc getFontFamily*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): pango.FontFamily =
  let gobj = gtk_font_chooser_get_font_family(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontFamily*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): pango.FontFamily =
  let gobj = gtk_font_chooser_get_font_family(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_chooser_get_font_features(self: ptr FontChooser00): cstring {.
    importc, libprag.}

proc getFontFeatures*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): string =
  let resul0 = gtk_font_chooser_get_font_features(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc fontFeatures*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): string =
  let resul0 = gtk_font_chooser_get_font_features(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_font_map(self: ptr FontChooser00): ptr pango.FontMap00 {.
    importc, libprag.}

proc getFontMap*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): pango.FontMap =
  let gobj = gtk_font_chooser_get_font_map(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontMap*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): pango.FontMap =
  let gobj = gtk_font_chooser_get_font_map(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_chooser_get_font_size(self: ptr FontChooser00): int32 {.
    importc, libprag.}

proc getFontSize*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): int =
  int(gtk_font_chooser_get_font_size(cast[ptr FontChooser00](self.impl)))

proc fontSize*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): int =
  int(gtk_font_chooser_get_font_size(cast[ptr FontChooser00](self.impl)))

proc gtk_font_chooser_get_language(self: ptr FontChooser00): cstring {.
    importc, libprag.}

proc getLanguage*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): string =
  let resul0 = gtk_font_chooser_get_language(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc language*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): string =
  let resul0 = gtk_font_chooser_get_language(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_preview_text(self: ptr FontChooser00): cstring {.
    importc, libprag.}

proc getPreviewText*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): string =
  let resul0 = gtk_font_chooser_get_preview_text(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc previewText*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): string =
  let resul0 = gtk_font_chooser_get_preview_text(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_show_preview_entry(self: ptr FontChooser00): gboolean {.
    importc, libprag.}

proc getShowPreviewEntry*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): bool =
  toBool(gtk_font_chooser_get_show_preview_entry(cast[ptr FontChooser00](self.impl)))

proc showPreviewEntry*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): bool =
  toBool(gtk_font_chooser_get_show_preview_entry(cast[ptr FontChooser00](self.impl)))

proc gtk_font_chooser_set_font(self: ptr FontChooser00; fontname: cstring) {.
    importc, libprag.}

proc setFont*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    fontname: cstring) =
  gtk_font_chooser_set_font(cast[ptr FontChooser00](self.impl), fontname)

proc `font=`*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    fontname: cstring) =
  gtk_font_chooser_set_font(cast[ptr FontChooser00](self.impl), fontname)

proc gtk_font_chooser_set_font_desc(self: ptr FontChooser00; fontDesc: ptr pango.FontDescription00) {.
    importc, libprag.}

proc setFontDesc*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    fontDesc: pango.FontDescription) =
  gtk_font_chooser_set_font_desc(cast[ptr FontChooser00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc `fontDesc=`*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    fontDesc: pango.FontDescription) =
  gtk_font_chooser_set_font_desc(cast[ptr FontChooser00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc gtk_font_chooser_set_font_map(self: ptr FontChooser00; fontmap: ptr pango.FontMap00) {.
    importc, libprag.}

proc setFontMap*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    fontmap: pango.FontMap = nil) =
  gtk_font_chooser_set_font_map(cast[ptr FontChooser00](self.impl), if fontmap.isNil: nil else: cast[ptr pango.FontMap00](fontmap.impl))

proc `fontMap=`*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    fontmap: pango.FontMap = nil) =
  gtk_font_chooser_set_font_map(cast[ptr FontChooser00](self.impl), if fontmap.isNil: nil else: cast[ptr pango.FontMap00](fontmap.impl))

proc gtk_font_chooser_set_language(self: ptr FontChooser00; language: cstring) {.
    importc, libprag.}

proc setLanguage*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    language: cstring) =
  gtk_font_chooser_set_language(cast[ptr FontChooser00](self.impl), language)

proc `language=`*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    language: cstring) =
  gtk_font_chooser_set_language(cast[ptr FontChooser00](self.impl), language)

proc gtk_font_chooser_set_preview_text(self: ptr FontChooser00; text: cstring) {.
    importc, libprag.}

proc setPreviewText*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    text: cstring) =
  gtk_font_chooser_set_preview_text(cast[ptr FontChooser00](self.impl), text)

proc `previewText=`*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    text: cstring) =
  gtk_font_chooser_set_preview_text(cast[ptr FontChooser00](self.impl), text)

proc gtk_font_chooser_set_show_preview_entry(self: ptr FontChooser00; showPreviewEntry: gboolean) {.
    importc, libprag.}

proc setShowPreviewEntry*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    showPreviewEntry: bool = true) =
  gtk_font_chooser_set_show_preview_entry(cast[ptr FontChooser00](self.impl), gboolean(showPreviewEntry))

proc `showPreviewEntry=`*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    showPreviewEntry: bool) =
  gtk_font_chooser_set_show_preview_entry(cast[ptr FontChooser00](self.impl), gboolean(showPreviewEntry))

type
  FontChooserLevelFlag* {.size: sizeof(cint), pure.} = enum
    style = 0
    size = 1
    variations = 2
    features = 3

  FontChooserLevel* = set[FontChooserLevelFlag]

const
  FontChooserLevelFamily* = FontChooserLevel({})
proc family*(t: typedesc[FontChooserLevel]): FontChooserLevel = FontChooserLevel({})

proc gtk_font_chooser_get_level(self: ptr FontChooser00): FontChooserLevel {.
    importc, libprag.}

proc getLevel*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): FontChooserLevel =
  gtk_font_chooser_get_level(cast[ptr FontChooser00](self.impl))

proc level*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget): FontChooserLevel =
  gtk_font_chooser_get_level(cast[ptr FontChooser00](self.impl))

proc gtk_font_chooser_set_level(self: ptr FontChooser00; level: FontChooserLevel) {.
    importc, libprag.}

proc setLevel*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    level: FontChooserLevel) =
  gtk_font_chooser_set_level(cast[ptr FontChooser00](self.impl), level)

proc `level=`*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    level: FontChooserLevel) =
  gtk_font_chooser_set_level(cast[ptr FontChooser00](self.impl), level)

type
  FontFilterFunc* = proc (family: ptr pango.FontFamily00; face: ptr pango.FontFace00; data: pointer): gboolean {.cdecl.}

proc gtk_font_chooser_set_filter_func(self: ptr FontChooser00; filter: FontFilterFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setFilterFunc*(self: FontChooser | FontChooserDialog | FontButton | FontChooserWidget;
    filter: FontFilterFunc; userData: pointer; destroy: DestroyNotify) =
  gtk_font_chooser_set_filter_func(cast[ptr FontChooser00](self.impl), filter, userData, destroy)

type
  GestureClick* = ref object of GestureSingle
  GestureClick00* = object of GestureSingle00

proc gtk_gesture_click_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureClick()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scPressed*(self: GestureClick;  p: proc (self: ptr GestureClick00; nPress: int32; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "pressed", cast[GCallback](p), xdata, nil, cf)

proc scReleased*(self: GestureClick;  p: proc (self: ptr GestureClick00; nPress: int32; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "released", cast[GCallback](p), xdata, nil, cf)

proc scStopped*(self: GestureClick;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "stopped", cast[GCallback](p), xdata, nil, cf)

proc scUnpairedRelease*(self: GestureClick;  p: proc (self: ptr GestureClick00; x: cdouble; y: cdouble; button: uint32; sequence: ptr gdk4.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unpaired-release", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_click_new(): ptr GestureClick00 {.
    importc, libprag.}

proc newGestureClick*(): GestureClick =
  let gobj = gtk_gesture_click_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureClick*(tdesc: typedesc): tdesc =
  assert(result is GestureClick)
  let gobj = gtk_gesture_click_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureClick*[T](result: var T) {.deprecated.} =
  assert(result is GestureClick)
  let gobj = gtk_gesture_click_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  GestureDrag* = ref object of GestureSingle
  GestureDrag00* = object of GestureSingle00

proc gtk_gesture_drag_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureDrag()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDragBegin*(self: GestureDrag;  p: proc (self: ptr GestureDrag00; startX: cdouble; startY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-begin", cast[GCallback](p), xdata, nil, cf)

proc scDragEnd*(self: GestureDrag;  p: proc (self: ptr GestureDrag00; offsetX: cdouble; offsetY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-end", cast[GCallback](p), xdata, nil, cf)

proc scDragUpdate*(self: GestureDrag;  p: proc (self: ptr GestureDrag00; offsetX: cdouble; offsetY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-update", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_drag_new(): ptr GestureDrag00 {.
    importc, libprag.}

proc newGestureDrag*(): GestureDrag =
  let gobj = gtk_gesture_drag_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureDrag*(tdesc: typedesc): tdesc =
  assert(result is GestureDrag)
  let gobj = gtk_gesture_drag_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureDrag*[T](result: var T) {.deprecated.} =
  assert(result is GestureDrag)
  let gobj = gtk_gesture_drag_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_drag_get_offset(self: ptr GestureDrag00; x: var cdouble;
    y: var cdouble): gboolean {.
    importc, libprag.}

proc getOffset*(self: GestureDrag; x: var cdouble = cast[var cdouble](nil);
    y: var cdouble = cast[var cdouble](nil)): bool =
  toBool(gtk_gesture_drag_get_offset(cast[ptr GestureDrag00](self.impl), x, y))

proc gtk_gesture_drag_get_start_point(self: ptr GestureDrag00; x: var cdouble;
    y: var cdouble): gboolean {.
    importc, libprag.}

proc getStartPoint*(self: GestureDrag; x: var cdouble = cast[var cdouble](nil);
    y: var cdouble = cast[var cdouble](nil)): bool =
  toBool(gtk_gesture_drag_get_start_point(cast[ptr GestureDrag00](self.impl), x, y))

type
  GestureLongPress* = ref object of GestureSingle
  GestureLongPress00* = object of GestureSingle00

proc gtk_gesture_long_press_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureLongPress()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scCancelled*(self: GestureLongPress;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cancelled", cast[GCallback](p), xdata, nil, cf)

proc scPressed*(self: GestureLongPress;  p: proc (self: ptr GestureLongPress00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "pressed", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_long_press_new(): ptr GestureLongPress00 {.
    importc, libprag.}

proc newGestureLongPress*(): GestureLongPress =
  let gobj = gtk_gesture_long_press_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureLongPress*(tdesc: typedesc): tdesc =
  assert(result is GestureLongPress)
  let gobj = gtk_gesture_long_press_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureLongPress*[T](result: var T) {.deprecated.} =
  assert(result is GestureLongPress)
  let gobj = gtk_gesture_long_press_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_long_press_get_delay_factor(self: ptr GestureLongPress00): cdouble {.
    importc, libprag.}

proc getDelayFactor*(self: GestureLongPress): cdouble =
  gtk_gesture_long_press_get_delay_factor(cast[ptr GestureLongPress00](self.impl))

proc delayFactor*(self: GestureLongPress): cdouble =
  gtk_gesture_long_press_get_delay_factor(cast[ptr GestureLongPress00](self.impl))

proc gtk_gesture_long_press_set_delay_factor(self: ptr GestureLongPress00;
    delayFactor: cdouble) {.
    importc, libprag.}

proc setDelayFactor*(self: GestureLongPress; delayFactor: cdouble) =
  gtk_gesture_long_press_set_delay_factor(cast[ptr GestureLongPress00](self.impl), delayFactor)

proc `delayFactor=`*(self: GestureLongPress; delayFactor: cdouble) =
  gtk_gesture_long_press_set_delay_factor(cast[ptr GestureLongPress00](self.impl), delayFactor)

type
  PanDirection* {.size: sizeof(cint), pure.} = enum
    left = 0
    right = 1
    up = 2
    down = 3

type
  GesturePan* = ref object of GestureDrag
  GesturePan00* = object of GestureDrag00

proc gtk_gesture_pan_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GesturePan()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scPan*(self: GesturePan;  p: proc (self: ptr GesturePan00; direction: PanDirection; offset: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "pan", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_pan_new(orientation: Orientation): ptr GesturePan00 {.
    importc, libprag.}

proc newGesturePan*(orientation: Orientation): GesturePan =
  let gobj = gtk_gesture_pan_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGesturePan*(tdesc: typedesc; orientation: Orientation): tdesc =
  assert(result is GesturePan)
  let gobj = gtk_gesture_pan_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGesturePan*[T](result: var T; orientation: Orientation) {.deprecated.} =
  assert(result is GesturePan)
  let gobj = gtk_gesture_pan_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_pan_get_orientation(self: ptr GesturePan00): Orientation {.
    importc, libprag.}

proc getOrientation*(self: GesturePan): Orientation =
  gtk_gesture_pan_get_orientation(cast[ptr GesturePan00](self.impl))

proc orientation*(self: GesturePan): Orientation =
  gtk_gesture_pan_get_orientation(cast[ptr GesturePan00](self.impl))

proc gtk_gesture_pan_set_orientation(self: ptr GesturePan00; orientation: Orientation) {.
    importc, libprag.}

proc setOrientation*(self: GesturePan; orientation: Orientation) =
  gtk_gesture_pan_set_orientation(cast[ptr GesturePan00](self.impl), orientation)

proc `orientation=`*(self: GesturePan; orientation: Orientation) =
  gtk_gesture_pan_set_orientation(cast[ptr GesturePan00](self.impl), orientation)

type
  GestureRotate* = ref object of Gesture
  GestureRotate00* = object of Gesture00

proc gtk_gesture_rotate_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureRotate()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAngleChanged*(self: GestureRotate;  p: proc (self: ptr GestureRotate00; angle: cdouble; angleDelta: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "angle-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_rotate_new(): ptr GestureRotate00 {.
    importc, libprag.}

proc newGestureRotate*(): GestureRotate =
  let gobj = gtk_gesture_rotate_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureRotate*(tdesc: typedesc): tdesc =
  assert(result is GestureRotate)
  let gobj = gtk_gesture_rotate_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureRotate*[T](result: var T) {.deprecated.} =
  assert(result is GestureRotate)
  let gobj = gtk_gesture_rotate_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_rotate_get_angle_delta(self: ptr GestureRotate00): cdouble {.
    importc, libprag.}

proc getAngleDelta*(self: GestureRotate): cdouble =
  gtk_gesture_rotate_get_angle_delta(cast[ptr GestureRotate00](self.impl))

proc angleDelta*(self: GestureRotate): cdouble =
  gtk_gesture_rotate_get_angle_delta(cast[ptr GestureRotate00](self.impl))

type
  GestureStylus* = ref object of GestureSingle
  GestureStylus00* = object of GestureSingle00

proc gtk_gesture_stylus_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureStylus()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDown*(self: GestureStylus;  p: proc (self: ptr GestureStylus00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "down", cast[GCallback](p), xdata, nil, cf)

proc scMotion*(self: GestureStylus;  p: proc (self: ptr GestureStylus00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "motion", cast[GCallback](p), xdata, nil, cf)

proc scProximity*(self: GestureStylus;  p: proc (self: ptr GestureStylus00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "proximity", cast[GCallback](p), xdata, nil, cf)

proc scUp*(self: GestureStylus;  p: proc (self: ptr GestureStylus00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "up", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_stylus_new(): ptr GestureStylus00 {.
    importc, libprag.}

proc newGestureStylus*(): GestureStylus =
  let gobj = gtk_gesture_stylus_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureStylus*(tdesc: typedesc): tdesc =
  assert(result is GestureStylus)
  let gobj = gtk_gesture_stylus_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureStylus*[T](result: var T) {.deprecated.} =
  assert(result is GestureStylus)
  let gobj = gtk_gesture_stylus_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_stylus_get_axes(self: ptr GestureStylus00; axes: ptr gdk4.AxisUse;
    values: var ptr cdouble): gboolean {.
    importc, libprag.}

proc getAxes*(self: GestureStylus; axes: ptr gdk4.AxisUse;
    values: var ptr cdouble): bool =
  toBool(gtk_gesture_stylus_get_axes(cast[ptr GestureStylus00](self.impl), axes, values))

proc gtk_gesture_stylus_get_axis(self: ptr GestureStylus00; axis: gdk4.AxisUse;
    value: var cdouble): gboolean {.
    importc, libprag.}

proc getAxis*(self: GestureStylus; axis: gdk4.AxisUse;
    value: var cdouble): bool =
  toBool(gtk_gesture_stylus_get_axis(cast[ptr GestureStylus00](self.impl), axis, value))

proc gtk_gesture_stylus_get_backlog(self: ptr GestureStylus00; backlog: var ptr gdk4.TimeCoord;
    nElems: var uint32): gboolean {.
    importc, libprag.}

proc getBacklog*(self: GestureStylus; backlog: var ptr gdk4.TimeCoord;
    nElems: var int): bool =
  var nElems_00: uint32
  result = toBool(gtk_gesture_stylus_get_backlog(cast[ptr GestureStylus00](self.impl), backlog, nElems_00))
  if nElems.addr != nil:
    nElems = int(nElems_00)

proc gtk_gesture_stylus_get_device_tool(self: ptr GestureStylus00): ptr gdk4.DeviceTool00 {.
    importc, libprag.}

proc getDeviceTool*(self: GestureStylus): gdk4.DeviceTool =
  let gobj = gtk_gesture_stylus_get_device_tool(cast[ptr GestureStylus00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc deviceTool*(self: GestureStylus): gdk4.DeviceTool =
  let gobj = gtk_gesture_stylus_get_device_tool(cast[ptr GestureStylus00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_stylus_get_stylus_only(self: ptr GestureStylus00): gboolean {.
    importc, libprag.}

proc getStylusOnly*(self: GestureStylus): bool =
  toBool(gtk_gesture_stylus_get_stylus_only(cast[ptr GestureStylus00](self.impl)))

proc stylusOnly*(self: GestureStylus): bool =
  toBool(gtk_gesture_stylus_get_stylus_only(cast[ptr GestureStylus00](self.impl)))

proc gtk_gesture_stylus_set_stylus_only(self: ptr GestureStylus00; stylusOnly: gboolean) {.
    importc, libprag.}

proc setStylusOnly*(self: GestureStylus; stylusOnly: bool = true) =
  gtk_gesture_stylus_set_stylus_only(cast[ptr GestureStylus00](self.impl), gboolean(stylusOnly))

proc `stylusOnly=`*(self: GestureStylus; stylusOnly: bool) =
  gtk_gesture_stylus_set_stylus_only(cast[ptr GestureStylus00](self.impl), gboolean(stylusOnly))

type
  GestureSwipe* = ref object of GestureSingle
  GestureSwipe00* = object of GestureSingle00

proc gtk_gesture_swipe_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureSwipe()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scSwipe*(self: GestureSwipe;  p: proc (self: ptr GestureSwipe00; velocityX: cdouble; velocityY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "swipe", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_swipe_new(): ptr GestureSwipe00 {.
    importc, libprag.}

proc newGestureSwipe*(): GestureSwipe =
  let gobj = gtk_gesture_swipe_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureSwipe*(tdesc: typedesc): tdesc =
  assert(result is GestureSwipe)
  let gobj = gtk_gesture_swipe_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureSwipe*[T](result: var T) {.deprecated.} =
  assert(result is GestureSwipe)
  let gobj = gtk_gesture_swipe_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_swipe_get_velocity(self: ptr GestureSwipe00; velocityX: var cdouble;
    velocityY: var cdouble): gboolean {.
    importc, libprag.}

proc getVelocity*(self: GestureSwipe; velocityX: var cdouble;
    velocityY: var cdouble): bool =
  toBool(gtk_gesture_swipe_get_velocity(cast[ptr GestureSwipe00](self.impl), velocityX, velocityY))

type
  GestureZoom* = ref object of Gesture
  GestureZoom00* = object of Gesture00

proc gtk_gesture_zoom_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureZoom()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scScaleChanged*(self: GestureZoom;  p: proc (self: ptr GestureZoom00; scale: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scale-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_zoom_new(): ptr GestureZoom00 {.
    importc, libprag.}

proc newGestureZoom*(): GestureZoom =
  let gobj = gtk_gesture_zoom_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureZoom*(tdesc: typedesc): tdesc =
  assert(result is GestureZoom)
  let gobj = gtk_gesture_zoom_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureZoom*[T](result: var T) {.deprecated.} =
  assert(result is GestureZoom)
  let gobj = gtk_gesture_zoom_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_zoom_get_scale_delta(self: ptr GestureZoom00): cdouble {.
    importc, libprag.}

proc getScaleDelta*(self: GestureZoom): cdouble =
  gtk_gesture_zoom_get_scale_delta(cast[ptr GestureZoom00](self.impl))

proc scaleDelta*(self: GestureZoom): cdouble =
  gtk_gesture_zoom_get_scale_delta(cast[ptr GestureZoom00](self.impl))

type
  GridLayout* = ref object of LayoutManager
  GridLayout00* = object of LayoutManager00

proc gtk_grid_layout_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GridLayout()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_grid_layout_new(): ptr GridLayout00 {.
    importc, libprag.}

proc newGridLayout*(): GridLayout =
  let gobj = gtk_grid_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGridLayout*(tdesc: typedesc): tdesc =
  assert(result is GridLayout)
  let gobj = gtk_grid_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGridLayout*[T](result: var T) {.deprecated.} =
  assert(result is GridLayout)
  let gobj = gtk_grid_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_layout_get_baseline_row(self: ptr GridLayout00): int32 {.
    importc, libprag.}

proc getBaselineRow*(self: GridLayout): int =
  int(gtk_grid_layout_get_baseline_row(cast[ptr GridLayout00](self.impl)))

proc baselineRow*(self: GridLayout): int =
  int(gtk_grid_layout_get_baseline_row(cast[ptr GridLayout00](self.impl)))

proc gtk_grid_layout_get_column_homogeneous(self: ptr GridLayout00): gboolean {.
    importc, libprag.}

proc getColumnHomogeneous*(self: GridLayout): bool =
  toBool(gtk_grid_layout_get_column_homogeneous(cast[ptr GridLayout00](self.impl)))

proc columnHomogeneous*(self: GridLayout): bool =
  toBool(gtk_grid_layout_get_column_homogeneous(cast[ptr GridLayout00](self.impl)))

proc gtk_grid_layout_get_column_spacing(self: ptr GridLayout00): uint32 {.
    importc, libprag.}

proc getColumnSpacing*(self: GridLayout): int =
  int(gtk_grid_layout_get_column_spacing(cast[ptr GridLayout00](self.impl)))

proc columnSpacing*(self: GridLayout): int =
  int(gtk_grid_layout_get_column_spacing(cast[ptr GridLayout00](self.impl)))

proc gtk_grid_layout_get_row_baseline_position(self: ptr GridLayout00; row: int32): BaselinePosition {.
    importc, libprag.}

proc getRowBaselinePosition*(self: GridLayout; row: int): BaselinePosition =
  gtk_grid_layout_get_row_baseline_position(cast[ptr GridLayout00](self.impl), int32(row))

proc gtk_grid_layout_get_row_homogeneous(self: ptr GridLayout00): gboolean {.
    importc, libprag.}

proc getRowHomogeneous*(self: GridLayout): bool =
  toBool(gtk_grid_layout_get_row_homogeneous(cast[ptr GridLayout00](self.impl)))

proc rowHomogeneous*(self: GridLayout): bool =
  toBool(gtk_grid_layout_get_row_homogeneous(cast[ptr GridLayout00](self.impl)))

proc gtk_grid_layout_get_row_spacing(self: ptr GridLayout00): uint32 {.
    importc, libprag.}

proc getRowSpacing*(self: GridLayout): int =
  int(gtk_grid_layout_get_row_spacing(cast[ptr GridLayout00](self.impl)))

proc rowSpacing*(self: GridLayout): int =
  int(gtk_grid_layout_get_row_spacing(cast[ptr GridLayout00](self.impl)))

proc gtk_grid_layout_set_baseline_row(self: ptr GridLayout00; row: int32) {.
    importc, libprag.}

proc setBaselineRow*(self: GridLayout; row: int) =
  gtk_grid_layout_set_baseline_row(cast[ptr GridLayout00](self.impl), int32(row))

proc `baselineRow=`*(self: GridLayout; row: int) =
  gtk_grid_layout_set_baseline_row(cast[ptr GridLayout00](self.impl), int32(row))

proc gtk_grid_layout_set_column_homogeneous(self: ptr GridLayout00; homogeneous: gboolean) {.
    importc, libprag.}

proc setColumnHomogeneous*(self: GridLayout; homogeneous: bool = true) =
  gtk_grid_layout_set_column_homogeneous(cast[ptr GridLayout00](self.impl), gboolean(homogeneous))

proc `columnHomogeneous=`*(self: GridLayout; homogeneous: bool) =
  gtk_grid_layout_set_column_homogeneous(cast[ptr GridLayout00](self.impl), gboolean(homogeneous))

proc gtk_grid_layout_set_column_spacing(self: ptr GridLayout00; spacing: uint32) {.
    importc, libprag.}

proc setColumnSpacing*(self: GridLayout; spacing: int) =
  gtk_grid_layout_set_column_spacing(cast[ptr GridLayout00](self.impl), uint32(spacing))

proc `columnSpacing=`*(self: GridLayout; spacing: int) =
  gtk_grid_layout_set_column_spacing(cast[ptr GridLayout00](self.impl), uint32(spacing))

proc gtk_grid_layout_set_row_baseline_position(self: ptr GridLayout00; row: int32;
    pos: BaselinePosition) {.
    importc, libprag.}

proc setRowBaselinePosition*(self: GridLayout; row: int;
    pos: BaselinePosition) =
  gtk_grid_layout_set_row_baseline_position(cast[ptr GridLayout00](self.impl), int32(row), pos)

proc gtk_grid_layout_set_row_homogeneous(self: ptr GridLayout00; homogeneous: gboolean) {.
    importc, libprag.}

proc setRowHomogeneous*(self: GridLayout; homogeneous: bool = true) =
  gtk_grid_layout_set_row_homogeneous(cast[ptr GridLayout00](self.impl), gboolean(homogeneous))

proc `rowHomogeneous=`*(self: GridLayout; homogeneous: bool) =
  gtk_grid_layout_set_row_homogeneous(cast[ptr GridLayout00](self.impl), gboolean(homogeneous))

proc gtk_grid_layout_set_row_spacing(self: ptr GridLayout00; spacing: uint32) {.
    importc, libprag.}

proc setRowSpacing*(self: GridLayout; spacing: int) =
  gtk_grid_layout_set_row_spacing(cast[ptr GridLayout00](self.impl), uint32(spacing))

proc `rowSpacing=`*(self: GridLayout; spacing: int) =
  gtk_grid_layout_set_row_spacing(cast[ptr GridLayout00](self.impl), uint32(spacing))

type
  GridLayoutChild* = ref object of LayoutChild
  GridLayoutChild00* = object of LayoutChild00

proc gtk_grid_layout_child_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GridLayoutChild()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_grid_layout_child_get_column(self: ptr GridLayoutChild00): int32 {.
    importc, libprag.}

proc getColumn*(self: GridLayoutChild): int =
  int(gtk_grid_layout_child_get_column(cast[ptr GridLayoutChild00](self.impl)))

proc column*(self: GridLayoutChild): int =
  int(gtk_grid_layout_child_get_column(cast[ptr GridLayoutChild00](self.impl)))

proc gtk_grid_layout_child_get_column_span(self: ptr GridLayoutChild00): int32 {.
    importc, libprag.}

proc getColumnSpan*(self: GridLayoutChild): int =
  int(gtk_grid_layout_child_get_column_span(cast[ptr GridLayoutChild00](self.impl)))

proc columnSpan*(self: GridLayoutChild): int =
  int(gtk_grid_layout_child_get_column_span(cast[ptr GridLayoutChild00](self.impl)))

proc gtk_grid_layout_child_get_row(self: ptr GridLayoutChild00): int32 {.
    importc, libprag.}

proc getRow*(self: GridLayoutChild): int =
  int(gtk_grid_layout_child_get_row(cast[ptr GridLayoutChild00](self.impl)))

proc row*(self: GridLayoutChild): int =
  int(gtk_grid_layout_child_get_row(cast[ptr GridLayoutChild00](self.impl)))

proc gtk_grid_layout_child_get_row_span(self: ptr GridLayoutChild00): int32 {.
    importc, libprag.}

proc getRowSpan*(self: GridLayoutChild): int =
  int(gtk_grid_layout_child_get_row_span(cast[ptr GridLayoutChild00](self.impl)))

proc rowSpan*(self: GridLayoutChild): int =
  int(gtk_grid_layout_child_get_row_span(cast[ptr GridLayoutChild00](self.impl)))

proc gtk_grid_layout_child_set_column(self: ptr GridLayoutChild00; column: int32) {.
    importc, libprag.}

proc setColumn*(self: GridLayoutChild; column: int) =
  gtk_grid_layout_child_set_column(cast[ptr GridLayoutChild00](self.impl), int32(column))

proc `column=`*(self: GridLayoutChild; column: int) =
  gtk_grid_layout_child_set_column(cast[ptr GridLayoutChild00](self.impl), int32(column))

proc gtk_grid_layout_child_set_column_span(self: ptr GridLayoutChild00; span: int32) {.
    importc, libprag.}

proc setColumnSpan*(self: GridLayoutChild; span: int) =
  gtk_grid_layout_child_set_column_span(cast[ptr GridLayoutChild00](self.impl), int32(span))

proc `columnSpan=`*(self: GridLayoutChild; span: int) =
  gtk_grid_layout_child_set_column_span(cast[ptr GridLayoutChild00](self.impl), int32(span))

proc gtk_grid_layout_child_set_row(self: ptr GridLayoutChild00; row: int32) {.
    importc, libprag.}

proc setRow*(self: GridLayoutChild; row: int) =
  gtk_grid_layout_child_set_row(cast[ptr GridLayoutChild00](self.impl), int32(row))

proc `row=`*(self: GridLayoutChild; row: int) =
  gtk_grid_layout_child_set_row(cast[ptr GridLayoutChild00](self.impl), int32(row))

proc gtk_grid_layout_child_set_row_span(self: ptr GridLayoutChild00; span: int32) {.
    importc, libprag.}

proc setRowSpan*(self: GridLayoutChild; span: int) =
  gtk_grid_layout_child_set_row_span(cast[ptr GridLayoutChild00](self.impl), int32(span))

proc `rowSpan=`*(self: GridLayoutChild; span: int) =
  gtk_grid_layout_child_set_row_span(cast[ptr GridLayoutChild00](self.impl), int32(span))

type
  IMContextSimple* = ref object of IMContext
  IMContextSimple00* = object of IMContext00

proc gtk_im_context_simple_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IMContextSimple()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_im_context_simple_new(): ptr IMContextSimple00 {.
    importc, libprag.}

proc newIMContextSimple*(): IMContextSimple =
  let gobj = gtk_im_context_simple_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIMContextSimple*(tdesc: typedesc): tdesc =
  assert(result is IMContextSimple)
  let gobj = gtk_im_context_simple_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIMContextSimple*[T](result: var T) {.deprecated.} =
  assert(result is IMContextSimple)
  let gobj = gtk_im_context_simple_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_im_context_simple_add_compose_file(self: ptr IMContextSimple00;
    composeFile: cstring) {.
    importc, libprag.}

proc addComposeFile*(self: IMContextSimple; composeFile: cstring) =
  gtk_im_context_simple_add_compose_file(cast[ptr IMContextSimple00](self.impl), composeFile)

type
  IMMulticontext* = ref object of IMContext
  IMMulticontext00* = object of IMContext00

proc gtk_im_multicontext_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IMMulticontext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_im_multicontext_new(): ptr IMMulticontext00 {.
    importc, libprag.}

proc newIMMulticontext*(): IMMulticontext =
  let gobj = gtk_im_multicontext_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIMMulticontext*(tdesc: typedesc): tdesc =
  assert(result is IMMulticontext)
  let gobj = gtk_im_multicontext_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIMMulticontext*[T](result: var T) {.deprecated.} =
  assert(result is IMMulticontext)
  let gobj = gtk_im_multicontext_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_im_multicontext_get_context_id(self: ptr IMMulticontext00): cstring {.
    importc, libprag.}

proc getContextId*(self: IMMulticontext): string =
  result = $gtk_im_multicontext_get_context_id(cast[ptr IMMulticontext00](self.impl))

proc contextId*(self: IMMulticontext): string =
  result = $gtk_im_multicontext_get_context_id(cast[ptr IMMulticontext00](self.impl))

proc gtk_im_multicontext_set_context_id(self: ptr IMMulticontext00; contextId: cstring) {.
    importc, libprag.}

proc setContextId*(self: IMMulticontext; contextId: cstring = nil) =
  gtk_im_multicontext_set_context_id(cast[ptr IMMulticontext00](self.impl), contextId)

proc `contextId=`*(self: IMMulticontext; contextId: cstring = nil) =
  gtk_im_multicontext_set_context_id(cast[ptr IMMulticontext00](self.impl), contextId)

const IM_MODULE_EXTENSION_POINT_NAME* = "gtk-im-module"

const INPUT_ERROR* = -1'i32

const INTERFACE_AGE* = 5'i32

const INVALID_LIST_POSITION* = 4294967295'u32

type
  IconLookupFlag* {.size: sizeof(cint), pure.} = enum
    forceRegular = 0
    forceSymbolic = 1
    preload = 2

  IconLookupFlags* = set[IconLookupFlag]

type
  IconPaintable* = ref object of gobject.Object
  IconPaintable00* = object of gobject.Object00

proc gtk_icon_paintable_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconPaintable()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_icon_paintable_new_for_file(file: ptr gio.GFile00; size: int32;
    scale: int32): ptr IconPaintable00 {.
    importc, libprag.}

proc newIconPaintableForFile*(file: gio.GFile; size: int; scale: int): IconPaintable =
  let gobj = gtk_icon_paintable_new_for_file(cast[ptr gio.GFile00](file.impl), int32(size), int32(scale))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconPaintableForFile*(tdesc: typedesc; file: gio.GFile; size: int; scale: int): tdesc =
  assert(result is IconPaintable)
  let gobj = gtk_icon_paintable_new_for_file(cast[ptr gio.GFile00](file.impl), int32(size), int32(scale))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconPaintableForFile*[T](result: var T; file: gio.GFile; size: int; scale: int) {.deprecated.} =
  assert(result is IconPaintable)
  let gobj = gtk_icon_paintable_new_for_file(cast[ptr gio.GFile00](file.impl), int32(size), int32(scale))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_paintable_get_file(self: ptr IconPaintable00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: IconPaintable): gio.GFile =
  let gobj = gtk_icon_paintable_get_file(cast[ptr IconPaintable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: IconPaintable): gio.GFile =
  let gobj = gtk_icon_paintable_get_file(cast[ptr IconPaintable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_paintable_get_icon_name(self: ptr IconPaintable00): cstring {.
    importc, libprag.}

proc getIconName*(self: IconPaintable): string =
  let resul0 = gtk_icon_paintable_get_icon_name(cast[ptr IconPaintable00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc iconName*(self: IconPaintable): string =
  let resul0 = gtk_icon_paintable_get_icon_name(cast[ptr IconPaintable00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_icon_paintable_is_symbolic(self: ptr IconPaintable00): gboolean {.
    importc, libprag.}

proc isSymbolic*(self: IconPaintable): bool =
  toBool(gtk_icon_paintable_is_symbolic(cast[ptr IconPaintable00](self.impl)))

type
  IconTheme* = ref object of gobject.Object
  IconTheme00* = object of gobject.Object00

proc gtk_icon_theme_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconTheme()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: IconTheme;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_icon_theme_new(): ptr IconTheme00 {.
    importc, libprag.}

proc newIconTheme*(): IconTheme =
  let gobj = gtk_icon_theme_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconTheme*(tdesc: typedesc): tdesc =
  assert(result is IconTheme)
  let gobj = gtk_icon_theme_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconTheme*[T](result: var T) {.deprecated.} =
  assert(result is IconTheme)
  let gobj = gtk_icon_theme_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_get_for_display(display: ptr gdk4.Display00): ptr IconTheme00 {.
    importc, libprag.}

proc getIconThemeForDisplay*(display: gdk4.Display): IconTheme =
  let gobj = gtk_icon_theme_get_for_display(cast[ptr gdk4.Display00](display.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_add_resource_path(self: ptr IconTheme00; path: cstring) {.
    importc, libprag.}

proc addResourcePath*(self: IconTheme; path: cstring) =
  gtk_icon_theme_add_resource_path(cast[ptr IconTheme00](self.impl), path)

proc gtk_icon_theme_add_search_path(self: ptr IconTheme00; path: cstring) {.
    importc, libprag.}

proc addSearchPath*(self: IconTheme; path: cstring) =
  gtk_icon_theme_add_search_path(cast[ptr IconTheme00](self.impl), path)

proc gtk_icon_theme_get_display(self: ptr IconTheme00): ptr gdk4.Display00 {.
    importc, libprag.}

proc getDisplay*(self: IconTheme): gdk4.Display =
  let gobj = gtk_icon_theme_get_display(cast[ptr IconTheme00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: IconTheme): gdk4.Display =
  let gobj = gtk_icon_theme_get_display(cast[ptr IconTheme00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_get_icon_names(self: ptr IconTheme00): ptr cstring {.
    importc, libprag.}

proc getIconNames*(self: IconTheme): seq[string] =
  let resul0 = gtk_icon_theme_get_icon_names(cast[ptr IconTheme00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc iconNames*(self: IconTheme): seq[string] =
  let resul0 = gtk_icon_theme_get_icon_names(cast[ptr IconTheme00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_icon_theme_get_icon_sizes(self: ptr IconTheme00; iconName: cstring): ptr int32 {.
    importc, libprag.}

proc getIconSizes*(self: IconTheme; iconName: cstring): seq[int32] =
  let resul0 = gtk_icon_theme_get_icon_sizes(cast[ptr IconTheme00](self.impl), iconName)
  result = int32ArrayZT2seq(resul0)
  cogfree(resul0)

proc gtk_icon_theme_get_resource_path(self: ptr IconTheme00): ptr cstring {.
    importc, libprag.}

proc getResourcePath*(self: IconTheme): seq[string] =
  let resul0 = gtk_icon_theme_get_resource_path(cast[ptr IconTheme00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc resourcePath*(self: IconTheme): seq[string] =
  let resul0 = gtk_icon_theme_get_resource_path(cast[ptr IconTheme00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_icon_theme_get_search_path(self: ptr IconTheme00): ptr cstring {.
    importc, libprag.}

proc getSearchPath*(self: IconTheme): seq[string] =
  let resul0 = gtk_icon_theme_get_search_path(cast[ptr IconTheme00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc searchPath*(self: IconTheme): seq[string] =
  let resul0 = gtk_icon_theme_get_search_path(cast[ptr IconTheme00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_icon_theme_get_theme_name(self: ptr IconTheme00): cstring {.
    importc, libprag.}

proc getThemeName*(self: IconTheme): string =
  let resul0 = gtk_icon_theme_get_theme_name(cast[ptr IconTheme00](self.impl))
  result = $resul0
  cogfree(resul0)

proc themeName*(self: IconTheme): string =
  let resul0 = gtk_icon_theme_get_theme_name(cast[ptr IconTheme00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_icon_theme_has_gicon(self: ptr IconTheme00; gicon: ptr gio.Icon00): gboolean {.
    importc, libprag.}

proc hasGicon*(self: IconTheme; gicon: gio.Icon): bool =
  toBool(gtk_icon_theme_has_gicon(cast[ptr IconTheme00](self.impl), cast[ptr gio.Icon00](gicon.impl)))

proc gtk_icon_theme_has_icon(self: ptr IconTheme00; iconName: cstring): gboolean {.
    importc, libprag.}

proc hasIcon*(self: IconTheme; iconName: cstring): bool =
  toBool(gtk_icon_theme_has_icon(cast[ptr IconTheme00](self.impl), iconName))

proc gtk_icon_theme_lookup_by_gicon(self: ptr IconTheme00; icon: ptr gio.Icon00;
    size: int32; scale: int32; direction: TextDirection; flags: IconLookupFlags): ptr IconPaintable00 {.
    importc, libprag.}

proc lookupByGicon*(self: IconTheme; icon: gio.Icon; size: int;
    scale: int; direction: TextDirection; flags: IconLookupFlags): IconPaintable =
  let gobj = gtk_icon_theme_lookup_by_gicon(cast[ptr IconTheme00](self.impl), cast[ptr gio.Icon00](icon.impl), int32(size), int32(scale), direction, flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_lookup_icon(self: ptr IconTheme00; iconName: cstring;
    fallbacks: ptr cstring; size: int32; scale: int32; direction: TextDirection;
    flags: IconLookupFlags): ptr IconPaintable00 {.
    importc, libprag.}

proc lookupIcon*(self: IconTheme; iconName: cstring; fallbacks: openArray[string];
    size: int; scale: int; direction: TextDirection; flags: IconLookupFlags): IconPaintable =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  let gobj = gtk_icon_theme_lookup_icon(cast[ptr IconTheme00](self.impl), iconName, seq2CstringArray(fallbacks, fs469n23), int32(size), int32(scale), direction, flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_set_resource_path(self: ptr IconTheme00; path: ptr cstring) {.
    importc, libprag.}

proc setResourcePath*(self: IconTheme; path: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_icon_theme_set_resource_path(cast[ptr IconTheme00](self.impl), seq2CstringArray(path, fs469n23))

proc `resourcePath=`*(self: IconTheme; path: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_icon_theme_set_resource_path(cast[ptr IconTheme00](self.impl), seq2CstringArray(path, fs469n23))

proc gtk_icon_theme_set_search_path(self: ptr IconTheme00; path: ptr cstring) {.
    importc, libprag.}

proc setSearchPath*(self: IconTheme; path: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_icon_theme_set_search_path(cast[ptr IconTheme00](self.impl), seq2CstringArray(path, fs469n23))

proc `searchPath=`*(self: IconTheme; path: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_icon_theme_set_search_path(cast[ptr IconTheme00](self.impl), seq2CstringArray(path, fs469n23))

proc gtk_icon_theme_set_theme_name(self: ptr IconTheme00; themeName: cstring) {.
    importc, libprag.}

proc setThemeName*(self: IconTheme; themeName: cstring = nil) =
  gtk_icon_theme_set_theme_name(cast[ptr IconTheme00](self.impl), themeName)

proc `themeName=`*(self: IconTheme; themeName: cstring = nil) =
  gtk_icon_theme_set_theme_name(cast[ptr IconTheme00](self.impl), themeName)

type
  IconThemeError* {.size: sizeof(cint), pure.} = enum
    notFound = 0
    failed = 1

type
  IconViewForeachFunc* = proc (iconView: ptr IconView00; path: ptr TreePath00; data: pointer) {.cdecl.}

proc gtk_icon_view_selected_foreach(self: ptr IconView00; `func`: IconViewForeachFunc;
    data: pointer) {.
    importc, libprag.}

proc selectedForeach*(self: IconView; `func`: IconViewForeachFunc;
    data: pointer) =
  gtk_icon_view_selected_foreach(cast[ptr IconView00](self.impl), `func`, data)

type
  KeyvalTrigger* = ref object of ShortcutTrigger
  KeyvalTrigger00* = object of ShortcutTrigger00

proc gtk_keyval_trigger_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(KeyvalTrigger()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_keyval_trigger_new(keyval: uint32; modifiers: gdk4.ModifierType): ptr KeyvalTrigger00 {.
    importc, libprag.}

proc newKeyvalTrigger*(keyval: int; modifiers: gdk4.ModifierType): KeyvalTrigger =
  let gobj = gtk_keyval_trigger_new(uint32(keyval), modifiers)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newKeyvalTrigger*(tdesc: typedesc; keyval: int; modifiers: gdk4.ModifierType): tdesc =
  assert(result is KeyvalTrigger)
  let gobj = gtk_keyval_trigger_new(uint32(keyval), modifiers)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initKeyvalTrigger*[T](result: var T; keyval: int; modifiers: gdk4.ModifierType) {.deprecated.} =
  assert(result is KeyvalTrigger)
  let gobj = gtk_keyval_trigger_new(uint32(keyval), modifiers)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_keyval_trigger_get_keyval(self: ptr KeyvalTrigger00): uint32 {.
    importc, libprag.}

proc getKeyval*(self: KeyvalTrigger): int =
  int(gtk_keyval_trigger_get_keyval(cast[ptr KeyvalTrigger00](self.impl)))

proc keyval*(self: KeyvalTrigger): int =
  int(gtk_keyval_trigger_get_keyval(cast[ptr KeyvalTrigger00](self.impl)))

proc gtk_keyval_trigger_get_modifiers(self: ptr KeyvalTrigger00): gdk4.ModifierType {.
    importc, libprag.}

proc getModifiers*(self: KeyvalTrigger): gdk4.ModifierType =
  gtk_keyval_trigger_get_modifiers(cast[ptr KeyvalTrigger00](self.impl))

proc modifiers*(self: KeyvalTrigger): gdk4.ModifierType =
  gtk_keyval_trigger_get_modifiers(cast[ptr KeyvalTrigger00](self.impl))

const LEVEL_BAR_OFFSET_FULL* = "full"

const LEVEL_BAR_OFFSET_HIGH* = "high"

const LEVEL_BAR_OFFSET_LOW* = "low"

type
  ListBoxCreateWidgetFunc* = proc (item: ptr gobject.Object00; userData: pointer): ptr Widget00 {.cdecl.}

proc gtk_list_box_bind_model(self: ptr ListBox00; model: ptr gio.ListModel00;
    createWidgetFunc: ListBoxCreateWidgetFunc; userData: pointer; userDataFreeFunc: DestroyNotify) {.
    importc, libprag.}

proc bindModel*(self: ListBox; model: gio.ListModel = nil; createWidgetFunc: ListBoxCreateWidgetFunc;
    userData: pointer; userDataFreeFunc: DestroyNotify) =
  gtk_list_box_bind_model(cast[ptr ListBox00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl), createWidgetFunc, userData, userDataFreeFunc)

type
  ListBoxFilterFunc* = proc (row: ptr ListBoxRow00; userData: pointer): gboolean {.cdecl.}

proc gtk_list_box_set_filter_func(self: ptr ListBox00; filterFunc: ListBoxFilterFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setFilterFunc*(self: ListBox; filterFunc: ListBoxFilterFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_list_box_set_filter_func(cast[ptr ListBox00](self.impl), filterFunc, userData, destroy)

type
  ListBoxForeachFunc* = proc (box: ptr ListBox00; row: ptr ListBoxRow00; userData: pointer) {.cdecl.}

proc gtk_list_box_selected_foreach(self: ptr ListBox00; `func`: ListBoxForeachFunc;
    data: pointer) {.
    importc, libprag.}

proc selectedForeach*(self: ListBox; `func`: ListBoxForeachFunc;
    data: pointer) =
  gtk_list_box_selected_foreach(cast[ptr ListBox00](self.impl), `func`, data)

type
  ListBoxSortFunc* = proc (row1: ptr ListBoxRow00; row2: ptr ListBoxRow00; userData: pointer): int32 {.cdecl.}

proc gtk_list_box_set_sort_func(self: ptr ListBox00; sortFunc: ListBoxSortFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setSortFunc*(self: ListBox; sortFunc: ListBoxSortFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_list_box_set_sort_func(cast[ptr ListBox00](self.impl), sortFunc, userData, destroy)

type
  ListBoxUpdateHeaderFunc* = proc (row: ptr ListBoxRow00; before: ptr ListBoxRow00; userData: pointer) {.cdecl.}

proc gtk_list_box_set_header_func(self: ptr ListBox00; updateHeader: ListBoxUpdateHeaderFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setHeaderFunc*(self: ListBox; updateHeader: ListBoxUpdateHeaderFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_list_box_set_header_func(cast[ptr ListBox00](self.impl), updateHeader, userData, destroy)

type
  ListHeader* = ref object of gobject.Object
  ListHeader00* = object of gobject.Object00

proc gtk_list_header_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListHeader()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_list_header_get_child(self: ptr ListHeader00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: ListHeader): Widget =
  let gobj = gtk_list_header_get_child(cast[ptr ListHeader00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: ListHeader): Widget =
  let gobj = gtk_list_header_get_child(cast[ptr ListHeader00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_header_get_end(self: ptr ListHeader00): uint32 {.
    importc, libprag.}

proc getEnd*(self: ListHeader): int =
  int(gtk_list_header_get_end(cast[ptr ListHeader00](self.impl)))

proc gtk_list_header_get_item(self: ptr ListHeader00): ptr gobject.Object00 {.
    importc, libprag.}

proc getItem*(self: ListHeader): gobject.Object =
  let gobj = gtk_list_header_get_item(cast[ptr ListHeader00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc item*(self: ListHeader): gobject.Object =
  let gobj = gtk_list_header_get_item(cast[ptr ListHeader00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_header_get_n_items(self: ptr ListHeader00): uint32 {.
    importc, libprag.}

proc getNItems*(self: ListHeader): int =
  int(gtk_list_header_get_n_items(cast[ptr ListHeader00](self.impl)))

proc nItems*(self: ListHeader): int =
  int(gtk_list_header_get_n_items(cast[ptr ListHeader00](self.impl)))

proc gtk_list_header_get_start(self: ptr ListHeader00): uint32 {.
    importc, libprag.}

proc getStart*(self: ListHeader): int =
  int(gtk_list_header_get_start(cast[ptr ListHeader00](self.impl)))

proc start*(self: ListHeader): int =
  int(gtk_list_header_get_start(cast[ptr ListHeader00](self.impl)))

proc gtk_list_header_set_child(self: ptr ListHeader00; child: ptr Widget00) {.
    importc, libprag.}

proc setChild*(self: ListHeader; child: Widget = nil) =
  gtk_list_header_set_child(cast[ptr ListHeader00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `child=`*(self: ListHeader; child: Widget = nil) =
  gtk_list_header_set_child(cast[ptr ListHeader00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

const MAJOR_VERSION* = 4'i32

const MAX_COMPOSE_LEN* = 7'i32

const MEDIA_FILE_EXTENSION_POINT_NAME* = "gtk-media-file"

const MICRO_VERSION* = 5'i32

const MINOR_VERSION* = 14'i32

type
  MapListModel* = ref object of gobject.Object
  MapListModel00* = object of gobject.Object00

proc gtk_map_list_model_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MapListModel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_map_list_model_get_model(self: ptr MapListModel00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: MapListModel): gio.ListModel =
  let gobj = gtk_map_list_model_get_model(cast[ptr MapListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: MapListModel): gio.ListModel =
  let gobj = gtk_map_list_model_get_model(cast[ptr MapListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_map_list_model_has_map(self: ptr MapListModel00): gboolean {.
    importc, libprag.}

proc hasMap*(self: MapListModel): bool =
  toBool(gtk_map_list_model_has_map(cast[ptr MapListModel00](self.impl)))

proc gtk_map_list_model_set_model(self: ptr MapListModel00; model: ptr gio.ListModel00) {.
    importc, libprag.}

proc setModel*(self: MapListModel; model: gio.ListModel = nil) =
  gtk_map_list_model_set_model(cast[ptr MapListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc `model=`*(self: MapListModel; model: gio.ListModel = nil) =
  gtk_map_list_model_set_model(cast[ptr MapListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

type
  MapListModelMapFunc* = proc (item: ptr gobject.Object00; userData: pointer): ptr gobject.Object00 {.cdecl.}

proc gtk_map_list_model_new(model: ptr gio.ListModel00; mapFunc: MapListModelMapFunc;
    userData: pointer; userDestroy: DestroyNotify): ptr MapListModel00 {.
    importc, libprag.}

proc newMapListModel*(model: gio.ListModel = nil; mapFunc: MapListModelMapFunc;
    userData: pointer; userDestroy: DestroyNotify): MapListModel =
  let gobj = gtk_map_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), mapFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMapListModel*(tdesc: typedesc; model: gio.ListModel = nil; mapFunc: MapListModelMapFunc;
    userData: pointer; userDestroy: DestroyNotify): tdesc =
  assert(result is MapListModel)
  let gobj = gtk_map_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), mapFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMapListModel*[T](result: var T; model: gio.ListModel = nil; mapFunc: MapListModelMapFunc;
    userData: pointer; userDestroy: DestroyNotify) {.deprecated.} =
  assert(result is MapListModel)
  let gobj = gtk_map_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), mapFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_map_list_model_set_map_func(self: ptr MapListModel00; mapFunc: MapListModelMapFunc;
    userData: pointer; userDestroy: DestroyNotify) {.
    importc, libprag.}

proc setMapFunc*(self: MapListModel; mapFunc: MapListModelMapFunc;
    userData: pointer; userDestroy: DestroyNotify) =
  gtk_map_list_model_set_map_func(cast[ptr MapListModel00](self.impl), mapFunc, userData, userDestroy)

type
  MediaFile* = ref object of MediaStream
  MediaFile00* = object of MediaStream00

proc gtk_media_file_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MediaFile()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_media_file_new(): ptr MediaFile00 {.
    importc, libprag.}

proc newMediaFile*(): MediaFile =
  let gobj = gtk_media_file_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMediaFile*(tdesc: typedesc): tdesc =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMediaFile*[T](result: var T) {.deprecated.} =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_media_file_new_for_file(file: ptr gio.GFile00): ptr MediaFile00 {.
    importc, libprag.}

proc newMediaFileForFile*(file: gio.GFile): MediaFile =
  let gobj = gtk_media_file_new_for_file(cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMediaFileForFile*(tdesc: typedesc; file: gio.GFile): tdesc =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new_for_file(cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMediaFileForFile*[T](result: var T; file: gio.GFile) {.deprecated.} =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new_for_file(cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_media_file_new_for_filename(filename: cstring): ptr MediaFile00 {.
    importc, libprag.}

proc newMediaFileForFilename*(filename: cstring): MediaFile =
  let gobj = gtk_media_file_new_for_filename(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMediaFileForFilename*(tdesc: typedesc; filename: cstring): tdesc =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new_for_filename(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMediaFileForFilename*[T](result: var T; filename: cstring) {.deprecated.} =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new_for_filename(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_media_file_new_for_input_stream(stream: ptr gio.InputStream00): ptr MediaFile00 {.
    importc, libprag.}

proc newMediaFileForInputStream*(stream: gio.InputStream): MediaFile =
  let gobj = gtk_media_file_new_for_input_stream(cast[ptr gio.InputStream00](stream.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMediaFileForInputStream*(tdesc: typedesc; stream: gio.InputStream): tdesc =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new_for_input_stream(cast[ptr gio.InputStream00](stream.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMediaFileForInputStream*[T](result: var T; stream: gio.InputStream) {.deprecated.} =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new_for_input_stream(cast[ptr gio.InputStream00](stream.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_media_file_new_for_resource(resourcePath: cstring): ptr MediaFile00 {.
    importc, libprag.}

proc newMediaFileForResource*(resourcePath: cstring): MediaFile =
  let gobj = gtk_media_file_new_for_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMediaFileForResource*(tdesc: typedesc; resourcePath: cstring): tdesc =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new_for_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMediaFileForResource*[T](result: var T; resourcePath: cstring) {.deprecated.} =
  assert(result is MediaFile)
  let gobj = gtk_media_file_new_for_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_media_file_clear(self: ptr MediaFile00) {.
    importc, libprag.}

proc clear*(self: MediaFile) =
  gtk_media_file_clear(cast[ptr MediaFile00](self.impl))

proc gtk_media_file_get_file(self: ptr MediaFile00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: MediaFile): gio.GFile =
  let gobj = gtk_media_file_get_file(cast[ptr MediaFile00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: MediaFile): gio.GFile =
  let gobj = gtk_media_file_get_file(cast[ptr MediaFile00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_media_file_get_input_stream(self: ptr MediaFile00): ptr gio.InputStream00 {.
    importc, libprag.}

proc getInputStream*(self: MediaFile): gio.InputStream =
  let gobj = gtk_media_file_get_input_stream(cast[ptr MediaFile00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc inputStream*(self: MediaFile): gio.InputStream =
  let gobj = gtk_media_file_get_input_stream(cast[ptr MediaFile00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_media_file_set_file(self: ptr MediaFile00; file: ptr gio.GFile00) {.
    importc, libprag.}

proc setFile*(self: MediaFile; file: gio.GFile = nil) =
  gtk_media_file_set_file(cast[ptr MediaFile00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc `file=`*(self: MediaFile; file: gio.GFile = nil) =
  gtk_media_file_set_file(cast[ptr MediaFile00](self.impl), if file.isNil: nil else: cast[ptr gio.GFile00](file.impl))

proc gtk_media_file_set_filename(self: ptr MediaFile00; filename: cstring) {.
    importc, libprag.}

proc setFilename*(self: MediaFile; filename: cstring = nil) =
  gtk_media_file_set_filename(cast[ptr MediaFile00](self.impl), filename)

proc `filename=`*(self: MediaFile; filename: cstring = nil) =
  gtk_media_file_set_filename(cast[ptr MediaFile00](self.impl), filename)

proc gtk_media_file_set_input_stream(self: ptr MediaFile00; stream: ptr gio.InputStream00) {.
    importc, libprag.}

proc setInputStream*(self: MediaFile; stream: gio.InputStream = nil) =
  gtk_media_file_set_input_stream(cast[ptr MediaFile00](self.impl), if stream.isNil: nil else: cast[ptr gio.InputStream00](stream.impl))

proc `inputStream=`*(self: MediaFile; stream: gio.InputStream = nil) =
  gtk_media_file_set_input_stream(cast[ptr MediaFile00](self.impl), if stream.isNil: nil else: cast[ptr gio.InputStream00](stream.impl))

proc gtk_media_file_set_resource(self: ptr MediaFile00; resourcePath: cstring) {.
    importc, libprag.}

proc setResource*(self: MediaFile; resourcePath: cstring = nil) =
  gtk_media_file_set_resource(cast[ptr MediaFile00](self.impl), resourcePath)

proc `resource=`*(self: MediaFile; resourcePath: cstring = nil) =
  gtk_media_file_set_resource(cast[ptr MediaFile00](self.impl), resourcePath)

type
  MenuButtonCreatePopupFunc* = proc (menuButton: ptr MenuButton00; userData: pointer) {.cdecl.}

proc gtk_menu_button_set_create_popup_func(self: ptr MenuButton00; `func`: MenuButtonCreatePopupFunc;
    userData: pointer; destroyNotify: DestroyNotify) {.
    importc, libprag.}

proc setCreatePopupFunc*(self: MenuButton; `func`: MenuButtonCreatePopupFunc;
    userData: pointer; destroyNotify: DestroyNotify) =
  gtk_menu_button_set_create_popup_func(cast[ptr MenuButton00](self.impl), `func`, userData, destroyNotify)

type
  MnemonicAction* = ref object of ShortcutAction
  MnemonicAction00* = object of ShortcutAction00

proc gtk_mnemonic_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MnemonicAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_mnemonic_action_get(): ptr MnemonicAction00 {.
    importc, libprag.}

proc getMnemonicAction*(): MnemonicAction =
  let gobj = gtk_mnemonic_action_get()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  MnemonicTrigger* = ref object of ShortcutTrigger
  MnemonicTrigger00* = object of ShortcutTrigger00

proc gtk_mnemonic_trigger_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MnemonicTrigger()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_mnemonic_trigger_new(keyval: uint32): ptr MnemonicTrigger00 {.
    importc, libprag.}

proc newMnemonicTrigger*(keyval: int): MnemonicTrigger =
  let gobj = gtk_mnemonic_trigger_new(uint32(keyval))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMnemonicTrigger*(tdesc: typedesc; keyval: int): tdesc =
  assert(result is MnemonicTrigger)
  let gobj = gtk_mnemonic_trigger_new(uint32(keyval))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMnemonicTrigger*[T](result: var T; keyval: int) {.deprecated.} =
  assert(result is MnemonicTrigger)
  let gobj = gtk_mnemonic_trigger_new(uint32(keyval))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mnemonic_trigger_get_keyval(self: ptr MnemonicTrigger00): uint32 {.
    importc, libprag.}

proc getKeyval*(self: MnemonicTrigger): int =
  int(gtk_mnemonic_trigger_get_keyval(cast[ptr MnemonicTrigger00](self.impl)))

proc keyval*(self: MnemonicTrigger): int =
  int(gtk_mnemonic_trigger_get_keyval(cast[ptr MnemonicTrigger00](self.impl)))

type
  MountOperation* = ref object of gio.MountOperation
  MountOperation00* = object of gio.MountOperation00

proc gtk_mount_operation_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MountOperation()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_mount_operation_new(parent: ptr Window00): ptr MountOperation00 {.
    importc, libprag.}

proc newMountOperation*(parent: Window = nil): MountOperation =
  let gobj = gtk_mount_operation_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMountOperation*(tdesc: typedesc; parent: Window = nil): tdesc =
  assert(result is MountOperation)
  let gobj = gtk_mount_operation_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMountOperation*[T](result: var T; parent: Window = nil) {.deprecated.} =
  assert(result is MountOperation)
  let gobj = gtk_mount_operation_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mount_operation_get_display(self: ptr MountOperation00): ptr gdk4.Display00 {.
    importc, libprag.}

proc getDisplay*(self: MountOperation): gdk4.Display =
  let gobj = gtk_mount_operation_get_display(cast[ptr MountOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: MountOperation): gdk4.Display =
  let gobj = gtk_mount_operation_get_display(cast[ptr MountOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mount_operation_get_parent(self: ptr MountOperation00): ptr Window00 {.
    importc, libprag.}

proc getParent*(self: MountOperation): Window =
  let gobj = gtk_mount_operation_get_parent(cast[ptr MountOperation00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parent*(self: MountOperation): Window =
  let gobj = gtk_mount_operation_get_parent(cast[ptr MountOperation00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mount_operation_is_showing(self: ptr MountOperation00): gboolean {.
    importc, libprag.}

proc isShowing*(self: MountOperation): bool =
  toBool(gtk_mount_operation_is_showing(cast[ptr MountOperation00](self.impl)))

proc gtk_mount_operation_set_display(self: ptr MountOperation00; display: ptr gdk4.Display00) {.
    importc, libprag.}

proc setDisplay*(self: MountOperation; display: gdk4.Display) =
  gtk_mount_operation_set_display(cast[ptr MountOperation00](self.impl), cast[ptr gdk4.Display00](display.impl))

proc `display=`*(self: MountOperation; display: gdk4.Display) =
  gtk_mount_operation_set_display(cast[ptr MountOperation00](self.impl), cast[ptr gdk4.Display00](display.impl))

proc gtk_mount_operation_set_parent(self: ptr MountOperation00; parent: ptr Window00) {.
    importc, libprag.}

proc setParent*(self: MountOperation; parent: Window = nil) =
  gtk_mount_operation_set_parent(cast[ptr MountOperation00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc `parent=`*(self: MountOperation; parent: Window = nil) =
  gtk_mount_operation_set_parent(cast[ptr MountOperation00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

type
  NamedAction* = ref object of ShortcutAction
  NamedAction00* = object of ShortcutAction00

proc gtk_named_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NamedAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_named_action_new(name: cstring): ptr NamedAction00 {.
    importc, libprag.}

proc newNamedAction*(name: cstring): NamedAction =
  let gobj = gtk_named_action_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newNamedAction*(tdesc: typedesc; name: cstring): tdesc =
  assert(result is NamedAction)
  let gobj = gtk_named_action_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initNamedAction*[T](result: var T; name: cstring) {.deprecated.} =
  assert(result is NamedAction)
  let gobj = gtk_named_action_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_named_action_get_action_name(self: ptr NamedAction00): cstring {.
    importc, libprag.}

proc getActionName*(self: NamedAction): string =
  result = $gtk_named_action_get_action_name(cast[ptr NamedAction00](self.impl))

proc actionName*(self: NamedAction): string =
  result = $gtk_named_action_get_action_name(cast[ptr NamedAction00](self.impl))

type
  NeverTrigger* = ref object of ShortcutTrigger
  NeverTrigger00* = object of ShortcutTrigger00

proc gtk_never_trigger_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NeverTrigger()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_never_trigger_get(): ptr NeverTrigger00 {.
    importc, libprag.}

proc getNeverTrigger*(): NeverTrigger =
  let gobj = gtk_never_trigger_get()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  NothingAction* = ref object of ShortcutAction
  NothingAction00* = object of ShortcutAction00

proc gtk_nothing_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NothingAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_nothing_action_get(): ptr NothingAction00 {.
    importc, libprag.}

proc getNothingAction*(): NothingAction =
  let gobj = gtk_nothing_action_get()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  NumericSorter* = ref object of Sorter
  NumericSorter00* = object of Sorter00

proc gtk_numeric_sorter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NumericSorter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_numeric_sorter_new(expression: ptr Expression00): ptr NumericSorter00 {.
    importc, libprag.}

proc newNumericSorter*(expression: Expression = nil): NumericSorter =
  let gobj = gtk_numeric_sorter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newNumericSorter*(tdesc: typedesc; expression: Expression = nil): tdesc =
  assert(result is NumericSorter)
  let gobj = gtk_numeric_sorter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initNumericSorter*[T](result: var T; expression: Expression = nil) {.deprecated.} =
  assert(result is NumericSorter)
  let gobj = gtk_numeric_sorter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_numeric_sorter_get_expression(self: ptr NumericSorter00): ptr Expression00 {.
    importc, libprag.}

proc getExpression*(self: NumericSorter): Expression =
  let impl0 = gtk_numeric_sorter_get_expression(cast[ptr NumericSorter00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc expression*(self: NumericSorter): Expression =
  let impl0 = gtk_numeric_sorter_get_expression(cast[ptr NumericSorter00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc gtk_numeric_sorter_get_sort_order(self: ptr NumericSorter00): SortType {.
    importc, libprag.}

proc getSortOrder*(self: NumericSorter): SortType =
  gtk_numeric_sorter_get_sort_order(cast[ptr NumericSorter00](self.impl))

proc sortOrder*(self: NumericSorter): SortType =
  gtk_numeric_sorter_get_sort_order(cast[ptr NumericSorter00](self.impl))

proc gtk_numeric_sorter_set_expression(self: ptr NumericSorter00; expression: ptr Expression00) {.
    importc, libprag.}

proc setExpression*(self: NumericSorter; expression: Expression = nil) =
  gtk_numeric_sorter_set_expression(cast[ptr NumericSorter00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

proc `expression=`*(self: NumericSorter; expression: Expression = nil) =
  gtk_numeric_sorter_set_expression(cast[ptr NumericSorter00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

proc gtk_numeric_sorter_set_sort_order(self: ptr NumericSorter00; sortOrder: SortType) {.
    importc, libprag.}

proc setSortOrder*(self: NumericSorter; sortOrder: SortType) =
  gtk_numeric_sorter_set_sort_order(cast[ptr NumericSorter00](self.impl), sortOrder)

proc `sortOrder=`*(self: NumericSorter; sortOrder: SortType) =
  gtk_numeric_sorter_set_sort_order(cast[ptr NumericSorter00](self.impl), sortOrder)

type
  ObjectExpression* = ref object of Expression
  ObjectExpression00* = object of Expression00

proc gtk_object_expression_get_type*(): GType {.importc, libprag.}

proc gtk_expression_unref*(self: ptr ObjectExpression00) {.importc, libprag.}

proc generic_gtk_expression_unref*(self: ObjectExpression) =
  if not self.ignoreFinalizer:
    gtk_expression_unref(self.impl)

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ObjectExpression()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      gtk_expression_unref(self.impl)
      self.impl = nil

proc gtk_object_expression_new(obj: ptr gobject.Object00): ptr ObjectExpression00 {.
    importc, libprag.}

proc newObjectExpression*(obj: gobject.Object): ObjectExpression =
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_object_expression_new(cast[ptr gobject.Object00](obj.impl))

proc newObjectExpression*(tdesc: typedesc; obj: gobject.Object): tdesc =
  assert(result is ObjectExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_object_expression_new(cast[ptr gobject.Object00](obj.impl))

proc initObjectExpression*[T](result: var T; obj: gobject.Object) {.deprecated.} =
  assert(result is ObjectExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_object_expression_new(cast[ptr gobject.Object00](obj.impl))

proc gtk_object_expression_get_object(self: ptr ObjectExpression00): ptr gobject.Object00 {.
    importc, libprag.}

proc getObject*(self: ObjectExpression): gobject.Object =
  let gobj = gtk_object_expression_get_object(cast[ptr ObjectExpression00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Orientable00* = object of gobject.Object00
  Orientable* = ref object of gobject.Object

proc gtk_orientable_get_orientation(self: ptr Orientable00): Orientation {.
    importc, libprag.}

proc getOrientation*(self: Orientable | FlowBox | CellRendererProgress | Scale | ShortcutsGroup | Range | ListBase | ScaleButton | StackSwitcher | ProgressBar | CellView | GridView | BoxLayout | VolumeButton | Grid | ShortcutsSection | SpinButton | CellAreaBox | Paned | LevelBar | Box | Scrollbar | Separator | CenterBox | ListView): Orientation =
  gtk_orientable_get_orientation(cast[ptr Orientable00](self.impl))

proc orientation*(self: Orientable | FlowBox | CellRendererProgress | Scale | ShortcutsGroup | Range | ListBase | ScaleButton | StackSwitcher | ProgressBar | CellView | GridView | BoxLayout | VolumeButton | Grid | ShortcutsSection | SpinButton | CellAreaBox | Paned | LevelBar | Box | Scrollbar | Separator | CenterBox | ListView): Orientation =
  gtk_orientable_get_orientation(cast[ptr Orientable00](self.impl))

proc gtk_orientable_set_orientation(self: ptr Orientable00; orientation: Orientation) {.
    importc, libprag.}

proc setOrientation*(self: Orientable | FlowBox | CellRendererProgress | Scale | ShortcutsGroup | Range | ListBase | ScaleButton | StackSwitcher | ProgressBar | CellView | GridView | BoxLayout | VolumeButton | Grid | ShortcutsSection | SpinButton | CellAreaBox | Paned | LevelBar | Box | Scrollbar | Separator | CenterBox | ListView;
    orientation: Orientation) =
  gtk_orientable_set_orientation(cast[ptr Orientable00](self.impl), orientation)

proc `orientation=`*(self: Orientable | FlowBox | CellRendererProgress | Scale | ShortcutsGroup | Range | ListBase | ScaleButton | StackSwitcher | ProgressBar | CellView | GridView | BoxLayout | VolumeButton | Grid | ShortcutsSection | SpinButton | CellAreaBox | Paned | LevelBar | Box | Scrollbar | Separator | CenterBox | ListView;
    orientation: Orientation) =
  gtk_orientable_set_orientation(cast[ptr Orientable00](self.impl), orientation)

type
  OverlayLayout* = ref object of LayoutManager
  OverlayLayout00* = object of LayoutManager00

proc gtk_overlay_layout_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(OverlayLayout()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_overlay_layout_new(): ptr OverlayLayout00 {.
    importc, libprag.}

proc newOverlayLayout*(): OverlayLayout =
  let gobj = gtk_overlay_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newOverlayLayout*(tdesc: typedesc): tdesc =
  assert(result is OverlayLayout)
  let gobj = gtk_overlay_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initOverlayLayout*[T](result: var T) {.deprecated.} =
  assert(result is OverlayLayout)
  let gobj = gtk_overlay_layout_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  OverlayLayoutChild* = ref object of LayoutChild
  OverlayLayoutChild00* = object of LayoutChild00

proc gtk_overlay_layout_child_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(OverlayLayoutChild()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_overlay_layout_child_get_clip_overlay(self: ptr OverlayLayoutChild00): gboolean {.
    importc, libprag.}

proc getClipOverlay*(self: OverlayLayoutChild): bool =
  toBool(gtk_overlay_layout_child_get_clip_overlay(cast[ptr OverlayLayoutChild00](self.impl)))

proc clipOverlay*(self: OverlayLayoutChild): bool =
  toBool(gtk_overlay_layout_child_get_clip_overlay(cast[ptr OverlayLayoutChild00](self.impl)))

proc gtk_overlay_layout_child_get_measure(self: ptr OverlayLayoutChild00): gboolean {.
    importc, libprag.}

proc getMeasure*(self: OverlayLayoutChild): bool =
  toBool(gtk_overlay_layout_child_get_measure(cast[ptr OverlayLayoutChild00](self.impl)))

proc measure*(self: OverlayLayoutChild): bool =
  toBool(gtk_overlay_layout_child_get_measure(cast[ptr OverlayLayoutChild00](self.impl)))

proc gtk_overlay_layout_child_set_clip_overlay(self: ptr OverlayLayoutChild00;
    clipOverlay: gboolean) {.
    importc, libprag.}

proc setClipOverlay*(self: OverlayLayoutChild;
    clipOverlay: bool = true) =
  gtk_overlay_layout_child_set_clip_overlay(cast[ptr OverlayLayoutChild00](self.impl), gboolean(clipOverlay))

proc `clipOverlay=`*(self: OverlayLayoutChild;
    clipOverlay: bool) =
  gtk_overlay_layout_child_set_clip_overlay(cast[ptr OverlayLayoutChild00](self.impl), gboolean(clipOverlay))

proc gtk_overlay_layout_child_set_measure(self: ptr OverlayLayoutChild00;
    measure: gboolean) {.
    importc, libprag.}

proc setMeasure*(self: OverlayLayoutChild; measure: bool = true) =
  gtk_overlay_layout_child_set_measure(cast[ptr OverlayLayoutChild00](self.impl), gboolean(measure))

proc `measure=`*(self: OverlayLayoutChild; measure: bool) =
  gtk_overlay_layout_child_set_measure(cast[ptr OverlayLayoutChild00](self.impl), gboolean(measure))

const PAPER_NAME_A3* = "iso_a3"

const PAPER_NAME_A4* = "iso_a4"

const PAPER_NAME_A5* = "iso_a5"

const PAPER_NAME_B5* = "iso_b5"

const PAPER_NAME_EXECUTIVE* = "na_executive"

const PAPER_NAME_LEGAL* = "na_legal"

const PAPER_NAME_LETTER* = "na_letter"

const PRINT_SETTINGS_COLLATE* = "collate"

const PRINT_SETTINGS_DEFAULT_SOURCE* = "default-source"

const PRINT_SETTINGS_DITHER* = "dither"

const PRINT_SETTINGS_DUPLEX* = "duplex"

const PRINT_SETTINGS_FINISHINGS* = "finishings"

const PRINT_SETTINGS_MEDIA_TYPE* = "media-type"

const PRINT_SETTINGS_NUMBER_UP* = "number-up"

const PRINT_SETTINGS_NUMBER_UP_LAYOUT* = "number-up-layout"

const PRINT_SETTINGS_N_COPIES* = "n-copies"

const PRINT_SETTINGS_ORIENTATION* = "orientation"

const PRINT_SETTINGS_OUTPUT_BASENAME* = "output-basename"

const PRINT_SETTINGS_OUTPUT_BIN* = "output-bin"

const PRINT_SETTINGS_OUTPUT_DIR* = "output-dir"

const PRINT_SETTINGS_OUTPUT_FILE_FORMAT* = "output-file-format"

const PRINT_SETTINGS_OUTPUT_URI* = "output-uri"

const PRINT_SETTINGS_PAGE_RANGES* = "page-ranges"

const PRINT_SETTINGS_PAGE_SET* = "page-set"

const PRINT_SETTINGS_PAPER_FORMAT* = "paper-format"

const PRINT_SETTINGS_PAPER_HEIGHT* = "paper-height"

const PRINT_SETTINGS_PAPER_WIDTH* = "paper-width"

const PRINT_SETTINGS_PRINTER* = "printer"

const PRINT_SETTINGS_PRINTER_LPI* = "printer-lpi"

const PRINT_SETTINGS_PRINT_PAGES* = "print-pages"

const PRINT_SETTINGS_QUALITY* = "quality"

const PRINT_SETTINGS_RESOLUTION* = "resolution"

const PRINT_SETTINGS_RESOLUTION_X* = "resolution-x"

const PRINT_SETTINGS_RESOLUTION_Y* = "resolution-y"

const PRINT_SETTINGS_REVERSE* = "reverse"

const PRINT_SETTINGS_SCALE* = "scale"

const PRINT_SETTINGS_USE_COLOR* = "use-color"

const PRINT_SETTINGS_WIN32_DRIVER_EXTRA* = "win32-driver-extra"

const PRINT_SETTINGS_WIN32_DRIVER_VERSION* = "win32-driver-version"

const PRIORITY_RESIZE* = 110'i32

type
  PadActionType* {.size: sizeof(cint), pure.} = enum
    button = 0
    ring = 1
    strip = 2

type
  PadActionEntry* {.pure, byRef.} = object
    `type`*: PadActionType
    index*: int32
    mode*: int32
    label*: cstring
    actionName*: cstring

type
  PadController* = ref object of EventController
  PadController00* = object of EventController00

proc gtk_pad_controller_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PadController()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_pad_controller_new(group: ptr gio.ActionGroup00; pad: ptr gdk4.Device00): ptr PadController00 {.
    importc, libprag.}

proc newPadController*(group: gio.ActionGroup | gio.SimpleActionGroup;
    pad: gdk4.Device = nil): PadController =
  let gobj = gtk_pad_controller_new(cast[ptr gio.ActionGroup00](group.impl), if pad.isNil: nil else: cast[ptr gdk4.Device00](pad.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPadController*(tdesc: typedesc; group: gio.ActionGroup | gio.SimpleActionGroup;
    pad: gdk4.Device = nil): tdesc =
  assert(result is PadController)
  let gobj = gtk_pad_controller_new(cast[ptr gio.ActionGroup00](group.impl), if pad.isNil: nil else: cast[ptr gdk4.Device00](pad.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPadController*[T](result: var T; group: gio.ActionGroup | gio.SimpleActionGroup;
    pad: gdk4.Device = nil) {.deprecated.} =
  assert(result is PadController)
  let gobj = gtk_pad_controller_new(cast[ptr gio.ActionGroup00](group.impl), if pad.isNil: nil else: cast[ptr gdk4.Device00](pad.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_pad_controller_set_action(self: ptr PadController00; `type`: PadActionType;
    index: int32; mode: int32; label: cstring; actionName: cstring) {.
    importc, libprag.}

proc setAction*(self: PadController; `type`: PadActionType;
    index: int; mode: int; label: cstring; actionName: cstring) =
  gtk_pad_controller_set_action(cast[ptr PadController00](self.impl), `type`, int32(index), int32(mode), label, actionName)

proc gtk_pad_controller_set_action_entries(self: ptr PadController00; entries: ptr PadActionEntry;
    nEntries: int32) {.
    importc, libprag.}

proc setActionEntries*(self: PadController; entries: ptr PadActionEntry;
    nEntries: int) =
  gtk_pad_controller_set_action_entries(cast[ptr PadController00](self.impl), entries, int32(nEntries))

type
  PageSetupDoneFunc* = proc (pageSetup: ptr PageSetup00; data: pointer) {.cdecl.}

type
  ParamSpecExpression* = ref object of gobject.ParamSpec
  ParamSpecExpression00* = object of gobject.ParamSpec00

proc gtk_param_expression_get_type*(): GType {.importc, libprag.}

proc g_param_spec_unref*(self: ptr ParamSpecExpression00) {.importc, libprag.}

proc generic_g_param_spec_unref*(self: ParamSpecExpression) =
  if not self.ignoreFinalizer:
    g_param_spec_unref(self.impl)

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ParamSpecExpression()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      g_param_spec_unref(self.impl)
      self.impl = nil

type
  PasswordEntryBuffer* = ref object of EntryBuffer
  PasswordEntryBuffer00* = object of EntryBuffer00

proc gtk_password_entry_buffer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PasswordEntryBuffer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_password_entry_buffer_new(): ptr PasswordEntryBuffer00 {.
    importc, libprag.}

proc newPasswordEntryBuffer*(): PasswordEntryBuffer =
  let gobj = gtk_password_entry_buffer_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPasswordEntryBuffer*(tdesc: typedesc): tdesc =
  assert(result is PasswordEntryBuffer)
  let gobj = gtk_password_entry_buffer_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPasswordEntryBuffer*[T](result: var T) {.deprecated.} =
  assert(result is PasswordEntryBuffer)
  let gobj = gtk_password_entry_buffer_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  PrintContext* = ref object of gobject.Object
  PrintContext00* = object of gobject.Object00

proc gtk_print_context_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintContext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_print_context_create_pango_context(self: ptr PrintContext00): ptr pango.Context00 {.
    importc, libprag.}

proc createPangoContext*(self: PrintContext): pango.Context =
  let gobj = gtk_print_context_create_pango_context(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_create_pango_layout(self: ptr PrintContext00): ptr pango.Layout00 {.
    importc, libprag.}

proc createPangoLayout*(self: PrintContext): pango.Layout =
  let gobj = gtk_print_context_create_pango_layout(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_get_cairo_context(self: ptr PrintContext00): ptr cairo.Context00 {.
    importc, libprag.}

proc getCairoContext*(self: PrintContext): cairo.Context =
  fnew(result, gBoxedFreeCairoContext)
  result.impl = gtk_print_context_get_cairo_context(cast[ptr PrintContext00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_context_get_type(), result.impl))

proc cairoContext*(self: PrintContext): cairo.Context =
  fnew(result, gBoxedFreeCairoContext)
  result.impl = gtk_print_context_get_cairo_context(cast[ptr PrintContext00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_context_get_type(), result.impl))

proc gtk_print_context_get_dpi_x(self: ptr PrintContext00): cdouble {.
    importc, libprag.}

proc getDpiX*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_x(cast[ptr PrintContext00](self.impl))

proc dpiX*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_x(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_dpi_y(self: ptr PrintContext00): cdouble {.
    importc, libprag.}

proc getDpiY*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_y(cast[ptr PrintContext00](self.impl))

proc dpiY*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_y(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_hard_margins(self: ptr PrintContext00; top: var cdouble;
    bottom: var cdouble; left: var cdouble; right: var cdouble): gboolean {.
    importc, libprag.}

proc getHardMargins*(self: PrintContext; top: var cdouble;
    bottom: var cdouble; left: var cdouble; right: var cdouble): bool =
  toBool(gtk_print_context_get_hard_margins(cast[ptr PrintContext00](self.impl), top, bottom, left, right))

proc gtk_print_context_get_height(self: ptr PrintContext00): cdouble {.
    importc, libprag.}

proc getHeight*(self: PrintContext): cdouble =
  gtk_print_context_get_height(cast[ptr PrintContext00](self.impl))

proc height*(self: PrintContext): cdouble =
  gtk_print_context_get_height(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_page_setup(self: ptr PrintContext00): ptr PageSetup00 {.
    importc, libprag.}

proc getPageSetup*(self: PrintContext): PageSetup =
  let gobj = gtk_print_context_get_page_setup(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pageSetup*(self: PrintContext): PageSetup =
  let gobj = gtk_print_context_get_page_setup(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_get_pango_fontmap(self: ptr PrintContext00): ptr pango.FontMap00 {.
    importc, libprag.}

proc getPangoFontmap*(self: PrintContext): pango.FontMap =
  let gobj = gtk_print_context_get_pango_fontmap(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pangoFontmap*(self: PrintContext): pango.FontMap =
  let gobj = gtk_print_context_get_pango_fontmap(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_get_width(self: ptr PrintContext00): cdouble {.
    importc, libprag.}

proc getWidth*(self: PrintContext): cdouble =
  gtk_print_context_get_width(cast[ptr PrintContext00](self.impl))

proc width*(self: PrintContext): cdouble =
  gtk_print_context_get_width(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_set_cairo_context(self: ptr PrintContext00; cr: ptr cairo.Context00;
    dpiX: cdouble; dpiY: cdouble) {.
    importc, libprag.}

proc setCairoContext*(self: PrintContext; cr: cairo.Context;
    dpiX: cdouble; dpiY: cdouble) =
  gtk_print_context_set_cairo_context(cast[ptr PrintContext00](self.impl), cast[ptr cairo.Context00](cr.impl), dpiX, dpiY)

type
  PrintDialog* = ref object of gobject.Object
  PrintDialog00* = object of gobject.Object00

proc gtk_print_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_print_dialog_new(): ptr PrintDialog00 {.
    importc, libprag.}

proc newPrintDialog*(): PrintDialog =
  let gobj = gtk_print_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintDialog*(tdesc: typedesc): tdesc =
  assert(result is PrintDialog)
  let gobj = gtk_print_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintDialog*[T](result: var T) {.deprecated.} =
  assert(result is PrintDialog)
  let gobj = gtk_print_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_dialog_get_accept_label(self: ptr PrintDialog00): cstring {.
    importc, libprag.}

proc getAcceptLabel*(self: PrintDialog): string =
  result = $gtk_print_dialog_get_accept_label(cast[ptr PrintDialog00](self.impl))

proc acceptLabel*(self: PrintDialog): string =
  result = $gtk_print_dialog_get_accept_label(cast[ptr PrintDialog00](self.impl))

proc gtk_print_dialog_get_modal(self: ptr PrintDialog00): gboolean {.
    importc, libprag.}

proc getModal*(self: PrintDialog): bool =
  toBool(gtk_print_dialog_get_modal(cast[ptr PrintDialog00](self.impl)))

proc modal*(self: PrintDialog): bool =
  toBool(gtk_print_dialog_get_modal(cast[ptr PrintDialog00](self.impl)))

proc gtk_print_dialog_get_page_setup(self: ptr PrintDialog00): ptr PageSetup00 {.
    importc, libprag.}

proc getPageSetup*(self: PrintDialog): PageSetup =
  let gobj = gtk_print_dialog_get_page_setup(cast[ptr PrintDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pageSetup*(self: PrintDialog): PageSetup =
  let gobj = gtk_print_dialog_get_page_setup(cast[ptr PrintDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_dialog_get_print_settings(self: ptr PrintDialog00): ptr PrintSettings00 {.
    importc, libprag.}

proc getPrintSettings*(self: PrintDialog): PrintSettings =
  let gobj = gtk_print_dialog_get_print_settings(cast[ptr PrintDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc printSettings*(self: PrintDialog): PrintSettings =
  let gobj = gtk_print_dialog_get_print_settings(cast[ptr PrintDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_dialog_get_title(self: ptr PrintDialog00): cstring {.
    importc, libprag.}

proc getTitle*(self: PrintDialog): string =
  result = $gtk_print_dialog_get_title(cast[ptr PrintDialog00](self.impl))

proc title*(self: PrintDialog): string =
  result = $gtk_print_dialog_get_title(cast[ptr PrintDialog00](self.impl))

proc gtk_print_dialog_print_file_finish(self: ptr PrintDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc printFileFinish*(self: PrintDialog; resu: gio.AsyncResult): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_dialog_print_file_finish(cast[ptr PrintDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_print_dialog_print_finish(self: ptr PrintDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr gio.OutputStream00 {.
    importc, libprag.}

proc printFinish*(self: PrintDialog; resu: gio.AsyncResult): gio.OutputStream =
  var gerror: ptr glib.Error
  let gobj = gtk_print_dialog_print_finish(cast[ptr PrintDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_dialog_set_accept_label(self: ptr PrintDialog00; acceptLabel: cstring) {.
    importc, libprag.}

proc setAcceptLabel*(self: PrintDialog; acceptLabel: cstring) =
  gtk_print_dialog_set_accept_label(cast[ptr PrintDialog00](self.impl), acceptLabel)

proc `acceptLabel=`*(self: PrintDialog; acceptLabel: cstring) =
  gtk_print_dialog_set_accept_label(cast[ptr PrintDialog00](self.impl), acceptLabel)

proc gtk_print_dialog_set_modal(self: ptr PrintDialog00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: PrintDialog; modal: bool = true) =
  gtk_print_dialog_set_modal(cast[ptr PrintDialog00](self.impl), gboolean(modal))

proc `modal=`*(self: PrintDialog; modal: bool) =
  gtk_print_dialog_set_modal(cast[ptr PrintDialog00](self.impl), gboolean(modal))

proc gtk_print_dialog_set_page_setup(self: ptr PrintDialog00; pageSetup: ptr PageSetup00) {.
    importc, libprag.}

proc setPageSetup*(self: PrintDialog; pageSetup: PageSetup) =
  gtk_print_dialog_set_page_setup(cast[ptr PrintDialog00](self.impl), cast[ptr PageSetup00](pageSetup.impl))

proc `pageSetup=`*(self: PrintDialog; pageSetup: PageSetup) =
  gtk_print_dialog_set_page_setup(cast[ptr PrintDialog00](self.impl), cast[ptr PageSetup00](pageSetup.impl))

proc gtk_print_dialog_set_print_settings(self: ptr PrintDialog00; printSettings: ptr PrintSettings00) {.
    importc, libprag.}

proc setPrintSettings*(self: PrintDialog; printSettings: PrintSettings) =
  gtk_print_dialog_set_print_settings(cast[ptr PrintDialog00](self.impl), cast[ptr PrintSettings00](printSettings.impl))

proc `printSettings=`*(self: PrintDialog; printSettings: PrintSettings) =
  gtk_print_dialog_set_print_settings(cast[ptr PrintDialog00](self.impl), cast[ptr PrintSettings00](printSettings.impl))

proc gtk_print_dialog_set_title(self: ptr PrintDialog00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: PrintDialog; title: cstring) =
  gtk_print_dialog_set_title(cast[ptr PrintDialog00](self.impl), title)

proc `title=`*(self: PrintDialog; title: cstring) =
  gtk_print_dialog_set_title(cast[ptr PrintDialog00](self.impl), title)

proc gtk_print_dialog_setup(self: ptr PrintDialog00; parent: ptr Window00;
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc setup*(self: PrintDialog; parent: Window = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_print_dialog_setup(cast[ptr PrintDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

type
  PrintSetup00* {.pure.} = object
  PrintSetup* = ref object
    impl*: ptr PrintSetup00
    ignoreFinalizer*: bool

proc gtk_print_setup_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkPrintSetup*(self: PrintSetup) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_print_setup_get_type(), cast[ptr PrintSetup00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintSetup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_print_setup_get_type(), cast[ptr PrintSetup00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var PrintSetup) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkPrintSetup)

proc gtk_print_setup_unref(self: ptr PrintSetup00) {.
    importc, libprag.}

proc unref*(self: PrintSetup) =
  gtk_print_setup_unref(cast[ptr PrintSetup00](self.impl))

proc finalizerunref*(self: PrintSetup) =
  if not self.ignoreFinalizer:
    gtk_print_setup_unref(cast[ptr PrintSetup00](self.impl))

proc gtk_print_setup_get_print_settings(self: ptr PrintSetup00): ptr PrintSettings00 {.
    importc, libprag.}

proc getPrintSettings*(self: PrintSetup): PrintSettings =
  let gobj = gtk_print_setup_get_print_settings(cast[ptr PrintSetup00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc printSettings*(self: PrintSetup): PrintSettings =
  let gobj = gtk_print_setup_get_print_settings(cast[ptr PrintSetup00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_setup_ref(self: ptr PrintSetup00): ptr PrintSetup00 {.
    importc, libprag.}

proc `ref`*(self: PrintSetup): PrintSetup =
  fnew(result, gBoxedFreeGtkPrintSetup)
  result.impl = gtk_print_setup_ref(cast[ptr PrintSetup00](self.impl))

proc gtk_print_setup_get_page_setup(self: ptr PrintSetup00): ptr PageSetup00 {.
    importc, libprag.}

proc getPageSetup*(self: PrintSetup): PageSetup =
  let gobj = gtk_print_setup_get_page_setup(cast[ptr PrintSetup00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pageSetup*(self: PrintSetup): PageSetup =
  let gobj = gtk_print_setup_get_page_setup(cast[ptr PrintSetup00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_dialog_print(self: ptr PrintDialog00; parent: ptr Window00;
    setup: ptr PrintSetup00; cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback;
    userData: pointer) {.
    importc, libprag.}

proc print*(self: PrintDialog; parent: Window = nil; setup: PrintSetup = nil;
    cancellable: gio.Cancellable = nil; callback: AsyncReadyCallback; userData: pointer) =
  gtk_print_dialog_print(cast[ptr PrintDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if setup.isNil: nil else: cast[ptr PrintSetup00](setup.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_print_dialog_print_file(self: ptr PrintDialog00; parent: ptr Window00;
    setup: ptr PrintSetup00; file: ptr gio.GFile00; cancellable: ptr gio.Cancellable00;
    callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc printFile*(self: PrintDialog; parent: Window = nil;
    setup: PrintSetup = nil; file: gio.GFile; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_print_dialog_print_file(cast[ptr PrintDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if setup.isNil: nil else: cast[ptr PrintSetup00](setup.impl), cast[ptr gio.GFile00](file.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_print_dialog_setup_finish(self: ptr PrintDialog00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr PrintSetup00 {.
    importc, libprag.}

proc setupFinish*(self: PrintDialog; resu: gio.AsyncResult): PrintSetup =
  var gerror: ptr glib.Error
  let impl0 = gtk_print_dialog_setup_finish(cast[ptr PrintDialog00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkPrintSetup)
  result.impl = impl0

type
  PrintError* {.size: sizeof(cint), pure.} = enum
    general = 0
    internalError = 1
    nomem = 2
    invalidFile = 3

type
  PrintJob* = ref object of gobject.Object
  PrintJob00* = object of gobject.Object00

proc gtk_print_job_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintJob()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scStatusChanged*(self: PrintJob;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "status-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_print_job_new(title: cstring; printer: ptr Printer00; settings: ptr PrintSettings00;
    pageSetup: ptr PageSetup00): ptr PrintJob00 {.
    importc, libprag.}

proc newPrintJob*(title: cstring; printer: Printer; settings: PrintSettings;
    pageSetup: PageSetup): PrintJob =
  let gobj = gtk_print_job_new(title, cast[ptr Printer00](printer.impl), cast[ptr PrintSettings00](settings.impl), cast[ptr PageSetup00](pageSetup.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintJob*(tdesc: typedesc; title: cstring; printer: Printer; settings: PrintSettings;
    pageSetup: PageSetup): tdesc =
  assert(result is PrintJob)
  let gobj = gtk_print_job_new(title, cast[ptr Printer00](printer.impl), cast[ptr PrintSettings00](settings.impl), cast[ptr PageSetup00](pageSetup.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintJob*[T](result: var T; title: cstring; printer: Printer; settings: PrintSettings;
    pageSetup: PageSetup) {.deprecated.} =
  assert(result is PrintJob)
  let gobj = gtk_print_job_new(title, cast[ptr Printer00](printer.impl), cast[ptr PrintSettings00](settings.impl), cast[ptr PageSetup00](pageSetup.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_job_get_collate(self: ptr PrintJob00): gboolean {.
    importc, libprag.}

proc getCollate*(self: PrintJob): bool =
  toBool(gtk_print_job_get_collate(cast[ptr PrintJob00](self.impl)))

proc collate*(self: PrintJob): bool =
  toBool(gtk_print_job_get_collate(cast[ptr PrintJob00](self.impl)))

proc gtk_print_job_get_n_up(self: ptr PrintJob00): uint32 {.
    importc, libprag.}

proc getNUp*(self: PrintJob): int =
  int(gtk_print_job_get_n_up(cast[ptr PrintJob00](self.impl)))

proc nUp*(self: PrintJob): int =
  int(gtk_print_job_get_n_up(cast[ptr PrintJob00](self.impl)))

proc gtk_print_job_get_n_up_layout(self: ptr PrintJob00): NumberUpLayout {.
    importc, libprag.}

proc getNUpLayout*(self: PrintJob): NumberUpLayout =
  gtk_print_job_get_n_up_layout(cast[ptr PrintJob00](self.impl))

proc nUpLayout*(self: PrintJob): NumberUpLayout =
  gtk_print_job_get_n_up_layout(cast[ptr PrintJob00](self.impl))

proc gtk_print_job_get_num_copies(self: ptr PrintJob00): int32 {.
    importc, libprag.}

proc getNumCopies*(self: PrintJob): int =
  int(gtk_print_job_get_num_copies(cast[ptr PrintJob00](self.impl)))

proc numCopies*(self: PrintJob): int =
  int(gtk_print_job_get_num_copies(cast[ptr PrintJob00](self.impl)))

proc gtk_print_job_get_page_ranges(self: ptr PrintJob00; nRanges: var int32): ptr PageRange {.
    importc, libprag.}

proc getPageRanges*(self: PrintJob; nRanges: var int): seq[PageRange] =
  var nRanges_00: int32
  result = pageRangeArrayToSeq(gtk_print_job_get_page_ranges(cast[ptr PrintJob00](self.impl), nRanges_00), nRanges_00.int)
  if nRanges.addr != nil:
    nRanges = int(nRanges_00)

proc gtk_print_job_get_page_set(self: ptr PrintJob00): PageSet {.
    importc, libprag.}

proc getPageSet*(self: PrintJob): PageSet =
  gtk_print_job_get_page_set(cast[ptr PrintJob00](self.impl))

proc pageSet*(self: PrintJob): PageSet =
  gtk_print_job_get_page_set(cast[ptr PrintJob00](self.impl))

proc gtk_print_job_get_pages(self: ptr PrintJob00): PrintPages {.
    importc, libprag.}

proc getPages*(self: PrintJob): PrintPages =
  gtk_print_job_get_pages(cast[ptr PrintJob00](self.impl))

proc pages*(self: PrintJob): PrintPages =
  gtk_print_job_get_pages(cast[ptr PrintJob00](self.impl))

proc gtk_print_job_get_printer(self: ptr PrintJob00): ptr Printer00 {.
    importc, libprag.}

proc getPrinter*(self: PrintJob): Printer =
  let gobj = gtk_print_job_get_printer(cast[ptr PrintJob00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc printer*(self: PrintJob): Printer =
  let gobj = gtk_print_job_get_printer(cast[ptr PrintJob00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_job_get_reverse(self: ptr PrintJob00): gboolean {.
    importc, libprag.}

proc getReverse*(self: PrintJob): bool =
  toBool(gtk_print_job_get_reverse(cast[ptr PrintJob00](self.impl)))

proc reverse*(self: PrintJob): bool =
  toBool(gtk_print_job_get_reverse(cast[ptr PrintJob00](self.impl)))

proc gtk_print_job_get_rotate(self: ptr PrintJob00): gboolean {.
    importc, libprag.}

proc getRotate*(self: PrintJob): bool =
  toBool(gtk_print_job_get_rotate(cast[ptr PrintJob00](self.impl)))

proc rotate*(self: PrintJob): bool =
  toBool(gtk_print_job_get_rotate(cast[ptr PrintJob00](self.impl)))

proc gtk_print_job_get_scale(self: ptr PrintJob00): cdouble {.
    importc, libprag.}

proc getScale*(self: PrintJob): cdouble =
  gtk_print_job_get_scale(cast[ptr PrintJob00](self.impl))

proc scale*(self: PrintJob): cdouble =
  gtk_print_job_get_scale(cast[ptr PrintJob00](self.impl))

proc gtk_print_job_get_settings(self: ptr PrintJob00): ptr PrintSettings00 {.
    importc, libprag.}

proc getSettings*(self: PrintJob): PrintSettings =
  let gobj = gtk_print_job_get_settings(cast[ptr PrintJob00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_job_get_surface(self: ptr PrintJob00; error: ptr ptr glib.Error = nil): ptr cairo.Surface00 {.
    importc, libprag.}

proc getSurface*(self: PrintJob): cairo.Surface =
  var gerror: ptr glib.Error
  let impl0 = gtk_print_job_get_surface(cast[ptr PrintJob00](self.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  fnew(result, gBoxedFreeCairoSurface)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_surface_get_type(), impl0))

proc surface*(self: PrintJob): cairo.Surface =
  var gerror: ptr glib.Error
  let impl0 = gtk_print_job_get_surface(cast[ptr PrintJob00](self.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  fnew(result, gBoxedFreeCairoSurface)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_surface_get_type(), impl0))

proc gtk_print_job_get_title(self: ptr PrintJob00): cstring {.
    importc, libprag.}

proc getTitle*(self: PrintJob): string =
  result = $gtk_print_job_get_title(cast[ptr PrintJob00](self.impl))

proc title*(self: PrintJob): string =
  result = $gtk_print_job_get_title(cast[ptr PrintJob00](self.impl))

proc gtk_print_job_get_track_print_status(self: ptr PrintJob00): gboolean {.
    importc, libprag.}

proc getTrackPrintStatus*(self: PrintJob): bool =
  toBool(gtk_print_job_get_track_print_status(cast[ptr PrintJob00](self.impl)))

proc trackPrintStatus*(self: PrintJob): bool =
  toBool(gtk_print_job_get_track_print_status(cast[ptr PrintJob00](self.impl)))

proc gtk_print_job_set_collate(self: ptr PrintJob00; collate: gboolean) {.
    importc, libprag.}

proc setCollate*(self: PrintJob; collate: bool = true) =
  gtk_print_job_set_collate(cast[ptr PrintJob00](self.impl), gboolean(collate))

proc `collate=`*(self: PrintJob; collate: bool) =
  gtk_print_job_set_collate(cast[ptr PrintJob00](self.impl), gboolean(collate))

proc gtk_print_job_set_n_up(self: ptr PrintJob00; nUp: uint32) {.
    importc, libprag.}

proc setNUp*(self: PrintJob; nUp: int) =
  gtk_print_job_set_n_up(cast[ptr PrintJob00](self.impl), uint32(nUp))

proc `nUp=`*(self: PrintJob; nUp: int) =
  gtk_print_job_set_n_up(cast[ptr PrintJob00](self.impl), uint32(nUp))

proc gtk_print_job_set_n_up_layout(self: ptr PrintJob00; layout: NumberUpLayout) {.
    importc, libprag.}

proc setNUpLayout*(self: PrintJob; layout: NumberUpLayout) =
  gtk_print_job_set_n_up_layout(cast[ptr PrintJob00](self.impl), layout)

proc `nUpLayout=`*(self: PrintJob; layout: NumberUpLayout) =
  gtk_print_job_set_n_up_layout(cast[ptr PrintJob00](self.impl), layout)

proc gtk_print_job_set_num_copies(self: ptr PrintJob00; numCopies: int32) {.
    importc, libprag.}

proc setNumCopies*(self: PrintJob; numCopies: int) =
  gtk_print_job_set_num_copies(cast[ptr PrintJob00](self.impl), int32(numCopies))

proc `numCopies=`*(self: PrintJob; numCopies: int) =
  gtk_print_job_set_num_copies(cast[ptr PrintJob00](self.impl), int32(numCopies))

proc gtk_print_job_set_page_ranges(self: ptr PrintJob00; ranges: ptr PageRange;
    nRanges: int32) {.
    importc, libprag.}

proc setPageRanges*(self: PrintJob; ranges: seq[PageRange]) =
  let nRanges = int(ranges.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_print_job_set_page_ranges(cast[ptr PrintJob00](self.impl), seq2PageRangeArray(ranges, fs469n23), int32(nRanges))

proc gtk_print_job_set_page_set(self: ptr PrintJob00; pageSet: PageSet) {.
    importc, libprag.}

proc setPageSet*(self: PrintJob; pageSet: PageSet) =
  gtk_print_job_set_page_set(cast[ptr PrintJob00](self.impl), pageSet)

proc `pageSet=`*(self: PrintJob; pageSet: PageSet) =
  gtk_print_job_set_page_set(cast[ptr PrintJob00](self.impl), pageSet)

proc gtk_print_job_set_pages(self: ptr PrintJob00; pages: PrintPages) {.
    importc, libprag.}

proc setPages*(self: PrintJob; pages: PrintPages) =
  gtk_print_job_set_pages(cast[ptr PrintJob00](self.impl), pages)

proc `pages=`*(self: PrintJob; pages: PrintPages) =
  gtk_print_job_set_pages(cast[ptr PrintJob00](self.impl), pages)

proc gtk_print_job_set_reverse(self: ptr PrintJob00; reverse: gboolean) {.
    importc, libprag.}

proc setReverse*(self: PrintJob; reverse: bool = true) =
  gtk_print_job_set_reverse(cast[ptr PrintJob00](self.impl), gboolean(reverse))

proc `reverse=`*(self: PrintJob; reverse: bool) =
  gtk_print_job_set_reverse(cast[ptr PrintJob00](self.impl), gboolean(reverse))

proc gtk_print_job_set_rotate(self: ptr PrintJob00; rotate: gboolean) {.
    importc, libprag.}

proc setRotate*(self: PrintJob; rotate: bool = true) =
  gtk_print_job_set_rotate(cast[ptr PrintJob00](self.impl), gboolean(rotate))

proc `rotate=`*(self: PrintJob; rotate: bool) =
  gtk_print_job_set_rotate(cast[ptr PrintJob00](self.impl), gboolean(rotate))

proc gtk_print_job_set_scale(self: ptr PrintJob00; scale: cdouble) {.
    importc, libprag.}

proc setScale*(self: PrintJob; scale: cdouble) =
  gtk_print_job_set_scale(cast[ptr PrintJob00](self.impl), scale)

proc `scale=`*(self: PrintJob; scale: cdouble) =
  gtk_print_job_set_scale(cast[ptr PrintJob00](self.impl), scale)

proc gtk_print_job_set_source_fd(self: ptr PrintJob00; fd: int32; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc setSourceFd*(self: PrintJob; fd: int): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_job_set_source_fd(cast[ptr PrintJob00](self.impl), int32(fd), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_print_job_set_source_file(self: ptr PrintJob00; filename: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc setSourceFile*(self: PrintJob; filename: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_job_set_source_file(cast[ptr PrintJob00](self.impl), filename, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_print_job_set_track_print_status(self: ptr PrintJob00; trackStatus: gboolean) {.
    importc, libprag.}

proc setTrackPrintStatus*(self: PrintJob; trackStatus: bool = true) =
  gtk_print_job_set_track_print_status(cast[ptr PrintJob00](self.impl), gboolean(trackStatus))

proc `trackPrintStatus=`*(self: PrintJob; trackStatus: bool) =
  gtk_print_job_set_track_print_status(cast[ptr PrintJob00](self.impl), gboolean(trackStatus))

type
  PrintStatus* {.size: sizeof(cint), pure.} = enum
    initial = 0
    preparing = 1
    generatingData = 2
    sendingData = 3
    pending = 4
    pendingIssue = 5
    printing = 6
    finished = 7
    finishedAborted = 8

proc gtk_print_job_get_status(self: ptr PrintJob00): PrintStatus {.
    importc, libprag.}

proc getStatus*(self: PrintJob): PrintStatus =
  gtk_print_job_get_status(cast[ptr PrintJob00](self.impl))

proc status*(self: PrintJob): PrintStatus =
  gtk_print_job_get_status(cast[ptr PrintJob00](self.impl))

type
  PrintJobCompleteFunc* = proc (printJob: ptr PrintJob00; userData: pointer; error: ptr glib.Error) {.cdecl.}

proc gtk_print_job_send(self: ptr PrintJob00; callback: PrintJobCompleteFunc;
    userData: pointer; dnotify: DestroyNotify) {.
    importc, libprag.}

proc send*(self: PrintJob; callback: PrintJobCompleteFunc; userData: pointer;
    dnotify: DestroyNotify) =
  gtk_print_job_send(cast[ptr PrintJob00](self.impl), callback, userData, dnotify)

type
  PrintOperationResult* {.size: sizeof(cint), pure.} = enum
    error = 0
    apply = 1
    cancel = 2
    inProgress = 3
type

  PrintOperationPreview00* = object of gobject.Object00
  PrintOperationPreview* = ref object of gobject.Object

  PrintOperation* = ref object of gobject.Object
  PrintOperation00* = object of gobject.Object00

proc gtk_print_operation_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintOperation()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scGotPageSize*(self: PrintOperationPreview | PrintOperation;  p: proc (self: ptr PrintOperationPreview00; context: ptr PrintContext00; pageSetup: ptr PageSetup00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "got-page-size", cast[GCallback](p), xdata, nil, cf)

proc scReady*(self: PrintOperationPreview | PrintOperation;  p: proc (self: ptr PrintOperationPreview00; context: ptr PrintContext00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "ready", cast[GCallback](p), xdata, nil, cf)

proc scBeginPrint*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "begin-print", cast[GCallback](p), xdata, nil, cf)

proc scCreateCustomWidget*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; xdata: pointer): ptr gobject.Object00 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "create-custom-widget", cast[GCallback](p), xdata, nil, cf)

proc scCustomWidgetApply*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; widget: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "custom-widget-apply", cast[GCallback](p), xdata, nil, cf)

proc scDone*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; resu: PrintOperationResult; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "done", cast[GCallback](p), xdata, nil, cf)

proc scDrawPage*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; pageNr: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "draw-page", cast[GCallback](p), xdata, nil, cf)

proc scEndPrint*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "end-print", cast[GCallback](p), xdata, nil, cf)

proc scPaginate*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "paginate", cast[GCallback](p), xdata, nil, cf)

proc scPreview*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; preview: ptr PrintOperationPreview00; context: ptr PrintContext00;
    parent: ptr Window00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preview", cast[GCallback](p), xdata, nil, cf)

proc scRequestPageSetup*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; pageNr: int32; setup: ptr PageSetup00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "request-page-setup", cast[GCallback](p), xdata, nil, cf)

proc scStatusChanged*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "status-changed", cast[GCallback](p), xdata, nil, cf)

proc scUpdateCustomWidget*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; widget: ptr Widget00; setup: ptr PageSetup00; settings: ptr PrintSettings00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "update-custom-widget", cast[GCallback](p), xdata, nil, cf)

proc gtk_print_operation_preview_end_preview(self: ptr PrintOperationPreview00) {.
    importc, libprag.}

proc endPreview*(self: PrintOperationPreview | PrintOperation) =
  gtk_print_operation_preview_end_preview(cast[ptr PrintOperationPreview00](self.impl))

proc gtk_print_operation_preview_is_selected(self: ptr PrintOperationPreview00;
    pageNr: int32): gboolean {.
    importc, libprag.}

proc isSelected*(self: PrintOperationPreview | PrintOperation;
    pageNr: int): bool =
  toBool(gtk_print_operation_preview_is_selected(cast[ptr PrintOperationPreview00](self.impl), int32(pageNr)))

proc gtk_print_operation_preview_render_page(self: ptr PrintOperationPreview00;
    pageNr: int32) {.
    importc, libprag.}

proc renderPage*(self: PrintOperationPreview | PrintOperation;
    pageNr: int) =
  gtk_print_operation_preview_render_page(cast[ptr PrintOperationPreview00](self.impl), int32(pageNr))

proc gtk_print_operation_new(): ptr PrintOperation00 {.
    importc, libprag.}

proc newPrintOperation*(): PrintOperation =
  let gobj = gtk_print_operation_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintOperation*(tdesc: typedesc): tdesc =
  assert(result is PrintOperation)
  let gobj = gtk_print_operation_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintOperation*[T](result: var T) {.deprecated.} =
  assert(result is PrintOperation)
  let gobj = gtk_print_operation_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_operation_cancel(self: ptr PrintOperation00) {.
    importc, libprag.}

proc cancel*(self: PrintOperation) =
  gtk_print_operation_cancel(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_draw_page_finish(self: ptr PrintOperation00) {.
    importc, libprag.}

proc drawPageFinish*(self: PrintOperation) =
  gtk_print_operation_draw_page_finish(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_get_default_page_setup(self: ptr PrintOperation00): ptr PageSetup00 {.
    importc, libprag.}

proc getDefaultPageSetup*(self: PrintOperation): PageSetup =
  let gobj = gtk_print_operation_get_default_page_setup(cast[ptr PrintOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultPageSetup*(self: PrintOperation): PageSetup =
  let gobj = gtk_print_operation_get_default_page_setup(cast[ptr PrintOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_operation_get_embed_page_setup(self: ptr PrintOperation00): gboolean {.
    importc, libprag.}

proc getEmbedPageSetup*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_embed_page_setup(cast[ptr PrintOperation00](self.impl)))

proc embedPageSetup*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_embed_page_setup(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_get_error(self: ptr PrintOperation00; error: ptr ptr glib.Error = nil) {.
    importc, libprag.}

proc getError*(self: PrintOperation) =
  var gerror: ptr glib.Error
  gtk_print_operation_get_error(cast[ptr PrintOperation00](self.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)

proc gtk_print_operation_get_has_selection(self: ptr PrintOperation00): gboolean {.
    importc, libprag.}

proc getHasSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_has_selection(cast[ptr PrintOperation00](self.impl)))

proc hasSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_has_selection(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_get_n_pages_to_print(self: ptr PrintOperation00): int32 {.
    importc, libprag.}

proc getNPagesToPrint*(self: PrintOperation): int =
  int(gtk_print_operation_get_n_pages_to_print(cast[ptr PrintOperation00](self.impl)))

proc nPagesToPrint*(self: PrintOperation): int =
  int(gtk_print_operation_get_n_pages_to_print(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_get_print_settings(self: ptr PrintOperation00): ptr PrintSettings00 {.
    importc, libprag.}

proc getPrintSettings*(self: PrintOperation): PrintSettings =
  let gobj = gtk_print_operation_get_print_settings(cast[ptr PrintOperation00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc printSettings*(self: PrintOperation): PrintSettings =
  let gobj = gtk_print_operation_get_print_settings(cast[ptr PrintOperation00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_operation_get_status(self: ptr PrintOperation00): PrintStatus {.
    importc, libprag.}

proc getStatus*(self: PrintOperation): PrintStatus =
  gtk_print_operation_get_status(cast[ptr PrintOperation00](self.impl))

proc status*(self: PrintOperation): PrintStatus =
  gtk_print_operation_get_status(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_get_status_string(self: ptr PrintOperation00): cstring {.
    importc, libprag.}

proc getStatusString*(self: PrintOperation): string =
  result = $gtk_print_operation_get_status_string(cast[ptr PrintOperation00](self.impl))

proc statusString*(self: PrintOperation): string =
  result = $gtk_print_operation_get_status_string(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_get_support_selection(self: ptr PrintOperation00): gboolean {.
    importc, libprag.}

proc getSupportSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_support_selection(cast[ptr PrintOperation00](self.impl)))

proc supportSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_support_selection(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_is_finished(self: ptr PrintOperation00): gboolean {.
    importc, libprag.}

proc isFinished*(self: PrintOperation): bool =
  toBool(gtk_print_operation_is_finished(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_set_allow_async(self: ptr PrintOperation00; allowAsync: gboolean) {.
    importc, libprag.}

proc setAllowAsync*(self: PrintOperation; allowAsync: bool = true) =
  gtk_print_operation_set_allow_async(cast[ptr PrintOperation00](self.impl), gboolean(allowAsync))

proc `allowAsync=`*(self: PrintOperation; allowAsync: bool) =
  gtk_print_operation_set_allow_async(cast[ptr PrintOperation00](self.impl), gboolean(allowAsync))

proc gtk_print_operation_set_current_page(self: ptr PrintOperation00; currentPage: int32) {.
    importc, libprag.}

proc setCurrentPage*(self: PrintOperation; currentPage: int) =
  gtk_print_operation_set_current_page(cast[ptr PrintOperation00](self.impl), int32(currentPage))

proc `currentPage=`*(self: PrintOperation; currentPage: int) =
  gtk_print_operation_set_current_page(cast[ptr PrintOperation00](self.impl), int32(currentPage))

proc gtk_print_operation_set_custom_tab_label(self: ptr PrintOperation00;
    label: cstring) {.
    importc, libprag.}

proc setCustomTabLabel*(self: PrintOperation; label: cstring = nil) =
  gtk_print_operation_set_custom_tab_label(cast[ptr PrintOperation00](self.impl), label)

proc `customTabLabel=`*(self: PrintOperation; label: cstring = nil) =
  gtk_print_operation_set_custom_tab_label(cast[ptr PrintOperation00](self.impl), label)

proc gtk_print_operation_set_default_page_setup(self: ptr PrintOperation00;
    defaultPageSetup: ptr PageSetup00) {.
    importc, libprag.}

proc setDefaultPageSetup*(self: PrintOperation; defaultPageSetup: PageSetup = nil) =
  gtk_print_operation_set_default_page_setup(cast[ptr PrintOperation00](self.impl), if defaultPageSetup.isNil: nil else: cast[ptr PageSetup00](defaultPageSetup.impl))

proc `defaultPageSetup=`*(self: PrintOperation; defaultPageSetup: PageSetup = nil) =
  gtk_print_operation_set_default_page_setup(cast[ptr PrintOperation00](self.impl), if defaultPageSetup.isNil: nil else: cast[ptr PageSetup00](defaultPageSetup.impl))

proc gtk_print_operation_set_defer_drawing(self: ptr PrintOperation00) {.
    importc, libprag.}

proc setDeferDrawing*(self: PrintOperation) =
  gtk_print_operation_set_defer_drawing(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_set_embed_page_setup(self: ptr PrintOperation00;
    embed: gboolean) {.
    importc, libprag.}

proc setEmbedPageSetup*(self: PrintOperation; embed: bool = true) =
  gtk_print_operation_set_embed_page_setup(cast[ptr PrintOperation00](self.impl), gboolean(embed))

proc `embedPageSetup=`*(self: PrintOperation; embed: bool) =
  gtk_print_operation_set_embed_page_setup(cast[ptr PrintOperation00](self.impl), gboolean(embed))

proc gtk_print_operation_set_export_filename(self: ptr PrintOperation00;
    filename: cstring) {.
    importc, libprag.}

proc setExportFilename*(self: PrintOperation; filename: cstring) =
  gtk_print_operation_set_export_filename(cast[ptr PrintOperation00](self.impl), filename)

proc `exportFilename=`*(self: PrintOperation; filename: cstring) =
  gtk_print_operation_set_export_filename(cast[ptr PrintOperation00](self.impl), filename)

proc gtk_print_operation_set_has_selection(self: ptr PrintOperation00; hasSelection: gboolean) {.
    importc, libprag.}

proc setHasSelection*(self: PrintOperation; hasSelection: bool = true) =
  gtk_print_operation_set_has_selection(cast[ptr PrintOperation00](self.impl), gboolean(hasSelection))

proc `hasSelection=`*(self: PrintOperation; hasSelection: bool) =
  gtk_print_operation_set_has_selection(cast[ptr PrintOperation00](self.impl), gboolean(hasSelection))

proc gtk_print_operation_set_job_name(self: ptr PrintOperation00; jobName: cstring) {.
    importc, libprag.}

proc setJobName*(self: PrintOperation; jobName: cstring) =
  gtk_print_operation_set_job_name(cast[ptr PrintOperation00](self.impl), jobName)

proc `jobName=`*(self: PrintOperation; jobName: cstring) =
  gtk_print_operation_set_job_name(cast[ptr PrintOperation00](self.impl), jobName)

proc gtk_print_operation_set_n_pages(self: ptr PrintOperation00; nPages: int32) {.
    importc, libprag.}

proc setNPages*(self: PrintOperation; nPages: int) =
  gtk_print_operation_set_n_pages(cast[ptr PrintOperation00](self.impl), int32(nPages))

proc `nPages=`*(self: PrintOperation; nPages: int) =
  gtk_print_operation_set_n_pages(cast[ptr PrintOperation00](self.impl), int32(nPages))

proc gtk_print_operation_set_print_settings(self: ptr PrintOperation00; printSettings: ptr PrintSettings00) {.
    importc, libprag.}

proc setPrintSettings*(self: PrintOperation; printSettings: PrintSettings = nil) =
  gtk_print_operation_set_print_settings(cast[ptr PrintOperation00](self.impl), if printSettings.isNil: nil else: cast[ptr PrintSettings00](printSettings.impl))

proc `printSettings=`*(self: PrintOperation; printSettings: PrintSettings = nil) =
  gtk_print_operation_set_print_settings(cast[ptr PrintOperation00](self.impl), if printSettings.isNil: nil else: cast[ptr PrintSettings00](printSettings.impl))

proc gtk_print_operation_set_show_progress(self: ptr PrintOperation00; showProgress: gboolean) {.
    importc, libprag.}

proc setShowProgress*(self: PrintOperation; showProgress: bool = true) =
  gtk_print_operation_set_show_progress(cast[ptr PrintOperation00](self.impl), gboolean(showProgress))

proc `showProgress=`*(self: PrintOperation; showProgress: bool) =
  gtk_print_operation_set_show_progress(cast[ptr PrintOperation00](self.impl), gboolean(showProgress))

proc gtk_print_operation_set_support_selection(self: ptr PrintOperation00;
    supportSelection: gboolean) {.
    importc, libprag.}

proc setSupportSelection*(self: PrintOperation; supportSelection: bool = true) =
  gtk_print_operation_set_support_selection(cast[ptr PrintOperation00](self.impl), gboolean(supportSelection))

proc `supportSelection=`*(self: PrintOperation; supportSelection: bool) =
  gtk_print_operation_set_support_selection(cast[ptr PrintOperation00](self.impl), gboolean(supportSelection))

proc gtk_print_operation_set_track_print_status(self: ptr PrintOperation00;
    trackStatus: gboolean) {.
    importc, libprag.}

proc setTrackPrintStatus*(self: PrintOperation; trackStatus: bool = true) =
  gtk_print_operation_set_track_print_status(cast[ptr PrintOperation00](self.impl), gboolean(trackStatus))

proc `trackPrintStatus=`*(self: PrintOperation; trackStatus: bool) =
  gtk_print_operation_set_track_print_status(cast[ptr PrintOperation00](self.impl), gboolean(trackStatus))

proc gtk_print_operation_set_unit(self: ptr PrintOperation00; unit: Unit) {.
    importc, libprag.}

proc setUnit*(self: PrintOperation; unit: Unit) =
  gtk_print_operation_set_unit(cast[ptr PrintOperation00](self.impl), unit)

proc `unit=`*(self: PrintOperation; unit: Unit) =
  gtk_print_operation_set_unit(cast[ptr PrintOperation00](self.impl), unit)

proc gtk_print_operation_set_use_full_page(self: ptr PrintOperation00; fullPage: gboolean) {.
    importc, libprag.}

proc setUseFullPage*(self: PrintOperation; fullPage: bool = true) =
  gtk_print_operation_set_use_full_page(cast[ptr PrintOperation00](self.impl), gboolean(fullPage))

proc `useFullPage=`*(self: PrintOperation; fullPage: bool) =
  gtk_print_operation_set_use_full_page(cast[ptr PrintOperation00](self.impl), gboolean(fullPage))

type
  PrintOperationAction* {.size: sizeof(cint), pure.} = enum
    printDialog = 0
    print = 1
    preview = 2
    `export` = 3

proc gtk_print_operation_run(self: ptr PrintOperation00; action: PrintOperationAction;
    parent: ptr Window00; error: ptr ptr glib.Error = nil): PrintOperationResult {.
    importc, libprag.}

proc run*(self: PrintOperation; action: PrintOperationAction;
    parent: Window = nil): PrintOperationResult =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_operation_run(cast[ptr PrintOperation00](self.impl), action, if parent.isNil: nil else: cast[ptr Window00](parent.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = resul0

type
  PrintSettingsFunc* = proc (key: cstring; value: cstring; userData: pointer) {.cdecl.}

proc gtk_print_settings_foreach(self: ptr PrintSettings00; `func`: PrintSettingsFunc;
    userData: pointer) {.
    importc, libprag.}

proc foreach*(self: PrintSettings; `func`: PrintSettingsFunc;
    userData: pointer) =
  gtk_print_settings_foreach(cast[ptr PrintSettings00](self.impl), `func`, userData)

type
  PrinterFunc* = proc (printer: ptr Printer00; data: pointer): gboolean {.cdecl.}

type
  PropertyExpression* = ref object of Expression
  PropertyExpression00* = object of Expression00

proc gtk_property_expression_get_type*(): GType {.importc, libprag.}

proc gtk_expression_unref*(self: ptr PropertyExpression00) {.importc, libprag.}

proc generic_gtk_expression_unref*(self: PropertyExpression) =
  if not self.ignoreFinalizer:
    gtk_expression_unref(self.impl)

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PropertyExpression()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      gtk_expression_unref(self.impl)
      self.impl = nil

proc gtk_property_expression_new(thisType: GType; expression: ptr Expression00;
    propertyName: cstring): ptr PropertyExpression00 {.
    importc, libprag.}

proc newPropertyExpression*(thisType: GType; expression: Expression = nil;
    propertyName: cstring): PropertyExpression =
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_property_expression_new(thisType, if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)), propertyName)

proc newPropertyExpression*(tdesc: typedesc; thisType: GType; expression: Expression = nil;
    propertyName: cstring): tdesc =
  assert(result is PropertyExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_property_expression_new(thisType, if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)), propertyName)

proc initPropertyExpression*[T](result: var T; thisType: GType; expression: Expression = nil;
    propertyName: cstring) {.deprecated.} =
  assert(result is PropertyExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_property_expression_new(thisType, if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)), propertyName)

proc gtk_property_expression_new_for_pspec(expression: ptr Expression00;
    pspec: ptr gobject.ParamSpec00): ptr PropertyExpression00 {.
    importc, libprag.}

proc newPropertyExpressionForPspec*(expression: Expression = nil;
    pspec: gobject.ParamSpec): PropertyExpression =
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_property_expression_new_for_pspec(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)), cast[ptr gobject.ParamSpec00](pspec.impl))

proc newPropertyExpressionForPspec*(tdesc: typedesc; expression: Expression = nil;
    pspec: gobject.ParamSpec): tdesc =
  assert(result is PropertyExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_property_expression_new_for_pspec(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)), cast[ptr gobject.ParamSpec00](pspec.impl))

proc initPropertyExpressionForPspec*[T](result: var T; expression: Expression = nil;
    pspec: gobject.ParamSpec) {.deprecated.} =
  assert(result is PropertyExpression)
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_property_expression_new_for_pspec(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)), cast[ptr gobject.ParamSpec00](pspec.impl))

proc gtk_property_expression_get_expression(self: ptr PropertyExpression00): ptr Expression00 {.
    importc, libprag.}

proc getExpression*(self: PropertyExpression): Expression =
  let impl0 = gtk_property_expression_get_expression(cast[ptr PropertyExpression00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc expression*(self: PropertyExpression): Expression =
  let impl0 = gtk_property_expression_get_expression(cast[ptr PropertyExpression00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc gtk_property_expression_get_pspec(self: ptr PropertyExpression00): ptr gobject.ParamSpec00 {.
    importc, libprag.}

proc getPspec*(self: PropertyExpression): gobject.ParamSpec =
  fnew(result, generic_g_param_spec_unref)
  result.impl = gtk_property_expression_get_pspec(cast[ptr PropertyExpression00](self.impl))
  result.impl = cast[typeof(result.impl)](g_param_spec_ref_sink(result.impl))

proc pspec*(self: PropertyExpression): gobject.ParamSpec =
  fnew(result, generic_g_param_spec_unref)
  result.impl = gtk_property_expression_get_pspec(cast[ptr PropertyExpression00](self.impl))
  result.impl = cast[typeof(result.impl)](g_param_spec_ref_sink(result.impl))

type
  RecentData* {.pure, byRef.} = object
    displayName*: cstring
    description*: cstring
    mimeType*: cstring
    appName*: cstring
    appExec*: cstring
    groups*: ptr cstring
    isPrivate*: gboolean

type
  RecentInfo00* {.pure.} = object
  RecentInfo* = ref object
    impl*: ptr RecentInfo00
    ignoreFinalizer*: bool

proc gtk_recent_info_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkRecentInfo*(self: RecentInfo) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_recent_info_get_type(), cast[ptr RecentInfo00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RecentInfo()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_recent_info_get_type(), cast[ptr RecentInfo00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var RecentInfo) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkRecentInfo)

proc gtk_recent_info_unref(self: ptr RecentInfo00) {.
    importc, libprag.}

proc unref*(self: RecentInfo) =
  gtk_recent_info_unref(cast[ptr RecentInfo00](self.impl))

proc finalizerunref*(self: RecentInfo) =
  if not self.ignoreFinalizer:
    gtk_recent_info_unref(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_exists(self: ptr RecentInfo00): gboolean {.
    importc, libprag.}

proc exists*(self: RecentInfo): bool =
  toBool(gtk_recent_info_exists(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_get_added(self: ptr RecentInfo00): ptr glib.DateTime00 {.
    importc, libprag.}

proc getAdded*(self: RecentInfo): glib.DateTime =
  fnew(result, gBoxedFreeGDateTime)
  result.impl = gtk_recent_info_get_added(cast[ptr RecentInfo00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_date_time_get_type(), result.impl))

proc added*(self: RecentInfo): glib.DateTime =
  fnew(result, gBoxedFreeGDateTime)
  result.impl = gtk_recent_info_get_added(cast[ptr RecentInfo00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_date_time_get_type(), result.impl))

proc gtk_recent_info_get_age(self: ptr RecentInfo00): int32 {.
    importc, libprag.}

proc getAge*(self: RecentInfo): int =
  int(gtk_recent_info_get_age(cast[ptr RecentInfo00](self.impl)))

proc age*(self: RecentInfo): int =
  int(gtk_recent_info_get_age(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_get_application_info(self: ptr RecentInfo00; appName: cstring;
    appExec: var cstring; count: var uint32; stamp: var ptr glib.DateTime00): gboolean {.
    importc, libprag.}

proc getApplicationInfo*(self: RecentInfo; appName: cstring;
    appExec: var string; count: var int; stamp: var glib.DateTime): bool =
  fnew(stamp, gBoxedFreeGDateTime)
  var count_00: uint32
  var appExec_00: cstring
  result = toBool(gtk_recent_info_get_application_info(cast[ptr RecentInfo00](self.impl), appName, appExec_00, count_00, cast[var ptr glib.DateTime00](addr stamp.impl)))
  if count.addr != nil:
    count = int(count_00)
  if appExec.addr != nil:
    appExec = $(appExec_00)

proc gtk_recent_info_get_applications(self: ptr RecentInfo00; length: var uint64): ptr cstring {.
    importc, libprag.}

proc getApplications*(self: RecentInfo; length: var uint64 = cast[var uint64](nil)): seq[string] =
  let resul0 = gtk_recent_info_get_applications(cast[ptr RecentInfo00](self.impl), length)
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_recent_info_get_description(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getDescription*(self: RecentInfo): string =
  result = $gtk_recent_info_get_description(cast[ptr RecentInfo00](self.impl))

proc description*(self: RecentInfo): string =
  result = $gtk_recent_info_get_description(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_display_name(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getDisplayName*(self: RecentInfo): string =
  result = $gtk_recent_info_get_display_name(cast[ptr RecentInfo00](self.impl))

proc displayName*(self: RecentInfo): string =
  result = $gtk_recent_info_get_display_name(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_gicon(self: ptr RecentInfo00): ptr gio.Icon00 {.
    importc, libprag.}

proc getGicon*(self: RecentInfo): gio.Icon =
  let gobj = gtk_recent_info_get_gicon(cast[ptr RecentInfo00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gicon*(self: RecentInfo): gio.Icon =
  let gobj = gtk_recent_info_get_gicon(cast[ptr RecentInfo00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_info_get_groups(self: ptr RecentInfo00; length: var uint64): ptr cstring {.
    importc, libprag.}

proc getGroups*(self: RecentInfo; length: var uint64 = cast[var uint64](nil)): seq[string] =
  let resul0 = gtk_recent_info_get_groups(cast[ptr RecentInfo00](self.impl), length)
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_recent_info_get_mime_type(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getMimeType*(self: RecentInfo): string =
  result = $gtk_recent_info_get_mime_type(cast[ptr RecentInfo00](self.impl))

proc mimeType*(self: RecentInfo): string =
  result = $gtk_recent_info_get_mime_type(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_modified(self: ptr RecentInfo00): ptr glib.DateTime00 {.
    importc, libprag.}

proc getModified*(self: RecentInfo): glib.DateTime =
  fnew(result, gBoxedFreeGDateTime)
  result.impl = gtk_recent_info_get_modified(cast[ptr RecentInfo00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_date_time_get_type(), result.impl))

proc modified*(self: RecentInfo): glib.DateTime =
  fnew(result, gBoxedFreeGDateTime)
  result.impl = gtk_recent_info_get_modified(cast[ptr RecentInfo00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_date_time_get_type(), result.impl))

proc gtk_recent_info_get_private_hint(self: ptr RecentInfo00): gboolean {.
    importc, libprag.}

proc getPrivateHint*(self: RecentInfo): bool =
  toBool(gtk_recent_info_get_private_hint(cast[ptr RecentInfo00](self.impl)))

proc privateHint*(self: RecentInfo): bool =
  toBool(gtk_recent_info_get_private_hint(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_get_short_name(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getShortName*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_short_name(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc shortName*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_short_name(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_recent_info_get_uri(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getUri*(self: RecentInfo): string =
  result = $gtk_recent_info_get_uri(cast[ptr RecentInfo00](self.impl))

proc uri*(self: RecentInfo): string =
  result = $gtk_recent_info_get_uri(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_uri_display(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getUriDisplay*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_uri_display(cast[ptr RecentInfo00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc uriDisplay*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_uri_display(cast[ptr RecentInfo00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_recent_info_get_visited(self: ptr RecentInfo00): ptr glib.DateTime00 {.
    importc, libprag.}

proc getVisited*(self: RecentInfo): glib.DateTime =
  fnew(result, gBoxedFreeGDateTime)
  result.impl = gtk_recent_info_get_visited(cast[ptr RecentInfo00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_date_time_get_type(), result.impl))

proc visited*(self: RecentInfo): glib.DateTime =
  fnew(result, gBoxedFreeGDateTime)
  result.impl = gtk_recent_info_get_visited(cast[ptr RecentInfo00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_date_time_get_type(), result.impl))

proc gtk_recent_info_has_application(self: ptr RecentInfo00; appName: cstring): gboolean {.
    importc, libprag.}

proc hasApplication*(self: RecentInfo; appName: cstring): bool =
  toBool(gtk_recent_info_has_application(cast[ptr RecentInfo00](self.impl), appName))

proc gtk_recent_info_has_group(self: ptr RecentInfo00; groupName: cstring): gboolean {.
    importc, libprag.}

proc hasGroup*(self: RecentInfo; groupName: cstring): bool =
  toBool(gtk_recent_info_has_group(cast[ptr RecentInfo00](self.impl), groupName))

proc gtk_recent_info_is_local(self: ptr RecentInfo00): gboolean {.
    importc, libprag.}

proc isLocal*(self: RecentInfo): bool =
  toBool(gtk_recent_info_is_local(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_last_application(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc lastApplication*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_last_application(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_recent_info_match(self: ptr RecentInfo00; infoB: ptr RecentInfo00): gboolean {.
    importc, libprag.}

proc match*(self: RecentInfo; infoB: RecentInfo): bool =
  toBool(gtk_recent_info_match(cast[ptr RecentInfo00](self.impl), cast[ptr RecentInfo00](infoB.impl)))

proc gtk_recent_info_ref(self: ptr RecentInfo00): ptr RecentInfo00 {.
    importc, libprag.}

proc `ref`*(self: RecentInfo): RecentInfo =
  fnew(result, gBoxedFreeGtkRecentInfo)
  result.impl = gtk_recent_info_ref(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_create_app_info(self: ptr RecentInfo00; appName: cstring;
    error: ptr ptr glib.Error = nil): ptr gio.AppInfo00 {.
    importc, libprag.}

proc createAppInfo*(self: RecentInfo; appName: cstring = nil): gio.AppInfo =
  var gerror: ptr glib.Error
  let gobj = gtk_recent_info_create_app_info(cast[ptr RecentInfo00](self.impl), appName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  RecentManager* = ref object of gobject.Object
  RecentManager00* = object of gobject.Object00

proc gtk_recent_manager_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RecentManager()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: RecentManager;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_recent_manager_new(): ptr RecentManager00 {.
    importc, libprag.}

proc newRecentManager*(): RecentManager =
  let gobj = gtk_recent_manager_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRecentManager*(tdesc: typedesc): tdesc =
  assert(result is RecentManager)
  let gobj = gtk_recent_manager_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentManager*[T](result: var T) {.deprecated.} =
  assert(result is RecentManager)
  let gobj = gtk_recent_manager_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_manager_get_default(): ptr RecentManager00 {.
    importc, libprag.}

proc getDefaultRecentManager*(): RecentManager =
  let gobj = gtk_recent_manager_get_default()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_manager_add_full(self: ptr RecentManager00; uri: cstring;
    recentData: RecentData): gboolean {.
    importc, libprag.}

proc addFull*(self: RecentManager; uri: cstring; recentData: RecentData): bool =
  toBool(gtk_recent_manager_add_full(cast[ptr RecentManager00](self.impl), uri, recentData))

proc gtk_recent_manager_add_item(self: ptr RecentManager00; uri: cstring): gboolean {.
    importc, libprag.}

proc addItem*(self: RecentManager; uri: cstring): bool =
  toBool(gtk_recent_manager_add_item(cast[ptr RecentManager00](self.impl), uri))

proc gtk_recent_manager_get_items(self: ptr RecentManager00): ptr glib.List {.
    importc, libprag.}

proc getItems*(self: RecentManager): seq[RecentInfo] =
  let resul0 = gtk_recent_manager_get_items(cast[ptr RecentManager00](self.impl))
  result = glistStructs2seq[RecentInfo](resul0, false)
  g_list_free(resul0)

proc items*(self: RecentManager): seq[RecentInfo] =
  let resul0 = gtk_recent_manager_get_items(cast[ptr RecentManager00](self.impl))
  result = glistStructs2seq[RecentInfo](resul0, false)
  g_list_free(resul0)

proc gtk_recent_manager_has_item(self: ptr RecentManager00; uri: cstring): gboolean {.
    importc, libprag.}

proc hasItem*(self: RecentManager; uri: cstring): bool =
  toBool(gtk_recent_manager_has_item(cast[ptr RecentManager00](self.impl), uri))

proc gtk_recent_manager_lookup_item(self: ptr RecentManager00; uri: cstring;
    error: ptr ptr glib.Error = nil): ptr RecentInfo00 {.
    importc, libprag.}

proc lookupItem*(self: RecentManager; uri: cstring): RecentInfo =
  var gerror: ptr glib.Error
  let impl0 = gtk_recent_manager_lookup_item(cast[ptr RecentManager00](self.impl), uri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkRecentInfo)
  result.impl = impl0

proc gtk_recent_manager_move_item(self: ptr RecentManager00; uri: cstring;
    newUri: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc moveItem*(self: RecentManager; uri: cstring; newUri: cstring = nil): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_recent_manager_move_item(cast[ptr RecentManager00](self.impl), uri, newUri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_recent_manager_purge_items(self: ptr RecentManager00; error: ptr ptr glib.Error = nil): int32 {.
    importc, libprag.}

proc purgeItems*(self: RecentManager): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_recent_manager_purge_items(cast[ptr RecentManager00](self.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_recent_manager_remove_item(self: ptr RecentManager00; uri: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc removeItem*(self: RecentManager; uri: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_recent_manager_remove_item(cast[ptr RecentManager00](self.impl), uri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

type
  RecentManagerError* {.size: sizeof(cint), pure.} = enum
    notFound = 0
    invalidUri = 1
    invalidEncoding = 2
    notRegistered = 3
    read = 4
    write = 5
    unknown = 6

type
  RequestedSize* {.pure, byRef.} = object
    data*: pointer
    minimumSize*: int32
    naturalSize*: int32

type
  ResponseType* {.size: sizeof(cint), pure.} = enum
    help = -11
    apply = -10
    no = -9
    yes = -8
    close = -7
    cancel = -6
    ok = -5
    deleteEvent = -4
    accept = -3
    reject = -2
    none = -1

const STYLE_PROVIDER_PRIORITY_APPLICATION* = 600'i32

const STYLE_PROVIDER_PRIORITY_FALLBACK* = 1'i32

const STYLE_PROVIDER_PRIORITY_SETTINGS* = 400'i32

const STYLE_PROVIDER_PRIORITY_THEME* = 200'i32

const STYLE_PROVIDER_PRIORITY_USER* = 800'i32

type
  ScaleFormatValueFunc* = proc (scale: ptr Scale00; value: cdouble; userData: pointer): cstring {.cdecl.}

proc gtk_scale_set_format_value_func(self: ptr Scale00; `func`: ScaleFormatValueFunc;
    userData: pointer; destroyNotify: DestroyNotify) {.
    importc, libprag.}

proc setFormatValueFunc*(self: Scale; `func`: ScaleFormatValueFunc;
    userData: pointer; destroyNotify: DestroyNotify) =
  gtk_scale_set_format_value_func(cast[ptr Scale00](self.impl), `func`, userData, destroyNotify)

type
  Scrollable00* = object of gobject.Object00
  Scrollable* = ref object of gobject.Object

proc gtk_scrollable_get_border(self: ptr Scrollable00; border: var Border): gboolean {.
    importc, libprag.}

proc getBorder*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView;
    border: var Border): bool =
  toBool(gtk_scrollable_get_border(cast[ptr Scrollable00](self.impl), border))

proc gtk_scrollable_get_hadjustment(self: ptr Scrollable00): ptr Adjustment00 {.
    importc, libprag.}

proc getHadjustment*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView): Adjustment =
  let gobj = gtk_scrollable_get_hadjustment(cast[ptr Scrollable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView): Adjustment =
  let gobj = gtk_scrollable_get_hadjustment(cast[ptr Scrollable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrollable_get_vadjustment(self: ptr Scrollable00): ptr Adjustment00 {.
    importc, libprag.}

proc getVadjustment*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView): Adjustment =
  let gobj = gtk_scrollable_get_vadjustment(cast[ptr Scrollable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView): Adjustment =
  let gobj = gtk_scrollable_get_vadjustment(cast[ptr Scrollable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrollable_set_hadjustment(self: ptr Scrollable00; hadjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setHadjustment*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView;
    hadjustment: Adjustment = nil) =
  gtk_scrollable_set_hadjustment(cast[ptr Scrollable00](self.impl), if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl))

proc `hadjustment=`*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView;
    hadjustment: Adjustment = nil) =
  gtk_scrollable_set_hadjustment(cast[ptr Scrollable00](self.impl), if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl))

proc gtk_scrollable_set_vadjustment(self: ptr Scrollable00; vadjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setVadjustment*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView;
    vadjustment: Adjustment = nil) =
  gtk_scrollable_set_vadjustment(cast[ptr Scrollable00](self.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))

proc `vadjustment=`*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView;
    vadjustment: Adjustment = nil) =
  gtk_scrollable_set_vadjustment(cast[ptr Scrollable00](self.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))

type
  ScrollablePolicy* {.size: sizeof(cint), pure.} = enum
    minimum = 0
    natural = 1

proc gtk_scrollable_get_hscroll_policy(self: ptr Scrollable00): ScrollablePolicy {.
    importc, libprag.}

proc getHscrollPolicy*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView): ScrollablePolicy =
  gtk_scrollable_get_hscroll_policy(cast[ptr Scrollable00](self.impl))

proc hscrollPolicy*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView): ScrollablePolicy =
  gtk_scrollable_get_hscroll_policy(cast[ptr Scrollable00](self.impl))

proc gtk_scrollable_get_vscroll_policy(self: ptr Scrollable00): ScrollablePolicy {.
    importc, libprag.}

proc getVscrollPolicy*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView): ScrollablePolicy =
  gtk_scrollable_get_vscroll_policy(cast[ptr Scrollable00](self.impl))

proc vscrollPolicy*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView): ScrollablePolicy =
  gtk_scrollable_get_vscroll_policy(cast[ptr Scrollable00](self.impl))

proc gtk_scrollable_set_hscroll_policy(self: ptr Scrollable00; policy: ScrollablePolicy) {.
    importc, libprag.}

proc setHscrollPolicy*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView;
    policy: ScrollablePolicy) =
  gtk_scrollable_set_hscroll_policy(cast[ptr Scrollable00](self.impl), policy)

proc `hscrollPolicy=`*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView;
    policy: ScrollablePolicy) =
  gtk_scrollable_set_hscroll_policy(cast[ptr Scrollable00](self.impl), policy)

proc gtk_scrollable_set_vscroll_policy(self: ptr Scrollable00; policy: ScrollablePolicy) {.
    importc, libprag.}

proc setVscrollPolicy*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView;
    policy: ScrollablePolicy) =
  gtk_scrollable_set_vscroll_policy(cast[ptr Scrollable00](self.impl), policy)

proc `vscrollPolicy=`*(self: Scrollable | Viewport | TextView | ListBase | GridView | ColumnView | IconView | TreeView | ListView;
    policy: ScrollablePolicy) =
  gtk_scrollable_set_vscroll_policy(cast[ptr Scrollable00](self.impl), policy)

type
  SliceListModel* = ref object of gobject.Object
  SliceListModel00* = object of gobject.Object00

proc gtk_slice_list_model_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SliceListModel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_slice_list_model_new(model: ptr gio.ListModel00; offset: uint32;
    size: uint32): ptr SliceListModel00 {.
    importc, libprag.}

proc newSliceListModel*(model: gio.ListModel = nil; offset: int; size: int): SliceListModel =
  let gobj = gtk_slice_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), uint32(offset), uint32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSliceListModel*(tdesc: typedesc; model: gio.ListModel = nil; offset: int; size: int): tdesc =
  assert(result is SliceListModel)
  let gobj = gtk_slice_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), uint32(offset), uint32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSliceListModel*[T](result: var T; model: gio.ListModel = nil; offset: int; size: int) {.deprecated.} =
  assert(result is SliceListModel)
  let gobj = gtk_slice_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), uint32(offset), uint32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_slice_list_model_get_model(self: ptr SliceListModel00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: SliceListModel): gio.ListModel =
  let gobj = gtk_slice_list_model_get_model(cast[ptr SliceListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: SliceListModel): gio.ListModel =
  let gobj = gtk_slice_list_model_get_model(cast[ptr SliceListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_slice_list_model_get_offset(self: ptr SliceListModel00): uint32 {.
    importc, libprag.}

proc getOffset*(self: SliceListModel): int =
  int(gtk_slice_list_model_get_offset(cast[ptr SliceListModel00](self.impl)))

proc offset*(self: SliceListModel): int =
  int(gtk_slice_list_model_get_offset(cast[ptr SliceListModel00](self.impl)))

proc gtk_slice_list_model_get_size(self: ptr SliceListModel00): uint32 {.
    importc, libprag.}

proc getSize*(self: SliceListModel): int =
  int(gtk_slice_list_model_get_size(cast[ptr SliceListModel00](self.impl)))

proc size*(self: SliceListModel): int =
  int(gtk_slice_list_model_get_size(cast[ptr SliceListModel00](self.impl)))

proc gtk_slice_list_model_set_model(self: ptr SliceListModel00; model: ptr gio.ListModel00) {.
    importc, libprag.}

proc setModel*(self: SliceListModel; model: gio.ListModel = nil) =
  gtk_slice_list_model_set_model(cast[ptr SliceListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc `model=`*(self: SliceListModel; model: gio.ListModel = nil) =
  gtk_slice_list_model_set_model(cast[ptr SliceListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc gtk_slice_list_model_set_offset(self: ptr SliceListModel00; offset: uint32) {.
    importc, libprag.}

proc setOffset*(self: SliceListModel; offset: int) =
  gtk_slice_list_model_set_offset(cast[ptr SliceListModel00](self.impl), uint32(offset))

proc `offset=`*(self: SliceListModel; offset: int) =
  gtk_slice_list_model_set_offset(cast[ptr SliceListModel00](self.impl), uint32(offset))

proc gtk_slice_list_model_set_size(self: ptr SliceListModel00; size: uint32) {.
    importc, libprag.}

proc setSize*(self: SliceListModel; size: int) =
  gtk_slice_list_model_set_size(cast[ptr SliceListModel00](self.impl), uint32(size))

proc `size=`*(self: SliceListModel; size: int) =
  gtk_slice_list_model_set_size(cast[ptr SliceListModel00](self.impl), uint32(size))

type
  SortListModel* = ref object of gobject.Object
  SortListModel00* = object of gobject.Object00

proc gtk_sort_list_model_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SortListModel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_sort_list_model_new(model: ptr gio.ListModel00; sorter: ptr Sorter00): ptr SortListModel00 {.
    importc, libprag.}

proc newSortListModel*(model: gio.ListModel = nil; sorter: Sorter = nil): SortListModel =
  let gobj = gtk_sort_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), if sorter.isNil: nil else: cast[ptr Sorter00](g_object_ref(sorter.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSortListModel*(tdesc: typedesc; model: gio.ListModel = nil; sorter: Sorter = nil): tdesc =
  assert(result is SortListModel)
  let gobj = gtk_sort_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), if sorter.isNil: nil else: cast[ptr Sorter00](g_object_ref(sorter.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSortListModel*[T](result: var T; model: gio.ListModel = nil; sorter: Sorter = nil) {.deprecated.} =
  assert(result is SortListModel)
  let gobj = gtk_sort_list_model_new(if model.isNil: nil else: cast[ptr gio.ListModel00](g_object_ref(model.impl)), if sorter.isNil: nil else: cast[ptr Sorter00](g_object_ref(sorter.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_sort_list_model_get_incremental(self: ptr SortListModel00): gboolean {.
    importc, libprag.}

proc getIncremental*(self: SortListModel): bool =
  toBool(gtk_sort_list_model_get_incremental(cast[ptr SortListModel00](self.impl)))

proc incremental*(self: SortListModel): bool =
  toBool(gtk_sort_list_model_get_incremental(cast[ptr SortListModel00](self.impl)))

proc gtk_sort_list_model_get_model(self: ptr SortListModel00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: SortListModel): gio.ListModel =
  let gobj = gtk_sort_list_model_get_model(cast[ptr SortListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: SortListModel): gio.ListModel =
  let gobj = gtk_sort_list_model_get_model(cast[ptr SortListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_sort_list_model_get_pending(self: ptr SortListModel00): uint32 {.
    importc, libprag.}

proc getPending*(self: SortListModel): int =
  int(gtk_sort_list_model_get_pending(cast[ptr SortListModel00](self.impl)))

proc pending*(self: SortListModel): int =
  int(gtk_sort_list_model_get_pending(cast[ptr SortListModel00](self.impl)))

proc gtk_sort_list_model_get_section_sorter(self: ptr SortListModel00): ptr Sorter00 {.
    importc, libprag.}

proc getSectionSorter*(self: SortListModel): Sorter =
  let gobj = gtk_sort_list_model_get_section_sorter(cast[ptr SortListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc sectionSorter*(self: SortListModel): Sorter =
  let gobj = gtk_sort_list_model_get_section_sorter(cast[ptr SortListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_sort_list_model_get_sorter(self: ptr SortListModel00): ptr Sorter00 {.
    importc, libprag.}

proc getSorter*(self: SortListModel): Sorter =
  let gobj = gtk_sort_list_model_get_sorter(cast[ptr SortListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc sorter*(self: SortListModel): Sorter =
  let gobj = gtk_sort_list_model_get_sorter(cast[ptr SortListModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_sort_list_model_set_incremental(self: ptr SortListModel00; incremental: gboolean) {.
    importc, libprag.}

proc setIncremental*(self: SortListModel; incremental: bool = true) =
  gtk_sort_list_model_set_incremental(cast[ptr SortListModel00](self.impl), gboolean(incremental))

proc `incremental=`*(self: SortListModel; incremental: bool) =
  gtk_sort_list_model_set_incremental(cast[ptr SortListModel00](self.impl), gboolean(incremental))

proc gtk_sort_list_model_set_model(self: ptr SortListModel00; model: ptr gio.ListModel00) {.
    importc, libprag.}

proc setModel*(self: SortListModel; model: gio.ListModel = nil) =
  gtk_sort_list_model_set_model(cast[ptr SortListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc `model=`*(self: SortListModel; model: gio.ListModel = nil) =
  gtk_sort_list_model_set_model(cast[ptr SortListModel00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl))

proc gtk_sort_list_model_set_section_sorter(self: ptr SortListModel00; sorter: ptr Sorter00) {.
    importc, libprag.}

proc setSectionSorter*(self: SortListModel; sorter: Sorter = nil) =
  gtk_sort_list_model_set_section_sorter(cast[ptr SortListModel00](self.impl), if sorter.isNil: nil else: cast[ptr Sorter00](sorter.impl))

proc `sectionSorter=`*(self: SortListModel; sorter: Sorter = nil) =
  gtk_sort_list_model_set_section_sorter(cast[ptr SortListModel00](self.impl), if sorter.isNil: nil else: cast[ptr Sorter00](sorter.impl))

proc gtk_sort_list_model_set_sorter(self: ptr SortListModel00; sorter: ptr Sorter00) {.
    importc, libprag.}

proc setSorter*(self: SortListModel; sorter: Sorter = nil) =
  gtk_sort_list_model_set_sorter(cast[ptr SortListModel00](self.impl), if sorter.isNil: nil else: cast[ptr Sorter00](sorter.impl))

proc `sorter=`*(self: SortListModel; sorter: Sorter = nil) =
  gtk_sort_list_model_set_sorter(cast[ptr SortListModel00](self.impl), if sorter.isNil: nil else: cast[ptr Sorter00](sorter.impl))

type
  SectionModel00* = object of gobject.Object00
  SectionModel* = ref object of gobject.Object

proc scSectionsChanged*(self: SectionModel | MapListModel | SingleSelection | FilterListModel | MultiSelection | NoSelection | FlattenListModel | SliceListModel | SortListModel;  p: proc (self: ptr SectionModel00; position: uint32; nItems: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "sections-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_section_model_get_section(self: ptr SectionModel00; position: uint32;
    outStart: var uint32; outEnd: var uint32) {.
    importc, libprag.}

proc getSection*(self: SectionModel | MapListModel | SingleSelection | FilterListModel | MultiSelection | NoSelection | FlattenListModel | SliceListModel | SortListModel;
    position: int; outStart: var int; outEnd: var int) =
  var outStart_00: uint32
  var outEnd_00: uint32
  gtk_section_model_get_section(cast[ptr SectionModel00](self.impl), uint32(position), outStart_00, outEnd_00)
  if outStart.addr != nil:
    outStart = int(outStart_00)
  if outEnd.addr != nil:
    outEnd = int(outEnd_00)

proc gtk_section_model_sections_changed(self: ptr SectionModel00; position: uint32;
    nItems: uint32) {.
    importc, libprag.}

proc sectionsChanged*(self: SectionModel | MapListModel | SingleSelection | FilterListModel | MultiSelection | NoSelection | FlattenListModel | SliceListModel | SortListModel;
    position: int; nItems: int) =
  gtk_section_model_sections_changed(cast[ptr SectionModel00](self.impl), uint32(position), uint32(nItems))

type
  SelectionFilterModel* = ref object of gobject.Object
  SelectionFilterModel00* = object of gobject.Object00

proc gtk_selection_filter_model_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SelectionFilterModel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_selection_filter_model_new(model: ptr SelectionModel00): ptr SelectionFilterModel00 {.
    importc, libprag.}

proc newSelectionFilterModel*(model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)): SelectionFilterModel =
  let gobj = gtk_selection_filter_model_new(if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSelectionFilterModel*(tdesc: typedesc; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)): tdesc =
  assert(result is SelectionFilterModel)
  let gobj = gtk_selection_filter_model_new(if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSelectionFilterModel*[T](result: var T; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) {.deprecated.} =
  assert(result is SelectionFilterModel)
  let gobj = gtk_selection_filter_model_new(if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_selection_filter_model_get_model(self: ptr SelectionFilterModel00): ptr SelectionModel00 {.
    importc, libprag.}

proc getModel*(self: SelectionFilterModel): SelectionModel =
  let gobj = gtk_selection_filter_model_get_model(cast[ptr SelectionFilterModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: SelectionFilterModel): SelectionModel =
  let gobj = gtk_selection_filter_model_get_model(cast[ptr SelectionFilterModel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_selection_filter_model_set_model(self: ptr SelectionFilterModel00;
    model: ptr SelectionModel00) {.
    importc, libprag.}

proc setModel*(self: SelectionFilterModel; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) =
  gtk_selection_filter_model_set_model(cast[ptr SelectionFilterModel00](self.impl), if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))

proc `model=`*(self: SelectionFilterModel; model: SelectionModel | SingleSelection | MultiSelection | NoSelection = SelectionModel(nil)) =
  gtk_selection_filter_model_set_model(cast[ptr SelectionFilterModel00](self.impl), if model.isNil: nil else: cast[ptr SelectionModel00](model.impl))

type
  ShortcutFunc* = proc (widget: ptr Widget00; args: ptr glib.Variant00; userData: pointer): gboolean {.cdecl.}

proc gtk_callback_action_new(callback: ShortcutFunc; data: pointer; destroy: DestroyNotify): ptr CallbackAction00 {.
    importc, libprag.}

proc newCallbackAction*(callback: ShortcutFunc; data: pointer; destroy: DestroyNotify): CallbackAction =
  let gobj = gtk_callback_action_new(callback, data, destroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCallbackAction*(tdesc: typedesc; callback: ShortcutFunc; data: pointer; destroy: DestroyNotify): tdesc =
  assert(result is CallbackAction)
  let gobj = gtk_callback_action_new(callback, data, destroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCallbackAction*[T](result: var T; callback: ShortcutFunc; data: pointer; destroy: DestroyNotify) {.deprecated.} =
  assert(result is CallbackAction)
  let gobj = gtk_callback_action_new(callback, data, destroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ShortcutManager00* = object of gobject.Object00
  ShortcutManager* = ref object of gobject.Object

type
  ShortcutType* {.size: sizeof(cint), pure.} = enum
    accelerator = 0
    gesturePinch = 1
    gestureStretch = 2
    gestureRotateClockwise = 3
    gestureRotateCounterclockwise = 4
    gestureTwoFingerSwipeLeft = 5
    gestureTwoFingerSwipeRight = 6
    gesture = 7
    gestureSwipeLeft = 8
    gestureSwipeRight = 9

type
  SignalAction* = ref object of ShortcutAction
  SignalAction00* = object of ShortcutAction00

proc gtk_signal_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SignalAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_signal_action_new(signalName: cstring): ptr SignalAction00 {.
    importc, libprag.}

proc newSignalAction*(signalName: cstring): SignalAction =
  let gobj = gtk_signal_action_new(signalName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSignalAction*(tdesc: typedesc; signalName: cstring): tdesc =
  assert(result is SignalAction)
  let gobj = gtk_signal_action_new(signalName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSignalAction*[T](result: var T; signalName: cstring) {.deprecated.} =
  assert(result is SignalAction)
  let gobj = gtk_signal_action_new(signalName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_signal_action_get_signal_name(self: ptr SignalAction00): cstring {.
    importc, libprag.}

proc getSignalName*(self: SignalAction): string =
  result = $gtk_signal_action_get_signal_name(cast[ptr SignalAction00](self.impl))

proc signalName*(self: SignalAction): string =
  result = $gtk_signal_action_get_signal_name(cast[ptr SignalAction00](self.impl))

type
  SignalListItemFactory* = ref object of ListItemFactory
  SignalListItemFactory00* = object of ListItemFactory00

proc gtk_signal_list_item_factory_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SignalListItemFactory()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scBind*(self: SignalListItemFactory;  p: proc (self: ptr SignalListItemFactory00; obj: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "bind", cast[GCallback](p), xdata, nil, cf)

proc scSetup*(self: SignalListItemFactory;  p: proc (self: ptr SignalListItemFactory00; obj: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "setup", cast[GCallback](p), xdata, nil, cf)

proc scTeardown*(self: SignalListItemFactory;  p: proc (self: ptr SignalListItemFactory00; obj: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "teardown", cast[GCallback](p), xdata, nil, cf)

proc scUnbind*(self: SignalListItemFactory;  p: proc (self: ptr SignalListItemFactory00; obj: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unbind", cast[GCallback](p), xdata, nil, cf)

proc gtk_signal_list_item_factory_new(): ptr SignalListItemFactory00 {.
    importc, libprag.}

proc newSignalListItemFactory*(): SignalListItemFactory =
  let gobj = gtk_signal_list_item_factory_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSignalListItemFactory*(tdesc: typedesc): tdesc =
  assert(result is SignalListItemFactory)
  let gobj = gtk_signal_list_item_factory_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSignalListItemFactory*[T](result: var T) {.deprecated.} =
  assert(result is SignalListItemFactory)
  let gobj = gtk_signal_list_item_factory_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  StringFilter* = ref object of Filter
  StringFilter00* = object of Filter00

proc gtk_string_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StringFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_string_filter_new(expression: ptr Expression00): ptr StringFilter00 {.
    importc, libprag.}

proc newStringFilter*(expression: Expression = nil): StringFilter =
  let gobj = gtk_string_filter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStringFilter*(tdesc: typedesc; expression: Expression = nil): tdesc =
  assert(result is StringFilter)
  let gobj = gtk_string_filter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStringFilter*[T](result: var T; expression: Expression = nil) {.deprecated.} =
  assert(result is StringFilter)
  let gobj = gtk_string_filter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_string_filter_get_expression(self: ptr StringFilter00): ptr Expression00 {.
    importc, libprag.}

proc getExpression*(self: StringFilter): Expression =
  let impl0 = gtk_string_filter_get_expression(cast[ptr StringFilter00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc expression*(self: StringFilter): Expression =
  let impl0 = gtk_string_filter_get_expression(cast[ptr StringFilter00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc gtk_string_filter_get_ignore_case(self: ptr StringFilter00): gboolean {.
    importc, libprag.}

proc getIgnoreCase*(self: StringFilter): bool =
  toBool(gtk_string_filter_get_ignore_case(cast[ptr StringFilter00](self.impl)))

proc ignoreCase*(self: StringFilter): bool =
  toBool(gtk_string_filter_get_ignore_case(cast[ptr StringFilter00](self.impl)))

proc gtk_string_filter_get_match_mode(self: ptr StringFilter00): StringFilterMatchMode {.
    importc, libprag.}

proc getMatchMode*(self: StringFilter): StringFilterMatchMode =
  gtk_string_filter_get_match_mode(cast[ptr StringFilter00](self.impl))

proc matchMode*(self: StringFilter): StringFilterMatchMode =
  gtk_string_filter_get_match_mode(cast[ptr StringFilter00](self.impl))

proc gtk_string_filter_get_search(self: ptr StringFilter00): cstring {.
    importc, libprag.}

proc getSearch*(self: StringFilter): string =
  let resul0 = gtk_string_filter_get_search(cast[ptr StringFilter00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc search*(self: StringFilter): string =
  let resul0 = gtk_string_filter_get_search(cast[ptr StringFilter00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_string_filter_set_expression(self: ptr StringFilter00; expression: ptr Expression00) {.
    importc, libprag.}

proc setExpression*(self: StringFilter; expression: Expression = nil) =
  gtk_string_filter_set_expression(cast[ptr StringFilter00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

proc `expression=`*(self: StringFilter; expression: Expression = nil) =
  gtk_string_filter_set_expression(cast[ptr StringFilter00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

proc gtk_string_filter_set_ignore_case(self: ptr StringFilter00; ignoreCase: gboolean) {.
    importc, libprag.}

proc setIgnoreCase*(self: StringFilter; ignoreCase: bool = true) =
  gtk_string_filter_set_ignore_case(cast[ptr StringFilter00](self.impl), gboolean(ignoreCase))

proc `ignoreCase=`*(self: StringFilter; ignoreCase: bool) =
  gtk_string_filter_set_ignore_case(cast[ptr StringFilter00](self.impl), gboolean(ignoreCase))

proc gtk_string_filter_set_match_mode(self: ptr StringFilter00; mode: StringFilterMatchMode) {.
    importc, libprag.}

proc setMatchMode*(self: StringFilter; mode: StringFilterMatchMode) =
  gtk_string_filter_set_match_mode(cast[ptr StringFilter00](self.impl), mode)

proc `matchMode=`*(self: StringFilter; mode: StringFilterMatchMode) =
  gtk_string_filter_set_match_mode(cast[ptr StringFilter00](self.impl), mode)

proc gtk_string_filter_set_search(self: ptr StringFilter00; search: cstring) {.
    importc, libprag.}

proc setSearch*(self: StringFilter; search: cstring = nil) =
  gtk_string_filter_set_search(cast[ptr StringFilter00](self.impl), search)

proc `search=`*(self: StringFilter; search: cstring = nil) =
  gtk_string_filter_set_search(cast[ptr StringFilter00](self.impl), search)

type
  StringObject* = ref object of gobject.Object
  StringObject00* = object of gobject.Object00

proc gtk_string_object_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StringObject()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_string_object_new(string: cstring): ptr StringObject00 {.
    importc, libprag.}

proc newStringObject*(string: cstring): StringObject =
  let gobj = gtk_string_object_new(string)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStringObject*(tdesc: typedesc; string: cstring): tdesc =
  assert(result is StringObject)
  let gobj = gtk_string_object_new(string)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStringObject*[T](result: var T; string: cstring) {.deprecated.} =
  assert(result is StringObject)
  let gobj = gtk_string_object_new(string)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_string_object_get_string(self: ptr StringObject00): cstring {.
    importc, libprag.}

proc getString*(self: StringObject): string =
  result = $gtk_string_object_get_string(cast[ptr StringObject00](self.impl))

type
  StringSorter* = ref object of Sorter
  StringSorter00* = object of Sorter00

proc gtk_string_sorter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StringSorter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_string_sorter_new(expression: ptr Expression00): ptr StringSorter00 {.
    importc, libprag.}

proc newStringSorter*(expression: Expression = nil): StringSorter =
  let gobj = gtk_string_sorter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStringSorter*(tdesc: typedesc; expression: Expression = nil): tdesc =
  assert(result is StringSorter)
  let gobj = gtk_string_sorter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStringSorter*[T](result: var T; expression: Expression = nil) {.deprecated.} =
  assert(result is StringSorter)
  let gobj = gtk_string_sorter_new(if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_string_sorter_get_collation(self: ptr StringSorter00): Collation {.
    importc, libprag.}

proc getCollation*(self: StringSorter): Collation =
  gtk_string_sorter_get_collation(cast[ptr StringSorter00](self.impl))

proc collation*(self: StringSorter): Collation =
  gtk_string_sorter_get_collation(cast[ptr StringSorter00](self.impl))

proc gtk_string_sorter_get_expression(self: ptr StringSorter00): ptr Expression00 {.
    importc, libprag.}

proc getExpression*(self: StringSorter): Expression =
  let impl0 = gtk_string_sorter_get_expression(cast[ptr StringSorter00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc expression*(self: StringSorter): Expression =
  let impl0 = gtk_string_sorter_get_expression(cast[ptr StringSorter00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc gtk_string_sorter_get_ignore_case(self: ptr StringSorter00): gboolean {.
    importc, libprag.}

proc getIgnoreCase*(self: StringSorter): bool =
  toBool(gtk_string_sorter_get_ignore_case(cast[ptr StringSorter00](self.impl)))

proc ignoreCase*(self: StringSorter): bool =
  toBool(gtk_string_sorter_get_ignore_case(cast[ptr StringSorter00](self.impl)))

proc gtk_string_sorter_set_collation(self: ptr StringSorter00; collation: Collation) {.
    importc, libprag.}

proc setCollation*(self: StringSorter; collation: Collation) =
  gtk_string_sorter_set_collation(cast[ptr StringSorter00](self.impl), collation)

proc `collation=`*(self: StringSorter; collation: Collation) =
  gtk_string_sorter_set_collation(cast[ptr StringSorter00](self.impl), collation)

proc gtk_string_sorter_set_expression(self: ptr StringSorter00; expression: ptr Expression00) {.
    importc, libprag.}

proc setExpression*(self: StringSorter; expression: Expression = nil) =
  gtk_string_sorter_set_expression(cast[ptr StringSorter00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

proc `expression=`*(self: StringSorter; expression: Expression = nil) =
  gtk_string_sorter_set_expression(cast[ptr StringSorter00](self.impl), if expression.isNil: nil else: cast[ptr Expression00](expression.impl))

proc gtk_string_sorter_set_ignore_case(self: ptr StringSorter00; ignoreCase: gboolean) {.
    importc, libprag.}

proc setIgnoreCase*(self: StringSorter; ignoreCase: bool = true) =
  gtk_string_sorter_set_ignore_case(cast[ptr StringSorter00](self.impl), gboolean(ignoreCase))

proc `ignoreCase=`*(self: StringSorter; ignoreCase: bool) =
  gtk_string_sorter_set_ignore_case(cast[ptr StringSorter00](self.impl), gboolean(ignoreCase))

type
  SymbolicColor* {.size: sizeof(cint), pure.} = enum
    foreground = 0
    error = 1
    warning = 2
    success = 3

type
  SymbolicPaintable00* = object of gobject.Object00
  SymbolicPaintable* = ref object of gobject.Object

proc gtk_symbolic_paintable_snapshot_symbolic(self: ptr SymbolicPaintable00;
    snapshot: ptr gdk4.Snapshot00; width: cdouble; height: cdouble; colors: ptr gdk4.RGBA;
    nColors: uint64) {.
    importc, libprag.}

proc snapshotSymbolic*(self: SymbolicPaintable | IconPaintable;
    snapshot: gdk4.Snapshot; width: cdouble; height: cdouble; colors: ptr gdk4.RGBA;
    nColors: uint64) =
  gtk_symbolic_paintable_snapshot_symbolic(cast[ptr SymbolicPaintable00](self.impl), cast[ptr gdk4.Snapshot00](snapshot.impl), width, height, colors, nColors)

type
  SystemSetting* {.size: sizeof(cint), pure.} = enum
    dpi = 0
    fontName = 1
    fontConfig = 2
    display = 3
    iconTheme = 4

const TEXT_VIEW_PRIORITY_VALIDATE* = 125'i32

const TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID* = -1'i32

const TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID* = -2'i32

type
  TextCharPredicate* = proc (ch: gunichar; userData: pointer): gboolean {.cdecl.}

proc gtk_text_iter_backward_find_char(self: TextIter; pred: TextCharPredicate;
    userData: pointer; limit: TextIter): gboolean {.
    importc, libprag.}

proc backwardFindChar*(self: TextIter; pred: TextCharPredicate;
    userData: pointer; limit: TextIter = cast[var TextIter](nil)): bool =
  toBool(gtk_text_iter_backward_find_char(self, pred, userData, limit))

proc gtk_text_iter_forward_find_char(self: TextIter; pred: TextCharPredicate;
    userData: pointer; limit: TextIter): gboolean {.
    importc, libprag.}

proc forwardFindChar*(self: TextIter; pred: TextCharPredicate;
    userData: pointer; limit: TextIter = cast[var TextIter](nil)): bool =
  toBool(gtk_text_iter_forward_find_char(self, pred, userData, limit))

type
  TextTagTableForeach* = proc (tag: ptr TextTag00; data: pointer) {.cdecl.}

proc gtk_text_tag_table_foreach(self: ptr TextTagTable00; `func`: TextTagTableForeach;
    data: pointer) {.
    importc, libprag.}

proc foreach*(self: TextTagTable; `func`: TextTagTableForeach;
    data: pointer) =
  gtk_text_tag_table_foreach(cast[ptr TextTagTable00](self.impl), `func`, data)

type
  TextViewLayer* {.size: sizeof(cint), pure.} = enum
    belowText = 0
    aboveText = 1

type
  TickCallback* = proc (widget: ptr Widget00; frameClock: ptr gdk4.FrameClock00; userData: pointer): gboolean {.cdecl.}

proc gtk_widget_add_tick_callback(self: ptr Widget00; callback: TickCallback;
    userData: pointer; notify: DestroyNotify): uint32 {.
    importc, libprag.}

proc addTickCallback*(self: Widget; callback: TickCallback; userData: pointer;
    notify: DestroyNotify): int =
  int(gtk_widget_add_tick_callback(cast[ptr Widget00](self.impl), callback, userData, notify))

type
  TreeCellDataFunc* = proc (treeColumn: ptr TreeViewColumn00; cell: ptr CellRenderer00; treeModel: ptr TreeModel00;
    iter: TreeIter; data: pointer) {.cdecl.}

proc gtk_tree_view_column_set_cell_data_func(self: ptr TreeViewColumn00;
    cellRenderer: ptr CellRenderer00; `func`: TreeCellDataFunc; funcData: pointer;
    destroy: DestroyNotify) {.
    importc, libprag.}

proc setCellDataFunc*(self: TreeViewColumn; cellRenderer: CellRenderer;
    `func`: TreeCellDataFunc; funcData: pointer; destroy: DestroyNotify) =
  gtk_tree_view_column_set_cell_data_func(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl), `func`, funcData, destroy)

proc gtk_tree_view_insert_column_with_data_func(self: ptr TreeView00; position: int32;
    title: cstring; cell: ptr CellRenderer00; `func`: TreeCellDataFunc; data: pointer;
    dnotify: DestroyNotify): int32 {.
    importc, libprag.}

proc insertColumnWithDataFunc*(self: TreeView; position: int;
    title: cstring; cell: CellRenderer; `func`: TreeCellDataFunc; data: pointer;
    dnotify: DestroyNotify): int =
  int(gtk_tree_view_insert_column_with_data_func(cast[ptr TreeView00](self.impl), int32(position), title, cast[ptr CellRenderer00](cell.impl), `func`, data, dnotify))

type
  TreeDragDest00* = object of gobject.Object00
  TreeDragDest* = ref object of gobject.Object

proc gtk_tree_drag_dest_drag_data_received(self: ptr TreeDragDest00; dest: ptr TreePath00;
    value: gobject.Value): gboolean {.
    importc, libprag.}

proc dragDataReceived*(self: TreeDragDest | TreeStore | ListStore;
    dest: TreePath; value: gobject.Value): bool =
  toBool(gtk_tree_drag_dest_drag_data_received(cast[ptr TreeDragDest00](self.impl), cast[ptr TreePath00](dest.impl), value))

proc gtk_tree_drag_dest_row_drop_possible(self: ptr TreeDragDest00; destPath: ptr TreePath00;
    value: gobject.Value): gboolean {.
    importc, libprag.}

proc rowDropPossible*(self: TreeDragDest | TreeStore | ListStore;
    destPath: TreePath; value: gobject.Value): bool =
  toBool(gtk_tree_drag_dest_row_drop_possible(cast[ptr TreeDragDest00](self.impl), cast[ptr TreePath00](destPath.impl), value))

type
  TreeDragSource00* = object of gobject.Object00
  TreeDragSource* = ref object of gobject.Object

proc gtk_tree_drag_source_drag_data_delete(self: ptr TreeDragSource00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc dragDataDelete*(self: TreeDragSource | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath): bool =
  toBool(gtk_tree_drag_source_drag_data_delete(cast[ptr TreeDragSource00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_drag_source_drag_data_get(self: ptr TreeDragSource00; path: ptr TreePath00): ptr gdk4.ContentProvider00 {.
    importc, libprag.}

proc dragDataGet*(self: TreeDragSource | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath): gdk4.ContentProvider =
  let gobj = gtk_tree_drag_source_drag_data_get(cast[ptr TreeDragSource00](self.impl), cast[ptr TreePath00](path.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_drag_source_row_draggable(self: ptr TreeDragSource00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc rowDraggable*(self: TreeDragSource | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath): bool =
  toBool(gtk_tree_drag_source_row_draggable(cast[ptr TreeDragSource00](self.impl), cast[ptr TreePath00](path.impl)))

type
  TreeIterCompareFunc* = proc (model: ptr TreeModel00; a: TreeIter; b: TreeIter; userData: pointer): int32 {.cdecl.}

type
  TreeListModel* = ref object of gobject.Object
  TreeListModel00* = object of gobject.Object00

proc gtk_tree_list_model_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeListModel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_list_model_get_autoexpand(self: ptr TreeListModel00): gboolean {.
    importc, libprag.}

proc getAutoexpand*(self: TreeListModel): bool =
  toBool(gtk_tree_list_model_get_autoexpand(cast[ptr TreeListModel00](self.impl)))

proc autoexpand*(self: TreeListModel): bool =
  toBool(gtk_tree_list_model_get_autoexpand(cast[ptr TreeListModel00](self.impl)))

proc gtk_tree_list_model_get_child_row(self: ptr TreeListModel00; position: uint32): ptr TreeListRow00 {.
    importc, libprag.}

proc getChildRow*(self: TreeListModel; position: int): TreeListRow =
  let gobj = gtk_tree_list_model_get_child_row(cast[ptr TreeListModel00](self.impl), uint32(position))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_list_model_get_model(self: ptr TreeListModel00): ptr gio.ListModel00 {.
    importc, libprag.}

proc getModel*(self: TreeListModel): gio.ListModel =
  let gobj = gtk_tree_list_model_get_model(cast[ptr TreeListModel00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: TreeListModel): gio.ListModel =
  let gobj = gtk_tree_list_model_get_model(cast[ptr TreeListModel00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_list_model_get_passthrough(self: ptr TreeListModel00): gboolean {.
    importc, libprag.}

proc getPassthrough*(self: TreeListModel): bool =
  toBool(gtk_tree_list_model_get_passthrough(cast[ptr TreeListModel00](self.impl)))

proc passthrough*(self: TreeListModel): bool =
  toBool(gtk_tree_list_model_get_passthrough(cast[ptr TreeListModel00](self.impl)))

proc gtk_tree_list_model_get_row(self: ptr TreeListModel00; position: uint32): ptr TreeListRow00 {.
    importc, libprag.}

proc getRow*(self: TreeListModel; position: int): TreeListRow =
  let gobj = gtk_tree_list_model_get_row(cast[ptr TreeListModel00](self.impl), uint32(position))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_list_model_set_autoexpand(self: ptr TreeListModel00; autoexpand: gboolean) {.
    importc, libprag.}

proc setAutoexpand*(self: TreeListModel; autoexpand: bool = true) =
  gtk_tree_list_model_set_autoexpand(cast[ptr TreeListModel00](self.impl), gboolean(autoexpand))

proc `autoexpand=`*(self: TreeListModel; autoexpand: bool) =
  gtk_tree_list_model_set_autoexpand(cast[ptr TreeListModel00](self.impl), gboolean(autoexpand))

type
  TreeListModelCreateModelFunc* = proc (item: ptr gobject.Object00; userData: pointer): ptr gio.ListModel00 {.cdecl.}

proc gtk_tree_list_model_new(root: ptr gio.ListModel00; passthrough: gboolean;
    autoexpand: gboolean; createFunc: TreeListModelCreateModelFunc; userData: pointer;
    userDestroy: DestroyNotify): ptr TreeListModel00 {.
    importc, libprag.}

proc newTreeListModel*(root: gio.ListModel; passthrough: bool; autoexpand: bool;
    createFunc: TreeListModelCreateModelFunc; userData: pointer; userDestroy: DestroyNotify): TreeListModel =
  let gobj = gtk_tree_list_model_new(cast[ptr gio.ListModel00](g_object_ref(root.impl)), gboolean(passthrough), gboolean(autoexpand), createFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeListModel*(tdesc: typedesc; root: gio.ListModel; passthrough: bool; autoexpand: bool;
    createFunc: TreeListModelCreateModelFunc; userData: pointer; userDestroy: DestroyNotify): tdesc =
  assert(result is TreeListModel)
  let gobj = gtk_tree_list_model_new(cast[ptr gio.ListModel00](g_object_ref(root.impl)), gboolean(passthrough), gboolean(autoexpand), createFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeListModel*[T](result: var T; root: gio.ListModel; passthrough: bool; autoexpand: bool;
    createFunc: TreeListModelCreateModelFunc; userData: pointer; userDestroy: DestroyNotify) {.deprecated.} =
  assert(result is TreeListModel)
  let gobj = gtk_tree_list_model_new(cast[ptr gio.ListModel00](g_object_ref(root.impl)), gboolean(passthrough), gboolean(autoexpand), createFunc, userData, userDestroy)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TreeListRowSorter* = ref object of Sorter
  TreeListRowSorter00* = object of Sorter00

proc gtk_tree_list_row_sorter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeListRowSorter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_list_row_sorter_new(sorter: ptr Sorter00): ptr TreeListRowSorter00 {.
    importc, libprag.}

proc newTreeListRowSorter*(sorter: Sorter = nil): TreeListRowSorter =
  let gobj = gtk_tree_list_row_sorter_new(if sorter.isNil: nil else: cast[ptr Sorter00](g_object_ref(sorter.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeListRowSorter*(tdesc: typedesc; sorter: Sorter = nil): tdesc =
  assert(result is TreeListRowSorter)
  let gobj = gtk_tree_list_row_sorter_new(if sorter.isNil: nil else: cast[ptr Sorter00](g_object_ref(sorter.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeListRowSorter*[T](result: var T; sorter: Sorter = nil) {.deprecated.} =
  assert(result is TreeListRowSorter)
  let gobj = gtk_tree_list_row_sorter_new(if sorter.isNil: nil else: cast[ptr Sorter00](g_object_ref(sorter.impl)))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_list_row_sorter_get_sorter(self: ptr TreeListRowSorter00): ptr Sorter00 {.
    importc, libprag.}

proc getSorter*(self: TreeListRowSorter): Sorter =
  let gobj = gtk_tree_list_row_sorter_get_sorter(cast[ptr TreeListRowSorter00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc sorter*(self: TreeListRowSorter): Sorter =
  let gobj = gtk_tree_list_row_sorter_get_sorter(cast[ptr TreeListRowSorter00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_list_row_sorter_set_sorter(self: ptr TreeListRowSorter00; sorter: ptr Sorter00) {.
    importc, libprag.}

proc setSorter*(self: TreeListRowSorter; sorter: Sorter = nil) =
  gtk_tree_list_row_sorter_set_sorter(cast[ptr TreeListRowSorter00](self.impl), if sorter.isNil: nil else: cast[ptr Sorter00](sorter.impl))

proc `sorter=`*(self: TreeListRowSorter; sorter: Sorter = nil) =
  gtk_tree_list_row_sorter_set_sorter(cast[ptr TreeListRowSorter00](self.impl), if sorter.isNil: nil else: cast[ptr Sorter00](sorter.impl))

type
  TreeModelFilterModifyFunc* = proc (model: ptr TreeModel00; iter: TreeIter; value: var gobject.Value; column: int32;
    data: pointer) {.cdecl.}

proc gtk_tree_model_filter_set_modify_func(self: ptr TreeModelFilter00; nColumns: int32;
    types: ptr GType; `func`: TreeModelFilterModifyFunc; data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setModifyFunc*(self: TreeModelFilter; nColumns: int;
    types: ptr GType; `func`: TreeModelFilterModifyFunc; data: pointer; destroy: DestroyNotify) =
  gtk_tree_model_filter_set_modify_func(cast[ptr TreeModelFilter00](self.impl), int32(nColumns), types, `func`, data, destroy)

type
  TreeModelFilterVisibleFunc* = proc (model: ptr TreeModel00; iter: TreeIter; data: pointer): gboolean {.cdecl.}

proc gtk_tree_model_filter_set_visible_func(self: ptr TreeModelFilter00;
    `func`: TreeModelFilterVisibleFunc; data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setVisibleFunc*(self: TreeModelFilter; `func`: TreeModelFilterVisibleFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_model_filter_set_visible_func(cast[ptr TreeModelFilter00](self.impl), `func`, data, destroy)

type
  TreeModelForeachFunc* = proc (model: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; data: pointer): gboolean {.cdecl.}

proc gtk_tree_model_foreach(self: ptr TreeModel00; `func`: TreeModelForeachFunc;
    userData: pointer) {.
    importc, libprag.}

proc foreach*(self: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    `func`: TreeModelForeachFunc; userData: pointer) =
  gtk_tree_model_foreach(cast[ptr TreeModel00](self.impl), `func`, userData)


type
  TreeRowReference00* {.pure.} = object
  TreeRowReference* = ref object
    impl*: ptr TreeRowReference00
    ignoreFinalizer*: bool

proc gtk_tree_row_reference_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkTreeRowReference*(self: TreeRowReference) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_tree_row_reference_get_type(), cast[ptr TreeRowReference00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeRowReference()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_tree_row_reference_get_type(), cast[ptr TreeRowReference00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var TreeRowReference) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkTreeRowReference)

proc gtk_tree_row_reference_free(self: ptr TreeRowReference00) {.
    importc, libprag.}

proc free*(self: TreeRowReference) =
  gtk_tree_row_reference_free(cast[ptr TreeRowReference00](self.impl))

proc finalizerfree*(self: TreeRowReference) =
  if not self.ignoreFinalizer:
    gtk_tree_row_reference_free(cast[ptr TreeRowReference00](self.impl))

proc gtk_tree_row_reference_new_proxy(proxy: ptr gobject.Object00; model: ptr TreeModel00;
    path: ptr TreePath00): ptr TreeRowReference00 {.
    importc, libprag.}

proc newTreeRowReferenceProxy*(proxy: gobject.Object; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath): TreeRowReference {.deprecated.}  =
  let impl0 = gtk_tree_row_reference_new_proxy(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = impl0

proc newTreeRowReferenceProxy*(tdesc: typedesc; proxy: gobject.Object; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath): tdesc {.deprecated.}  =
  assert(result is TreeRowReference)
  let impl0 = gtk_tree_row_reference_new_proxy(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = impl0

proc initTreeRowReferenceProxy*[T](result: var T; proxy: gobject.Object; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath) {.deprecated.} =
  assert(result is TreeRowReference)
  let impl0 = gtk_tree_row_reference_new_proxy(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = impl0

proc gtk_tree_row_reference_copy(self: ptr TreeRowReference00): ptr TreeRowReference00 {.
    importc, libprag.}

proc copy*(self: TreeRowReference): TreeRowReference =
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = gtk_tree_row_reference_copy(cast[ptr TreeRowReference00](self.impl))

proc gtk_tree_row_reference_new(model: ptr TreeModel00; path: ptr TreePath00): ptr TreeRowReference00 {.
    importc, libprag.}

proc newTreeRowReference*(model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath): TreeRowReference {.deprecated.}  =
  let impl0 = gtk_tree_row_reference_new(cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = impl0

proc newTreeRowReference*(tdesc: typedesc; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath): tdesc {.deprecated.}  =
  assert(result is TreeRowReference)
  let impl0 = gtk_tree_row_reference_new(cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = impl0

proc initTreeRowReference*[T](result: var T; model: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath) {.deprecated.} =
  assert(result is TreeRowReference)
  let impl0 = gtk_tree_row_reference_new(cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = impl0

proc gtk_tree_row_reference_get_model(self: ptr TreeRowReference00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: TreeRowReference): TreeModel =
  let gobj = gtk_tree_row_reference_get_model(cast[ptr TreeRowReference00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: TreeRowReference): TreeModel =
  let gobj = gtk_tree_row_reference_get_model(cast[ptr TreeRowReference00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_row_reference_get_path(self: ptr TreeRowReference00): ptr TreePath00 {.
    importc, libprag.}

proc getPath*(self: TreeRowReference): TreePath =
  let impl0 = gtk_tree_row_reference_get_path(cast[ptr TreeRowReference00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc path*(self: TreeRowReference): TreePath =
  let impl0 = gtk_tree_row_reference_get_path(cast[ptr TreeRowReference00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_row_reference_valid(self: ptr TreeRowReference00): gboolean {.
    importc, libprag.}

proc valid*(self: TreeRowReference): bool =
  toBool(gtk_tree_row_reference_valid(cast[ptr TreeRowReference00](self.impl)))

proc gtk_tree_row_reference_deleted(proxy: ptr gobject.Object00; path: ptr TreePath00) {.
    importc, libprag.}

proc deleted*(proxy: gobject.Object; path: TreePath) =
  gtk_tree_row_reference_deleted(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_row_reference_inserted(proxy: ptr gobject.Object00; path: ptr TreePath00) {.
    importc, libprag.}

proc inserted*(proxy: gobject.Object; path: TreePath) =
  gtk_tree_row_reference_inserted(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreePath00](path.impl))

type
  TreeSelectionForeachFunc* = proc (model: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; data: pointer) {.cdecl.}

proc gtk_tree_selection_selected_foreach(self: ptr TreeSelection00; `func`: TreeSelectionForeachFunc;
    data: pointer) {.
    importc, libprag.}

proc selectedForeach*(self: TreeSelection; `func`: TreeSelectionForeachFunc;
    data: pointer) =
  gtk_tree_selection_selected_foreach(cast[ptr TreeSelection00](self.impl), `func`, data)

type
  TreeSelectionFunc* = proc (selection: ptr TreeSelection00; model: ptr TreeModel00; path: ptr TreePath00;
    pathCurrentlySelected: gboolean; data: pointer): gboolean {.cdecl.}

proc gtk_tree_selection_set_select_function(self: ptr TreeSelection00; `func`: TreeSelectionFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setSelectFunction*(self: TreeSelection; `func`: TreeSelectionFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_selection_set_select_function(cast[ptr TreeSelection00](self.impl), `func`, data, destroy)

type
  TreeSortable00* = object of gobject.Object00
  TreeSortable* = ref object of gobject.Object

proc scSortColumnChanged*(self: TreeSortable | TreeModelSort | TreeStore | ListStore;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "sort-column-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_sortable_get_sort_column_id(self: ptr TreeSortable00; sortColumnId: var int32;
    order: var SortType): gboolean {.
    importc, libprag.}

proc getSortColumnId*(self: TreeSortable | TreeModelSort | TreeStore | ListStore;
    sortColumnId: var int; order: var SortType): bool =
  var sortColumnId_00: int32
  result = toBool(gtk_tree_sortable_get_sort_column_id(cast[ptr TreeSortable00](self.impl), sortColumnId_00, order))
  if sortColumnId.addr != nil:
    sortColumnId = int(sortColumnId_00)

proc gtk_tree_sortable_has_default_sort_func(self: ptr TreeSortable00): gboolean {.
    importc, libprag.}

proc hasDefaultSortFunc*(self: TreeSortable | TreeModelSort | TreeStore | ListStore): bool =
  toBool(gtk_tree_sortable_has_default_sort_func(cast[ptr TreeSortable00](self.impl)))

proc gtk_tree_sortable_set_default_sort_func(self: ptr TreeSortable00; sortFunc: TreeIterCompareFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setDefaultSortFunc*(self: TreeSortable | TreeModelSort | TreeStore | ListStore;
    sortFunc: TreeIterCompareFunc; userData: pointer; destroy: DestroyNotify) =
  gtk_tree_sortable_set_default_sort_func(cast[ptr TreeSortable00](self.impl), sortFunc, userData, destroy)

proc gtk_tree_sortable_set_sort_column_id(self: ptr TreeSortable00; sortColumnId: int32;
    order: SortType) {.
    importc, libprag.}

proc setSortColumnId*(self: TreeSortable | TreeModelSort | TreeStore | ListStore;
    sortColumnId: int; order: SortType) =
  gtk_tree_sortable_set_sort_column_id(cast[ptr TreeSortable00](self.impl), int32(sortColumnId), order)

proc gtk_tree_sortable_set_sort_func(self: ptr TreeSortable00; sortColumnId: int32;
    sortFunc: TreeIterCompareFunc; userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setSortFunc*(self: TreeSortable | TreeModelSort | TreeStore | ListStore;
    sortColumnId: int; sortFunc: TreeIterCompareFunc; userData: pointer; destroy: DestroyNotify) =
  gtk_tree_sortable_set_sort_func(cast[ptr TreeSortable00](self.impl), int32(sortColumnId), sortFunc, userData, destroy)

proc gtk_tree_sortable_sort_column_changed(self: ptr TreeSortable00) {.
    importc, libprag.}

proc sortColumnChanged*(self: TreeSortable | TreeModelSort | TreeStore | ListStore) =
  gtk_tree_sortable_sort_column_changed(cast[ptr TreeSortable00](self.impl))

type
  TreeViewColumnDropFunc* = proc (treeView: ptr TreeView00; column: ptr TreeViewColumn00; prevColumn: ptr TreeViewColumn00;
    nextColumn: ptr TreeViewColumn00; data: pointer): gboolean {.cdecl.}

proc gtk_tree_view_set_column_drag_function(self: ptr TreeView00; `func`: TreeViewColumnDropFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setColumnDragFunction*(self: TreeView; `func`: TreeViewColumnDropFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_tree_view_set_column_drag_function(cast[ptr TreeView00](self.impl), `func`, userData, destroy)

type
  TreeViewMappingFunc* = proc (treeView: ptr TreeView00; path: ptr TreePath00; userData: pointer) {.cdecl.}

proc gtk_tree_view_map_expanded_rows(self: ptr TreeView00; `func`: TreeViewMappingFunc;
    data: pointer) {.
    importc, libprag.}

proc mapExpandedRows*(self: TreeView; `func`: TreeViewMappingFunc;
    data: pointer) =
  gtk_tree_view_map_expanded_rows(cast[ptr TreeView00](self.impl), `func`, data)

type
  TreeViewRowSeparatorFunc* = proc (model: ptr TreeModel00; iter: TreeIter; data: pointer): gboolean {.cdecl.}

proc gtk_combo_box_set_row_separator_func(self: ptr ComboBox00; `func`: TreeViewRowSeparatorFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setRowSeparatorFunc*(self: ComboBox; `func`: TreeViewRowSeparatorFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_combo_box_set_row_separator_func(cast[ptr ComboBox00](self.impl), `func`, data, destroy)

proc gtk_tree_view_set_row_separator_func(self: ptr TreeView00; `func`: TreeViewRowSeparatorFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setRowSeparatorFunc*(self: TreeView; `func`: TreeViewRowSeparatorFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_view_set_row_separator_func(cast[ptr TreeView00](self.impl), `func`, data, destroy)

type
  TreeViewSearchEqualFunc* = proc (model: ptr TreeModel00; column: int32; key: cstring; iter: TreeIter;
    searchData: pointer): gboolean {.cdecl.}

proc gtk_tree_view_set_search_equal_func(self: ptr TreeView00; searchEqualFunc: TreeViewSearchEqualFunc;
    searchUserData: pointer; searchDestroy: DestroyNotify) {.
    importc, libprag.}

proc setSearchEqualFunc*(self: TreeView; searchEqualFunc: TreeViewSearchEqualFunc;
    searchUserData: pointer; searchDestroy: DestroyNotify) =
  gtk_tree_view_set_search_equal_func(cast[ptr TreeView00](self.impl), searchEqualFunc, searchUserData, searchDestroy)

type
  UriLauncher* = ref object of gobject.Object
  UriLauncher00* = object of gobject.Object00

proc gtk_uri_launcher_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(UriLauncher()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_uri_launcher_new(uri: cstring): ptr UriLauncher00 {.
    importc, libprag.}

proc newUriLauncher*(uri: cstring = nil): UriLauncher =
  let gobj = gtk_uri_launcher_new(uri)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newUriLauncher*(tdesc: typedesc; uri: cstring = nil): tdesc =
  assert(result is UriLauncher)
  let gobj = gtk_uri_launcher_new(uri)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initUriLauncher*[T](result: var T; uri: cstring = nil) {.deprecated.} =
  assert(result is UriLauncher)
  let gobj = gtk_uri_launcher_new(uri)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_uri_launcher_get_uri(self: ptr UriLauncher00): cstring {.
    importc, libprag.}

proc getUri*(self: UriLauncher): string =
  let resul0 = gtk_uri_launcher_get_uri(cast[ptr UriLauncher00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc uri*(self: UriLauncher): string =
  let resul0 = gtk_uri_launcher_get_uri(cast[ptr UriLauncher00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_uri_launcher_launch(self: ptr UriLauncher00; parent: ptr Window00;
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc launch*(self: UriLauncher; parent: Window = nil; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_uri_launcher_launch(cast[ptr UriLauncher00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_uri_launcher_launch_finish(self: ptr UriLauncher00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc launchFinish*(self: UriLauncher; resu: gio.AsyncResult): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_uri_launcher_launch_finish(cast[ptr UriLauncher00](self.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_uri_launcher_set_uri(self: ptr UriLauncher00; uri: cstring) {.
    importc, libprag.}

proc setUri*(self: UriLauncher; uri: cstring = nil) =
  gtk_uri_launcher_set_uri(cast[ptr UriLauncher00](self.impl), uri)

proc `uri=`*(self: UriLauncher; uri: cstring = nil) =
  gtk_uri_launcher_set_uri(cast[ptr UriLauncher00](self.impl), uri)

type
  WidgetActionActivateFunc* = proc (widget: ptr Widget00; actionName: cstring; parameter: ptr glib.Variant00) {.cdecl.}

type
  WidgetPaintable* = ref object of gobject.Object
  WidgetPaintable00* = object of gobject.Object00

proc gtk_widget_paintable_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(WidgetPaintable()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_widget_paintable_new(widget: ptr Widget00): ptr WidgetPaintable00 {.
    importc, libprag.}

proc newWidgetPaintable*(widget: Widget = nil): WidgetPaintable =
  let gobj = gtk_widget_paintable_new(if widget.isNil: nil else: cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newWidgetPaintable*(tdesc: typedesc; widget: Widget = nil): tdesc =
  assert(result is WidgetPaintable)
  let gobj = gtk_widget_paintable_new(if widget.isNil: nil else: cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initWidgetPaintable*[T](result: var T; widget: Widget = nil) {.deprecated.} =
  assert(result is WidgetPaintable)
  let gobj = gtk_widget_paintable_new(if widget.isNil: nil else: cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_paintable_get_widget(self: ptr WidgetPaintable00): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: WidgetPaintable): Widget =
  let gobj = gtk_widget_paintable_get_widget(cast[ptr WidgetPaintable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: WidgetPaintable): Widget =
  let gobj = gtk_widget_paintable_get_widget(cast[ptr WidgetPaintable00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_paintable_set_widget(self: ptr WidgetPaintable00; widget: ptr Widget00) {.
    importc, libprag.}

proc setWidget*(self: WidgetPaintable; widget: Widget = nil) =
  gtk_widget_paintable_set_widget(cast[ptr WidgetPaintable00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `widget=`*(self: WidgetPaintable; widget: Widget = nil) =
  gtk_widget_paintable_set_widget(cast[ptr WidgetPaintable00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc acceleratorGetDefaultModMask*(): gdk4.ModifierType {.
    importc: "gtk_accelerator_get_default_mod_mask", libprag.}

proc gtk_accelerator_get_label(acceleratorKey: uint32; acceleratorMods: gdk4.ModifierType): cstring {.
    importc, libprag.}

proc acceleratorGetLabel*(acceleratorKey: int; acceleratorMods: gdk4.ModifierType): string =
  let resul0 = gtk_accelerator_get_label(uint32(acceleratorKey), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_get_label_with_keycode(display: ptr gdk4.Display00;
    acceleratorKey: uint32; keycode: uint32; acceleratorMods: gdk4.ModifierType): cstring {.
    importc, libprag.}

proc acceleratorGetLabelWithKeycode*(display: gdk4.Display = nil;
    acceleratorKey: int; keycode: int; acceleratorMods: gdk4.ModifierType): string =
  let resul0 = gtk_accelerator_get_label_with_keycode(if display.isNil: nil else: cast[ptr gdk4.Display00](display.impl), uint32(acceleratorKey), uint32(keycode), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_name(acceleratorKey: uint32; acceleratorMods: gdk4.ModifierType): cstring {.
    importc, libprag.}

proc acceleratorName*(acceleratorKey: int; acceleratorMods: gdk4.ModifierType): string =
  let resul0 = gtk_accelerator_name(uint32(acceleratorKey), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_name_with_keycode(display: ptr gdk4.Display00; acceleratorKey: uint32;
    keycode: uint32; acceleratorMods: gdk4.ModifierType): cstring {.
    importc, libprag.}

proc acceleratorNameWithKeycode*(display: gdk4.Display = nil; acceleratorKey: int;
    keycode: int; acceleratorMods: gdk4.ModifierType): string =
  let resul0 = gtk_accelerator_name_with_keycode(if display.isNil: nil else: cast[ptr gdk4.Display00](display.impl), uint32(acceleratorKey), uint32(keycode), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_parse(accelerator: cstring; acceleratorKey: var uint32;
    acceleratorMods: var gdk4.ModifierType): gboolean {.
    importc, libprag.}

proc acceleratorParse*(accelerator: cstring; acceleratorKey: var int = cast[var int](nil);
    acceleratorMods: var gdk4.ModifierType = cast[var gdk4.ModifierType](nil)): bool =
  var acceleratorKey_00: uint32
  result = toBool(gtk_accelerator_parse(accelerator, acceleratorKey_00, acceleratorMods))
  if acceleratorKey.addr != nil:
    acceleratorKey = int(acceleratorKey_00)

proc gtk_accelerator_valid(keyval: uint32; modifiers: gdk4.ModifierType): gboolean {.
    importc, libprag.}

proc acceleratorValid*(keyval: int; modifiers: gdk4.ModifierType): bool =
  toBool(gtk_accelerator_valid(uint32(keyval), modifiers))

proc gtk_check_version(requiredMajor: uint32; requiredMinor: uint32; requiredMicro: uint32): cstring {.
    importc, libprag.}

proc checkVersion*(requiredMajor: int; requiredMinor: int; requiredMicro: int): string =
  let resul0 = gtk_check_version(uint32(requiredMajor), uint32(requiredMinor), uint32(requiredMicro))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_css_parser_error_quark(): uint32 {.
    importc, libprag.}

proc cssParserErrorQuark*(): int =
  int(gtk_css_parser_error_quark())

proc gtk_css_parser_warning_quark(): uint32 {.
    importc, libprag.}

proc cssParserWarningQuark*(): int =
  int(gtk_css_parser_warning_quark())

proc disableSetlocale*() {.
    importc: "gtk_disable_setlocale", libprag.}

proc gtk_distribute_natural_allocation(extraSpace: int32; nRequestedSizes: uint32;
    sizes: ptr RequestedSize): int32 {.
    importc, libprag.}

proc distributeNaturalAllocation*(extraSpace: int; nRequestedSizes: int;
    sizes: ptr RequestedSize): int =
  int(gtk_distribute_natural_allocation(int32(extraSpace), uint32(nRequestedSizes), sizes))

proc gtk_enumerate_printers(`func`: PrinterFunc; data: pointer; destroy: DestroyNotify;
    wait: gboolean) {.
    importc, libprag.}

proc enumeratePrinters*(`func`: PrinterFunc; data: pointer; destroy: DestroyNotify;
    wait: bool) =
  gtk_enumerate_printers(`func`, data, destroy, gboolean(wait))

proc gtk_get_binary_age(): uint32 {.
    importc, libprag.}

proc getBinaryAge*(): int =
  int(gtk_get_binary_age())

proc getDebugFlags*(): DebugFlags {.
    importc: "gtk_get_debug_flags", libprag.}

proc gtk_get_default_language(): ptr pango.Language00 {.
    importc, libprag.}

proc getDefaultLanguage*(): pango.Language =
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = gtk_get_default_language()
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_language_get_type(), result.impl))

proc gtk_get_interface_age(): uint32 {.
    importc, libprag.}

proc getInterfaceAge*(): int =
  int(gtk_get_interface_age())

proc getLocaleDirection*(): TextDirection {.
    importc: "gtk_get_locale_direction", libprag.}

proc gtk_get_major_version(): uint32 {.
    importc, libprag.}

proc getMajorVersion*(): int =
  int(gtk_get_major_version())

proc gtk_get_micro_version(): uint32 {.
    importc, libprag.}

proc getMicroVersion*(): int =
  int(gtk_get_micro_version())

proc gtk_get_minor_version(): uint32 {.
    importc, libprag.}

proc getMinorVersion*(): int =
  int(gtk_get_minor_version())

proc hsvToRgb*(h: cfloat; s: cfloat; v: cfloat; r: var cfloat; g: var cfloat;
    b: var cfloat) {.
    importc: "gtk_hsv_to_rgb", libprag.}

proc init*() {.
    importc: "gtk_init", libprag.}

proc gtk_init_check(): gboolean {.
    importc, libprag.}

proc initCheck*(): bool =
  toBool(gtk_init_check())

proc gtk_is_initialized(): gboolean {.
    importc, libprag.}

proc isInitialized*(): bool =
  toBool(gtk_is_initialized())

proc gtk_param_spec_expression(name: cstring; nick: cstring; blurb: cstring;
    flags: gobject.ParamFlags): ptr gobject.ParamSpec00 {.
    importc, libprag.}

proc paramSpecExpression*(name: cstring; nick: cstring; blurb: cstring;
    flags: gobject.ParamFlags): gobject.ParamSpec =
  fnew(result, generic_g_param_spec_unref)
  result.impl = gtk_param_spec_expression(name, nick, blurb, flags)

proc gtk_print_run_page_setup_dialog(parent: ptr Window00; pageSetup: ptr PageSetup00;
    settings: ptr PrintSettings00): ptr PageSetup00 {.
    importc, libprag.}

proc printRunPageSetupDialog*(parent: Window = nil; pageSetup: PageSetup = nil;
    settings: PrintSettings): PageSetup =
  let gobj = gtk_print_run_page_setup_dialog(if parent.isNil: nil else: cast[ptr Window00](parent.impl), if pageSetup.isNil: nil else: cast[ptr PageSetup00](pageSetup.impl), cast[ptr PrintSettings00](settings.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_run_page_setup_dialog_async(parent: ptr Window00; pageSetup: ptr PageSetup00;
    settings: ptr PrintSettings00; doneCb: PageSetupDoneFunc; data: pointer) {.
    importc, libprag.}

proc printRunPageSetupDialogAsync*(parent: Window = nil; pageSetup: PageSetup = nil;
    settings: PrintSettings; doneCb: PageSetupDoneFunc; data: pointer) =
  gtk_print_run_page_setup_dialog_async(if parent.isNil: nil else: cast[ptr Window00](parent.impl), if pageSetup.isNil: nil else: cast[ptr PageSetup00](pageSetup.impl), cast[ptr PrintSettings00](settings.impl), doneCb, data)

proc gtk_render_activity(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderActivity*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_activity(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_arrow(context: ptr StyleContext00; cr: ptr cairo.Context00;
    angle: cdouble; x: cdouble; y: cdouble; size: cdouble) {.
    importc, libprag.}

proc renderArrow*(context: StyleContext; cr: cairo.Context; angle: cdouble;
    x: cdouble; y: cdouble; size: cdouble) =
  gtk_render_arrow(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), angle, x, y, size)

proc gtk_render_background(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderBackground*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_background(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_check(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderCheck*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_check(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_expander(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderExpander*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_expander(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_focus(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderFocus*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_focus(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_frame(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderFrame*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_frame(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_handle(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderHandle*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_handle(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_icon(context: ptr StyleContext00; cr: ptr cairo.Context00;
    texture: ptr gdk4.Texture00; x: cdouble; y: cdouble) {.
    importc, libprag.}

proc renderIcon*(context: StyleContext; cr: cairo.Context; texture: gdk4.Texture;
    x: cdouble; y: cdouble) =
  gtk_render_icon(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr gdk4.Texture00](texture.impl), x, y)

proc gtk_render_layout(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; layout: ptr pango.Layout00) {.
    importc, libprag.}

proc renderLayout*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; layout: pango.Layout) =
  gtk_render_layout(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, cast[ptr pango.Layout00](layout.impl))

proc gtk_render_line(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble) {.
    importc, libprag.}

proc renderLine*(context: StyleContext; cr: cairo.Context; x0: cdouble;
    y0: cdouble; x1: cdouble; y1: cdouble) =
  gtk_render_line(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x0, y0, x1, y1)

proc gtk_render_option(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderOption*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_option(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc rgbToHsv*(r: cfloat; g: cfloat; b: cfloat; h: var cfloat; s: var cfloat;
    v: var cfloat) {.
    importc: "gtk_rgb_to_hsv", libprag.}

proc setDebugFlags*(flags: DebugFlags) {.
    importc: "gtk_set_debug_flags", libprag.}

proc gtk_show_uri(parent: ptr Window00; uri: cstring; timestamp: uint32) {.
    importc, libprag.}

proc showUri*(parent: Window = nil; uri: cstring; timestamp: int) =
  gtk_show_uri(if parent.isNil: nil else: cast[ptr Window00](parent.impl), uri, uint32(timestamp))

proc gtk_show_uri_full(parent: ptr Window00; uri: cstring; timestamp: uint32;
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc showUriFull*(parent: Window = nil; uri: cstring; timestamp: int;
    cancellable: gio.Cancellable = nil; callback: AsyncReadyCallback; userData: pointer) =
  gtk_show_uri_full(if parent.isNil: nil else: cast[ptr Window00](parent.impl), uri, uint32(timestamp), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_show_uri_full_finish(parent: ptr Window00; resu: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc showUriFullFinish*(parent: Window; resu: gio.AsyncResult): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_show_uri_full_finish(cast[ptr Window00](parent.impl), cast[ptr gio.AsyncResult00](resu.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_test_accessible_assertion_message_role(domain: cstring; file: cstring;
    line: int32; `func`: cstring; expr: cstring; accessible: ptr Accessible00;
    expectedRole: AccessibleRole; actualRole: AccessibleRole) {.
    importc, libprag.}

proc testAccessibleAssertionMessageRole*(domain: cstring; file: cstring;
    line: int; `func`: cstring; expr: cstring; accessible: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    expectedRole: AccessibleRole; actualRole: AccessibleRole) =
  gtk_test_accessible_assertion_message_role(domain, file, int32(line), `func`, expr, cast[ptr Accessible00](accessible.impl), expectedRole, actualRole)

proc gtk_test_accessible_has_property(accessible: ptr Accessible00; property: AccessibleProperty): gboolean {.
    importc, libprag.}

proc testAccessibleHasProperty*(accessible: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    property: AccessibleProperty): bool =
  toBool(gtk_test_accessible_has_property(cast[ptr Accessible00](accessible.impl), property))

proc gtk_test_accessible_has_relation(accessible: ptr Accessible00; relation: AccessibleRelation): gboolean {.
    importc, libprag.}

proc testAccessibleHasRelation*(accessible: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    relation: AccessibleRelation): bool =
  toBool(gtk_test_accessible_has_relation(cast[ptr Accessible00](accessible.impl), relation))

proc gtk_test_accessible_has_role(accessible: ptr Accessible00; role: AccessibleRole): gboolean {.
    importc, libprag.}

proc testAccessibleHasRole*(accessible: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    role: AccessibleRole): bool =
  toBool(gtk_test_accessible_has_role(cast[ptr Accessible00](accessible.impl), role))

proc gtk_test_accessible_has_state(accessible: ptr Accessible00; state: AccessibleState): gboolean {.
    importc, libprag.}

proc testAccessibleHasState*(accessible: Accessible | FlowBox | EmojiChooser | FontChooserDialog | ShortcutsWindow | Viewport | TreeExpander | Scale | Inscription | GLArea | Dialog | MediaControls | FileChooserDialog | FontButton | ShortcutsGroup | ColorChooserWidget | LinkButton | Range | Stack | ComboBox | Image | AboutDialog | ListBox | ScrolledWindow | Overlay | Frame | TextView | FileChooserWidget | ListBoxRow | Widget | ListBase | ScaleButton | DrawingArea | ShortcutLabel | DropDown | LockButton | DragIcon | AppChooserDialog | StackSwitcher | ComboBoxText | Assistant | MenuButton | WindowControls | Button | ColorChooserDialog | AppChooserButton | ColorDialogButton | Calendar | PopoverMenuBar | Expander | ProgressBar | StackSidebar | CellView | PrintUnixDialog | GridView | EditableLabel | Label | Spinner | ToggleButton | SearchBar | ApplicationWindow | CheckButton | FontDialogButton | ColumnView | VolumeButton | StackPage | InfoBar | IconView | HeaderBar | PageSetupUnixDialog | AppChooserWidget | FontChooserWidget | PasswordEntry | Statusbar | Entry | ShortcutsShortcut | Fixed | Revealer | Grid | Picture | ShortcutsSection | Notebook | TreeView | SpinButton | WindowHandle | PopoverMenu | AspectFrame | Paned | Video | Window | LevelBar | FlowBoxChild | ActionBar | Text | Box | Scrollbar | Separator | Switch | MessageDialog | Popover | CenterBox | SearchEntry | ListView | ColorButton | GraphicsOffload;
    state: AccessibleState): bool =
  toBool(gtk_test_accessible_has_state(cast[ptr Accessible00](accessible.impl), state))

proc gtk_test_list_all_types(nTypes: var uint32): ptr GType {.
    importc, libprag.}

proc testListAllTypes*(nTypes: var int): ptr GType =
  var nTypes_00: uint32
  result = gtk_test_list_all_types(nTypes_00)
  if nTypes.addr != nil:
    nTypes = int(nTypes_00)

proc testRegisterAllTypes*() {.
    importc: "gtk_test_register_all_types", libprag.}

proc gtk_test_widget_wait_for_draw(widget: ptr Widget00) {.
    importc, libprag.}

proc testWidgetWaitForDraw*(widget: Widget) =
  gtk_test_widget_wait_for_draw(cast[ptr Widget00](widget.impl))

proc gtk_tree_create_row_drag_content(treeModel: ptr TreeModel00; path: ptr TreePath00): ptr gdk4.ContentProvider00 {.
    importc, libprag.}

proc treeCreateRowDragContent*(treeModel: TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore;
    path: TreePath): gdk4.ContentProvider =
  let gobj = gtk_tree_create_row_drag_content(cast[ptr TreeModel00](treeModel.impl), cast[ptr TreePath00](path.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_get_row_drag_data(value: gobject.Value; treeModel: var ptr TreeModel00;
    path: var ptr TreePath00): gboolean {.
    importc, libprag.}

proc treeGetRowDragData*(value: gobject.Value; treeModel: var (TreeModel | TreeModelFilter | TreeModelSort | TreeStore | ListStore) = cast[var TreeModel](nil);
    path: var TreePath = cast[var TreePath](nil)): bool =
  var tmpoutgobjectarg: ptr TreeModel00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_tree_get_row_drag_data(value, cast[var ptr TreeModel00](if addr(treeModel) == nil: nil else: addr tmpoutgobjectarg), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl)))
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil
#  dothemagic(treeModel
  if addr(treeModel) != nil:
    treeModel = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      treeModel = cast[type(treeModel)](argqdata)
      assert(treeModel.impl == tmpoutgobjectarg)
    else:
      fnew(treeModel, gtk4.finalizeGObject)
      treeModel.impl = tmpoutgobjectarg
      GC_ref(treeModel)
      if g_object_is_floating(treeModel.impl).int != 0:
        discard g_object_ref_sink(treeModel.impl)
      g_object_add_toggle_ref(treeModel.impl, toggleNotify, addr(treeModel[]))
      g_object_unref(treeModel.impl)
      assert(g_object_get_qdata(treeModel.impl, Quark) == nil)
      g_object_set_qdata(treeModel.impl, Quark, addr(treeModel[]))


proc gtk_value_dup_expression(value: gobject.Value): ptr Expression00 {.
    importc, libprag.}

proc valueDupExpression*(value: gobject.Value): Expression =
  let impl0 = gtk_value_dup_expression(value)
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = impl0

proc gtk_value_get_expression(value: gobject.Value): ptr Expression00 {.
    importc, libprag.}

proc valueGetExpression*(value: gobject.Value): Expression =
  let impl0 = gtk_value_get_expression(value)
  if impl0.isNil:
    return nil
  fnew(result, generic_gtk_expression_unref)
  result.impl = cast[typeof(result.impl)](gtk_expression_ref(impl0))

proc gtk_value_set_expression(value: gobject.Value; expression: ptr Expression00) {.
    importc, libprag.}

proc valueSetExpression*(value: gobject.Value; expression: Expression) =
  gtk_value_set_expression(value, cast[ptr Expression00](expression.impl))

proc gtk_value_take_expression(value: gobject.Value; expression: ptr Expression00) {.
    importc, libprag.}

proc valueTakeExpression*(value: gobject.Value; expression: Expression = nil) =
  gtk_value_take_expression(value, if expression.isNil: nil else: cast[ptr Expression00](gtk_expression_ref(expression.impl)))
# === remaining symbols:

# Extern interfaces: (we don't use converters, but explicit procs for now.)

proc listModel*(x: gtk4.AnyFilter): gio.ListModel = cast[gio.ListModel](x)

proc actionGroup*(x: gtk4.Application): gio.ActionGroup = cast[gio.ActionGroup](x)

proc actionMap*(x: gtk4.Application): gio.ActionMap = cast[gio.ActionMap](x)

proc actionGroup*(x: gtk4.ApplicationWindow): gio.ActionGroup = cast[gio.ActionGroup](x)

proc actionMap*(x: gtk4.ApplicationWindow): gio.ActionMap = cast[gio.ActionMap](x)

proc listModel*(x: gtk4.BookmarkList): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.DirectoryList): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.EveryFilter): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.FilterListModel): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.FlattenListModel): gio.ListModel = cast[gio.ListModel](x)

proc paintable*(x: gtk4.IconPaintable): gdk4.Paintable = cast[gdk4.Paintable](x)

proc listModel*(x: gtk4.MapListModel): gio.ListModel = cast[gio.ListModel](x)

proc paintable*(x: gtk4.MediaFile): gdk4.Paintable = cast[gdk4.Paintable](x)

proc paintable*(x: gtk4.MediaStream): gdk4.Paintable = cast[gdk4.Paintable](x)

proc listModel*(x: gtk4.MultiFilter): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.MultiSelection): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.MultiSorter): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.NoSelection): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.SelectionFilterModel): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.ShortcutController): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.SingleSelection): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.SliceListModel): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.SortListModel): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.StringList): gio.ListModel = cast[gio.ListModel](x)

proc listModel*(x: gtk4.TreeListModel): gio.ListModel = cast[gio.ListModel](x)

proc paintable*(x: gtk4.WidgetPaintable): gdk4.Paintable = cast[gdk4.Paintable](x)

proc setMargin*(w: Widget; m: int) =
  setMarginStart(w, m)
  setMarginEnd(w, m)
  setMarginTop(w, m)
  setMarginBottom(w, m)


# allow connecting GtkText and GtkEntry to "changed" signal of GtkEditable!
proc editable*(x: Text): Editable = cast[Editable](x)

proc editable*(x: Entry): Editable = cast[Editable](x)

#proc loadFromData*(self: CssProvider; data: cstring): bool =
#  loadFromData(self, uint8Array(data), -1)

proc addAction*(self: ApplicationWindow; action: Action | PropertyAction | SimpleAction) =
  g_action_map_add_action(cast[ptr ActionMap00](self.impl), cast[ptr Action00](action.impl))

proc gtk_file_chooser_dialog_new*(title: cstring; parent: ptr Window00; action: FileChooserAction; 
    firstButtonText: cstring = nil): ptr FileChooserDialog00 {.varargs,
    importc: "gtk_file_chooser_dialog_new", libprag.}

proc newFileChooserDialog*(title: cstring = nil; parent: Window = nil; action: FileChooserAction): FileChooserDialog =
  let gobj = gtk_file_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserDialog*[T](result: var T; title: cstring = nil; parent: Window = nil; action: FileChooserAction) =
  assert(result is FileChooserDialog)
  let gobj = gtk_file_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

import macros, strutils

#include gisup
#include gimpl


proc getRootWidget*(self: Widget): Widget =
  let h = self.getRoot
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](h.impl), gtk_widget_get_type())))
  #g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))
  cast[Widget](h)

proc stringObject*(self: gobject.Object): StringObject =
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](self.impl), gtk_string_object_get_type())))
  cast[StringObject](self)

proc fileInfo*(self: gobject.Object): gio.FileInfo =
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](self.impl), g_file_info_get_type())))
  cast[gio.FileInfo](self)

proc gtk_constant_expression_new(value_type: GType): ptr Expression00 {.varargs, importc, libprag.}

proc newConstantExpression*(gtype: GType; obj: gobject.Object): Expression =
  fnew(result, generic_gtk_expression_unref)
  result.impl = gtk_constant_expression_new(gtype, obj.impl)


include gisup4
include gimplgobj
include gimplgtk
include gimplgtk4
proc getAboutDialog*(builder: Builder; name: string): AboutDialog =
  let gt = gtk_about_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getActionBar*(builder: Builder; name: string): ActionBar =
  let gt = gtk_action_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAnyFilter*(builder: Builder; name: string): AnyFilter =
  let gt = gtk_any_filter_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAppChooserButton*(builder: Builder; name: string): AppChooserButton =
  let gt = gtk_app_chooser_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAppChooserDialog*(builder: Builder; name: string): AppChooserDialog =
  let gt = gtk_app_chooser_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAppChooserWidget*(builder: Builder; name: string): AppChooserWidget =
  let gt = gtk_app_chooser_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getApplicationWindow*(builder: Builder; name: string): ApplicationWindow =
  let gt = gtk_application_window_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAspectFrame*(builder: Builder; name: string): AspectFrame =
  let gt = gtk_aspect_frame_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAssistant*(builder: Builder; name: string): Assistant =
  let gt = gtk_assistant_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getBox*(builder: Builder; name: string): Box =
  let gt = gtk_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getButton*(builder: Builder; name: string): Button =
  let gt = gtk_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCalendar*(builder: Builder; name: string): Calendar =
  let gt = gtk_calendar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCellArea*(builder: Builder; name: string): CellArea =
  let gt = gtk_cell_area_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCellAreaBox*(builder: Builder; name: string): CellAreaBox =
  let gt = gtk_cell_area_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCellView*(builder: Builder; name: string): CellView =
  let gt = gtk_cell_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCenterBox*(builder: Builder; name: string): CenterBox =
  let gt = gtk_center_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCheckButton*(builder: Builder; name: string): CheckButton =
  let gt = gtk_check_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColorButton*(builder: Builder; name: string): ColorButton =
  let gt = gtk_color_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColorChooserDialog*(builder: Builder; name: string): ColorChooserDialog =
  let gt = gtk_color_chooser_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColorChooserWidget*(builder: Builder; name: string): ColorChooserWidget =
  let gt = gtk_color_chooser_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColorDialogButton*(builder: Builder; name: string): ColorDialogButton =
  let gt = gtk_color_dialog_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColumnView*(builder: Builder; name: string): ColumnView =
  let gt = gtk_column_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getComboBox*(builder: Builder; name: string): ComboBox =
  let gt = gtk_combo_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getComboBoxText*(builder: Builder; name: string): ComboBoxText =
  let gt = gtk_combo_box_text_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getConstraintLayout*(builder: Builder; name: string): ConstraintLayout =
  let gt = gtk_constraint_layout_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getDialog*(builder: Builder; name: string): Dialog =
  let gt = gtk_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getDragIcon*(builder: Builder; name: string): DragIcon =
  let gt = gtk_drag_icon_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getDrawingArea*(builder: Builder; name: string): DrawingArea =
  let gt = gtk_drawing_area_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getDropDown*(builder: Builder; name: string): DropDown =
  let gt = gtk_drop_down_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getEditableLabel*(builder: Builder; name: string): EditableLabel =
  let gt = gtk_editable_label_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getEmojiChooser*(builder: Builder; name: string): EmojiChooser =
  let gt = gtk_emoji_chooser_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getEntry*(builder: Builder; name: string): Entry =
  let gt = gtk_entry_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getEntryCompletion*(builder: Builder; name: string): EntryCompletion =
  let gt = gtk_entry_completion_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getEveryFilter*(builder: Builder; name: string): EveryFilter =
  let gt = gtk_every_filter_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getExpander*(builder: Builder; name: string): Expander =
  let gt = gtk_expander_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFileChooserDialog*(builder: Builder; name: string): FileChooserDialog =
  let gt = gtk_file_chooser_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFileChooserWidget*(builder: Builder; name: string): FileChooserWidget =
  let gt = gtk_file_chooser_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFileFilter*(builder: Builder; name: string): FileFilter =
  let gt = gtk_file_filter_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFixed*(builder: Builder; name: string): Fixed =
  let gt = gtk_fixed_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFlowBox*(builder: Builder; name: string): FlowBox =
  let gt = gtk_flow_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFlowBoxChild*(builder: Builder; name: string): FlowBoxChild =
  let gt = gtk_flow_box_child_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFontButton*(builder: Builder; name: string): FontButton =
  let gt = gtk_font_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFontChooserDialog*(builder: Builder; name: string): FontChooserDialog =
  let gt = gtk_font_chooser_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFontChooserWidget*(builder: Builder; name: string): FontChooserWidget =
  let gt = gtk_font_chooser_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFontDialogButton*(builder: Builder; name: string): FontDialogButton =
  let gt = gtk_font_dialog_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFrame*(builder: Builder; name: string): Frame =
  let gt = gtk_frame_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getGLArea*(builder: Builder; name: string): GLArea =
  let gt = gtk_glarea_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getGraphicsOffload*(builder: Builder; name: string): GraphicsOffload =
  let gt = gtk_graphics_offload_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getGrid*(builder: Builder; name: string): Grid =
  let gt = gtk_grid_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getGridView*(builder: Builder; name: string): GridView =
  let gt = gtk_grid_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHeaderBar*(builder: Builder; name: string): HeaderBar =
  let gt = gtk_header_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getIconView*(builder: Builder; name: string): IconView =
  let gt = gtk_icon_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getImage*(builder: Builder; name: string): Image =
  let gt = gtk_image_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getInfoBar*(builder: Builder; name: string): InfoBar =
  let gt = gtk_info_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getInscription*(builder: Builder; name: string): Inscription =
  let gt = gtk_inscription_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getLabel*(builder: Builder; name: string): Label =
  let gt = gtk_label_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getLevelBar*(builder: Builder; name: string): LevelBar =
  let gt = gtk_level_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getLinkButton*(builder: Builder; name: string): LinkButton =
  let gt = gtk_link_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getListBase*(builder: Builder; name: string): ListBase =
  let gt = gtk_list_base_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getListBox*(builder: Builder; name: string): ListBox =
  let gt = gtk_list_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getListBoxRow*(builder: Builder; name: string): ListBoxRow =
  let gt = gtk_list_box_row_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getListStore*(builder: Builder; name: string): ListStore =
  let gt = gtk_list_store_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getListView*(builder: Builder; name: string): ListView =
  let gt = gtk_list_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getLockButton*(builder: Builder; name: string): LockButton =
  let gt = gtk_lock_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMediaControls*(builder: Builder; name: string): MediaControls =
  let gt = gtk_media_controls_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMenuButton*(builder: Builder; name: string): MenuButton =
  let gt = gtk_menu_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMessageDialog*(builder: Builder; name: string): MessageDialog =
  let gt = gtk_message_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMultiFilter*(builder: Builder; name: string): MultiFilter =
  let gt = gtk_multi_filter_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMultiSorter*(builder: Builder; name: string): MultiSorter =
  let gt = gtk_multi_sorter_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getNotebook*(builder: Builder; name: string): Notebook =
  let gt = gtk_notebook_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getOverlay*(builder: Builder; name: string): Overlay =
  let gt = gtk_overlay_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPageSetupUnixDialog*(builder: Builder; name: string): PageSetupUnixDialog =
  let gt = gtk_page_setup_unix_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPaned*(builder: Builder; name: string): Paned =
  let gt = gtk_paned_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPasswordEntry*(builder: Builder; name: string): PasswordEntry =
  let gt = gtk_password_entry_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPicture*(builder: Builder; name: string): Picture =
  let gt = gtk_picture_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPopover*(builder: Builder; name: string): Popover =
  let gt = gtk_popover_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPopoverMenu*(builder: Builder; name: string): PopoverMenu =
  let gt = gtk_popover_menu_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPopoverMenuBar*(builder: Builder; name: string): PopoverMenuBar =
  let gt = gtk_popover_menu_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPrintUnixDialog*(builder: Builder; name: string): PrintUnixDialog =
  let gt = gtk_print_unix_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getProgressBar*(builder: Builder; name: string): ProgressBar =
  let gt = gtk_progress_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRange*(builder: Builder; name: string): Range =
  let gt = gtk_range_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRevealer*(builder: Builder; name: string): Revealer =
  let gt = gtk_revealer_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getScale*(builder: Builder; name: string): Scale =
  let gt = gtk_scale_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getScaleButton*(builder: Builder; name: string): ScaleButton =
  let gt = gtk_scale_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getScrollbar*(builder: Builder; name: string): Scrollbar =
  let gt = gtk_scrollbar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getScrolledWindow*(builder: Builder; name: string): ScrolledWindow =
  let gt = gtk_scrolled_window_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSearchBar*(builder: Builder; name: string): SearchBar =
  let gt = gtk_search_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSearchEntry*(builder: Builder; name: string): SearchEntry =
  let gt = gtk_search_entry_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSeparator*(builder: Builder; name: string): Separator =
  let gt = gtk_separator_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutController*(builder: Builder; name: string): ShortcutController =
  let gt = gtk_shortcut_controller_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutLabel*(builder: Builder; name: string): ShortcutLabel =
  let gt = gtk_shortcut_label_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutsGroup*(builder: Builder; name: string): ShortcutsGroup =
  let gt = gtk_shortcuts_group_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutsSection*(builder: Builder; name: string): ShortcutsSection =
  let gt = gtk_shortcuts_section_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutsShortcut*(builder: Builder; name: string): ShortcutsShortcut =
  let gt = gtk_shortcuts_shortcut_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutsWindow*(builder: Builder; name: string): ShortcutsWindow =
  let gt = gtk_shortcuts_window_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSizeGroup*(builder: Builder; name: string): SizeGroup =
  let gt = gtk_size_group_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSpinButton*(builder: Builder; name: string): SpinButton =
  let gt = gtk_spin_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSpinner*(builder: Builder; name: string): Spinner =
  let gt = gtk_spinner_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getStack*(builder: Builder; name: string): Stack =
  let gt = gtk_stack_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getStackSidebar*(builder: Builder; name: string): StackSidebar =
  let gt = gtk_stack_sidebar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getStackSwitcher*(builder: Builder; name: string): StackSwitcher =
  let gt = gtk_stack_switcher_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getStatusbar*(builder: Builder; name: string): Statusbar =
  let gt = gtk_statusbar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getStringList*(builder: Builder; name: string): StringList =
  let gt = gtk_string_list_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSwitch*(builder: Builder; name: string): Switch =
  let gt = gtk_switch_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getText*(builder: Builder; name: string): Text =
  let gt = gtk_text_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTextTagTable*(builder: Builder; name: string): TextTagTable =
  let gt = gtk_text_tag_table_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTextView*(builder: Builder; name: string): TextView =
  let gt = gtk_text_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getToggleButton*(builder: Builder; name: string): ToggleButton =
  let gt = gtk_toggle_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTreeExpander*(builder: Builder; name: string): TreeExpander =
  let gt = gtk_tree_expander_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTreeStore*(builder: Builder; name: string): TreeStore =
  let gt = gtk_tree_store_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTreeView*(builder: Builder; name: string): TreeView =
  let gt = gtk_tree_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTreeViewColumn*(builder: Builder; name: string): TreeViewColumn =
  let gt = gtk_tree_view_column_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getVideo*(builder: Builder; name: string): Video =
  let gt = gtk_video_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getViewport*(builder: Builder; name: string): Viewport =
  let gt = gtk_viewport_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getVolumeButton*(builder: Builder; name: string): VolumeButton =
  let gt = gtk_volume_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getWidget*(builder: Builder; name: string): Widget =
  let gt = gtk_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getWindow*(builder: Builder; name: string): Window =
  let gt = gtk_window_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getWindowControls*(builder: Builder; name: string): WindowControls =
  let gt = gtk_window_controls_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getWindowHandle*(builder: Builder; name: string): WindowHandle =
  let gt = gtk_window_handle_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMenuModel*(builder: Builder; name: string): MenuModel =
  let gt = g_menu_model_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFileChooserNative*(builder: Builder; name: string): FileChooserNative =
  let gt = gtk_file_chooser_native_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk4.finalizeGObject)
    result.impl = gobj # not floating, with ref count == 1
    #result.ignoreFinalizer = true
    #discard g_object_ref(result.impl) # v0.99, try to fix issue
    GC_ref(result) # when builder instance goes out and is destroyed, it unrefs its childs...
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    #g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

