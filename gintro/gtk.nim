# dependencies:
# Pango-1.0
# GObject-2.0
# xlib-2.0
# cairo-1.0
# Gdk-3.0
# Gio-2.0
# Atk-1.0
# GdkPixbuf-2.0
# GModule-2.0
# GLib-2.0
# immediate dependencies:
# xlib-2.0
# Gdk-3.0
# Atk-1.0
# libraries:
# libgtk-3.so.0,libgdk-3.so.0
{.deadCodeElim: on.}
import pango, gobject, xlib, cairo, gdk, gio, atk, gdkpixbuf, gmodule, glib
const Lib* = "libgtk-3.so.0"
{.pragma: libprag, cdecl, dynlib: Lib.}
type
  TargetEntry00Array* = pointer
type
  AccelGroupEntry00Array* = pointer
type
  BindingArg00Array* = pointer
type
  StockItem00Array* = pointer
type
  PageRange00Array* = pointer
type
  PadActionEntry00Array* = pointer
type
  Array* = pointer
let Quark = g_quark_from_static_string("NimGIQuark")

type
  WidgetPrivate00* {.pure.} = object
  WidgetPrivate* = ref object
    impl*: ptr WidgetPrivate00

type
  TextDirection* {.size: sizeof(cint), pure.} = enum
    none = 0
    ltr = 1
    rtl = 2

type
  SelectionData00* {.pure.} = object
  SelectionData* = ref object
    impl*: ptr SelectionData00

proc gtk_selection_data_copy*(self: ptr SelectionData00): ptr SelectionData00 {.
    importc: "gtk_selection_data_copy", libprag.}

proc copy*(self: SelectionData): SelectionData =
  new(result)
  result.impl = gtk_selection_data_copy(cast[ptr SelectionData00](self.impl))

proc gtk_selection_data_free*(self: ptr SelectionData00) {.
    importc: "gtk_selection_data_free", libprag.}

proc free*(self: SelectionData) =
  gtk_selection_data_free(cast[ptr SelectionData00](self.impl))

proc gtk_selection_data_get_data_type*(self: ptr SelectionData00): ptr gdk.Atom00 {.
    importc: "gtk_selection_data_get_data_type", libprag.}

proc getDataType*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_data_type(cast[ptr SelectionData00](self.impl))

proc dataType*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_data_type(cast[ptr SelectionData00](self.impl))

proc gtk_selection_data_get_data_with_length*(self: ptr SelectionData00; length: var int32): uint8Array {.
    importc: "gtk_selection_data_get_data_with_length", libprag.}

proc getData*(self: SelectionData; length: var int): uint8Array =
  var length_00 = int32(length)
  result = gtk_selection_data_get_data_with_length(cast[ptr SelectionData00](self.impl), length_00)
  length = int(length_00)

proc data*(self: SelectionData; length: var int): uint8Array =
  var length_00 = int32(length)
  result = gtk_selection_data_get_data_with_length(cast[ptr SelectionData00](self.impl), length_00)
  length = int(length_00)

proc gtk_selection_data_get_display*(self: ptr SelectionData00): ptr gdk.Display00 {.
    importc: "gtk_selection_data_get_display", libprag.}

proc getDisplay*(self: SelectionData): gdk.Display =
  let gobj = gtk_selection_data_get_display(cast[ptr SelectionData00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Display](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: SelectionData): gdk.Display =
  let gobj = gtk_selection_data_get_display(cast[ptr SelectionData00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Display](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_selection_data_get_format*(self: ptr SelectionData00): int32 {.
    importc: "gtk_selection_data_get_format", libprag.}

proc getFormat*(self: SelectionData): int =
  int(gtk_selection_data_get_format(cast[ptr SelectionData00](self.impl)))

proc format*(self: SelectionData): int =
  int(gtk_selection_data_get_format(cast[ptr SelectionData00](self.impl)))

proc gtk_selection_data_get_length*(self: ptr SelectionData00): int32 {.
    importc: "gtk_selection_data_get_length", libprag.}

proc getLength*(self: SelectionData): int =
  int(gtk_selection_data_get_length(cast[ptr SelectionData00](self.impl)))

proc length*(self: SelectionData): int =
  int(gtk_selection_data_get_length(cast[ptr SelectionData00](self.impl)))

proc gtk_selection_data_get_pixbuf*(self: ptr SelectionData00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_selection_data_get_pixbuf", libprag.}

proc getPixbuf*(self: SelectionData): gdkpixbuf.Pixbuf =
  let gobj = gtk_selection_data_get_pixbuf(cast[ptr SelectionData00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: SelectionData): gdkpixbuf.Pixbuf =
  let gobj = gtk_selection_data_get_pixbuf(cast[ptr SelectionData00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_selection_data_get_selection*(self: ptr SelectionData00): ptr gdk.Atom00 {.
    importc: "gtk_selection_data_get_selection", libprag.}

proc getSelection*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_selection(cast[ptr SelectionData00](self.impl))

proc selection*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_selection(cast[ptr SelectionData00](self.impl))

proc gtk_selection_data_get_target*(self: ptr SelectionData00): ptr gdk.Atom00 {.
    importc: "gtk_selection_data_get_target", libprag.}

proc getTarget*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_target(cast[ptr SelectionData00](self.impl))

proc target*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_target(cast[ptr SelectionData00](self.impl))

proc gtk_selection_data_get_targets*(self: ptr SelectionData00; targets: var ptr gdk.Atom00Array; 
    nAtoms: var int32): gboolean {.
    importc: "gtk_selection_data_get_targets", libprag.}

proc getTargets*(self: SelectionData; targets: var ptr gdk.Atom00Array; 
    nAtoms: var int): bool =
  var nAtoms_00 = int32(nAtoms)
  result = toBool(gtk_selection_data_get_targets(cast[ptr SelectionData00](self.impl), targets, nAtoms_00))
  nAtoms = int(nAtoms_00)

proc targets*(self: SelectionData; targets: var ptr gdk.Atom00Array; 
    nAtoms: var int): bool =
  var nAtoms_00 = int32(nAtoms)
  result = toBool(gtk_selection_data_get_targets(cast[ptr SelectionData00](self.impl), targets, nAtoms_00))
  nAtoms = int(nAtoms_00)

proc gtk_selection_data_get_text*(self: ptr SelectionData00): cstring {.
    importc: "gtk_selection_data_get_text", libprag.}

proc getText*(self: SelectionData): string =
  let resul0 = gtk_selection_data_get_text(cast[ptr SelectionData00](self.impl))
  result = $resul0
  cogfree(resul0)

proc text*(self: SelectionData): string =
  let resul0 = gtk_selection_data_get_text(cast[ptr SelectionData00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_selection_data_get_uris*(self: ptr SelectionData00): cstringArray {.
    importc: "gtk_selection_data_get_uris", libprag.}

proc getUris*(self: SelectionData): cstringArray =
  gtk_selection_data_get_uris(cast[ptr SelectionData00](self.impl))

proc uris*(self: SelectionData): cstringArray =
  gtk_selection_data_get_uris(cast[ptr SelectionData00](self.impl))

proc gtk_selection_data_set*(self: ptr SelectionData00; `type`: ptr gdk.Atom00; 
    format: int32; data: uint8Array; length: int32) {.
    importc: "gtk_selection_data_set", libprag.}

proc set*(self: SelectionData; `type`: gdk.Atom; format: int; 
    data: uint8Array; length: int) =
  gtk_selection_data_set(cast[ptr SelectionData00](self.impl), cast[ptr gdk.Atom00](`type`.impl), int32(format), data, int32(length))

proc gtk_selection_data_set_pixbuf*(self: ptr SelectionData00; pixbuf: ptr gdkpixbuf.Pixbuf00): gboolean {.
    importc: "gtk_selection_data_set_pixbuf", libprag.}

proc setPixbuf*(self: SelectionData; pixbuf: gdkpixbuf.Pixbuf): bool =
  toBool(gtk_selection_data_set_pixbuf(cast[ptr SelectionData00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl)))

proc `pixbuf=`*(self: SelectionData; pixbuf: gdkpixbuf.Pixbuf): bool =
  toBool(gtk_selection_data_set_pixbuf(cast[ptr SelectionData00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl)))

proc gtk_selection_data_set_text*(self: ptr SelectionData00; str: cstring; len: int32): gboolean {.
    importc: "gtk_selection_data_set_text", libprag.}

proc setText*(self: SelectionData; str: string; len: int): bool =
  toBool(gtk_selection_data_set_text(cast[ptr SelectionData00](self.impl), cstring(str), int32(len)))

proc gtk_selection_data_set_uris*(self: ptr SelectionData00; uris: cstringArray): gboolean {.
    importc: "gtk_selection_data_set_uris", libprag.}

proc setUris*(self: SelectionData; uris: cstringArray): bool =
  toBool(gtk_selection_data_set_uris(cast[ptr SelectionData00](self.impl), uris))

proc `uris=`*(self: SelectionData; uris: cstringArray): bool =
  toBool(gtk_selection_data_set_uris(cast[ptr SelectionData00](self.impl), uris))

proc gtk_selection_data_targets_include_image*(self: ptr SelectionData00; writable: gboolean): gboolean {.
    importc: "gtk_selection_data_targets_include_image", libprag.}

proc targetsIncludeImage*(self: SelectionData; writable: bool): bool =
  toBool(gtk_selection_data_targets_include_image(cast[ptr SelectionData00](self.impl), gboolean(writable)))

proc gtk_selection_data_targets_include_text*(self: ptr SelectionData00): gboolean {.
    importc: "gtk_selection_data_targets_include_text", libprag.}

proc targetsIncludeText*(self: SelectionData): bool =
  toBool(gtk_selection_data_targets_include_text(cast[ptr SelectionData00](self.impl)))

proc gtk_selection_data_targets_include_uri*(self: ptr SelectionData00): gboolean {.
    importc: "gtk_selection_data_targets_include_uri", libprag.}

proc targetsIncludeUri*(self: SelectionData): bool =
  toBool(gtk_selection_data_targets_include_uri(cast[ptr SelectionData00](self.impl)))

type
  DragResult* {.size: sizeof(cint), pure.} = enum
    success = 0
    noTarget = 1
    userCancelled = 2
    timeoutExpired = 3
    grabBroken = 4
    error = 5

type
  DirectionType* {.size: sizeof(cint), pure.} = enum
    tabForward = 0
    tabBackward = 1
    up = 2
    down = 3
    left = 4
    right = 5

type
  Tooltip* = ref object of gobject.Object
  Tooltip00* = object of gobject.Object00

proc gtk_tooltip_trigger_tooltip_query*(display: ptr gdk.Display00) {.
    importc: "gtk_tooltip_trigger_tooltip_query", libprag.}

proc triggerTooltipQuery*(display: gdk.Display) =
  gtk_tooltip_trigger_tooltip_query(cast[ptr gdk.Display00](display.impl))

proc gtk_tooltip_set_icon*(self: ptr Tooltip00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_tooltip_set_icon", libprag.}

proc setIcon*(self: Tooltip; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_tooltip_set_icon(cast[ptr Tooltip00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `icon=`*(self: Tooltip; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_tooltip_set_icon(cast[ptr Tooltip00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_tooltip_set_icon_from_gicon*(self: ptr Tooltip00; gicon: ptr gio.Icon00; size: int32) {.
    importc: "gtk_tooltip_set_icon_from_gicon", libprag.}

proc setIconFromGicon*(self: Tooltip; gicon: gio.Icon; size: int) =
  gtk_tooltip_set_icon_from_gicon(cast[ptr Tooltip00](self.impl), cast[ptr gio.Icon00](gicon.impl), int32(size))

proc gtk_tooltip_set_icon_from_icon_name*(self: ptr Tooltip00; iconName: cstring; size: int32) {.
    importc: "gtk_tooltip_set_icon_from_icon_name", libprag.}

proc setIconFromIconName*(self: Tooltip; iconName: string; size: int) =
  gtk_tooltip_set_icon_from_icon_name(cast[ptr Tooltip00](self.impl), cstring(iconName), int32(size))

proc gtk_tooltip_set_icon_from_stock*(self: ptr Tooltip00; stockId: cstring; size: int32) {.
    importc: "gtk_tooltip_set_icon_from_stock", libprag.}

proc setIconFromStock*(self: Tooltip; stockId: string; size: int) =
  gtk_tooltip_set_icon_from_stock(cast[ptr Tooltip00](self.impl), cstring(stockId), int32(size))

proc gtk_tooltip_set_markup*(self: ptr Tooltip00; markup: cstring) {.
    importc: "gtk_tooltip_set_markup", libprag.}

proc setMarkup*(self: Tooltip; markup: string) =
  gtk_tooltip_set_markup(cast[ptr Tooltip00](self.impl), cstring(markup))

proc `markup=`*(self: Tooltip; markup: string) =
  gtk_tooltip_set_markup(cast[ptr Tooltip00](self.impl), cstring(markup))

proc gtk_tooltip_set_text*(self: ptr Tooltip00; text: cstring) {.
    importc: "gtk_tooltip_set_text", libprag.}

proc setText*(self: Tooltip; text: string) =
  gtk_tooltip_set_text(cast[ptr Tooltip00](self.impl), cstring(text))

proc `text=`*(self: Tooltip; text: string) =
  gtk_tooltip_set_text(cast[ptr Tooltip00](self.impl), cstring(text))

proc gtk_tooltip_set_tip_area*(self: ptr Tooltip00; rect: ptr gdk.Rectangle00) {.
    importc: "gtk_tooltip_set_tip_area", libprag.}

proc setTipArea*(self: Tooltip; rect: gdk.Rectangle) =
  gtk_tooltip_set_tip_area(cast[ptr Tooltip00](self.impl), cast[ptr gdk.Rectangle00](rect.impl))

proc `tipArea=`*(self: Tooltip; rect: gdk.Rectangle) =
  gtk_tooltip_set_tip_area(cast[ptr Tooltip00](self.impl), cast[ptr gdk.Rectangle00](rect.impl))

type
  WidgetHelpType* {.size: sizeof(cint), pure.} = enum
    tooltip = 0
    whatsThis = 1

type
  StateType* {.size: sizeof(cint), pure.} = enum
    normal = 0
    active = 1
    prelight = 2
    selected = 3
    insensitive = 4
    inconsistent = 5
    focused = 6

type
  StateFlag* {.size: sizeof(cint), pure.} = enum
    active = 1
    prelight = 2
    selected = 3
    insensitive = 4
    inconsistent = 5
    focused = 6
    backdrop = 7
    dirLtr = 8
    dirRtl = 9
    link = 10
    visited = 11
    checked = 12
    dropActive = 13

  StateFlags* {.size: sizeof(cint).} = set[StateFlag]

type
  RcFlag* {.size: sizeof(cint), pure.} = enum
    fg = 1
    bg = 2
    text = 3
    base = 4

  RcFlags* {.size: sizeof(cint).} = set[RcFlag]

type
  RcStyle* = ref object of gobject.Object
  RcStyle00* = object of gobject.Object00
    name*: cstring
    bgPixmapName*: array[5, cstring]
    fontDesc*: ptr pango.FontDescription00
    colorFlags*: array[5, RcFlags]
    fg*: array[5, gdk.Color00]
    bg*: array[5, gdk.Color00]
    text*: array[5, gdk.Color00]
    base*: array[5, gdk.Color00]
    xthickness*: int32
    ythickness*: int32
    rcProperties*: ptr Array
    rcStyleLists*: ptr pointer
    iconFactories*: ptr pointer
    engineSpecified*: uint32

proc gtk_rc_style_new*(): ptr RcStyle00 {.
    importc: "gtk_rc_style_new", libprag.}

proc newRcStyle*(): RcStyle =
  new(result, finalizeGObject)
  result.impl = gtk_rc_style_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRcStyle*[T](result: var T) =
  assert(result is RcStyle)
  new(result, finalizeGObject)
  result.impl = gtk_rc_style_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_rc_style_copy*(self: ptr RcStyle00): ptr RcStyle00 {.
    importc: "gtk_rc_style_copy", libprag.}

proc copy*(self: RcStyle): RcStyle =
  let gobj = gtk_rc_style_copy(cast[ptr RcStyle00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[RcStyle](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Style* = ref object of gobject.Object
  Style00* = object of gobject.Object00
    fg*: array[5, gdk.Color00]
    bg*: array[5, gdk.Color00]
    light*: array[5, gdk.Color00]
    dark*: array[5, gdk.Color00]
    mid*: array[5, gdk.Color00]
    text*: array[5, gdk.Color00]
    base*: array[5, gdk.Color00]
    textAa*: array[5, gdk.Color00]
    black*: gdk.Color00
    white*: gdk.Color00
    fontDesc*: ptr pango.FontDescription00
    xthickness*: int32
    ythickness*: int32
    background*: array[5, ptr cairo.Pattern00]
    attachCount*: int32
    visual*: ptr gdk.Visual00
    privateFontDesc*: ptr pango.FontDescription00
    rcStyle*: ptr RcStyle00
    styles*: ptr pointer
    propertyCache*: ptr Array
    iconFactories*: ptr pointer

proc scRealize*(self: Style;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "realize", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUnrealize*(self: Style;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "unrealize", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_style_new*(): ptr Style00 {.
    importc: "gtk_style_new", libprag.}

proc newStyle*(): Style =
  new(result, finalizeGObject)
  result.impl = gtk_style_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStyle*[T](result: var T) =
  assert(result is Style)
  new(result, finalizeGObject)
  result.impl = gtk_style_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_apply_default_background*(self: ptr Style00; cr: ptr cairo.Context00; window: ptr gdk.Window00; 
    stateType: StateType; x: int32; y: int32; width: int32; height: int32) {.
    importc: "gtk_style_apply_default_background", libprag.}

proc applyDefaultBackground*(self: Style; cr: cairo.Context; window: gdk.Window; 
    stateType: StateType; x: int; y: int; width: int; height: int) =
  gtk_style_apply_default_background(cast[ptr Style00](self.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr gdk.Window00](window.impl), stateType, int32(x), int32(y), int32(width), int32(height))

proc gtk_style_copy*(self: ptr Style00): ptr Style00 {.
    importc: "gtk_style_copy", libprag.}

proc copy*(self: Style): Style =
  let gobj = gtk_style_copy(cast[ptr Style00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Style](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_detach*(self: ptr Style00) {.
    importc: "gtk_style_detach", libprag.}

proc detach*(self: Style) =
  gtk_style_detach(cast[ptr Style00](self.impl))

proc gtk_style_get_style_property*(self: ptr Style00; widgetType: GType; propertyName: cstring; 
    value: var gobject.Value00) {.
    importc: "gtk_style_get_style_property", libprag.}

proc getStyleProperty*(self: ptr Style00; widgetType: GType; propertyName: cstring; 
    value: var gobject.Value00) {.
    importc: "gtk_style_get_style_property", libprag.}

proc styleProperty*(self: ptr Style00; widgetType: GType; propertyName: cstring; 
    value: var gobject.Value00) {.
    importc: "gtk_style_get_style_property", libprag.}

proc gtk_style_has_context*(self: ptr Style00): gboolean {.
    importc: "gtk_style_has_context", libprag.}

proc hasContext*(self: Style): bool =
  toBool(gtk_style_has_context(cast[ptr Style00](self.impl)))

proc gtk_style_lookup_color*(self: ptr Style00; colorName: cstring; color: var gdk.Color00): gboolean {.
    importc: "gtk_style_lookup_color", libprag.}

proc lookupColor*(self: ptr Style00; colorName: cstring; color: var gdk.Color00): gboolean {.
    importc: "gtk_style_lookup_color", libprag.}

proc gtk_style_set_background*(self: ptr Style00; window: ptr gdk.Window00; stateType: StateType) {.
    importc: "gtk_style_set_background", libprag.}

proc setBackground*(self: Style; window: gdk.Window; stateType: StateType) =
  gtk_style_set_background(cast[ptr Style00](self.impl), cast[ptr gdk.Window00](window.impl), stateType)

type
  Widget* = ref object of gobject.InitiallyUnowned
  Widget00* = object of gobject.InitiallyUnowned00
    priv1: ptr WidgetPrivate00

proc scAccelClosuresChanged*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "accel-closures-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scButtonPressEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "button-press-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scButtonReleaseEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "button-release-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCanActivateAccel*(self: Widget;  p: proc (self: ptr gobject.Object00; signalId: uint32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "can-activate-accel", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scChildNotify*(self: Widget;  p: proc (self: ptr gobject.Object00; childProperty: gobject.ParamSpec00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "child-notify", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCompositedChanged*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "composited-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scConfigureEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventConfigure00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "configure-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDamageEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventExpose00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "damage-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDeleteEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.Event00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "delete-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDestroy*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "destroy", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDestroyEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.Event00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "destroy-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDirectionChanged*(self: Widget;  p: proc (self: ptr gobject.Object00; previousDirection: TextDirection; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "direction-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragBegin*(self: Widget;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-begin", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragDataDelete*(self: Widget;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-data-delete", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragDataGet*(self: Widget;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; data: SelectionData00; 
    info: uint32; time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-data-get", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragDataReceived*(self: Widget;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; x: int32; y: int32; data: SelectionData00; 
    info: uint32; time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-data-received", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragDrop*(self: Widget;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; x: int32; y: int32; time: uint32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-drop", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragEnd*(self: Widget;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-end", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragFailed*(self: Widget;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; resu: DragResult; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-failed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragLeave*(self: Widget;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-leave", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragMotion*(self: Widget;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; x: int32; y: int32; time: uint32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-motion", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDraw*(self: Widget;  p: proc (self: ptr gobject.Object00; cr: cairo.Context00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "draw", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEnterNotifyEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventCrossing00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "enter-notify-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.Event00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEventAfter*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.Event00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "event-after", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scFocus*(self: Widget;  p: proc (self: ptr gobject.Object00; direction: DirectionType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "focus", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scFocusInEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventFocus00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "focus-in-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scFocusOutEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventFocus00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "focus-out-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scGrabBrokenEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventGrabBroken00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "grab-broken-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scGrabFocus*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "grab-focus", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scGrabNotify*(self: Widget;  p: proc (self: ptr gobject.Object00; wasGrabbed: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "grab-notify", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scHide*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "hide", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scHierarchyChanged*(self: Widget;  p: proc (self: ptr gobject.Object00; previousToplevel: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "hierarchy-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scKeyPressEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventKey00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "key-press-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scKeyReleaseEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventKey00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "key-release-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scKeynavFailed*(self: Widget;  p: proc (self: ptr gobject.Object00; direction: DirectionType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "keynav-failed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scLeaveNotifyEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventCrossing00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "leave-notify-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMap*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "map", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMapEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventAny00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "map-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMnemonicActivate*(self: Widget;  p: proc (self: ptr gobject.Object00; groupCycling: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "mnemonic-activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMotionNotifyEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventMotion00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "motion-notify-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveFocus*(self: Widget;  p: proc (self: ptr gobject.Object00; direction: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-focus", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scParentSet*(self: Widget;  p: proc (self: ptr gobject.Object00; oldParent: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "parent-set", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopupMenu*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "popup-menu", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPropertyNotifyEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventProperty00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "property-notify-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scProximityInEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventProximity00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "proximity-in-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scProximityOutEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventProximity00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "proximity-out-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scQueryTooltip*(self: Widget;  p: proc (self: ptr gobject.Object00; x: int32; y: int32; keyboardMode: gboolean; tooltip: Tooltip00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "query-tooltip", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRealize*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "realize", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scScreenChanged*(self: Widget;  p: proc (self: ptr gobject.Object00; previousScreen: gdk.Screen00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "screen-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scScrollEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventScroll00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "scroll-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectionClearEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventSelection00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "selection-clear-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectionGet*(self: Widget;  p: proc (self: ptr gobject.Object00; data: SelectionData00; info: uint32; time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "selection-get", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectionNotifyEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventSelection00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "selection-notify-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectionReceived*(self: Widget;  p: proc (self: ptr gobject.Object00; data: SelectionData00; time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "selection-received", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectionRequestEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventSelection00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "selection-request-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scShow*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "show", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scShowHelp*(self: Widget;  p: proc (self: ptr gobject.Object00; helpType: WidgetHelpType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "show-help", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSizeAllocate*(self: Widget;  p: proc (self: ptr gobject.Object00; allocation: gdk.Rectangle00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "size-allocate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStateChanged*(self: Widget;  p: proc (self: ptr gobject.Object00; state: StateType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "state-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStateFlagsChanged*(self: Widget;  p: proc (self: ptr gobject.Object00; flags: StateFlags; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "state-flags-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStyleSet*(self: Widget;  p: proc (self: ptr gobject.Object00; previousStyle: Style00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "style-set", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStyleUpdated*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "style-updated", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scTouchEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; `object`: gdk.Event00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "touch-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUnmap*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "unmap", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUnmapEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventAny00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "unmap-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUnrealize*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "unrealize", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scVisibilityNotifyEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventVisibility00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "visibility-notify-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scWindowStateEvent*(self: Widget;  p: proc (self: ptr gobject.Object00; event: gdk.EventWindowState00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "window-state-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_widget_get_default_direction*(): TextDirection {.
    importc: "gtk_widget_get_default_direction", libprag.}

proc getDefaultDirection*(): TextDirection {.
    importc: "gtk_widget_get_default_direction", libprag.}

proc defaultDirection*(): TextDirection {.
    importc: "gtk_widget_get_default_direction", libprag.}

proc gtk_widget_get_default_style*(): ptr Style00 {.
    importc: "gtk_widget_get_default_style", libprag.}

proc getDefaultStyle*(): Style =
  let gobj = gtk_widget_get_default_style()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Style](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultStyle*(): Style =
  let gobj = gtk_widget_get_default_style()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Style](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_pop_composite_child*() {.
    importc: "gtk_widget_pop_composite_child", libprag.}

proc popCompositeChild*() {.
    importc: "gtk_widget_pop_composite_child", libprag.}

proc gtk_widget_push_composite_child*() {.
    importc: "gtk_widget_push_composite_child", libprag.}

proc pushCompositeChild*() {.
    importc: "gtk_widget_push_composite_child", libprag.}

proc gtk_widget_set_default_direction*(dir: TextDirection) {.
    importc: "gtk_widget_set_default_direction", libprag.}

proc setDefaultDirection*(dir: TextDirection) {.
    importc: "gtk_widget_set_default_direction", libprag.}

proc `defaultDirection=`*(dir: TextDirection) {.
    importc: "gtk_widget_set_default_direction", libprag.}

proc gtk_widget_activate*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_activate", libprag.}

proc activate*(self: Widget): bool =
  toBool(gtk_widget_activate(cast[ptr Widget00](self.impl)))

proc gtk_widget_add_device_events*(self: ptr Widget00; device: ptr gdk.Device00; events: gdk.EventMask) {.
    importc: "gtk_widget_add_device_events", libprag.}

proc addDeviceEvents*(self: Widget; device: gdk.Device; events: gdk.EventMask) =
  gtk_widget_add_device_events(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl), events)

proc gtk_widget_add_events*(self: ptr Widget00; events: int32) {.
    importc: "gtk_widget_add_events", libprag.}

proc addEvents*(self: Widget; events: int) =
  gtk_widget_add_events(cast[ptr Widget00](self.impl), int32(events))

proc gtk_widget_add_mnemonic_label*(self: ptr Widget00; label: ptr Widget00) {.
    importc: "gtk_widget_add_mnemonic_label", libprag.}

proc addMnemonicLabel*(self: Widget; label: Widget) =
  gtk_widget_add_mnemonic_label(cast[ptr Widget00](self.impl), cast[ptr Widget00](label.impl))

proc gtk_widget_can_activate_accel*(self: ptr Widget00; signalId: uint32): gboolean {.
    importc: "gtk_widget_can_activate_accel", libprag.}

proc canActivateAccel*(self: Widget; signalId: int): bool =
  toBool(gtk_widget_can_activate_accel(cast[ptr Widget00](self.impl), uint32(signalId)))

proc gtk_widget_child_focus*(self: ptr Widget00; direction: DirectionType): gboolean {.
    importc: "gtk_widget_child_focus", libprag.}

proc childFocus*(self: Widget; direction: DirectionType): bool =
  toBool(gtk_widget_child_focus(cast[ptr Widget00](self.impl), direction))

proc gtk_widget_child_notify*(self: ptr Widget00; childProperty: cstring) {.
    importc: "gtk_widget_child_notify", libprag.}

proc childNotify*(self: Widget; childProperty: string) =
  gtk_widget_child_notify(cast[ptr Widget00](self.impl), cstring(childProperty))

proc gtk_widget_class_path*(self: ptr Widget00; pathLength: var uint32; path: var cstring; 
    pathReversed: var cstring) {.
    importc: "gtk_widget_class_path", libprag.}

proc classPath*(self: Widget; pathLength: var int; path: var string; 
    pathReversed: var string) =
  var pathReversed_00 = cstring(pathReversed)
  var pathLength_00 = uint32(pathLength)
  var path_00 = cstring(path)
  gtk_widget_class_path(cast[ptr Widget00](self.impl), pathLength_00, path_00, pathReversed_00)
  pathReversed = $(pathReversed_00)
  pathLength = int(pathLength_00)
  path = $(path_00)

proc gtk_widget_create_pango_context*(self: ptr Widget00): ptr pango.Context00 {.
    importc: "gtk_widget_create_pango_context", libprag.}

proc createPangoContext*(self: Widget): pango.Context =
  let gobj = gtk_widget_create_pango_context(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Context](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_create_pango_layout*(self: ptr Widget00; text: cstring): ptr pango.Layout00 {.
    importc: "gtk_widget_create_pango_layout", libprag.}

proc createPangoLayout*(self: Widget; text: string): pango.Layout =
  let gobj = gtk_widget_create_pango_layout(cast[ptr Widget00](self.impl), cstring(text))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Layout](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_destroy*(self: ptr Widget00) {.
    importc: "gtk_widget_destroy", libprag.}

proc destroy*(self: Widget) =
  gtk_widget_destroy(cast[ptr Widget00](self.impl))

proc gtk_widget_destroyed*(self: ptr Widget00; widgetPointer: ptr Widget00) {.
    importc: "gtk_widget_destroyed", libprag.}

proc destroyed*(self: ptr Widget00; widgetPointer: ptr Widget00) {.
    importc: "gtk_widget_destroyed", libprag.}

proc gtk_widget_device_is_shadowed*(self: ptr Widget00; device: ptr gdk.Device00): gboolean {.
    importc: "gtk_widget_device_is_shadowed", libprag.}

proc deviceIsShadowed*(self: Widget; device: gdk.Device): bool =
  toBool(gtk_widget_device_is_shadowed(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl)))

proc gtk_drag_check_threshold*(self: ptr Widget00; startX: int32; startY: int32; 
    currentX: int32; currentY: int32): gboolean {.
    importc: "gtk_drag_check_threshold", libprag.}

proc dragCheckThreshold*(self: Widget; startX: int; startY: int; currentX: int; 
    currentY: int): bool =
  toBool(gtk_drag_check_threshold(cast[ptr Widget00](self.impl), int32(startX), int32(startY), int32(currentX), int32(currentY)))

proc gtk_drag_dest_add_image_targets*(self: ptr Widget00) {.
    importc: "gtk_drag_dest_add_image_targets", libprag.}

proc dragDestAddImageTargets*(self: Widget) =
  gtk_drag_dest_add_image_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_dest_add_text_targets*(self: ptr Widget00) {.
    importc: "gtk_drag_dest_add_text_targets", libprag.}

proc dragDestAddTextTargets*(self: Widget) =
  gtk_drag_dest_add_text_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_dest_add_uri_targets*(self: ptr Widget00) {.
    importc: "gtk_drag_dest_add_uri_targets", libprag.}

proc dragDestAddUriTargets*(self: Widget) =
  gtk_drag_dest_add_uri_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_dest_get_track_motion*(self: ptr Widget00): gboolean {.
    importc: "gtk_drag_dest_get_track_motion", libprag.}

proc dragDestGetTrackMotion*(self: Widget): bool =
  toBool(gtk_drag_dest_get_track_motion(cast[ptr Widget00](self.impl)))

proc gtk_drag_dest_set_proxy*(self: ptr Widget00; proxyWindow: ptr gdk.Window00; 
    protocol: gdk.DragProtocol; useCoordinates: gboolean) {.
    importc: "gtk_drag_dest_set_proxy", libprag.}

proc dragDestSetProxy*(self: Widget; proxyWindow: gdk.Window; protocol: gdk.DragProtocol; 
    useCoordinates: bool) =
  gtk_drag_dest_set_proxy(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](proxyWindow.impl), protocol, gboolean(useCoordinates))

proc gtk_drag_dest_set_track_motion*(self: ptr Widget00; trackMotion: gboolean) {.
    importc: "gtk_drag_dest_set_track_motion", libprag.}

proc dragDestSetTrackMotion*(self: Widget; trackMotion: bool) =
  gtk_drag_dest_set_track_motion(cast[ptr Widget00](self.impl), gboolean(trackMotion))

proc gtk_drag_dest_unset*(self: ptr Widget00) {.
    importc: "gtk_drag_dest_unset", libprag.}

proc dragDestUnset*(self: Widget) =
  gtk_drag_dest_unset(cast[ptr Widget00](self.impl))

proc gtk_drag_get_data*(self: ptr Widget00; context: ptr gdk.DragContext00; 
    target: ptr gdk.Atom00; time: uint32) {.
    importc: "gtk_drag_get_data", libprag.}

proc dragGetData*(self: Widget; context: gdk.DragContext; target: gdk.Atom; 
    time: int) =
  gtk_drag_get_data(cast[ptr Widget00](self.impl), cast[ptr gdk.DragContext00](context.impl), cast[ptr gdk.Atom00](target.impl), uint32(time))

proc gtk_drag_highlight*(self: ptr Widget00) {.
    importc: "gtk_drag_highlight", libprag.}

proc dragHighlight*(self: Widget) =
  gtk_drag_highlight(cast[ptr Widget00](self.impl))

proc gtk_drag_source_add_image_targets*(self: ptr Widget00) {.
    importc: "gtk_drag_source_add_image_targets", libprag.}

proc dragSourceAddImageTargets*(self: Widget) =
  gtk_drag_source_add_image_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_source_add_text_targets*(self: ptr Widget00) {.
    importc: "gtk_drag_source_add_text_targets", libprag.}

proc dragSourceAddTextTargets*(self: Widget) =
  gtk_drag_source_add_text_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_source_add_uri_targets*(self: ptr Widget00) {.
    importc: "gtk_drag_source_add_uri_targets", libprag.}

proc dragSourceAddUriTargets*(self: Widget) =
  gtk_drag_source_add_uri_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_source_set_icon_gicon*(self: ptr Widget00; icon: ptr gio.Icon00) {.
    importc: "gtk_drag_source_set_icon_gicon", libprag.}

proc dragSourceSetIconGicon*(self: Widget; icon: gio.Icon) =
  gtk_drag_source_set_icon_gicon(cast[ptr Widget00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc gtk_drag_source_set_icon_name*(self: ptr Widget00; iconName: cstring) {.
    importc: "gtk_drag_source_set_icon_name", libprag.}

proc dragSourceSetIconName*(self: Widget; iconName: string) =
  gtk_drag_source_set_icon_name(cast[ptr Widget00](self.impl), cstring(iconName))

proc gtk_drag_source_set_icon_pixbuf*(self: ptr Widget00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_drag_source_set_icon_pixbuf", libprag.}

proc dragSourceSetIconPixbuf*(self: Widget; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_drag_source_set_icon_pixbuf(cast[ptr Widget00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_drag_source_set_icon_stock*(self: ptr Widget00; stockId: cstring) {.
    importc: "gtk_drag_source_set_icon_stock", libprag.}

proc dragSourceSetIconStock*(self: Widget; stockId: string) =
  gtk_drag_source_set_icon_stock(cast[ptr Widget00](self.impl), cstring(stockId))

proc gtk_drag_source_unset*(self: ptr Widget00) {.
    importc: "gtk_drag_source_unset", libprag.}

proc dragSourceUnset*(self: Widget) =
  gtk_drag_source_unset(cast[ptr Widget00](self.impl))

proc gtk_drag_unhighlight*(self: ptr Widget00) {.
    importc: "gtk_drag_unhighlight", libprag.}

proc dragUnhighlight*(self: Widget) =
  gtk_drag_unhighlight(cast[ptr Widget00](self.impl))

proc gtk_widget_draw*(self: ptr Widget00; cr: ptr cairo.Context00) {.
    importc: "gtk_widget_draw", libprag.}

proc draw*(self: Widget; cr: cairo.Context) =
  gtk_widget_draw(cast[ptr Widget00](self.impl), cast[ptr cairo.Context00](cr.impl))

proc gtk_widget_ensure_style*(self: ptr Widget00) {.
    importc: "gtk_widget_ensure_style", libprag.}

proc ensureStyle*(self: Widget) =
  gtk_widget_ensure_style(cast[ptr Widget00](self.impl))

proc gtk_widget_error_bell*(self: ptr Widget00) {.
    importc: "gtk_widget_error_bell", libprag.}

proc errorBell*(self: Widget) =
  gtk_widget_error_bell(cast[ptr Widget00](self.impl))

proc gtk_widget_event*(self: ptr Widget00; event: ptr gdk.Event00): gboolean {.
    importc: "gtk_widget_event", libprag.}

proc event*(self: Widget; event: gdk.Event): bool =
  toBool(gtk_widget_event(cast[ptr Widget00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_widget_freeze_child_notify*(self: ptr Widget00) {.
    importc: "gtk_widget_freeze_child_notify", libprag.}

proc freezeChildNotify*(self: Widget) =
  gtk_widget_freeze_child_notify(cast[ptr Widget00](self.impl))

proc gtk_widget_get_accessible*(self: ptr Widget00): ptr atk.Object00 {.
    importc: "gtk_widget_get_accessible", libprag.}

proc getAccessible*(self: Widget): atk.Object =
  let gobj = gtk_widget_get_accessible(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[atk.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accessible*(self: Widget): atk.Object =
  let gobj = gtk_widget_get_accessible(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[atk.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_action_group*(self: ptr Widget00; prefix: cstring): ptr gio.ActionGroup00 {.
    importc: "gtk_widget_get_action_group", libprag.}

proc getActionGroup*(self: Widget; prefix: string): gio.ActionGroup =
  new(result)
  result.impl = gtk_widget_get_action_group(cast[ptr Widget00](self.impl), cstring(prefix))

proc actionGroup*(self: Widget; prefix: string): gio.ActionGroup =
  new(result)
  result.impl = gtk_widget_get_action_group(cast[ptr Widget00](self.impl), cstring(prefix))

proc gtk_widget_get_allocated_baseline*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_allocated_baseline", libprag.}

proc getAllocatedBaseline*(self: Widget): int =
  int(gtk_widget_get_allocated_baseline(cast[ptr Widget00](self.impl)))

proc allocatedBaseline*(self: Widget): int =
  int(gtk_widget_get_allocated_baseline(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_allocated_height*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_allocated_height", libprag.}

proc getAllocatedHeight*(self: Widget): int =
  int(gtk_widget_get_allocated_height(cast[ptr Widget00](self.impl)))

proc allocatedHeight*(self: Widget): int =
  int(gtk_widget_get_allocated_height(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_allocated_size*(self: ptr Widget00; allocation: var gdk.Rectangle00; 
    baseline: var int32) {.
    importc: "gtk_widget_get_allocated_size", libprag.}

proc getAllocatedSize*(self: ptr Widget00; allocation: var gdk.Rectangle00; 
    baseline: var int32) {.
    importc: "gtk_widget_get_allocated_size", libprag.}

proc allocatedSize*(self: ptr Widget00; allocation: var gdk.Rectangle00; 
    baseline: var int32) {.
    importc: "gtk_widget_get_allocated_size", libprag.}

proc gtk_widget_get_allocated_width*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_allocated_width", libprag.}

proc getAllocatedWidth*(self: Widget): int =
  int(gtk_widget_get_allocated_width(cast[ptr Widget00](self.impl)))

proc allocatedWidth*(self: Widget): int =
  int(gtk_widget_get_allocated_width(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_allocation*(self: ptr Widget00; allocation: var gdk.Rectangle00) {.
    importc: "gtk_widget_get_allocation", libprag.}

proc getAllocation*(self: ptr Widget00; allocation: var gdk.Rectangle00) {.
    importc: "gtk_widget_get_allocation", libprag.}

proc allocation*(self: ptr Widget00; allocation: var gdk.Rectangle00) {.
    importc: "gtk_widget_get_allocation", libprag.}

proc gtk_widget_get_ancestor*(self: ptr Widget00; widgetType: GType): ptr Widget00 {.
    importc: "gtk_widget_get_ancestor", libprag.}

proc getAncestor*(self: Widget; widgetType: GType): Widget =
  let gobj = gtk_widget_get_ancestor(cast[ptr Widget00](self.impl), widgetType)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc ancestor*(self: Widget; widgetType: GType): Widget =
  let gobj = gtk_widget_get_ancestor(cast[ptr Widget00](self.impl), widgetType)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_app_paintable*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_app_paintable", libprag.}

proc getAppPaintable*(self: Widget): bool =
  toBool(gtk_widget_get_app_paintable(cast[ptr Widget00](self.impl)))

proc appPaintable*(self: Widget): bool =
  toBool(gtk_widget_get_app_paintable(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_can_default*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_can_default", libprag.}

proc getCanDefault*(self: Widget): bool =
  toBool(gtk_widget_get_can_default(cast[ptr Widget00](self.impl)))

proc canDefault*(self: Widget): bool =
  toBool(gtk_widget_get_can_default(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_can_focus*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_can_focus", libprag.}

proc getCanFocus*(self: Widget): bool =
  toBool(gtk_widget_get_can_focus(cast[ptr Widget00](self.impl)))

proc canFocus*(self: Widget): bool =
  toBool(gtk_widget_get_can_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_child_visible*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_child_visible", libprag.}

proc getChildVisible*(self: Widget): bool =
  toBool(gtk_widget_get_child_visible(cast[ptr Widget00](self.impl)))

proc childVisible*(self: Widget): bool =
  toBool(gtk_widget_get_child_visible(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_clip*(self: ptr Widget00; clip: var gdk.Rectangle00) {.
    importc: "gtk_widget_get_clip", libprag.}

proc getClip*(self: ptr Widget00; clip: var gdk.Rectangle00) {.
    importc: "gtk_widget_get_clip", libprag.}

proc clip*(self: ptr Widget00; clip: var gdk.Rectangle00) {.
    importc: "gtk_widget_get_clip", libprag.}

proc gtk_widget_get_composite_name*(self: ptr Widget00): cstring {.
    importc: "gtk_widget_get_composite_name", libprag.}

proc getCompositeName*(self: Widget): string =
  let resul0 = gtk_widget_get_composite_name(cast[ptr Widget00](self.impl))
  result = $resul0
  cogfree(resul0)

proc compositeName*(self: Widget): string =
  let resul0 = gtk_widget_get_composite_name(cast[ptr Widget00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_widget_get_device_enabled*(self: ptr Widget00; device: ptr gdk.Device00): gboolean {.
    importc: "gtk_widget_get_device_enabled", libprag.}

proc getDeviceEnabled*(self: Widget; device: gdk.Device): bool =
  toBool(gtk_widget_get_device_enabled(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl)))

proc deviceEnabled*(self: Widget; device: gdk.Device): bool =
  toBool(gtk_widget_get_device_enabled(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl)))

proc gtk_widget_get_device_events*(self: ptr Widget00; device: ptr gdk.Device00): gdk.EventMask {.
    importc: "gtk_widget_get_device_events", libprag.}

proc getDeviceEvents*(self: Widget; device: gdk.Device): gdk.EventMask =
  gtk_widget_get_device_events(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl))

proc deviceEvents*(self: Widget; device: gdk.Device): gdk.EventMask =
  gtk_widget_get_device_events(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl))

proc gtk_widget_get_direction*(self: ptr Widget00): TextDirection {.
    importc: "gtk_widget_get_direction", libprag.}

proc getDirection*(self: Widget): TextDirection =
  gtk_widget_get_direction(cast[ptr Widget00](self.impl))

proc direction*(self: Widget): TextDirection =
  gtk_widget_get_direction(cast[ptr Widget00](self.impl))

proc gtk_widget_get_display*(self: ptr Widget00): ptr gdk.Display00 {.
    importc: "gtk_widget_get_display", libprag.}

proc getDisplay*(self: Widget): gdk.Display =
  let gobj = gtk_widget_get_display(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Display](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: Widget): gdk.Display =
  let gobj = gtk_widget_get_display(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Display](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_double_buffered*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_double_buffered", libprag.}

proc getDoubleBuffered*(self: Widget): bool =
  toBool(gtk_widget_get_double_buffered(cast[ptr Widget00](self.impl)))

proc doubleBuffered*(self: Widget): bool =
  toBool(gtk_widget_get_double_buffered(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_events*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_events", libprag.}

proc getEvents*(self: Widget): int =
  int(gtk_widget_get_events(cast[ptr Widget00](self.impl)))

proc events*(self: Widget): int =
  int(gtk_widget_get_events(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_focus_on_click*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_focus_on_click", libprag.}

proc getFocusOnClick*(self: Widget): bool =
  toBool(gtk_widget_get_focus_on_click(cast[ptr Widget00](self.impl)))

proc focusOnClick*(self: Widget): bool =
  toBool(gtk_widget_get_focus_on_click(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_font_map*(self: ptr Widget00): ptr pango.FontMap00 {.
    importc: "gtk_widget_get_font_map", libprag.}

proc getFontMap*(self: Widget): pango.FontMap =
  let gobj = gtk_widget_get_font_map(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontMap](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontMap*(self: Widget): pango.FontMap =
  let gobj = gtk_widget_get_font_map(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontMap](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_font_options*(self: ptr Widget00): ptr cairo.FontOptions00 {.
    importc: "gtk_widget_get_font_options", libprag.}

proc getFontOptions*(self: Widget): cairo.FontOptions =
  new(result)
  result.impl = gtk_widget_get_font_options(cast[ptr Widget00](self.impl))

proc fontOptions*(self: Widget): cairo.FontOptions =
  new(result)
  result.impl = gtk_widget_get_font_options(cast[ptr Widget00](self.impl))

proc gtk_widget_get_frame_clock*(self: ptr Widget00): ptr gdk.FrameClock00 {.
    importc: "gtk_widget_get_frame_clock", libprag.}

proc getFrameClock*(self: Widget): gdk.FrameClock =
  let gobj = gtk_widget_get_frame_clock(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.FrameClock](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc frameClock*(self: Widget): gdk.FrameClock =
  let gobj = gtk_widget_get_frame_clock(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.FrameClock](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_has_tooltip*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_has_tooltip", libprag.}

proc getHasTooltip*(self: Widget): bool =
  toBool(gtk_widget_get_has_tooltip(cast[ptr Widget00](self.impl)))

proc hasTooltip*(self: Widget): bool =
  toBool(gtk_widget_get_has_tooltip(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_has_window*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_has_window", libprag.}

proc getHasWindow*(self: Widget): bool =
  toBool(gtk_widget_get_has_window(cast[ptr Widget00](self.impl)))

proc hasWindow*(self: Widget): bool =
  toBool(gtk_widget_get_has_window(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_hexpand*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_hexpand", libprag.}

proc getHexpand*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand(cast[ptr Widget00](self.impl)))

proc hexpand*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_hexpand_set*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_hexpand_set", libprag.}

proc getHexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand_set(cast[ptr Widget00](self.impl)))

proc hexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand_set(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_mapped*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_mapped", libprag.}

proc getMapped*(self: Widget): bool =
  toBool(gtk_widget_get_mapped(cast[ptr Widget00](self.impl)))

proc mapped*(self: Widget): bool =
  toBool(gtk_widget_get_mapped(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_bottom*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_margin_bottom", libprag.}

proc getMarginBottom*(self: Widget): int =
  int(gtk_widget_get_margin_bottom(cast[ptr Widget00](self.impl)))

proc marginBottom*(self: Widget): int =
  int(gtk_widget_get_margin_bottom(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_end*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_margin_end", libprag.}

proc getMarginEnd*(self: Widget): int =
  int(gtk_widget_get_margin_end(cast[ptr Widget00](self.impl)))

proc marginEnd*(self: Widget): int =
  int(gtk_widget_get_margin_end(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_left*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_margin_left", libprag.}

proc getMarginLeft*(self: Widget): int =
  int(gtk_widget_get_margin_left(cast[ptr Widget00](self.impl)))

proc marginLeft*(self: Widget): int =
  int(gtk_widget_get_margin_left(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_right*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_margin_right", libprag.}

proc getMarginRight*(self: Widget): int =
  int(gtk_widget_get_margin_right(cast[ptr Widget00](self.impl)))

proc marginRight*(self: Widget): int =
  int(gtk_widget_get_margin_right(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_start*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_margin_start", libprag.}

proc getMarginStart*(self: Widget): int =
  int(gtk_widget_get_margin_start(cast[ptr Widget00](self.impl)))

proc marginStart*(self: Widget): int =
  int(gtk_widget_get_margin_start(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_top*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_margin_top", libprag.}

proc getMarginTop*(self: Widget): int =
  int(gtk_widget_get_margin_top(cast[ptr Widget00](self.impl)))

proc marginTop*(self: Widget): int =
  int(gtk_widget_get_margin_top(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_modifier_mask*(self: ptr Widget00; intent: gdk.ModifierIntent): gdk.ModifierType {.
    importc: "gtk_widget_get_modifier_mask", libprag.}

proc getModifierMask*(self: Widget; intent: gdk.ModifierIntent): gdk.ModifierType =
  gtk_widget_get_modifier_mask(cast[ptr Widget00](self.impl), intent)

proc modifierMask*(self: Widget; intent: gdk.ModifierIntent): gdk.ModifierType =
  gtk_widget_get_modifier_mask(cast[ptr Widget00](self.impl), intent)

proc gtk_widget_get_modifier_style*(self: ptr Widget00): ptr RcStyle00 {.
    importc: "gtk_widget_get_modifier_style", libprag.}

proc getModifierStyle*(self: Widget): RcStyle =
  let gobj = gtk_widget_get_modifier_style(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[RcStyle](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc modifierStyle*(self: Widget): RcStyle =
  let gobj = gtk_widget_get_modifier_style(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[RcStyle](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_name*(self: ptr Widget00): cstring {.
    importc: "gtk_widget_get_name", libprag.}

proc getName*(self: Widget): string =
  let resul0 = gtk_widget_get_name(cast[ptr Widget00](self.impl))
  result = $resul0

proc name*(self: Widget): string =
  let resul0 = gtk_widget_get_name(cast[ptr Widget00](self.impl))
  result = $resul0

proc gtk_widget_get_no_show_all*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_no_show_all", libprag.}

proc getNoShowAll*(self: Widget): bool =
  toBool(gtk_widget_get_no_show_all(cast[ptr Widget00](self.impl)))

proc noShowAll*(self: Widget): bool =
  toBool(gtk_widget_get_no_show_all(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_opacity*(self: ptr Widget00): cdouble {.
    importc: "gtk_widget_get_opacity", libprag.}

proc getOpacity*(self: Widget): cdouble =
  gtk_widget_get_opacity(cast[ptr Widget00](self.impl))

proc opacity*(self: Widget): cdouble =
  gtk_widget_get_opacity(cast[ptr Widget00](self.impl))

proc gtk_widget_get_pango_context*(self: ptr Widget00): ptr pango.Context00 {.
    importc: "gtk_widget_get_pango_context", libprag.}

proc getPangoContext*(self: Widget): pango.Context =
  let gobj = gtk_widget_get_pango_context(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Context](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pangoContext*(self: Widget): pango.Context =
  let gobj = gtk_widget_get_pango_context(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Context](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_parent*(self: ptr Widget00): ptr Widget00 {.
    importc: "gtk_widget_get_parent", libprag.}

proc getParent*(self: Widget): Widget =
  let gobj = gtk_widget_get_parent(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parent*(self: Widget): Widget =
  let gobj = gtk_widget_get_parent(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_parent_window*(self: ptr Widget00): ptr gdk.Window00 {.
    importc: "gtk_widget_get_parent_window", libprag.}

proc getParentWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_parent_window(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parentWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_parent_window(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_pointer*(self: ptr Widget00; x: var int32; y: var int32) {.
    importc: "gtk_widget_get_pointer", libprag.}

proc getPointer*(self: Widget; x: var int; y: var int) =
  var y_00 = int32(y)
  var x_00 = int32(x)
  gtk_widget_get_pointer(cast[ptr Widget00](self.impl), x_00, y_00)
  y = int(y_00)
  x = int(x_00)

proc gtk_widget_get_preferred_height*(self: ptr Widget00; minimumHeight: var int32; naturalHeight: var int32) {.
    importc: "gtk_widget_get_preferred_height", libprag.}

proc getPreferredHeight*(self: Widget; minimumHeight: var int; naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_widget_get_preferred_height(cast[ptr Widget00](self.impl), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc preferredHeight*(self: Widget; minimumHeight: var int; naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_widget_get_preferred_height(cast[ptr Widget00](self.impl), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc gtk_widget_get_preferred_height_and_baseline_for_width*(self: ptr Widget00; width: int32; minimumHeight: var int32; 
    naturalHeight: var int32; minimumBaseline: var int32; naturalBaseline: var int32) {.
    importc: "gtk_widget_get_preferred_height_and_baseline_for_width", libprag.}

proc getPreferredHeightAndBaselineForWidth*(self: Widget; width: int; minimumHeight: var int; 
    naturalHeight: var int; minimumBaseline: var int; naturalBaseline: var int) =
  var minimumBaseline_00 = int32(minimumBaseline)
  var naturalHeight_00 = int32(naturalHeight)
  var naturalBaseline_00 = int32(naturalBaseline)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_widget_get_preferred_height_and_baseline_for_width(cast[ptr Widget00](self.impl), int32(width), minimumHeight_00, naturalHeight_00, minimumBaseline_00, naturalBaseline_00)
  minimumBaseline = int(minimumBaseline_00)
  naturalHeight = int(naturalHeight_00)
  naturalBaseline = int(naturalBaseline_00)
  minimumHeight = int(minimumHeight_00)

proc preferredHeightAndBaselineForWidth*(self: Widget; width: int; minimumHeight: var int; 
    naturalHeight: var int; minimumBaseline: var int; naturalBaseline: var int) =
  var minimumBaseline_00 = int32(minimumBaseline)
  var naturalHeight_00 = int32(naturalHeight)
  var naturalBaseline_00 = int32(naturalBaseline)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_widget_get_preferred_height_and_baseline_for_width(cast[ptr Widget00](self.impl), int32(width), minimumHeight_00, naturalHeight_00, minimumBaseline_00, naturalBaseline_00)
  minimumBaseline = int(minimumBaseline_00)
  naturalHeight = int(naturalHeight_00)
  naturalBaseline = int(naturalBaseline_00)
  minimumHeight = int(minimumHeight_00)

proc gtk_widget_get_preferred_height_for_width*(self: ptr Widget00; width: int32; minimumHeight: var int32; 
    naturalHeight: var int32) {.
    importc: "gtk_widget_get_preferred_height_for_width", libprag.}

proc getPreferredHeightForWidth*(self: Widget; width: int; minimumHeight: var int; 
    naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_widget_get_preferred_height_for_width(cast[ptr Widget00](self.impl), int32(width), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc preferredHeightForWidth*(self: Widget; width: int; minimumHeight: var int; 
    naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_widget_get_preferred_height_for_width(cast[ptr Widget00](self.impl), int32(width), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc gtk_widget_get_preferred_width*(self: ptr Widget00; minimumWidth: var int32; naturalWidth: var int32) {.
    importc: "gtk_widget_get_preferred_width", libprag.}

proc getPreferredWidth*(self: Widget; minimumWidth: var int; naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_widget_get_preferred_width(cast[ptr Widget00](self.impl), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc preferredWidth*(self: Widget; minimumWidth: var int; naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_widget_get_preferred_width(cast[ptr Widget00](self.impl), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc gtk_widget_get_preferred_width_for_height*(self: ptr Widget00; height: int32; minimumWidth: var int32; 
    naturalWidth: var int32) {.
    importc: "gtk_widget_get_preferred_width_for_height", libprag.}

proc getPreferredWidthForHeight*(self: Widget; height: int; minimumWidth: var int; 
    naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_widget_get_preferred_width_for_height(cast[ptr Widget00](self.impl), int32(height), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc preferredWidthForHeight*(self: Widget; height: int; minimumWidth: var int; 
    naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_widget_get_preferred_width_for_height(cast[ptr Widget00](self.impl), int32(height), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc gtk_widget_get_realized*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_realized", libprag.}

proc getRealized*(self: Widget): bool =
  toBool(gtk_widget_get_realized(cast[ptr Widget00](self.impl)))

proc realized*(self: Widget): bool =
  toBool(gtk_widget_get_realized(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_receives_default*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_receives_default", libprag.}

proc getReceivesDefault*(self: Widget): bool =
  toBool(gtk_widget_get_receives_default(cast[ptr Widget00](self.impl)))

proc receivesDefault*(self: Widget): bool =
  toBool(gtk_widget_get_receives_default(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_root_window*(self: ptr Widget00): ptr gdk.Window00 {.
    importc: "gtk_widget_get_root_window", libprag.}

proc getRootWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_root_window(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc rootWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_root_window(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_scale_factor*(self: ptr Widget00): int32 {.
    importc: "gtk_widget_get_scale_factor", libprag.}

proc getScaleFactor*(self: Widget): int =
  int(gtk_widget_get_scale_factor(cast[ptr Widget00](self.impl)))

proc scaleFactor*(self: Widget): int =
  int(gtk_widget_get_scale_factor(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_screen*(self: ptr Widget00): ptr gdk.Screen00 {.
    importc: "gtk_widget_get_screen", libprag.}

proc getScreen*(self: Widget): gdk.Screen =
  let gobj = gtk_widget_get_screen(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: Widget): gdk.Screen =
  let gobj = gtk_widget_get_screen(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_sensitive*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_sensitive", libprag.}

proc getSensitive*(self: Widget): bool =
  toBool(gtk_widget_get_sensitive(cast[ptr Widget00](self.impl)))

proc sensitive*(self: Widget): bool =
  toBool(gtk_widget_get_sensitive(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_size_request*(self: ptr Widget00; width: var int32; height: var int32) {.
    importc: "gtk_widget_get_size_request", libprag.}

proc getSizeRequest*(self: Widget; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_widget_get_size_request(cast[ptr Widget00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc sizeRequest*(self: Widget; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_widget_get_size_request(cast[ptr Widget00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc gtk_widget_get_state*(self: ptr Widget00): StateType {.
    importc: "gtk_widget_get_state", libprag.}

proc getState*(self: Widget): StateType =
  gtk_widget_get_state(cast[ptr Widget00](self.impl))

proc state*(self: Widget): StateType =
  gtk_widget_get_state(cast[ptr Widget00](self.impl))

proc gtk_widget_get_state_flags*(self: ptr Widget00): StateFlags {.
    importc: "gtk_widget_get_state_flags", libprag.}

proc getStateFlags*(self: Widget): StateFlags =
  gtk_widget_get_state_flags(cast[ptr Widget00](self.impl))

proc stateFlags*(self: Widget): StateFlags =
  gtk_widget_get_state_flags(cast[ptr Widget00](self.impl))

proc gtk_widget_get_style*(self: ptr Widget00): ptr Style00 {.
    importc: "gtk_widget_get_style", libprag.}

proc getStyle*(self: Widget): Style =
  let gobj = gtk_widget_get_style(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Style](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc style*(self: Widget): Style =
  let gobj = gtk_widget_get_style(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Style](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_support_multidevice*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_support_multidevice", libprag.}

proc getSupportMultidevice*(self: Widget): bool =
  toBool(gtk_widget_get_support_multidevice(cast[ptr Widget00](self.impl)))

proc supportMultidevice*(self: Widget): bool =
  toBool(gtk_widget_get_support_multidevice(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_template_child*(self: ptr Widget00; widgetType: GType; name: cstring): ptr gobject.Object00 {.
    importc: "gtk_widget_get_template_child", libprag.}

proc getTemplateChild*(self: Widget; widgetType: GType; name: string): gobject.Object =
  let gobj = gtk_widget_get_template_child(cast[ptr Widget00](self.impl), widgetType, cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gobject.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc templateChild*(self: Widget; widgetType: GType; name: string): gobject.Object =
  let gobj = gtk_widget_get_template_child(cast[ptr Widget00](self.impl), widgetType, cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gobject.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_tooltip_markup*(self: ptr Widget00): cstring {.
    importc: "gtk_widget_get_tooltip_markup", libprag.}

proc getTooltipMarkup*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_markup(cast[ptr Widget00](self.impl))
  result = $resul0
  cogfree(resul0)

proc tooltipMarkup*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_markup(cast[ptr Widget00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_widget_get_tooltip_text*(self: ptr Widget00): cstring {.
    importc: "gtk_widget_get_tooltip_text", libprag.}

proc getTooltipText*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_text(cast[ptr Widget00](self.impl))
  result = $resul0
  cogfree(resul0)

proc tooltipText*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_text(cast[ptr Widget00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_widget_get_toplevel*(self: ptr Widget00): ptr Widget00 {.
    importc: "gtk_widget_get_toplevel", libprag.}

proc getToplevel*(self: Widget): Widget =
  let gobj = gtk_widget_get_toplevel(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc toplevel*(self: Widget): Widget =
  let gobj = gtk_widget_get_toplevel(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_vexpand*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_vexpand", libprag.}

proc getVexpand*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand(cast[ptr Widget00](self.impl)))

proc vexpand*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_vexpand_set*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_vexpand_set", libprag.}

proc getVexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand_set(cast[ptr Widget00](self.impl)))

proc vexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand_set(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_visible*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_get_visible", libprag.}

proc getVisible*(self: Widget): bool =
  toBool(gtk_widget_get_visible(cast[ptr Widget00](self.impl)))

proc visible*(self: Widget): bool =
  toBool(gtk_widget_get_visible(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_visual*(self: ptr Widget00): ptr gdk.Visual00 {.
    importc: "gtk_widget_get_visual", libprag.}

proc getVisual*(self: Widget): gdk.Visual =
  let gobj = gtk_widget_get_visual(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Visual](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc visual*(self: Widget): gdk.Visual =
  let gobj = gtk_widget_get_visual(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Visual](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_window*(self: ptr Widget00): ptr gdk.Window00 {.
    importc: "gtk_widget_get_window", libprag.}

proc getWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_window(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc window*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_window(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grab_add*(self: ptr Widget00) {.
    importc: "gtk_grab_add", libprag.}

proc grabAdd*(self: Widget) =
  gtk_grab_add(cast[ptr Widget00](self.impl))

proc gtk_widget_grab_default*(self: ptr Widget00) {.
    importc: "gtk_widget_grab_default", libprag.}

proc grabDefault*(self: Widget) =
  gtk_widget_grab_default(cast[ptr Widget00](self.impl))

proc gtk_widget_grab_focus*(self: ptr Widget00) {.
    importc: "gtk_widget_grab_focus", libprag.}

proc grabFocus*(self: Widget) =
  gtk_widget_grab_focus(cast[ptr Widget00](self.impl))

proc gtk_grab_remove*(self: ptr Widget00) {.
    importc: "gtk_grab_remove", libprag.}

proc grabRemove*(self: Widget) =
  gtk_grab_remove(cast[ptr Widget00](self.impl))

proc gtk_widget_has_default*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_has_default", libprag.}

proc hasDefault*(self: Widget): bool =
  toBool(gtk_widget_has_default(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_focus*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_has_focus", libprag.}

proc hasFocus*(self: Widget): bool =
  toBool(gtk_widget_has_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_grab*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_has_grab", libprag.}

proc hasGrab*(self: Widget): bool =
  toBool(gtk_widget_has_grab(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_rc_style*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_has_rc_style", libprag.}

proc hasRcStyle*(self: Widget): bool =
  toBool(gtk_widget_has_rc_style(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_screen*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_has_screen", libprag.}

proc hasScreen*(self: Widget): bool =
  toBool(gtk_widget_has_screen(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_visible_focus*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_has_visible_focus", libprag.}

proc hasVisibleFocus*(self: Widget): bool =
  toBool(gtk_widget_has_visible_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_hide*(self: ptr Widget00) {.
    importc: "gtk_widget_hide", libprag.}

proc hide*(self: Widget) =
  gtk_widget_hide(cast[ptr Widget00](self.impl))

proc gtk_widget_hide_on_delete*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_hide_on_delete", libprag.}

proc hideOnDelete*(self: Widget): bool =
  toBool(gtk_widget_hide_on_delete(cast[ptr Widget00](self.impl)))

proc gtk_widget_in_destruction*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_in_destruction", libprag.}

proc inDestruction*(self: Widget): bool =
  toBool(gtk_widget_in_destruction(cast[ptr Widget00](self.impl)))

proc gtk_widget_init_template*(self: ptr Widget00) {.
    importc: "gtk_widget_init_template", libprag.}

proc initTemplate*(self: Widget) =
  gtk_widget_init_template(cast[ptr Widget00](self.impl))

proc gtk_widget_input_shape_combine_region*(self: ptr Widget00; region: ptr cairo.Region00) {.
    importc: "gtk_widget_input_shape_combine_region", libprag.}

proc inputShapeCombineRegion*(self: Widget; region: cairo.Region) =
  gtk_widget_input_shape_combine_region(cast[ptr Widget00](self.impl), cast[ptr cairo.Region00](region.impl))

proc gtk_widget_insert_action_group*(self: ptr Widget00; name: cstring; group: ptr gio.ActionGroup00) {.
    importc: "gtk_widget_insert_action_group", libprag.}

proc insertActionGroup*(self: Widget; name: string; group: gio.ActionGroup) =
  gtk_widget_insert_action_group(cast[ptr Widget00](self.impl), cstring(name), cast[ptr gio.ActionGroup00](group.impl))

proc gtk_widget_intersect*(self: ptr Widget00; area: ptr gdk.Rectangle00; intersection: var gdk.Rectangle00): gboolean {.
    importc: "gtk_widget_intersect", libprag.}

proc intersect*(self: ptr Widget00; area: ptr gdk.Rectangle00; intersection: var gdk.Rectangle00): gboolean {.
    importc: "gtk_widget_intersect", libprag.}

proc gtk_widget_is_ancestor*(self: ptr Widget00; ancestor: ptr Widget00): gboolean {.
    importc: "gtk_widget_is_ancestor", libprag.}

proc isAncestor*(self: Widget; ancestor: Widget): bool =
  toBool(gtk_widget_is_ancestor(cast[ptr Widget00](self.impl), cast[ptr Widget00](ancestor.impl)))

proc gtk_widget_is_composited*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_is_composited", libprag.}

proc isComposited*(self: Widget): bool =
  toBool(gtk_widget_is_composited(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_drawable*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_is_drawable", libprag.}

proc isDrawable*(self: Widget): bool =
  toBool(gtk_widget_is_drawable(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_focus*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_is_focus", libprag.}

proc isFocus*(self: Widget): bool =
  toBool(gtk_widget_is_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_sensitive*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_is_sensitive", libprag.}

proc isSensitive*(self: Widget): bool =
  toBool(gtk_widget_is_sensitive(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_toplevel*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_is_toplevel", libprag.}

proc isToplevel*(self: Widget): bool =
  toBool(gtk_widget_is_toplevel(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_visible*(self: ptr Widget00): gboolean {.
    importc: "gtk_widget_is_visible", libprag.}

proc isVisible*(self: Widget): bool =
  toBool(gtk_widget_is_visible(cast[ptr Widget00](self.impl)))

proc gtk_widget_keynav_failed*(self: ptr Widget00; direction: DirectionType): gboolean {.
    importc: "gtk_widget_keynav_failed", libprag.}

proc keynavFailed*(self: Widget; direction: DirectionType): bool =
  toBool(gtk_widget_keynav_failed(cast[ptr Widget00](self.impl), direction))

proc gtk_widget_list_accel_closures*(self: ptr Widget00): ptr pointer {.
    importc: "gtk_widget_list_accel_closures", libprag.}

proc listAccelClosures*(self: Widget): ptr pointer =
  gtk_widget_list_accel_closures(cast[ptr Widget00](self.impl))

proc gtk_widget_list_action_prefixes*(self: ptr Widget00): cstringArray {.
    importc: "gtk_widget_list_action_prefixes", libprag.}

proc listActionPrefixes*(self: Widget): cstringArray =
  gtk_widget_list_action_prefixes(cast[ptr Widget00](self.impl))

proc gtk_widget_list_mnemonic_labels*(self: ptr Widget00): ptr pointer {.
    importc: "gtk_widget_list_mnemonic_labels", libprag.}

proc listMnemonicLabels*(self: Widget): ptr pointer =
  gtk_widget_list_mnemonic_labels(cast[ptr Widget00](self.impl))

proc gtk_widget_map*(self: ptr Widget00) {.
    importc: "gtk_widget_map", libprag.}

proc map*(self: Widget) =
  gtk_widget_map(cast[ptr Widget00](self.impl))

proc gtk_widget_mnemonic_activate*(self: ptr Widget00; groupCycling: gboolean): gboolean {.
    importc: "gtk_widget_mnemonic_activate", libprag.}

proc mnemonicActivate*(self: Widget; groupCycling: bool): bool =
  toBool(gtk_widget_mnemonic_activate(cast[ptr Widget00](self.impl), gboolean(groupCycling)))

proc gtk_widget_modify_base*(self: ptr Widget00; state: StateType; color: ptr gdk.Color00) {.
    importc: "gtk_widget_modify_base", libprag.}

proc modifyBase*(self: Widget; state: StateType; color: gdk.Color) =
  gtk_widget_modify_base(cast[ptr Widget00](self.impl), state, cast[ptr gdk.Color00](color.impl))

proc gtk_widget_modify_bg*(self: ptr Widget00; state: StateType; color: ptr gdk.Color00) {.
    importc: "gtk_widget_modify_bg", libprag.}

proc modifyBg*(self: Widget; state: StateType; color: gdk.Color) =
  gtk_widget_modify_bg(cast[ptr Widget00](self.impl), state, cast[ptr gdk.Color00](color.impl))

proc gtk_widget_modify_cursor*(self: ptr Widget00; primary: ptr gdk.Color00; secondary: ptr gdk.Color00) {.
    importc: "gtk_widget_modify_cursor", libprag.}

proc modifyCursor*(self: Widget; primary: gdk.Color; secondary: gdk.Color) =
  gtk_widget_modify_cursor(cast[ptr Widget00](self.impl), cast[ptr gdk.Color00](primary.impl), cast[ptr gdk.Color00](secondary.impl))

proc gtk_widget_modify_fg*(self: ptr Widget00; state: StateType; color: ptr gdk.Color00) {.
    importc: "gtk_widget_modify_fg", libprag.}

proc modifyFg*(self: Widget; state: StateType; color: gdk.Color) =
  gtk_widget_modify_fg(cast[ptr Widget00](self.impl), state, cast[ptr gdk.Color00](color.impl))

proc gtk_widget_modify_font*(self: ptr Widget00; fontDesc: ptr pango.FontDescription00) {.
    importc: "gtk_widget_modify_font", libprag.}

proc modifyFont*(self: Widget; fontDesc: pango.FontDescription) =
  gtk_widget_modify_font(cast[ptr Widget00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc gtk_widget_modify_style*(self: ptr Widget00; style: ptr RcStyle00) {.
    importc: "gtk_widget_modify_style", libprag.}

proc modifyStyle*(self: Widget; style: RcStyle) =
  gtk_widget_modify_style(cast[ptr Widget00](self.impl), cast[ptr RcStyle00](style.impl))

proc gtk_widget_modify_text*(self: ptr Widget00; state: StateType; color: ptr gdk.Color00) {.
    importc: "gtk_widget_modify_text", libprag.}

proc modifyText*(self: Widget; state: StateType; color: gdk.Color) =
  gtk_widget_modify_text(cast[ptr Widget00](self.impl), state, cast[ptr gdk.Color00](color.impl))

proc gtk_widget_override_background_color*(self: ptr Widget00; state: StateFlags; color: ptr gdk.RGBA00) {.
    importc: "gtk_widget_override_background_color", libprag.}

proc overrideBackgroundColor*(self: Widget; state: StateFlags; color: gdk.RGBA) =
  gtk_widget_override_background_color(cast[ptr Widget00](self.impl), state, cast[ptr gdk.RGBA00](color.impl))

proc gtk_widget_override_color*(self: ptr Widget00; state: StateFlags; color: ptr gdk.RGBA00) {.
    importc: "gtk_widget_override_color", libprag.}

proc overrideColor*(self: Widget; state: StateFlags; color: gdk.RGBA) =
  gtk_widget_override_color(cast[ptr Widget00](self.impl), state, cast[ptr gdk.RGBA00](color.impl))

proc gtk_widget_override_cursor*(self: ptr Widget00; cursor: ptr gdk.RGBA00; secondaryCursor: ptr gdk.RGBA00) {.
    importc: "gtk_widget_override_cursor", libprag.}

proc overrideCursor*(self: Widget; cursor: gdk.RGBA; secondaryCursor: gdk.RGBA) =
  gtk_widget_override_cursor(cast[ptr Widget00](self.impl), cast[ptr gdk.RGBA00](cursor.impl), cast[ptr gdk.RGBA00](secondaryCursor.impl))

proc gtk_widget_override_font*(self: ptr Widget00; fontDesc: ptr pango.FontDescription00) {.
    importc: "gtk_widget_override_font", libprag.}

proc overrideFont*(self: Widget; fontDesc: pango.FontDescription) =
  gtk_widget_override_font(cast[ptr Widget00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc gtk_widget_override_symbolic_color*(self: ptr Widget00; name: cstring; color: ptr gdk.RGBA00) {.
    importc: "gtk_widget_override_symbolic_color", libprag.}

proc overrideSymbolicColor*(self: Widget; name: string; color: gdk.RGBA) =
  gtk_widget_override_symbolic_color(cast[ptr Widget00](self.impl), cstring(name), cast[ptr gdk.RGBA00](color.impl))

proc gtk_widget_path*(self: ptr Widget00; pathLength: var uint32; path: var cstring; 
    pathReversed: var cstring) {.
    importc: "gtk_widget_path", libprag.}

proc path*(self: Widget; pathLength: var int; path: var string; 
    pathReversed: var string) =
  var pathReversed_00 = cstring(pathReversed)
  var pathLength_00 = uint32(pathLength)
  var path_00 = cstring(path)
  gtk_widget_path(cast[ptr Widget00](self.impl), pathLength_00, path_00, pathReversed_00)
  pathReversed = $(pathReversed_00)
  pathLength = int(pathLength_00)
  path = $(path_00)

proc gtk_widget_queue_allocate*(self: ptr Widget00) {.
    importc: "gtk_widget_queue_allocate", libprag.}

proc queueAllocate*(self: Widget) =
  gtk_widget_queue_allocate(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_compute_expand*(self: ptr Widget00) {.
    importc: "gtk_widget_queue_compute_expand", libprag.}

proc queueComputeExpand*(self: Widget) =
  gtk_widget_queue_compute_expand(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_draw*(self: ptr Widget00) {.
    importc: "gtk_widget_queue_draw", libprag.}

proc queueDraw*(self: Widget) =
  gtk_widget_queue_draw(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_draw_area*(self: ptr Widget00; x: int32; y: int32; width: int32; 
    height: int32) {.
    importc: "gtk_widget_queue_draw_area", libprag.}

proc queueDrawArea*(self: Widget; x: int; y: int; width: int; height: int) =
  gtk_widget_queue_draw_area(cast[ptr Widget00](self.impl), int32(x), int32(y), int32(width), int32(height))

proc gtk_widget_queue_draw_region*(self: ptr Widget00; region: ptr cairo.Region00) {.
    importc: "gtk_widget_queue_draw_region", libprag.}

proc queueDrawRegion*(self: Widget; region: cairo.Region) =
  gtk_widget_queue_draw_region(cast[ptr Widget00](self.impl), cast[ptr cairo.Region00](region.impl))

proc gtk_widget_queue_resize*(self: ptr Widget00) {.
    importc: "gtk_widget_queue_resize", libprag.}

proc queueResize*(self: Widget) =
  gtk_widget_queue_resize(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_resize_no_redraw*(self: ptr Widget00) {.
    importc: "gtk_widget_queue_resize_no_redraw", libprag.}

proc queueResizeNoRedraw*(self: Widget) =
  gtk_widget_queue_resize_no_redraw(cast[ptr Widget00](self.impl))

proc gtk_widget_realize*(self: ptr Widget00) {.
    importc: "gtk_widget_realize", libprag.}

proc realize*(self: Widget) =
  gtk_widget_realize(cast[ptr Widget00](self.impl))

proc gtk_widget_region_intersect*(self: ptr Widget00; region: ptr cairo.Region00): ptr cairo.Region00 {.
    importc: "gtk_widget_region_intersect", libprag.}

proc regionIntersect*(self: Widget; region: cairo.Region): cairo.Region =
  new(result)
  result.impl = gtk_widget_region_intersect(cast[ptr Widget00](self.impl), cast[ptr cairo.Region00](region.impl))

proc gtk_widget_register_window*(self: ptr Widget00; window: ptr gdk.Window00) {.
    importc: "gtk_widget_register_window", libprag.}

proc registerWindow*(self: Widget; window: gdk.Window) =
  gtk_widget_register_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_widget_remove_mnemonic_label*(self: ptr Widget00; label: ptr Widget00) {.
    importc: "gtk_widget_remove_mnemonic_label", libprag.}

proc removeMnemonicLabel*(self: Widget; label: Widget) =
  gtk_widget_remove_mnemonic_label(cast[ptr Widget00](self.impl), cast[ptr Widget00](label.impl))

proc gtk_widget_remove_tick_callback*(self: ptr Widget00; id: uint32) {.
    importc: "gtk_widget_remove_tick_callback", libprag.}

proc removeTickCallback*(self: Widget; id: int) =
  gtk_widget_remove_tick_callback(cast[ptr Widget00](self.impl), uint32(id))

proc gtk_widget_render_icon*(self: ptr Widget00; stockId: cstring; size: int32; 
    detail: cstring): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_widget_render_icon", libprag.}

proc renderIcon*(self: Widget; stockId: string; size: int; detail: string): gdkpixbuf.Pixbuf =
  let gobj = gtk_widget_render_icon(cast[ptr Widget00](self.impl), cstring(stockId), int32(size), cstring(detail))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_render_icon_pixbuf*(self: ptr Widget00; stockId: cstring; size: int32): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_widget_render_icon_pixbuf", libprag.}

proc renderIconPixbuf*(self: Widget; stockId: string; size: int): gdkpixbuf.Pixbuf =
  let gobj = gtk_widget_render_icon_pixbuf(cast[ptr Widget00](self.impl), cstring(stockId), int32(size))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_reparent*(self: ptr Widget00; newParent: ptr Widget00) {.
    importc: "gtk_widget_reparent", libprag.}

proc reparent*(self: Widget; newParent: Widget) =
  gtk_widget_reparent(cast[ptr Widget00](self.impl), cast[ptr Widget00](newParent.impl))

proc gtk_widget_reset_rc_styles*(self: ptr Widget00) {.
    importc: "gtk_widget_reset_rc_styles", libprag.}

proc resetRcStyles*(self: Widget) =
  gtk_widget_reset_rc_styles(cast[ptr Widget00](self.impl))

proc gtk_widget_reset_style*(self: ptr Widget00) {.
    importc: "gtk_widget_reset_style", libprag.}

proc resetStyle*(self: Widget) =
  gtk_widget_reset_style(cast[ptr Widget00](self.impl))

proc gtk_widget_send_expose*(self: ptr Widget00; event: ptr gdk.Event00): int32 {.
    importc: "gtk_widget_send_expose", libprag.}

proc sendExpose*(self: Widget; event: gdk.Event): int =
  int(gtk_widget_send_expose(cast[ptr Widget00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_widget_send_focus_change*(self: ptr Widget00; event: ptr gdk.Event00): gboolean {.
    importc: "gtk_widget_send_focus_change", libprag.}

proc sendFocusChange*(self: Widget; event: gdk.Event): bool =
  toBool(gtk_widget_send_focus_change(cast[ptr Widget00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_widget_set_allocation*(self: ptr Widget00; allocation: ptr gdk.Rectangle00) {.
    importc: "gtk_widget_set_allocation", libprag.}

proc setAllocation*(self: Widget; allocation: gdk.Rectangle) =
  gtk_widget_set_allocation(cast[ptr Widget00](self.impl), cast[ptr gdk.Rectangle00](allocation.impl))

proc `allocation=`*(self: Widget; allocation: gdk.Rectangle) =
  gtk_widget_set_allocation(cast[ptr Widget00](self.impl), cast[ptr gdk.Rectangle00](allocation.impl))

proc gtk_widget_set_app_paintable*(self: ptr Widget00; appPaintable: gboolean) {.
    importc: "gtk_widget_set_app_paintable", libprag.}

proc setAppPaintable*(self: Widget; appPaintable: bool) =
  gtk_widget_set_app_paintable(cast[ptr Widget00](self.impl), gboolean(appPaintable))

proc `appPaintable=`*(self: Widget; appPaintable: bool) =
  gtk_widget_set_app_paintable(cast[ptr Widget00](self.impl), gboolean(appPaintable))

proc gtk_widget_set_can_default*(self: ptr Widget00; canDefault: gboolean) {.
    importc: "gtk_widget_set_can_default", libprag.}

proc setCanDefault*(self: Widget; canDefault: bool) =
  gtk_widget_set_can_default(cast[ptr Widget00](self.impl), gboolean(canDefault))

proc `canDefault=`*(self: Widget; canDefault: bool) =
  gtk_widget_set_can_default(cast[ptr Widget00](self.impl), gboolean(canDefault))

proc gtk_widget_set_can_focus*(self: ptr Widget00; canFocus: gboolean) {.
    importc: "gtk_widget_set_can_focus", libprag.}

proc setCanFocus*(self: Widget; canFocus: bool) =
  gtk_widget_set_can_focus(cast[ptr Widget00](self.impl), gboolean(canFocus))

proc `canFocus=`*(self: Widget; canFocus: bool) =
  gtk_widget_set_can_focus(cast[ptr Widget00](self.impl), gboolean(canFocus))

proc gtk_widget_set_child_visible*(self: ptr Widget00; isVisible: gboolean) {.
    importc: "gtk_widget_set_child_visible", libprag.}

proc setChildVisible*(self: Widget; isVisible: bool) =
  gtk_widget_set_child_visible(cast[ptr Widget00](self.impl), gboolean(isVisible))

proc `childVisible=`*(self: Widget; isVisible: bool) =
  gtk_widget_set_child_visible(cast[ptr Widget00](self.impl), gboolean(isVisible))

proc gtk_widget_set_clip*(self: ptr Widget00; clip: ptr gdk.Rectangle00) {.
    importc: "gtk_widget_set_clip", libprag.}

proc setClip*(self: Widget; clip: gdk.Rectangle) =
  gtk_widget_set_clip(cast[ptr Widget00](self.impl), cast[ptr gdk.Rectangle00](clip.impl))

proc `clip=`*(self: Widget; clip: gdk.Rectangle) =
  gtk_widget_set_clip(cast[ptr Widget00](self.impl), cast[ptr gdk.Rectangle00](clip.impl))

proc gtk_widget_set_composite_name*(self: ptr Widget00; name: cstring) {.
    importc: "gtk_widget_set_composite_name", libprag.}

proc setCompositeName*(self: Widget; name: string) =
  gtk_widget_set_composite_name(cast[ptr Widget00](self.impl), cstring(name))

proc `compositeName=`*(self: Widget; name: string) =
  gtk_widget_set_composite_name(cast[ptr Widget00](self.impl), cstring(name))

proc gtk_widget_set_device_enabled*(self: ptr Widget00; device: ptr gdk.Device00; enabled: gboolean) {.
    importc: "gtk_widget_set_device_enabled", libprag.}

proc setDeviceEnabled*(self: Widget; device: gdk.Device; enabled: bool) =
  gtk_widget_set_device_enabled(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl), gboolean(enabled))

proc gtk_widget_set_device_events*(self: ptr Widget00; device: ptr gdk.Device00; events: gdk.EventMask) {.
    importc: "gtk_widget_set_device_events", libprag.}

proc setDeviceEvents*(self: Widget; device: gdk.Device; events: gdk.EventMask) =
  gtk_widget_set_device_events(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl), events)

proc gtk_widget_set_direction*(self: ptr Widget00; dir: TextDirection) {.
    importc: "gtk_widget_set_direction", libprag.}

proc setDirection*(self: Widget; dir: TextDirection) =
  gtk_widget_set_direction(cast[ptr Widget00](self.impl), dir)

proc `direction=`*(self: Widget; dir: TextDirection) =
  gtk_widget_set_direction(cast[ptr Widget00](self.impl), dir)

proc gtk_widget_set_double_buffered*(self: ptr Widget00; doubleBuffered: gboolean) {.
    importc: "gtk_widget_set_double_buffered", libprag.}

proc setDoubleBuffered*(self: Widget; doubleBuffered: bool) =
  gtk_widget_set_double_buffered(cast[ptr Widget00](self.impl), gboolean(doubleBuffered))

proc `doubleBuffered=`*(self: Widget; doubleBuffered: bool) =
  gtk_widget_set_double_buffered(cast[ptr Widget00](self.impl), gboolean(doubleBuffered))

proc gtk_widget_set_events*(self: ptr Widget00; events: int32) {.
    importc: "gtk_widget_set_events", libprag.}

proc setEvents*(self: Widget; events: int) =
  gtk_widget_set_events(cast[ptr Widget00](self.impl), int32(events))

proc `events=`*(self: Widget; events: int) =
  gtk_widget_set_events(cast[ptr Widget00](self.impl), int32(events))

proc gtk_widget_set_focus_on_click*(self: ptr Widget00; focusOnClick: gboolean) {.
    importc: "gtk_widget_set_focus_on_click", libprag.}

proc setFocusOnClick*(self: Widget; focusOnClick: bool) =
  gtk_widget_set_focus_on_click(cast[ptr Widget00](self.impl), gboolean(focusOnClick))

proc `focusOnClick=`*(self: Widget; focusOnClick: bool) =
  gtk_widget_set_focus_on_click(cast[ptr Widget00](self.impl), gboolean(focusOnClick))

proc gtk_widget_set_font_map*(self: ptr Widget00; fontMap: ptr pango.FontMap00) {.
    importc: "gtk_widget_set_font_map", libprag.}

proc setFontMap*(self: Widget; fontMap: pango.FontMap) =
  gtk_widget_set_font_map(cast[ptr Widget00](self.impl), cast[ptr pango.FontMap00](fontMap.impl))

proc `fontMap=`*(self: Widget; fontMap: pango.FontMap) =
  gtk_widget_set_font_map(cast[ptr Widget00](self.impl), cast[ptr pango.FontMap00](fontMap.impl))

proc gtk_widget_set_font_options*(self: ptr Widget00; options: ptr cairo.FontOptions00) {.
    importc: "gtk_widget_set_font_options", libprag.}

proc setFontOptions*(self: Widget; options: cairo.FontOptions) =
  gtk_widget_set_font_options(cast[ptr Widget00](self.impl), cast[ptr cairo.FontOptions00](options.impl))

proc `fontOptions=`*(self: Widget; options: cairo.FontOptions) =
  gtk_widget_set_font_options(cast[ptr Widget00](self.impl), cast[ptr cairo.FontOptions00](options.impl))

proc gtk_widget_set_has_tooltip*(self: ptr Widget00; hasTooltip: gboolean) {.
    importc: "gtk_widget_set_has_tooltip", libprag.}

proc setHasTooltip*(self: Widget; hasTooltip: bool) =
  gtk_widget_set_has_tooltip(cast[ptr Widget00](self.impl), gboolean(hasTooltip))

proc `hasTooltip=`*(self: Widget; hasTooltip: bool) =
  gtk_widget_set_has_tooltip(cast[ptr Widget00](self.impl), gboolean(hasTooltip))

proc gtk_widget_set_has_window*(self: ptr Widget00; hasWindow: gboolean) {.
    importc: "gtk_widget_set_has_window", libprag.}

proc setHasWindow*(self: Widget; hasWindow: bool) =
  gtk_widget_set_has_window(cast[ptr Widget00](self.impl), gboolean(hasWindow))

proc `hasWindow=`*(self: Widget; hasWindow: bool) =
  gtk_widget_set_has_window(cast[ptr Widget00](self.impl), gboolean(hasWindow))

proc gtk_widget_set_hexpand*(self: ptr Widget00; expand: gboolean) {.
    importc: "gtk_widget_set_hexpand", libprag.}

proc setHexpand*(self: Widget; expand: bool) =
  gtk_widget_set_hexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc `hexpand=`*(self: Widget; expand: bool) =
  gtk_widget_set_hexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc gtk_widget_set_hexpand_set*(self: ptr Widget00; set: gboolean) {.
    importc: "gtk_widget_set_hexpand_set", libprag.}

proc setHexpandSet*(self: Widget; set: bool) =
  gtk_widget_set_hexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc `hexpandSet=`*(self: Widget; set: bool) =
  gtk_widget_set_hexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc gtk_widget_set_mapped*(self: ptr Widget00; mapped: gboolean) {.
    importc: "gtk_widget_set_mapped", libprag.}

proc setMapped*(self: Widget; mapped: bool) =
  gtk_widget_set_mapped(cast[ptr Widget00](self.impl), gboolean(mapped))

proc `mapped=`*(self: Widget; mapped: bool) =
  gtk_widget_set_mapped(cast[ptr Widget00](self.impl), gboolean(mapped))

proc gtk_widget_set_margin_bottom*(self: ptr Widget00; margin: int32) {.
    importc: "gtk_widget_set_margin_bottom", libprag.}

proc setMarginBottom*(self: Widget; margin: int) =
  gtk_widget_set_margin_bottom(cast[ptr Widget00](self.impl), int32(margin))

proc `marginBottom=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_bottom(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_end*(self: ptr Widget00; margin: int32) {.
    importc: "gtk_widget_set_margin_end", libprag.}

proc setMarginEnd*(self: Widget; margin: int) =
  gtk_widget_set_margin_end(cast[ptr Widget00](self.impl), int32(margin))

proc `marginEnd=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_end(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_left*(self: ptr Widget00; margin: int32) {.
    importc: "gtk_widget_set_margin_left", libprag.}

proc setMarginLeft*(self: Widget; margin: int) =
  gtk_widget_set_margin_left(cast[ptr Widget00](self.impl), int32(margin))

proc `marginLeft=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_left(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_right*(self: ptr Widget00; margin: int32) {.
    importc: "gtk_widget_set_margin_right", libprag.}

proc setMarginRight*(self: Widget; margin: int) =
  gtk_widget_set_margin_right(cast[ptr Widget00](self.impl), int32(margin))

proc `marginRight=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_right(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_start*(self: ptr Widget00; margin: int32) {.
    importc: "gtk_widget_set_margin_start", libprag.}

proc setMarginStart*(self: Widget; margin: int) =
  gtk_widget_set_margin_start(cast[ptr Widget00](self.impl), int32(margin))

proc `marginStart=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_start(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_top*(self: ptr Widget00; margin: int32) {.
    importc: "gtk_widget_set_margin_top", libprag.}

proc setMarginTop*(self: Widget; margin: int) =
  gtk_widget_set_margin_top(cast[ptr Widget00](self.impl), int32(margin))

proc `marginTop=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_top(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_name*(self: ptr Widget00; name: cstring) {.
    importc: "gtk_widget_set_name", libprag.}

proc setName*(self: Widget; name: string) =
  gtk_widget_set_name(cast[ptr Widget00](self.impl), cstring(name))

proc `name=`*(self: Widget; name: string) =
  gtk_widget_set_name(cast[ptr Widget00](self.impl), cstring(name))

proc gtk_widget_set_no_show_all*(self: ptr Widget00; noShowAll: gboolean) {.
    importc: "gtk_widget_set_no_show_all", libprag.}

proc setNoShowAll*(self: Widget; noShowAll: bool) =
  gtk_widget_set_no_show_all(cast[ptr Widget00](self.impl), gboolean(noShowAll))

proc `noShowAll=`*(self: Widget; noShowAll: bool) =
  gtk_widget_set_no_show_all(cast[ptr Widget00](self.impl), gboolean(noShowAll))

proc gtk_widget_set_opacity*(self: ptr Widget00; opacity: cdouble) {.
    importc: "gtk_widget_set_opacity", libprag.}

proc setOpacity*(self: Widget; opacity: cdouble) =
  gtk_widget_set_opacity(cast[ptr Widget00](self.impl), opacity)

proc `opacity=`*(self: Widget; opacity: cdouble) =
  gtk_widget_set_opacity(cast[ptr Widget00](self.impl), opacity)

proc gtk_widget_set_parent*(self: ptr Widget00; parent: ptr Widget00) {.
    importc: "gtk_widget_set_parent", libprag.}

proc setParent*(self: Widget; parent: Widget) =
  gtk_widget_set_parent(cast[ptr Widget00](self.impl), cast[ptr Widget00](parent.impl))

proc `parent=`*(self: Widget; parent: Widget) =
  gtk_widget_set_parent(cast[ptr Widget00](self.impl), cast[ptr Widget00](parent.impl))

proc gtk_widget_set_parent_window*(self: ptr Widget00; parentWindow: ptr gdk.Window00) {.
    importc: "gtk_widget_set_parent_window", libprag.}

proc setParentWindow*(self: Widget; parentWindow: gdk.Window) =
  gtk_widget_set_parent_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](parentWindow.impl))

proc `parentWindow=`*(self: Widget; parentWindow: gdk.Window) =
  gtk_widget_set_parent_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](parentWindow.impl))

proc gtk_widget_set_realized*(self: ptr Widget00; realized: gboolean) {.
    importc: "gtk_widget_set_realized", libprag.}

proc setRealized*(self: Widget; realized: bool) =
  gtk_widget_set_realized(cast[ptr Widget00](self.impl), gboolean(realized))

proc `realized=`*(self: Widget; realized: bool) =
  gtk_widget_set_realized(cast[ptr Widget00](self.impl), gboolean(realized))

proc gtk_widget_set_receives_default*(self: ptr Widget00; receivesDefault: gboolean) {.
    importc: "gtk_widget_set_receives_default", libprag.}

proc setReceivesDefault*(self: Widget; receivesDefault: bool) =
  gtk_widget_set_receives_default(cast[ptr Widget00](self.impl), gboolean(receivesDefault))

proc `receivesDefault=`*(self: Widget; receivesDefault: bool) =
  gtk_widget_set_receives_default(cast[ptr Widget00](self.impl), gboolean(receivesDefault))

proc gtk_widget_set_redraw_on_allocate*(self: ptr Widget00; redrawOnAllocate: gboolean) {.
    importc: "gtk_widget_set_redraw_on_allocate", libprag.}

proc setRedrawOnAllocate*(self: Widget; redrawOnAllocate: bool) =
  gtk_widget_set_redraw_on_allocate(cast[ptr Widget00](self.impl), gboolean(redrawOnAllocate))

proc `redrawOnAllocate=`*(self: Widget; redrawOnAllocate: bool) =
  gtk_widget_set_redraw_on_allocate(cast[ptr Widget00](self.impl), gboolean(redrawOnAllocate))

proc gtk_widget_set_sensitive*(self: ptr Widget00; sensitive: gboolean) {.
    importc: "gtk_widget_set_sensitive", libprag.}

proc setSensitive*(self: Widget; sensitive: bool) =
  gtk_widget_set_sensitive(cast[ptr Widget00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: Widget; sensitive: bool) =
  gtk_widget_set_sensitive(cast[ptr Widget00](self.impl), gboolean(sensitive))

proc gtk_widget_set_size_request*(self: ptr Widget00; width: int32; height: int32) {.
    importc: "gtk_widget_set_size_request", libprag.}

proc setSizeRequest*(self: Widget; width: int; height: int) =
  gtk_widget_set_size_request(cast[ptr Widget00](self.impl), int32(width), int32(height))

proc gtk_widget_set_state*(self: ptr Widget00; state: StateType) {.
    importc: "gtk_widget_set_state", libprag.}

proc setState*(self: Widget; state: StateType) =
  gtk_widget_set_state(cast[ptr Widget00](self.impl), state)

proc `state=`*(self: Widget; state: StateType) =
  gtk_widget_set_state(cast[ptr Widget00](self.impl), state)

proc gtk_widget_set_state_flags*(self: ptr Widget00; flags: StateFlags; clear: gboolean) {.
    importc: "gtk_widget_set_state_flags", libprag.}

proc setStateFlags*(self: Widget; flags: StateFlags; clear: bool) =
  gtk_widget_set_state_flags(cast[ptr Widget00](self.impl), flags, gboolean(clear))

proc gtk_widget_set_style*(self: ptr Widget00; style: ptr Style00) {.
    importc: "gtk_widget_set_style", libprag.}

proc setStyle*(self: Widget; style: Style) =
  gtk_widget_set_style(cast[ptr Widget00](self.impl), cast[ptr Style00](style.impl))

proc `style=`*(self: Widget; style: Style) =
  gtk_widget_set_style(cast[ptr Widget00](self.impl), cast[ptr Style00](style.impl))

proc gtk_widget_set_support_multidevice*(self: ptr Widget00; supportMultidevice: gboolean) {.
    importc: "gtk_widget_set_support_multidevice", libprag.}

proc setSupportMultidevice*(self: Widget; supportMultidevice: bool) =
  gtk_widget_set_support_multidevice(cast[ptr Widget00](self.impl), gboolean(supportMultidevice))

proc `supportMultidevice=`*(self: Widget; supportMultidevice: bool) =
  gtk_widget_set_support_multidevice(cast[ptr Widget00](self.impl), gboolean(supportMultidevice))

proc gtk_widget_set_tooltip_markup*(self: ptr Widget00; markup: cstring) {.
    importc: "gtk_widget_set_tooltip_markup", libprag.}

proc setTooltipMarkup*(self: Widget; markup: string) =
  gtk_widget_set_tooltip_markup(cast[ptr Widget00](self.impl), cstring(markup))

proc `tooltipMarkup=`*(self: Widget; markup: string) =
  gtk_widget_set_tooltip_markup(cast[ptr Widget00](self.impl), cstring(markup))

proc gtk_widget_set_tooltip_text*(self: ptr Widget00; text: cstring) {.
    importc: "gtk_widget_set_tooltip_text", libprag.}

proc setTooltipText*(self: Widget; text: string) =
  gtk_widget_set_tooltip_text(cast[ptr Widget00](self.impl), cstring(text))

proc `tooltipText=`*(self: Widget; text: string) =
  gtk_widget_set_tooltip_text(cast[ptr Widget00](self.impl), cstring(text))

proc gtk_widget_set_vexpand*(self: ptr Widget00; expand: gboolean) {.
    importc: "gtk_widget_set_vexpand", libprag.}

proc setVexpand*(self: Widget; expand: bool) =
  gtk_widget_set_vexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc `vexpand=`*(self: Widget; expand: bool) =
  gtk_widget_set_vexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc gtk_widget_set_vexpand_set*(self: ptr Widget00; set: gboolean) {.
    importc: "gtk_widget_set_vexpand_set", libprag.}

proc setVexpandSet*(self: Widget; set: bool) =
  gtk_widget_set_vexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc `vexpandSet=`*(self: Widget; set: bool) =
  gtk_widget_set_vexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc gtk_widget_set_visible*(self: ptr Widget00; visible: gboolean) {.
    importc: "gtk_widget_set_visible", libprag.}

proc setVisible*(self: Widget; visible: bool) =
  gtk_widget_set_visible(cast[ptr Widget00](self.impl), gboolean(visible))

proc `visible=`*(self: Widget; visible: bool) =
  gtk_widget_set_visible(cast[ptr Widget00](self.impl), gboolean(visible))

proc gtk_widget_set_visual*(self: ptr Widget00; visual: ptr gdk.Visual00) {.
    importc: "gtk_widget_set_visual", libprag.}

proc setVisual*(self: Widget; visual: gdk.Visual) =
  gtk_widget_set_visual(cast[ptr Widget00](self.impl), cast[ptr gdk.Visual00](visual.impl))

proc `visual=`*(self: Widget; visual: gdk.Visual) =
  gtk_widget_set_visual(cast[ptr Widget00](self.impl), cast[ptr gdk.Visual00](visual.impl))

proc gtk_widget_set_window*(self: ptr Widget00; window: ptr gdk.Window00) {.
    importc: "gtk_widget_set_window", libprag.}

proc setWindow*(self: Widget; window: gdk.Window) =
  gtk_widget_set_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](window.impl))

proc `window=`*(self: Widget; window: gdk.Window) =
  gtk_widget_set_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_widget_shape_combine_region*(self: ptr Widget00; region: ptr cairo.Region00) {.
    importc: "gtk_widget_shape_combine_region", libprag.}

proc shapeCombineRegion*(self: Widget; region: cairo.Region) =
  gtk_widget_shape_combine_region(cast[ptr Widget00](self.impl), cast[ptr cairo.Region00](region.impl))

proc gtk_widget_show*(self: ptr Widget00) {.
    importc: "gtk_widget_show", libprag.}

proc show*(self: Widget) =
  gtk_widget_show(cast[ptr Widget00](self.impl))

proc gtk_widget_show_all*(self: ptr Widget00) {.
    importc: "gtk_widget_show_all", libprag.}

proc showAll*(self: Widget) =
  gtk_widget_show_all(cast[ptr Widget00](self.impl))

proc gtk_widget_show_now*(self: ptr Widget00) {.
    importc: "gtk_widget_show_now", libprag.}

proc showNow*(self: Widget) =
  gtk_widget_show_now(cast[ptr Widget00](self.impl))

proc gtk_widget_size_allocate*(self: ptr Widget00; allocation: ptr gdk.Rectangle00) {.
    importc: "gtk_widget_size_allocate", libprag.}

proc sizeAllocate*(self: Widget; allocation: gdk.Rectangle) =
  gtk_widget_size_allocate(cast[ptr Widget00](self.impl), cast[ptr gdk.Rectangle00](allocation.impl))

proc gtk_widget_size_allocate_with_baseline*(self: ptr Widget00; allocation: ptr gdk.Rectangle00; 
    baseline: int32) {.
    importc: "gtk_widget_size_allocate_with_baseline", libprag.}

proc sizeAllocateWithBaseline*(self: Widget; allocation: gdk.Rectangle; baseline: int) =
  gtk_widget_size_allocate_with_baseline(cast[ptr Widget00](self.impl), cast[ptr gdk.Rectangle00](allocation.impl), int32(baseline))

proc gtk_widget_style_attach*(self: ptr Widget00) {.
    importc: "gtk_widget_style_attach", libprag.}

proc styleAttach*(self: Widget) =
  gtk_widget_style_attach(cast[ptr Widget00](self.impl))

proc gtk_widget_style_get_property*(self: ptr Widget00; propertyName: cstring; value: ptr gobject.Value00) {.
    importc: "gtk_widget_style_get_property", libprag.}

proc styleGetProperty*(self: Widget; propertyName: string; value: gobject.Value) =
  gtk_widget_style_get_property(cast[ptr Widget00](self.impl), cstring(propertyName), cast[ptr gobject.Value00](value.impl))

proc gtk_widget_thaw_child_notify*(self: ptr Widget00) {.
    importc: "gtk_widget_thaw_child_notify", libprag.}

proc thawChildNotify*(self: Widget) =
  gtk_widget_thaw_child_notify(cast[ptr Widget00](self.impl))

proc gtk_widget_translate_coordinates*(self: ptr Widget00; destWidget: ptr Widget00; srcX: int32; 
    srcY: int32; destX: var int32; destY: var int32): gboolean {.
    importc: "gtk_widget_translate_coordinates", libprag.}

proc translateCoordinates*(self: Widget; destWidget: Widget; srcX: int; srcY: int; 
    destX: var int; destY: var int): bool =
  var destY_00 = int32(destY)
  var destX_00 = int32(destX)
  result = toBool(gtk_widget_translate_coordinates(cast[ptr Widget00](self.impl), cast[ptr Widget00](destWidget.impl), int32(srcX), int32(srcY), destX_00, destY_00))
  destY = int(destY_00)
  destX = int(destX_00)

proc gtk_widget_trigger_tooltip_query*(self: ptr Widget00) {.
    importc: "gtk_widget_trigger_tooltip_query", libprag.}

proc triggerTooltipQuery*(self: Widget) =
  gtk_widget_trigger_tooltip_query(cast[ptr Widget00](self.impl))

proc gtk_widget_unmap*(self: ptr Widget00) {.
    importc: "gtk_widget_unmap", libprag.}

proc unmap*(self: Widget) =
  gtk_widget_unmap(cast[ptr Widget00](self.impl))

proc gtk_widget_unparent*(self: ptr Widget00) {.
    importc: "gtk_widget_unparent", libprag.}

proc unparent*(self: Widget) =
  gtk_widget_unparent(cast[ptr Widget00](self.impl))

proc gtk_widget_unrealize*(self: ptr Widget00) {.
    importc: "gtk_widget_unrealize", libprag.}

proc unrealize*(self: Widget) =
  gtk_widget_unrealize(cast[ptr Widget00](self.impl))

proc gtk_widget_unregister_window*(self: ptr Widget00; window: ptr gdk.Window00) {.
    importc: "gtk_widget_unregister_window", libprag.}

proc unregisterWindow*(self: Widget; window: gdk.Window) =
  gtk_widget_unregister_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_widget_unset_state_flags*(self: ptr Widget00; flags: StateFlags) {.
    importc: "gtk_widget_unset_state_flags", libprag.}

proc unsetStateFlags*(self: Widget; flags: StateFlags) =
  gtk_widget_unset_state_flags(cast[ptr Widget00](self.impl), flags)

proc gtk_tooltip_set_custom*(self: ptr Tooltip00; customWidget: ptr Widget00) {.
    importc: "gtk_tooltip_set_custom", libprag.}

proc setCustom*(self: Tooltip; customWidget: Widget) =
  gtk_tooltip_set_custom(cast[ptr Tooltip00](self.impl), cast[ptr Widget00](customWidget.impl))

proc `custom=`*(self: Tooltip; customWidget: Widget) =
  gtk_tooltip_set_custom(cast[ptr Tooltip00](self.impl), cast[ptr Widget00](customWidget.impl))

type
  ContainerPrivate00* {.pure.} = object
  ContainerPrivate* = ref object
    impl*: ptr ContainerPrivate00

type
  Container* = ref object of Widget
  Container00* = object of Widget00
    priv2: ptr ContainerPrivate00

proc scAdd*(self: Container;  p: proc (self: ptr gobject.Object00; `object`: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "add", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCheckResize*(self: Container;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "check-resize", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRemove*(self: Container;  p: proc (self: ptr gobject.Object00; `object`: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "remove", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSetFocusChild*(self: Container;  p: proc (self: ptr gobject.Object00; `object`: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "set-focus-child", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_container_add*(self: ptr Container00; widget: ptr Widget00) {.
    importc: "gtk_container_add", libprag.}

proc add*(self: Container; widget: Widget) =
  gtk_container_add(cast[ptr Container00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_container_check_resize*(self: ptr Container00) {.
    importc: "gtk_container_check_resize", libprag.}

proc checkResize*(self: Container) =
  gtk_container_check_resize(cast[ptr Container00](self.impl))

proc gtk_container_child_get_property*(self: ptr Container00; child: ptr Widget00; propertyName: cstring; 
    value: ptr gobject.Value00) {.
    importc: "gtk_container_child_get_property", libprag.}

proc childGetProperty*(self: Container; child: Widget; propertyName: string; 
    value: gobject.Value) =
  gtk_container_child_get_property(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), cstring(propertyName), cast[ptr gobject.Value00](value.impl))

proc gtk_container_child_notify*(self: ptr Container00; child: ptr Widget00; childProperty: cstring) {.
    importc: "gtk_container_child_notify", libprag.}

proc childNotify*(self: Container; child: Widget; childProperty: string) =
  gtk_container_child_notify(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), cstring(childProperty))

proc gtk_container_child_notify_by_pspec*(self: ptr Container00; child: ptr Widget00; pspec: ptr gobject.ParamSpec00) {.
    importc: "gtk_container_child_notify_by_pspec", libprag.}

proc childNotifyByPspec*(self: Container; child: Widget; pspec: gobject.ParamSpec) =
  gtk_container_child_notify_by_pspec(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), cast[ptr gobject.ParamSpec00](pspec.impl))

proc gtk_container_child_set_property*(self: ptr Container00; child: ptr Widget00; propertyName: cstring; 
    value: ptr gobject.Value00) {.
    importc: "gtk_container_child_set_property", libprag.}

proc childSetProperty*(self: Container; child: Widget; propertyName: string; 
    value: gobject.Value) =
  gtk_container_child_set_property(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), cstring(propertyName), cast[ptr gobject.Value00](value.impl))

proc gtk_container_child_type*(self: ptr Container00): GType {.
    importc: "gtk_container_child_type", libprag.}

proc childType*(self: Container): GType =
  gtk_container_child_type(cast[ptr Container00](self.impl))

proc gtk_container_get_border_width*(self: ptr Container00): uint32 {.
    importc: "gtk_container_get_border_width", libprag.}

proc getBorderWidth*(self: Container): int =
  int(gtk_container_get_border_width(cast[ptr Container00](self.impl)))

proc borderWidth*(self: Container): int =
  int(gtk_container_get_border_width(cast[ptr Container00](self.impl)))

proc gtk_container_get_children*(self: ptr Container00): ptr pointer {.
    importc: "gtk_container_get_children", libprag.}

proc getChildren*(self: Container): ptr pointer =
  gtk_container_get_children(cast[ptr Container00](self.impl))

proc children*(self: Container): ptr pointer =
  gtk_container_get_children(cast[ptr Container00](self.impl))

proc gtk_container_get_focus_chain*(self: ptr Container00; focusableWidgets: var ptr pointer): gboolean {.
    importc: "gtk_container_get_focus_chain", libprag.}

proc getFocusChain*(self: Container; focusableWidgets: var ptr pointer): bool =
  toBool(gtk_container_get_focus_chain(cast[ptr Container00](self.impl), focusableWidgets))

proc focusChain*(self: Container; focusableWidgets: var ptr pointer): bool =
  toBool(gtk_container_get_focus_chain(cast[ptr Container00](self.impl), focusableWidgets))

proc gtk_container_get_focus_child*(self: ptr Container00): ptr Widget00 {.
    importc: "gtk_container_get_focus_child", libprag.}

proc getFocusChild*(self: Container): Widget =
  let gobj = gtk_container_get_focus_child(cast[ptr Container00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusChild*(self: Container): Widget =
  let gobj = gtk_container_get_focus_child(cast[ptr Container00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_container_propagate_draw*(self: ptr Container00; child: ptr Widget00; cr: ptr cairo.Context00) {.
    importc: "gtk_container_propagate_draw", libprag.}

proc propagateDraw*(self: Container; child: Widget; cr: cairo.Context) =
  gtk_container_propagate_draw(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), cast[ptr cairo.Context00](cr.impl))

proc gtk_container_remove*(self: ptr Container00; widget: ptr Widget00) {.
    importc: "gtk_container_remove", libprag.}

proc remove*(self: Container; widget: Widget) =
  gtk_container_remove(cast[ptr Container00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_container_resize_children*(self: ptr Container00) {.
    importc: "gtk_container_resize_children", libprag.}

proc resizeChildren*(self: Container) =
  gtk_container_resize_children(cast[ptr Container00](self.impl))

proc gtk_container_set_border_width*(self: ptr Container00; borderWidth: uint32) {.
    importc: "gtk_container_set_border_width", libprag.}

proc setBorderWidth*(self: Container; borderWidth: int) =
  gtk_container_set_border_width(cast[ptr Container00](self.impl), uint32(borderWidth))

proc `borderWidth=`*(self: Container; borderWidth: int) =
  gtk_container_set_border_width(cast[ptr Container00](self.impl), uint32(borderWidth))

proc gtk_container_set_focus_chain*(self: ptr Container00; focusableWidgets: ptr pointer) {.
    importc: "gtk_container_set_focus_chain", libprag.}

proc setFocusChain*(self: Container; focusableWidgets: ptr pointer) =
  gtk_container_set_focus_chain(cast[ptr Container00](self.impl), focusableWidgets)

proc `focusChain=`*(self: Container; focusableWidgets: ptr pointer) =
  gtk_container_set_focus_chain(cast[ptr Container00](self.impl), focusableWidgets)

proc gtk_container_set_focus_child*(self: ptr Container00; child: ptr Widget00) {.
    importc: "gtk_container_set_focus_child", libprag.}

proc setFocusChild*(self: Container; child: Widget) =
  gtk_container_set_focus_child(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl))

proc `focusChild=`*(self: Container; child: Widget) =
  gtk_container_set_focus_child(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_container_set_reallocate_redraws*(self: ptr Container00; needsRedraws: gboolean) {.
    importc: "gtk_container_set_reallocate_redraws", libprag.}

proc setReallocateRedraws*(self: Container; needsRedraws: bool) =
  gtk_container_set_reallocate_redraws(cast[ptr Container00](self.impl), gboolean(needsRedraws))

proc `reallocateRedraws=`*(self: Container; needsRedraws: bool) =
  gtk_container_set_reallocate_redraws(cast[ptr Container00](self.impl), gboolean(needsRedraws))

proc gtk_container_unset_focus_chain*(self: ptr Container00) {.
    importc: "gtk_container_unset_focus_chain", libprag.}

proc unsetFocusChain*(self: Container) =
  gtk_container_unset_focus_chain(cast[ptr Container00](self.impl))

type
  BinPrivate00* {.pure.} = object
  BinPrivate* = ref object
    impl*: ptr BinPrivate00

type
  Bin* = ref object of Container
  Bin00* = object of Container00
    priv3: ptr BinPrivate00

proc gtk_bin_get_child*(self: ptr Bin00): ptr Widget00 {.
    importc: "gtk_bin_get_child", libprag.}

proc getChild*(self: Bin): Widget =
  let gobj = gtk_bin_get_child(cast[ptr Bin00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Bin): Widget =
  let gobj = gtk_bin_get_child(cast[ptr Bin00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  WindowPrivate00* {.pure.} = object
  WindowPrivate* = ref object
    impl*: ptr WindowPrivate00

type
  Window* = ref object of Bin
  Window00* = object of Bin00
    priv4: ptr WindowPrivate00

proc scActivateDefault*(self: Window;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-default", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scActivateFocus*(self: Window;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-focus", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEnableDebugging*(self: Window;  p: proc (self: ptr gobject.Object00; toggle: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "enable-debugging", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scKeysChanged*(self: Window;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "keys-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSetFocus*(self: Window;  p: proc (self: ptr gobject.Object00; `object`: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "set-focus", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_window_get_default_icon_list*(): ptr pointer {.
    importc: "gtk_window_get_default_icon_list", libprag.}

proc getDefaultIconList*(): ptr pointer {.
    importc: "gtk_window_get_default_icon_list", libprag.}

proc defaultIconList*(): ptr pointer {.
    importc: "gtk_window_get_default_icon_list", libprag.}

proc gtk_window_get_default_icon_name*(): cstring {.
    importc: "gtk_window_get_default_icon_name", libprag.}

proc getDefaultIconName*(): string =
  let resul0 = gtk_window_get_default_icon_name()
  result = $resul0

proc defaultIconName*(): string =
  let resul0 = gtk_window_get_default_icon_name()
  result = $resul0

proc gtk_window_list_toplevels*(): ptr pointer {.
    importc: "gtk_window_list_toplevels", libprag.}

proc listToplevels*(): ptr pointer {.
    importc: "gtk_window_list_toplevels", libprag.}

proc gtk_window_set_auto_startup_notification*(setting: gboolean) {.
    importc: "gtk_window_set_auto_startup_notification", libprag.}

proc setAutoStartupNotification*(setting: gboolean) {.
    importc: "gtk_window_set_auto_startup_notification", libprag.}

proc `autoStartupNotification=`*(setting: gboolean) {.
    importc: "gtk_window_set_auto_startup_notification", libprag.}

proc gtk_window_set_default_icon*(icon: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_window_set_default_icon", libprag.}

proc setDefaultIcon*(icon: gdkpixbuf.Pixbuf) =
  gtk_window_set_default_icon(cast[ptr gdkpixbuf.Pixbuf00](icon.impl))

proc `defaultIcon=`*(icon: gdkpixbuf.Pixbuf) =
  gtk_window_set_default_icon(cast[ptr gdkpixbuf.Pixbuf00](icon.impl))

proc gtk_window_set_default_icon_from_file*(filename: ucstring): gboolean {.
    importc: "gtk_window_set_default_icon_from_file", libprag.}

proc setDefaultIconFromFile*(filename: ucstring): gboolean {.
    importc: "gtk_window_set_default_icon_from_file", libprag.}

proc `defaultIconFromFile=`*(filename: ucstring): gboolean {.
    importc: "gtk_window_set_default_icon_from_file", libprag.}

proc gtk_window_set_default_icon_list*(list: ptr pointer) {.
    importc: "gtk_window_set_default_icon_list", libprag.}

proc setDefaultIconList*(list: ptr pointer) {.
    importc: "gtk_window_set_default_icon_list", libprag.}

proc `defaultIconList=`*(list: ptr pointer) {.
    importc: "gtk_window_set_default_icon_list", libprag.}

proc gtk_window_set_default_icon_name*(name: cstring) {.
    importc: "gtk_window_set_default_icon_name", libprag.}

proc setDefaultIconName*(name: cstring) {.
    importc: "gtk_window_set_default_icon_name", libprag.}

proc `defaultIconName=`*(name: cstring) {.
    importc: "gtk_window_set_default_icon_name", libprag.}

proc gtk_window_set_interactive_debugging*(enable: gboolean) {.
    importc: "gtk_window_set_interactive_debugging", libprag.}

proc setInteractiveDebugging*(enable: gboolean) {.
    importc: "gtk_window_set_interactive_debugging", libprag.}

proc `interactiveDebugging=`*(enable: gboolean) {.
    importc: "gtk_window_set_interactive_debugging", libprag.}

proc gtk_window_activate_default*(self: ptr Window00): gboolean {.
    importc: "gtk_window_activate_default", libprag.}

proc activateDefault*(self: Window): bool =
  toBool(gtk_window_activate_default(cast[ptr Window00](self.impl)))

proc gtk_window_activate_focus*(self: ptr Window00): gboolean {.
    importc: "gtk_window_activate_focus", libprag.}

proc activateFocus*(self: Window): bool =
  toBool(gtk_window_activate_focus(cast[ptr Window00](self.impl)))

proc gtk_window_activate_key*(self: ptr Window00; event: ptr gdk.EventKey00): gboolean {.
    importc: "gtk_window_activate_key", libprag.}

proc activateKey*(self: Window; event: gdk.EventKey): bool =
  toBool(gtk_window_activate_key(cast[ptr Window00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_window_add_mnemonic*(self: ptr Window00; keyval: uint32; target: ptr Widget00) {.
    importc: "gtk_window_add_mnemonic", libprag.}

proc addMnemonic*(self: Window; keyval: int; target: Widget) =
  gtk_window_add_mnemonic(cast[ptr Window00](self.impl), uint32(keyval), cast[ptr Widget00](target.impl))

proc gtk_window_begin_move_drag*(self: ptr Window00; button: int32; rootX: int32; rootY: int32; 
    timestamp: uint32) {.
    importc: "gtk_window_begin_move_drag", libprag.}

proc beginMoveDrag*(self: Window; button: int; rootX: int; rootY: int; 
    timestamp: int) =
  gtk_window_begin_move_drag(cast[ptr Window00](self.impl), int32(button), int32(rootX), int32(rootY), uint32(timestamp))

proc gtk_window_begin_resize_drag*(self: ptr Window00; edge: gdk.WindowEdge; button: int32; 
    rootX: int32; rootY: int32; timestamp: uint32) {.
    importc: "gtk_window_begin_resize_drag", libprag.}

proc beginResizeDrag*(self: Window; edge: gdk.WindowEdge; button: int; rootX: int; 
    rootY: int; timestamp: int) =
  gtk_window_begin_resize_drag(cast[ptr Window00](self.impl), edge, int32(button), int32(rootX), int32(rootY), uint32(timestamp))

proc gtk_window_close*(self: ptr Window00) {.
    importc: "gtk_window_close", libprag.}

proc close*(self: Window) =
  gtk_window_close(cast[ptr Window00](self.impl))

proc gtk_window_deiconify*(self: ptr Window00) {.
    importc: "gtk_window_deiconify", libprag.}

proc deiconify*(self: Window) =
  gtk_window_deiconify(cast[ptr Window00](self.impl))

proc gtk_window_fullscreen*(self: ptr Window00) {.
    importc: "gtk_window_fullscreen", libprag.}

proc fullscreen*(self: Window) =
  gtk_window_fullscreen(cast[ptr Window00](self.impl))

proc gtk_window_fullscreen_on_monitor*(self: ptr Window00; screen: ptr gdk.Screen00; monitor: int32) {.
    importc: "gtk_window_fullscreen_on_monitor", libprag.}

proc fullscreenOnMonitor*(self: Window; screen: gdk.Screen; monitor: int) =
  gtk_window_fullscreen_on_monitor(cast[ptr Window00](self.impl), cast[ptr gdk.Screen00](screen.impl), int32(monitor))

proc gtk_window_get_accept_focus*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_accept_focus", libprag.}

proc getAcceptFocus*(self: Window): bool =
  toBool(gtk_window_get_accept_focus(cast[ptr Window00](self.impl)))

proc acceptFocus*(self: Window): bool =
  toBool(gtk_window_get_accept_focus(cast[ptr Window00](self.impl)))

proc gtk_window_get_attached_to*(self: ptr Window00): ptr Widget00 {.
    importc: "gtk_window_get_attached_to", libprag.}

proc getAttachedTo*(self: Window): Widget =
  let gobj = gtk_window_get_attached_to(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc attachedTo*(self: Window): Widget =
  let gobj = gtk_window_get_attached_to(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_decorated*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_decorated", libprag.}

proc getDecorated*(self: Window): bool =
  toBool(gtk_window_get_decorated(cast[ptr Window00](self.impl)))

proc decorated*(self: Window): bool =
  toBool(gtk_window_get_decorated(cast[ptr Window00](self.impl)))

proc gtk_window_get_default_size*(self: ptr Window00; width: var int32; height: var int32) {.
    importc: "gtk_window_get_default_size", libprag.}

proc getDefaultSize*(self: Window; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_window_get_default_size(cast[ptr Window00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc defaultSize*(self: Window; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_window_get_default_size(cast[ptr Window00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc gtk_window_get_default_widget*(self: ptr Window00): ptr Widget00 {.
    importc: "gtk_window_get_default_widget", libprag.}

proc getDefaultWidget*(self: Window): Widget =
  let gobj = gtk_window_get_default_widget(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultWidget*(self: Window): Widget =
  let gobj = gtk_window_get_default_widget(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_deletable*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_deletable", libprag.}

proc getDeletable*(self: Window): bool =
  toBool(gtk_window_get_deletable(cast[ptr Window00](self.impl)))

proc deletable*(self: Window): bool =
  toBool(gtk_window_get_deletable(cast[ptr Window00](self.impl)))

proc gtk_window_get_destroy_with_parent*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_destroy_with_parent", libprag.}

proc getDestroyWithParent*(self: Window): bool =
  toBool(gtk_window_get_destroy_with_parent(cast[ptr Window00](self.impl)))

proc destroyWithParent*(self: Window): bool =
  toBool(gtk_window_get_destroy_with_parent(cast[ptr Window00](self.impl)))

proc gtk_window_get_focus*(self: ptr Window00): ptr Widget00 {.
    importc: "gtk_window_get_focus", libprag.}

proc getFocus*(self: Window): Widget =
  let gobj = gtk_window_get_focus(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focus*(self: Window): Widget =
  let gobj = gtk_window_get_focus(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_focus_on_map*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_focus_on_map", libprag.}

proc getFocusOnMap*(self: Window): bool =
  toBool(gtk_window_get_focus_on_map(cast[ptr Window00](self.impl)))

proc focusOnMap*(self: Window): bool =
  toBool(gtk_window_get_focus_on_map(cast[ptr Window00](self.impl)))

proc gtk_window_get_focus_visible*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_focus_visible", libprag.}

proc getFocusVisible*(self: Window): bool =
  toBool(gtk_window_get_focus_visible(cast[ptr Window00](self.impl)))

proc focusVisible*(self: Window): bool =
  toBool(gtk_window_get_focus_visible(cast[ptr Window00](self.impl)))

proc gtk_window_get_gravity*(self: ptr Window00): gdk.Gravity {.
    importc: "gtk_window_get_gravity", libprag.}

proc getGravity*(self: Window): gdk.Gravity =
  gtk_window_get_gravity(cast[ptr Window00](self.impl))

proc gravity*(self: Window): gdk.Gravity =
  gtk_window_get_gravity(cast[ptr Window00](self.impl))

proc gtk_window_get_has_resize_grip*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_has_resize_grip", libprag.}

proc getHasResizeGrip*(self: Window): bool =
  toBool(gtk_window_get_has_resize_grip(cast[ptr Window00](self.impl)))

proc hasResizeGrip*(self: Window): bool =
  toBool(gtk_window_get_has_resize_grip(cast[ptr Window00](self.impl)))

proc gtk_window_get_hide_titlebar_when_maximized*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_hide_titlebar_when_maximized", libprag.}

proc getHideTitlebarWhenMaximized*(self: Window): bool =
  toBool(gtk_window_get_hide_titlebar_when_maximized(cast[ptr Window00](self.impl)))

proc hideTitlebarWhenMaximized*(self: Window): bool =
  toBool(gtk_window_get_hide_titlebar_when_maximized(cast[ptr Window00](self.impl)))

proc gtk_window_get_icon*(self: ptr Window00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_window_get_icon", libprag.}

proc getIcon*(self: Window): gdkpixbuf.Pixbuf =
  let gobj = gtk_window_get_icon(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc icon*(self: Window): gdkpixbuf.Pixbuf =
  let gobj = gtk_window_get_icon(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_icon_list*(self: ptr Window00): ptr pointer {.
    importc: "gtk_window_get_icon_list", libprag.}

proc getIconList*(self: Window): ptr pointer =
  gtk_window_get_icon_list(cast[ptr Window00](self.impl))

proc iconList*(self: Window): ptr pointer =
  gtk_window_get_icon_list(cast[ptr Window00](self.impl))

proc gtk_window_get_icon_name*(self: ptr Window00): cstring {.
    importc: "gtk_window_get_icon_name", libprag.}

proc getIconName*(self: Window): string =
  let resul0 = gtk_window_get_icon_name(cast[ptr Window00](self.impl))
  result = $resul0

proc iconName*(self: Window): string =
  let resul0 = gtk_window_get_icon_name(cast[ptr Window00](self.impl))
  result = $resul0

proc gtk_window_get_mnemonic_modifier*(self: ptr Window00): gdk.ModifierType {.
    importc: "gtk_window_get_mnemonic_modifier", libprag.}

proc getMnemonicModifier*(self: Window): gdk.ModifierType =
  gtk_window_get_mnemonic_modifier(cast[ptr Window00](self.impl))

proc mnemonicModifier*(self: Window): gdk.ModifierType =
  gtk_window_get_mnemonic_modifier(cast[ptr Window00](self.impl))

proc gtk_window_get_mnemonics_visible*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_mnemonics_visible", libprag.}

proc getMnemonicsVisible*(self: Window): bool =
  toBool(gtk_window_get_mnemonics_visible(cast[ptr Window00](self.impl)))

proc mnemonicsVisible*(self: Window): bool =
  toBool(gtk_window_get_mnemonics_visible(cast[ptr Window00](self.impl)))

proc gtk_window_get_modal*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_modal", libprag.}

proc getModal*(self: Window): bool =
  toBool(gtk_window_get_modal(cast[ptr Window00](self.impl)))

proc modal*(self: Window): bool =
  toBool(gtk_window_get_modal(cast[ptr Window00](self.impl)))

proc gtk_window_get_opacity*(self: ptr Window00): cdouble {.
    importc: "gtk_window_get_opacity", libprag.}

proc getOpacity*(self: Window): cdouble =
  gtk_window_get_opacity(cast[ptr Window00](self.impl))

proc opacity*(self: Window): cdouble =
  gtk_window_get_opacity(cast[ptr Window00](self.impl))

proc gtk_window_get_position*(self: ptr Window00; rootX: var int32; rootY: var int32) {.
    importc: "gtk_window_get_position", libprag.}

proc getPosition*(self: Window; rootX: var int; rootY: var int) =
  var rootY_00 = int32(rootY)
  var rootX_00 = int32(rootX)
  gtk_window_get_position(cast[ptr Window00](self.impl), rootX_00, rootY_00)
  rootY = int(rootY_00)
  rootX = int(rootX_00)

proc position*(self: Window; rootX: var int; rootY: var int) =
  var rootY_00 = int32(rootY)
  var rootX_00 = int32(rootX)
  gtk_window_get_position(cast[ptr Window00](self.impl), rootX_00, rootY_00)
  rootY = int(rootY_00)
  rootX = int(rootX_00)

proc gtk_window_get_resizable*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_resizable", libprag.}

proc getResizable*(self: Window): bool =
  toBool(gtk_window_get_resizable(cast[ptr Window00](self.impl)))

proc resizable*(self: Window): bool =
  toBool(gtk_window_get_resizable(cast[ptr Window00](self.impl)))

proc gtk_window_get_resize_grip_area*(self: ptr Window00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_window_get_resize_grip_area", libprag.}

proc getResizeGripArea*(self: ptr Window00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_window_get_resize_grip_area", libprag.}

proc resizeGripArea*(self: ptr Window00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_window_get_resize_grip_area", libprag.}

proc gtk_window_get_role*(self: ptr Window00): cstring {.
    importc: "gtk_window_get_role", libprag.}

proc getRole*(self: Window): string =
  let resul0 = gtk_window_get_role(cast[ptr Window00](self.impl))
  result = $resul0

proc role*(self: Window): string =
  let resul0 = gtk_window_get_role(cast[ptr Window00](self.impl))
  result = $resul0

proc gtk_window_get_screen*(self: ptr Window00): ptr gdk.Screen00 {.
    importc: "gtk_window_get_screen", libprag.}

proc getScreen*(self: Window): gdk.Screen =
  let gobj = gtk_window_get_screen(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: Window): gdk.Screen =
  let gobj = gtk_window_get_screen(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_size*(self: ptr Window00; width: var int32; height: var int32) {.
    importc: "gtk_window_get_size", libprag.}

proc getSize*(self: Window; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_window_get_size(cast[ptr Window00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc size*(self: Window; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_window_get_size(cast[ptr Window00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc gtk_window_get_skip_pager_hint*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_skip_pager_hint", libprag.}

proc getSkipPagerHint*(self: Window): bool =
  toBool(gtk_window_get_skip_pager_hint(cast[ptr Window00](self.impl)))

proc skipPagerHint*(self: Window): bool =
  toBool(gtk_window_get_skip_pager_hint(cast[ptr Window00](self.impl)))

proc gtk_window_get_skip_taskbar_hint*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_skip_taskbar_hint", libprag.}

proc getSkipTaskbarHint*(self: Window): bool =
  toBool(gtk_window_get_skip_taskbar_hint(cast[ptr Window00](self.impl)))

proc skipTaskbarHint*(self: Window): bool =
  toBool(gtk_window_get_skip_taskbar_hint(cast[ptr Window00](self.impl)))

proc gtk_window_get_title*(self: ptr Window00): cstring {.
    importc: "gtk_window_get_title", libprag.}

proc getTitle*(self: Window): string =
  let resul0 = gtk_window_get_title(cast[ptr Window00](self.impl))
  result = $resul0

proc title*(self: Window): string =
  let resul0 = gtk_window_get_title(cast[ptr Window00](self.impl))
  result = $resul0

proc gtk_window_get_titlebar*(self: ptr Window00): ptr Widget00 {.
    importc: "gtk_window_get_titlebar", libprag.}

proc getTitlebar*(self: Window): Widget =
  let gobj = gtk_window_get_titlebar(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc titlebar*(self: Window): Widget =
  let gobj = gtk_window_get_titlebar(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_transient_for*(self: ptr Window00): ptr Window00 {.
    importc: "gtk_window_get_transient_for", libprag.}

proc getTransientFor*(self: Window): Window =
  let gobj = gtk_window_get_transient_for(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc transientFor*(self: Window): Window =
  let gobj = gtk_window_get_transient_for(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_type_hint*(self: ptr Window00): gdk.WindowTypeHint {.
    importc: "gtk_window_get_type_hint", libprag.}

proc getTypeHint*(self: Window): gdk.WindowTypeHint =
  gtk_window_get_type_hint(cast[ptr Window00](self.impl))

proc typeHint*(self: Window): gdk.WindowTypeHint =
  gtk_window_get_type_hint(cast[ptr Window00](self.impl))

proc gtk_window_get_urgency_hint*(self: ptr Window00): gboolean {.
    importc: "gtk_window_get_urgency_hint", libprag.}

proc getUrgencyHint*(self: Window): bool =
  toBool(gtk_window_get_urgency_hint(cast[ptr Window00](self.impl)))

proc urgencyHint*(self: Window): bool =
  toBool(gtk_window_get_urgency_hint(cast[ptr Window00](self.impl)))

proc gtk_window_has_group*(self: ptr Window00): gboolean {.
    importc: "gtk_window_has_group", libprag.}

proc hasGroup*(self: Window): bool =
  toBool(gtk_window_has_group(cast[ptr Window00](self.impl)))

proc gtk_window_has_toplevel_focus*(self: ptr Window00): gboolean {.
    importc: "gtk_window_has_toplevel_focus", libprag.}

proc hasToplevelFocus*(self: Window): bool =
  toBool(gtk_window_has_toplevel_focus(cast[ptr Window00](self.impl)))

proc gtk_window_iconify*(self: ptr Window00) {.
    importc: "gtk_window_iconify", libprag.}

proc iconify*(self: Window) =
  gtk_window_iconify(cast[ptr Window00](self.impl))

proc gtk_window_is_active*(self: ptr Window00): gboolean {.
    importc: "gtk_window_is_active", libprag.}

proc isActive*(self: Window): bool =
  toBool(gtk_window_is_active(cast[ptr Window00](self.impl)))

proc gtk_window_is_maximized*(self: ptr Window00): gboolean {.
    importc: "gtk_window_is_maximized", libprag.}

proc isMaximized*(self: Window): bool =
  toBool(gtk_window_is_maximized(cast[ptr Window00](self.impl)))

proc gtk_window_maximize*(self: ptr Window00) {.
    importc: "gtk_window_maximize", libprag.}

proc maximize*(self: Window) =
  gtk_window_maximize(cast[ptr Window00](self.impl))

proc gtk_window_mnemonic_activate*(self: ptr Window00; keyval: uint32; modifier: gdk.ModifierType): gboolean {.
    importc: "gtk_window_mnemonic_activate", libprag.}

proc mnemonicActivate*(self: Window; keyval: int; modifier: gdk.ModifierType): bool =
  toBool(gtk_window_mnemonic_activate(cast[ptr Window00](self.impl), uint32(keyval), modifier))

proc gtk_window_move*(self: ptr Window00; x: int32; y: int32) {.
    importc: "gtk_window_move", libprag.}

proc move*(self: Window; x: int; y: int) =
  gtk_window_move(cast[ptr Window00](self.impl), int32(x), int32(y))

proc gtk_window_parse_geometry*(self: ptr Window00; geometry: cstring): gboolean {.
    importc: "gtk_window_parse_geometry", libprag.}

proc parseGeometry*(self: Window; geometry: string): bool =
  toBool(gtk_window_parse_geometry(cast[ptr Window00](self.impl), cstring(geometry)))

proc gtk_window_present*(self: ptr Window00) {.
    importc: "gtk_window_present", libprag.}

proc present*(self: Window) =
  gtk_window_present(cast[ptr Window00](self.impl))

proc gtk_window_present_with_time*(self: ptr Window00; timestamp: uint32) {.
    importc: "gtk_window_present_with_time", libprag.}

proc presentWithTime*(self: Window; timestamp: int) =
  gtk_window_present_with_time(cast[ptr Window00](self.impl), uint32(timestamp))

proc gtk_window_propagate_key_event*(self: ptr Window00; event: ptr gdk.EventKey00): gboolean {.
    importc: "gtk_window_propagate_key_event", libprag.}

proc propagateKeyEvent*(self: Window; event: gdk.EventKey): bool =
  toBool(gtk_window_propagate_key_event(cast[ptr Window00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_window_remove_mnemonic*(self: ptr Window00; keyval: uint32; target: ptr Widget00) {.
    importc: "gtk_window_remove_mnemonic", libprag.}

proc removeMnemonic*(self: Window; keyval: int; target: Widget) =
  gtk_window_remove_mnemonic(cast[ptr Window00](self.impl), uint32(keyval), cast[ptr Widget00](target.impl))

proc gtk_window_reshow_with_initial_size*(self: ptr Window00) {.
    importc: "gtk_window_reshow_with_initial_size", libprag.}

proc reshowWithInitialSize*(self: Window) =
  gtk_window_reshow_with_initial_size(cast[ptr Window00](self.impl))

proc gtk_window_resize*(self: ptr Window00; width: int32; height: int32) {.
    importc: "gtk_window_resize", libprag.}

proc resize*(self: Window; width: int; height: int) =
  gtk_window_resize(cast[ptr Window00](self.impl), int32(width), int32(height))

proc gtk_window_resize_grip_is_visible*(self: ptr Window00): gboolean {.
    importc: "gtk_window_resize_grip_is_visible", libprag.}

proc resizeGripIsVisible*(self: Window): bool =
  toBool(gtk_window_resize_grip_is_visible(cast[ptr Window00](self.impl)))

proc gtk_window_resize_to_geometry*(self: ptr Window00; width: int32; height: int32) {.
    importc: "gtk_window_resize_to_geometry", libprag.}

proc resizeToGeometry*(self: Window; width: int; height: int) =
  gtk_window_resize_to_geometry(cast[ptr Window00](self.impl), int32(width), int32(height))

proc gtk_window_set_accept_focus*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_accept_focus", libprag.}

proc setAcceptFocus*(self: Window; setting: bool) =
  gtk_window_set_accept_focus(cast[ptr Window00](self.impl), gboolean(setting))

proc `acceptFocus=`*(self: Window; setting: bool) =
  gtk_window_set_accept_focus(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_attached_to*(self: ptr Window00; attachWidget: ptr Widget00) {.
    importc: "gtk_window_set_attached_to", libprag.}

proc setAttachedTo*(self: Window; attachWidget: Widget) =
  gtk_window_set_attached_to(cast[ptr Window00](self.impl), cast[ptr Widget00](attachWidget.impl))

proc `attachedTo=`*(self: Window; attachWidget: Widget) =
  gtk_window_set_attached_to(cast[ptr Window00](self.impl), cast[ptr Widget00](attachWidget.impl))

proc gtk_window_set_decorated*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_decorated", libprag.}

proc setDecorated*(self: Window; setting: bool) =
  gtk_window_set_decorated(cast[ptr Window00](self.impl), gboolean(setting))

proc `decorated=`*(self: Window; setting: bool) =
  gtk_window_set_decorated(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_default*(self: ptr Window00; defaultWidget: ptr Widget00) {.
    importc: "gtk_window_set_default", libprag.}

proc setDefault*(self: Window; defaultWidget: Widget) =
  gtk_window_set_default(cast[ptr Window00](self.impl), cast[ptr Widget00](defaultWidget.impl))

proc `default=`*(self: Window; defaultWidget: Widget) =
  gtk_window_set_default(cast[ptr Window00](self.impl), cast[ptr Widget00](defaultWidget.impl))

proc gtk_window_set_default_geometry*(self: ptr Window00; width: int32; height: int32) {.
    importc: "gtk_window_set_default_geometry", libprag.}

proc setDefaultGeometry*(self: Window; width: int; height: int) =
  gtk_window_set_default_geometry(cast[ptr Window00](self.impl), int32(width), int32(height))

proc gtk_window_set_default_size*(self: ptr Window00; width: int32; height: int32) {.
    importc: "gtk_window_set_default_size", libprag.}

proc setDefaultSize*(self: Window; width: int; height: int) =
  gtk_window_set_default_size(cast[ptr Window00](self.impl), int32(width), int32(height))

proc `defaultSize=`*(self: Window; dim: tuple[width: int; height: int]) =
  gtk_window_set_default_size(cast[ptr Window00](self.impl), int32(dim[0]), int32(dim[1]))

proc gtk_window_set_deletable*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_deletable", libprag.}

proc setDeletable*(self: Window; setting: bool) =
  gtk_window_set_deletable(cast[ptr Window00](self.impl), gboolean(setting))

proc `deletable=`*(self: Window; setting: bool) =
  gtk_window_set_deletable(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_destroy_with_parent*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_destroy_with_parent", libprag.}

proc setDestroyWithParent*(self: Window; setting: bool) =
  gtk_window_set_destroy_with_parent(cast[ptr Window00](self.impl), gboolean(setting))

proc `destroyWithParent=`*(self: Window; setting: bool) =
  gtk_window_set_destroy_with_parent(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_focus*(self: ptr Window00; focus: ptr Widget00) {.
    importc: "gtk_window_set_focus", libprag.}

proc setFocus*(self: Window; focus: Widget) =
  gtk_window_set_focus(cast[ptr Window00](self.impl), cast[ptr Widget00](focus.impl))

proc `focus=`*(self: Window; focus: Widget) =
  gtk_window_set_focus(cast[ptr Window00](self.impl), cast[ptr Widget00](focus.impl))

proc gtk_window_set_focus_on_map*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_focus_on_map", libprag.}

proc setFocusOnMap*(self: Window; setting: bool) =
  gtk_window_set_focus_on_map(cast[ptr Window00](self.impl), gboolean(setting))

proc `focusOnMap=`*(self: Window; setting: bool) =
  gtk_window_set_focus_on_map(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_focus_visible*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_focus_visible", libprag.}

proc setFocusVisible*(self: Window; setting: bool) =
  gtk_window_set_focus_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc `focusVisible=`*(self: Window; setting: bool) =
  gtk_window_set_focus_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_geometry_hints*(self: ptr Window00; geometryWidget: ptr Widget00; 
    geometry: ptr gdk.Geometry00; geomMask: gdk.WindowHints) {.
    importc: "gtk_window_set_geometry_hints", libprag.}

proc setGeometryHints*(self: Window; geometryWidget: Widget; geometry: gdk.Geometry; 
    geomMask: gdk.WindowHints) =
  gtk_window_set_geometry_hints(cast[ptr Window00](self.impl), cast[ptr Widget00](geometryWidget.impl), cast[ptr gdk.Geometry00](geometry.impl), geomMask)

proc gtk_window_set_gravity*(self: ptr Window00; gravity: gdk.Gravity) {.
    importc: "gtk_window_set_gravity", libprag.}

proc setGravity*(self: Window; gravity: gdk.Gravity) =
  gtk_window_set_gravity(cast[ptr Window00](self.impl), gravity)

proc `gravity=`*(self: Window; gravity: gdk.Gravity) =
  gtk_window_set_gravity(cast[ptr Window00](self.impl), gravity)

proc gtk_window_set_has_resize_grip*(self: ptr Window00; value: gboolean) {.
    importc: "gtk_window_set_has_resize_grip", libprag.}

proc setHasResizeGrip*(self: Window; value: bool) =
  gtk_window_set_has_resize_grip(cast[ptr Window00](self.impl), gboolean(value))

proc `hasResizeGrip=`*(self: Window; value: bool) =
  gtk_window_set_has_resize_grip(cast[ptr Window00](self.impl), gboolean(value))

proc gtk_window_set_has_user_ref_count*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_has_user_ref_count", libprag.}

proc setHasUserRefCount*(self: Window; setting: bool) =
  gtk_window_set_has_user_ref_count(cast[ptr Window00](self.impl), gboolean(setting))

proc `hasUserRefCount=`*(self: Window; setting: bool) =
  gtk_window_set_has_user_ref_count(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_hide_titlebar_when_maximized*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_hide_titlebar_when_maximized", libprag.}

proc setHideTitlebarWhenMaximized*(self: Window; setting: bool) =
  gtk_window_set_hide_titlebar_when_maximized(cast[ptr Window00](self.impl), gboolean(setting))

proc `hideTitlebarWhenMaximized=`*(self: Window; setting: bool) =
  gtk_window_set_hide_titlebar_when_maximized(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_icon*(self: ptr Window00; icon: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_window_set_icon", libprag.}

proc setIcon*(self: Window; icon: gdkpixbuf.Pixbuf) =
  gtk_window_set_icon(cast[ptr Window00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](icon.impl))

proc `icon=`*(self: Window; icon: gdkpixbuf.Pixbuf) =
  gtk_window_set_icon(cast[ptr Window00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](icon.impl))

proc gtk_window_set_icon_from_file*(self: ptr Window00; filename: ucstring): gboolean {.
    importc: "gtk_window_set_icon_from_file", libprag.}

proc setIconFromFile*(self: Window; filename: ucstring): bool =
  toBool(gtk_window_set_icon_from_file(cast[ptr Window00](self.impl), filename))

proc `iconFromFile=`*(self: Window; filename: ucstring): bool =
  toBool(gtk_window_set_icon_from_file(cast[ptr Window00](self.impl), filename))

proc gtk_window_set_icon_list*(self: ptr Window00; list: ptr pointer) {.
    importc: "gtk_window_set_icon_list", libprag.}

proc setIconList*(self: Window; list: ptr pointer) =
  gtk_window_set_icon_list(cast[ptr Window00](self.impl), list)

proc `iconList=`*(self: Window; list: ptr pointer) =
  gtk_window_set_icon_list(cast[ptr Window00](self.impl), list)

proc gtk_window_set_icon_name*(self: ptr Window00; name: cstring) {.
    importc: "gtk_window_set_icon_name", libprag.}

proc setIconName*(self: Window; name: string) =
  gtk_window_set_icon_name(cast[ptr Window00](self.impl), cstring(name))

proc `iconName=`*(self: Window; name: string) =
  gtk_window_set_icon_name(cast[ptr Window00](self.impl), cstring(name))

proc gtk_window_set_keep_above*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_keep_above", libprag.}

proc setKeepAbove*(self: Window; setting: bool) =
  gtk_window_set_keep_above(cast[ptr Window00](self.impl), gboolean(setting))

proc `keepAbove=`*(self: Window; setting: bool) =
  gtk_window_set_keep_above(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_keep_below*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_keep_below", libprag.}

proc setKeepBelow*(self: Window; setting: bool) =
  gtk_window_set_keep_below(cast[ptr Window00](self.impl), gboolean(setting))

proc `keepBelow=`*(self: Window; setting: bool) =
  gtk_window_set_keep_below(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_mnemonic_modifier*(self: ptr Window00; modifier: gdk.ModifierType) {.
    importc: "gtk_window_set_mnemonic_modifier", libprag.}

proc setMnemonicModifier*(self: Window; modifier: gdk.ModifierType) =
  gtk_window_set_mnemonic_modifier(cast[ptr Window00](self.impl), modifier)

proc `mnemonicModifier=`*(self: Window; modifier: gdk.ModifierType) =
  gtk_window_set_mnemonic_modifier(cast[ptr Window00](self.impl), modifier)

proc gtk_window_set_mnemonics_visible*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_mnemonics_visible", libprag.}

proc setMnemonicsVisible*(self: Window; setting: bool) =
  gtk_window_set_mnemonics_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc `mnemonicsVisible=`*(self: Window; setting: bool) =
  gtk_window_set_mnemonics_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_modal*(self: ptr Window00; modal: gboolean) {.
    importc: "gtk_window_set_modal", libprag.}

proc setModal*(self: Window; modal: bool) =
  gtk_window_set_modal(cast[ptr Window00](self.impl), gboolean(modal))

proc `modal=`*(self: Window; modal: bool) =
  gtk_window_set_modal(cast[ptr Window00](self.impl), gboolean(modal))

proc gtk_window_set_opacity*(self: ptr Window00; opacity: cdouble) {.
    importc: "gtk_window_set_opacity", libprag.}

proc setOpacity*(self: Window; opacity: cdouble) =
  gtk_window_set_opacity(cast[ptr Window00](self.impl), opacity)

proc `opacity=`*(self: Window; opacity: cdouble) =
  gtk_window_set_opacity(cast[ptr Window00](self.impl), opacity)

proc gtk_window_set_resizable*(self: ptr Window00; resizable: gboolean) {.
    importc: "gtk_window_set_resizable", libprag.}

proc setResizable*(self: Window; resizable: bool) =
  gtk_window_set_resizable(cast[ptr Window00](self.impl), gboolean(resizable))

proc `resizable=`*(self: Window; resizable: bool) =
  gtk_window_set_resizable(cast[ptr Window00](self.impl), gboolean(resizable))

proc gtk_window_set_role*(self: ptr Window00; role: cstring) {.
    importc: "gtk_window_set_role", libprag.}

proc setRole*(self: Window; role: string) =
  gtk_window_set_role(cast[ptr Window00](self.impl), cstring(role))

proc `role=`*(self: Window; role: string) =
  gtk_window_set_role(cast[ptr Window00](self.impl), cstring(role))

proc gtk_window_set_screen*(self: ptr Window00; screen: ptr gdk.Screen00) {.
    importc: "gtk_window_set_screen", libprag.}

proc setScreen*(self: Window; screen: gdk.Screen) =
  gtk_window_set_screen(cast[ptr Window00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: Window; screen: gdk.Screen) =
  gtk_window_set_screen(cast[ptr Window00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc gtk_window_set_skip_pager_hint*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_skip_pager_hint", libprag.}

proc setSkipPagerHint*(self: Window; setting: bool) =
  gtk_window_set_skip_pager_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc `skipPagerHint=`*(self: Window; setting: bool) =
  gtk_window_set_skip_pager_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_skip_taskbar_hint*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_skip_taskbar_hint", libprag.}

proc setSkipTaskbarHint*(self: Window; setting: bool) =
  gtk_window_set_skip_taskbar_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc `skipTaskbarHint=`*(self: Window; setting: bool) =
  gtk_window_set_skip_taskbar_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_startup_id*(self: ptr Window00; startupId: cstring) {.
    importc: "gtk_window_set_startup_id", libprag.}

proc setStartupId*(self: Window; startupId: string) =
  gtk_window_set_startup_id(cast[ptr Window00](self.impl), cstring(startupId))

proc `startupId=`*(self: Window; startupId: string) =
  gtk_window_set_startup_id(cast[ptr Window00](self.impl), cstring(startupId))

proc gtk_window_set_title*(self: ptr Window00; title: cstring) {.
    importc: "gtk_window_set_title", libprag.}

proc setTitle*(self: Window; title: string) =
  gtk_window_set_title(cast[ptr Window00](self.impl), cstring(title))

proc `title=`*(self: Window; title: string) =
  gtk_window_set_title(cast[ptr Window00](self.impl), cstring(title))

proc gtk_window_set_titlebar*(self: ptr Window00; titlebar: ptr Widget00) {.
    importc: "gtk_window_set_titlebar", libprag.}

proc setTitlebar*(self: Window; titlebar: Widget) =
  gtk_window_set_titlebar(cast[ptr Window00](self.impl), cast[ptr Widget00](titlebar.impl))

proc `titlebar=`*(self: Window; titlebar: Widget) =
  gtk_window_set_titlebar(cast[ptr Window00](self.impl), cast[ptr Widget00](titlebar.impl))

proc gtk_window_set_transient_for*(self: ptr Window00; parent: ptr Window00) {.
    importc: "gtk_window_set_transient_for", libprag.}

proc setTransientFor*(self: Window; parent: Window) =
  gtk_window_set_transient_for(cast[ptr Window00](self.impl), cast[ptr Window00](parent.impl))

proc `transientFor=`*(self: Window; parent: Window) =
  gtk_window_set_transient_for(cast[ptr Window00](self.impl), cast[ptr Window00](parent.impl))

proc gtk_window_set_type_hint*(self: ptr Window00; hint: gdk.WindowTypeHint) {.
    importc: "gtk_window_set_type_hint", libprag.}

proc setTypeHint*(self: Window; hint: gdk.WindowTypeHint) =
  gtk_window_set_type_hint(cast[ptr Window00](self.impl), hint)

proc `typeHint=`*(self: Window; hint: gdk.WindowTypeHint) =
  gtk_window_set_type_hint(cast[ptr Window00](self.impl), hint)

proc gtk_window_set_urgency_hint*(self: ptr Window00; setting: gboolean) {.
    importc: "gtk_window_set_urgency_hint", libprag.}

proc setUrgencyHint*(self: Window; setting: bool) =
  gtk_window_set_urgency_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc `urgencyHint=`*(self: Window; setting: bool) =
  gtk_window_set_urgency_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_wmclass*(self: ptr Window00; wmclassName: cstring; wmclassClass: cstring) {.
    importc: "gtk_window_set_wmclass", libprag.}

proc setWmclass*(self: Window; wmclassName: string; wmclassClass: string) =
  gtk_window_set_wmclass(cast[ptr Window00](self.impl), cstring(wmclassName), cstring(wmclassClass))

proc gtk_window_stick*(self: ptr Window00) {.
    importc: "gtk_window_stick", libprag.}

proc stick*(self: Window) =
  gtk_window_stick(cast[ptr Window00](self.impl))

proc gtk_window_unfullscreen*(self: ptr Window00) {.
    importc: "gtk_window_unfullscreen", libprag.}

proc unfullscreen*(self: Window) =
  gtk_window_unfullscreen(cast[ptr Window00](self.impl))

proc gtk_window_unmaximize*(self: ptr Window00) {.
    importc: "gtk_window_unmaximize", libprag.}

proc unmaximize*(self: Window) =
  gtk_window_unmaximize(cast[ptr Window00](self.impl))

proc gtk_window_unstick*(self: ptr Window00) {.
    importc: "gtk_window_unstick", libprag.}

proc unstick*(self: Window) =
  gtk_window_unstick(cast[ptr Window00](self.impl))

proc gtk_widget_get_tooltip_window*(self: ptr Widget00): ptr Window00 {.
    importc: "gtk_widget_get_tooltip_window", libprag.}

proc getTooltipWindow*(self: Widget): Window =
  let gobj = gtk_widget_get_tooltip_window(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc tooltipWindow*(self: Widget): Window =
  let gobj = gtk_widget_get_tooltip_window(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_set_tooltip_window*(self: ptr Widget00; customWindow: ptr Window00) {.
    importc: "gtk_widget_set_tooltip_window", libprag.}

proc setTooltipWindow*(self: Widget; customWindow: Window) =
  gtk_widget_set_tooltip_window(cast[ptr Widget00](self.impl), cast[ptr Window00](customWindow.impl))

proc `tooltipWindow=`*(self: Widget; customWindow: Window) =
  gtk_widget_set_tooltip_window(cast[ptr Widget00](self.impl), cast[ptr Window00](customWindow.impl))

type
  DialogPrivate00* {.pure.} = object
  DialogPrivate* = ref object
    impl*: ptr DialogPrivate00

type
  Dialog* = ref object of Window
  Dialog00* = object of Window00
    priv5: ptr DialogPrivate00

proc scClose*(self: Dialog;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scResponse*(self: Dialog;  p: proc (self: ptr gobject.Object00; responseId: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "response", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_dialog_new*(): ptr Dialog00 {.
    importc: "gtk_dialog_new", libprag.}

proc newDialog*(): Dialog =
  new(result, finalizeGObject)
  result.impl = gtk_dialog_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDialog*[T](result: var T) =
  assert(result is Dialog)
  new(result, finalizeGObject)
  result.impl = gtk_dialog_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_add_action_widget*(self: ptr Dialog00; child: ptr Widget00; responseId: int32) {.
    importc: "gtk_dialog_add_action_widget", libprag.}

proc addActionWidget*(self: Dialog; child: Widget; responseId: int) =
  gtk_dialog_add_action_widget(cast[ptr Dialog00](self.impl), cast[ptr Widget00](child.impl), int32(responseId))

proc gtk_dialog_add_button*(self: ptr Dialog00; buttonText: cstring; responseId: int32): ptr Widget00 {.
    importc: "gtk_dialog_add_button", libprag.}

proc addButton*(self: Dialog; buttonText: string; responseId: int): Widget =
  let gobj = gtk_dialog_add_button(cast[ptr Dialog00](self.impl), cstring(buttonText), int32(responseId))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_get_action_area*(self: ptr Dialog00): ptr Widget00 {.
    importc: "gtk_dialog_get_action_area", libprag.}

proc getActionArea*(self: Dialog): Widget =
  let gobj = gtk_dialog_get_action_area(cast[ptr Dialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc actionArea*(self: Dialog): Widget =
  let gobj = gtk_dialog_get_action_area(cast[ptr Dialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_get_header_bar*(self: ptr Dialog00): ptr Widget00 {.
    importc: "gtk_dialog_get_header_bar", libprag.}

proc getHeaderBar*(self: Dialog): Widget =
  let gobj = gtk_dialog_get_header_bar(cast[ptr Dialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc headerBar*(self: Dialog): Widget =
  let gobj = gtk_dialog_get_header_bar(cast[ptr Dialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_get_response_for_widget*(self: ptr Dialog00; widget: ptr Widget00): int32 {.
    importc: "gtk_dialog_get_response_for_widget", libprag.}

proc getResponseForWidget*(self: Dialog; widget: Widget): int =
  int(gtk_dialog_get_response_for_widget(cast[ptr Dialog00](self.impl), cast[ptr Widget00](widget.impl)))

proc responseForWidget*(self: Dialog; widget: Widget): int =
  int(gtk_dialog_get_response_for_widget(cast[ptr Dialog00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_dialog_get_widget_for_response*(self: ptr Dialog00; responseId: int32): ptr Widget00 {.
    importc: "gtk_dialog_get_widget_for_response", libprag.}

proc getWidgetForResponse*(self: Dialog; responseId: int): Widget =
  let gobj = gtk_dialog_get_widget_for_response(cast[ptr Dialog00](self.impl), int32(responseId))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widgetForResponse*(self: Dialog; responseId: int): Widget =
  let gobj = gtk_dialog_get_widget_for_response(cast[ptr Dialog00](self.impl), int32(responseId))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_response*(self: ptr Dialog00; responseId: int32) {.
    importc: "gtk_dialog_response", libprag.}

proc response*(self: Dialog; responseId: int) =
  gtk_dialog_response(cast[ptr Dialog00](self.impl), int32(responseId))

proc gtk_dialog_run*(self: ptr Dialog00): int32 {.
    importc: "gtk_dialog_run", libprag.}

proc run*(self: Dialog): int =
  int(gtk_dialog_run(cast[ptr Dialog00](self.impl)))

proc gtk_dialog_set_alternative_button_order_from_array*(self: ptr Dialog00; nParams: int32; newOrder: int32Array) {.
    importc: "gtk_dialog_set_alternative_button_order_from_array", libprag.}

proc setAlternativeButtonOrderFromArray*(self: Dialog; nParams: int; newOrder: int32Array) =
  gtk_dialog_set_alternative_button_order_from_array(cast[ptr Dialog00](self.impl), int32(nParams), newOrder)

proc gtk_dialog_set_default_response*(self: ptr Dialog00; responseId: int32) {.
    importc: "gtk_dialog_set_default_response", libprag.}

proc setDefaultResponse*(self: Dialog; responseId: int) =
  gtk_dialog_set_default_response(cast[ptr Dialog00](self.impl), int32(responseId))

proc `defaultResponse=`*(self: Dialog; responseId: int) =
  gtk_dialog_set_default_response(cast[ptr Dialog00](self.impl), int32(responseId))

proc gtk_dialog_set_response_sensitive*(self: ptr Dialog00; responseId: int32; setting: gboolean) {.
    importc: "gtk_dialog_set_response_sensitive", libprag.}

proc setResponseSensitive*(self: Dialog; responseId: int; setting: bool) =
  gtk_dialog_set_response_sensitive(cast[ptr Dialog00](self.impl), int32(responseId), gboolean(setting))

type
  AboutDialogPrivate00* {.pure.} = object
  AboutDialogPrivate* = ref object
    impl*: ptr AboutDialogPrivate00

type
  AboutDialog* = ref object of Dialog
  AboutDialog00* = object of Dialog00
    priv6: ptr AboutDialogPrivate00

proc scActivateLink*(self: AboutDialog;  p: proc (self: ptr gobject.Object00; uri: cstring; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-link", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_about_dialog_new*(): ptr AboutDialog00 {.
    importc: "gtk_about_dialog_new", libprag.}

proc newAboutDialog*(): AboutDialog =
  new(result, finalizeGObject)
  result.impl = gtk_about_dialog_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAboutDialog*[T](result: var T) =
  assert(result is AboutDialog)
  new(result, finalizeGObject)
  result.impl = gtk_about_dialog_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_about_dialog_add_credit_section*(self: ptr AboutDialog00; sectionName: cstring; people: cstringArray) {.
    importc: "gtk_about_dialog_add_credit_section", libprag.}

proc addCreditSection*(self: AboutDialog; sectionName: string; people: cstringArray) =
  gtk_about_dialog_add_credit_section(cast[ptr AboutDialog00](self.impl), cstring(sectionName), people)

proc gtk_about_dialog_get_artists*(self: ptr AboutDialog00): cstringArray {.
    importc: "gtk_about_dialog_get_artists", libprag.}

proc getArtists*(self: AboutDialog): cstringArray =
  gtk_about_dialog_get_artists(cast[ptr AboutDialog00](self.impl))

proc artists*(self: AboutDialog): cstringArray =
  gtk_about_dialog_get_artists(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_authors*(self: ptr AboutDialog00): cstringArray {.
    importc: "gtk_about_dialog_get_authors", libprag.}

proc getAuthors*(self: AboutDialog): cstringArray =
  gtk_about_dialog_get_authors(cast[ptr AboutDialog00](self.impl))

proc authors*(self: AboutDialog): cstringArray =
  gtk_about_dialog_get_authors(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_comments*(self: ptr AboutDialog00): cstring {.
    importc: "gtk_about_dialog_get_comments", libprag.}

proc getComments*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_comments(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc comments*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_comments(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc gtk_about_dialog_get_copyright*(self: ptr AboutDialog00): cstring {.
    importc: "gtk_about_dialog_get_copyright", libprag.}

proc getCopyright*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_copyright(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc copyright*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_copyright(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc gtk_about_dialog_get_documenters*(self: ptr AboutDialog00): cstringArray {.
    importc: "gtk_about_dialog_get_documenters", libprag.}

proc getDocumenters*(self: AboutDialog): cstringArray =
  gtk_about_dialog_get_documenters(cast[ptr AboutDialog00](self.impl))

proc documenters*(self: AboutDialog): cstringArray =
  gtk_about_dialog_get_documenters(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_license*(self: ptr AboutDialog00): cstring {.
    importc: "gtk_about_dialog_get_license", libprag.}

proc getLicense*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_license(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc license*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_license(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc gtk_about_dialog_get_logo*(self: ptr AboutDialog00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_about_dialog_get_logo", libprag.}

proc getLogo*(self: AboutDialog): gdkpixbuf.Pixbuf =
  let gobj = gtk_about_dialog_get_logo(cast[ptr AboutDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc logo*(self: AboutDialog): gdkpixbuf.Pixbuf =
  let gobj = gtk_about_dialog_get_logo(cast[ptr AboutDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_about_dialog_get_logo_icon_name*(self: ptr AboutDialog00): cstring {.
    importc: "gtk_about_dialog_get_logo_icon_name", libprag.}

proc getLogoIconName*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_logo_icon_name(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc logoIconName*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_logo_icon_name(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc gtk_about_dialog_get_program_name*(self: ptr AboutDialog00): cstring {.
    importc: "gtk_about_dialog_get_program_name", libprag.}

proc getProgramName*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_program_name(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc programName*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_program_name(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc gtk_about_dialog_get_translator_credits*(self: ptr AboutDialog00): cstring {.
    importc: "gtk_about_dialog_get_translator_credits", libprag.}

proc getTranslatorCredits*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_translator_credits(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc translatorCredits*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_translator_credits(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc gtk_about_dialog_get_version*(self: ptr AboutDialog00): cstring {.
    importc: "gtk_about_dialog_get_version", libprag.}

proc getVersion*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_version(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc version*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_version(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc gtk_about_dialog_get_website*(self: ptr AboutDialog00): cstring {.
    importc: "gtk_about_dialog_get_website", libprag.}

proc getWebsite*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_website(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc website*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_website(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc gtk_about_dialog_get_website_label*(self: ptr AboutDialog00): cstring {.
    importc: "gtk_about_dialog_get_website_label", libprag.}

proc getWebsiteLabel*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_website_label(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc websiteLabel*(self: AboutDialog): string =
  let resul0 = gtk_about_dialog_get_website_label(cast[ptr AboutDialog00](self.impl))
  result = $resul0

proc gtk_about_dialog_get_wrap_license*(self: ptr AboutDialog00): gboolean {.
    importc: "gtk_about_dialog_get_wrap_license", libprag.}

proc getWrapLicense*(self: AboutDialog): bool =
  toBool(gtk_about_dialog_get_wrap_license(cast[ptr AboutDialog00](self.impl)))

proc wrapLicense*(self: AboutDialog): bool =
  toBool(gtk_about_dialog_get_wrap_license(cast[ptr AboutDialog00](self.impl)))

proc gtk_about_dialog_set_artists*(self: ptr AboutDialog00; artists: cstringArray) {.
    importc: "gtk_about_dialog_set_artists", libprag.}

proc setArtists*(self: AboutDialog; artists: cstringArray) =
  gtk_about_dialog_set_artists(cast[ptr AboutDialog00](self.impl), artists)

proc `artists=`*(self: AboutDialog; artists: cstringArray) =
  gtk_about_dialog_set_artists(cast[ptr AboutDialog00](self.impl), artists)

proc gtk_about_dialog_set_authors*(self: ptr AboutDialog00; authors: cstringArray) {.
    importc: "gtk_about_dialog_set_authors", libprag.}

proc setAuthors*(self: AboutDialog; authors: cstringArray) =
  gtk_about_dialog_set_authors(cast[ptr AboutDialog00](self.impl), authors)

proc `authors=`*(self: AboutDialog; authors: cstringArray) =
  gtk_about_dialog_set_authors(cast[ptr AboutDialog00](self.impl), authors)

proc gtk_about_dialog_set_comments*(self: ptr AboutDialog00; comments: cstring) {.
    importc: "gtk_about_dialog_set_comments", libprag.}

proc setComments*(self: AboutDialog; comments: string) =
  gtk_about_dialog_set_comments(cast[ptr AboutDialog00](self.impl), cstring(comments))

proc `comments=`*(self: AboutDialog; comments: string) =
  gtk_about_dialog_set_comments(cast[ptr AboutDialog00](self.impl), cstring(comments))

proc gtk_about_dialog_set_copyright*(self: ptr AboutDialog00; copyright: cstring) {.
    importc: "gtk_about_dialog_set_copyright", libprag.}

proc setCopyright*(self: AboutDialog; copyright: string) =
  gtk_about_dialog_set_copyright(cast[ptr AboutDialog00](self.impl), cstring(copyright))

proc `copyright=`*(self: AboutDialog; copyright: string) =
  gtk_about_dialog_set_copyright(cast[ptr AboutDialog00](self.impl), cstring(copyright))

proc gtk_about_dialog_set_documenters*(self: ptr AboutDialog00; documenters: cstringArray) {.
    importc: "gtk_about_dialog_set_documenters", libprag.}

proc setDocumenters*(self: AboutDialog; documenters: cstringArray) =
  gtk_about_dialog_set_documenters(cast[ptr AboutDialog00](self.impl), documenters)

proc `documenters=`*(self: AboutDialog; documenters: cstringArray) =
  gtk_about_dialog_set_documenters(cast[ptr AboutDialog00](self.impl), documenters)

proc gtk_about_dialog_set_license*(self: ptr AboutDialog00; license: cstring) {.
    importc: "gtk_about_dialog_set_license", libprag.}

proc setLicense*(self: AboutDialog; license: string) =
  gtk_about_dialog_set_license(cast[ptr AboutDialog00](self.impl), cstring(license))

proc `license=`*(self: AboutDialog; license: string) =
  gtk_about_dialog_set_license(cast[ptr AboutDialog00](self.impl), cstring(license))

proc gtk_about_dialog_set_logo*(self: ptr AboutDialog00; logo: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_about_dialog_set_logo", libprag.}

proc setLogo*(self: AboutDialog; logo: gdkpixbuf.Pixbuf) =
  gtk_about_dialog_set_logo(cast[ptr AboutDialog00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](logo.impl))

proc `logo=`*(self: AboutDialog; logo: gdkpixbuf.Pixbuf) =
  gtk_about_dialog_set_logo(cast[ptr AboutDialog00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](logo.impl))

proc gtk_about_dialog_set_logo_icon_name*(self: ptr AboutDialog00; iconName: cstring) {.
    importc: "gtk_about_dialog_set_logo_icon_name", libprag.}

proc setLogoIconName*(self: AboutDialog; iconName: string) =
  gtk_about_dialog_set_logo_icon_name(cast[ptr AboutDialog00](self.impl), cstring(iconName))

proc `logoIconName=`*(self: AboutDialog; iconName: string) =
  gtk_about_dialog_set_logo_icon_name(cast[ptr AboutDialog00](self.impl), cstring(iconName))

proc gtk_about_dialog_set_program_name*(self: ptr AboutDialog00; name: cstring) {.
    importc: "gtk_about_dialog_set_program_name", libprag.}

proc setProgramName*(self: AboutDialog; name: string) =
  gtk_about_dialog_set_program_name(cast[ptr AboutDialog00](self.impl), cstring(name))

proc `programName=`*(self: AboutDialog; name: string) =
  gtk_about_dialog_set_program_name(cast[ptr AboutDialog00](self.impl), cstring(name))

proc gtk_about_dialog_set_translator_credits*(self: ptr AboutDialog00; translatorCredits: cstring) {.
    importc: "gtk_about_dialog_set_translator_credits", libprag.}

proc setTranslatorCredits*(self: AboutDialog; translatorCredits: string) =
  gtk_about_dialog_set_translator_credits(cast[ptr AboutDialog00](self.impl), cstring(translatorCredits))

proc `translatorCredits=`*(self: AboutDialog; translatorCredits: string) =
  gtk_about_dialog_set_translator_credits(cast[ptr AboutDialog00](self.impl), cstring(translatorCredits))

proc gtk_about_dialog_set_version*(self: ptr AboutDialog00; version: cstring) {.
    importc: "gtk_about_dialog_set_version", libprag.}

proc setVersion*(self: AboutDialog; version: string) =
  gtk_about_dialog_set_version(cast[ptr AboutDialog00](self.impl), cstring(version))

proc `version=`*(self: AboutDialog; version: string) =
  gtk_about_dialog_set_version(cast[ptr AboutDialog00](self.impl), cstring(version))

proc gtk_about_dialog_set_website*(self: ptr AboutDialog00; website: cstring) {.
    importc: "gtk_about_dialog_set_website", libprag.}

proc setWebsite*(self: AboutDialog; website: string) =
  gtk_about_dialog_set_website(cast[ptr AboutDialog00](self.impl), cstring(website))

proc `website=`*(self: AboutDialog; website: string) =
  gtk_about_dialog_set_website(cast[ptr AboutDialog00](self.impl), cstring(website))

proc gtk_about_dialog_set_website_label*(self: ptr AboutDialog00; websiteLabel: cstring) {.
    importc: "gtk_about_dialog_set_website_label", libprag.}

proc setWebsiteLabel*(self: AboutDialog; websiteLabel: string) =
  gtk_about_dialog_set_website_label(cast[ptr AboutDialog00](self.impl), cstring(websiteLabel))

proc `websiteLabel=`*(self: AboutDialog; websiteLabel: string) =
  gtk_about_dialog_set_website_label(cast[ptr AboutDialog00](self.impl), cstring(websiteLabel))

proc gtk_about_dialog_set_wrap_license*(self: ptr AboutDialog00; wrapLicense: gboolean) {.
    importc: "gtk_about_dialog_set_wrap_license", libprag.}

proc setWrapLicense*(self: AboutDialog; wrapLicense: bool) =
  gtk_about_dialog_set_wrap_license(cast[ptr AboutDialog00](self.impl), gboolean(wrapLicense))

proc `wrapLicense=`*(self: AboutDialog; wrapLicense: bool) =
  gtk_about_dialog_set_wrap_license(cast[ptr AboutDialog00](self.impl), gboolean(wrapLicense))

type
  License* {.size: sizeof(cint), pure.} = enum
    unknown = 0
    custom = 1
    gpl_2_0 = 2
    gpl_3_0 = 3
    lgpl_2_1 = 4
    lgpl_3_0 = 5
    bsd = 6
    mitX11 = 7
    artistic = 8
    gpl_2_0Only = 9
    gpl_3_0Only = 10
    lgpl_2_1Only = 11
    lgpl_3_0Only = 12
    agpl_3_0 = 13

proc gtk_about_dialog_get_license_type*(self: ptr AboutDialog00): License {.
    importc: "gtk_about_dialog_get_license_type", libprag.}

proc getLicenseType*(self: AboutDialog): License =
  gtk_about_dialog_get_license_type(cast[ptr AboutDialog00](self.impl))

proc licenseType*(self: AboutDialog): License =
  gtk_about_dialog_get_license_type(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_set_license_type*(self: ptr AboutDialog00; licenseType: License) {.
    importc: "gtk_about_dialog_set_license_type", libprag.}

proc setLicenseType*(self: AboutDialog; licenseType: License) =
  gtk_about_dialog_set_license_type(cast[ptr AboutDialog00](self.impl), licenseType)

proc `licenseType=`*(self: AboutDialog; licenseType: License) =
  gtk_about_dialog_set_license_type(cast[ptr AboutDialog00](self.impl), licenseType)

type
  BoxPrivate00* {.pure.} = object
  BoxPrivate* = ref object
    impl*: ptr BoxPrivate00

type
  Box* = ref object of Container
  Box00* = object of Container00
    priv3: ptr BoxPrivate00

proc gtk_box_get_center_widget*(self: ptr Box00): ptr Widget00 {.
    importc: "gtk_box_get_center_widget", libprag.}

proc getCenterWidget*(self: Box): Widget =
  let gobj = gtk_box_get_center_widget(cast[ptr Box00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc centerWidget*(self: Box): Widget =
  let gobj = gtk_box_get_center_widget(cast[ptr Box00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_box_get_homogeneous*(self: ptr Box00): gboolean {.
    importc: "gtk_box_get_homogeneous", libprag.}

proc getHomogeneous*(self: Box): bool =
  toBool(gtk_box_get_homogeneous(cast[ptr Box00](self.impl)))

proc homogeneous*(self: Box): bool =
  toBool(gtk_box_get_homogeneous(cast[ptr Box00](self.impl)))

proc gtk_box_get_spacing*(self: ptr Box00): int32 {.
    importc: "gtk_box_get_spacing", libprag.}

proc getSpacing*(self: Box): int =
  int(gtk_box_get_spacing(cast[ptr Box00](self.impl)))

proc spacing*(self: Box): int =
  int(gtk_box_get_spacing(cast[ptr Box00](self.impl)))

proc gtk_box_pack_end*(self: ptr Box00; child: ptr Widget00; expand: gboolean; 
    fill: gboolean; padding: uint32) {.
    importc: "gtk_box_pack_end", libprag.}

proc packEnd*(self: Box; child: Widget; expand: bool; fill: bool; 
    padding: int) =
  gtk_box_pack_end(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), gboolean(expand), gboolean(fill), uint32(padding))

proc gtk_box_pack_start*(self: ptr Box00; child: ptr Widget00; expand: gboolean; 
    fill: gboolean; padding: uint32) {.
    importc: "gtk_box_pack_start", libprag.}

proc packStart*(self: Box; child: Widget; expand: bool; fill: bool; 
    padding: int) =
  gtk_box_pack_start(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), gboolean(expand), gboolean(fill), uint32(padding))

proc gtk_box_reorder_child*(self: ptr Box00; child: ptr Widget00; position: int32) {.
    importc: "gtk_box_reorder_child", libprag.}

proc reorderChild*(self: Box; child: Widget; position: int) =
  gtk_box_reorder_child(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_box_set_center_widget*(self: ptr Box00; widget: ptr Widget00) {.
    importc: "gtk_box_set_center_widget", libprag.}

proc setCenterWidget*(self: Box; widget: Widget) =
  gtk_box_set_center_widget(cast[ptr Box00](self.impl), cast[ptr Widget00](widget.impl))

proc `centerWidget=`*(self: Box; widget: Widget) =
  gtk_box_set_center_widget(cast[ptr Box00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_box_set_homogeneous*(self: ptr Box00; homogeneous: gboolean) {.
    importc: "gtk_box_set_homogeneous", libprag.}

proc setHomogeneous*(self: Box; homogeneous: bool) =
  gtk_box_set_homogeneous(cast[ptr Box00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: Box; homogeneous: bool) =
  gtk_box_set_homogeneous(cast[ptr Box00](self.impl), gboolean(homogeneous))

proc gtk_box_set_spacing*(self: ptr Box00; spacing: int32) {.
    importc: "gtk_box_set_spacing", libprag.}

proc setSpacing*(self: Box; spacing: int) =
  gtk_box_set_spacing(cast[ptr Box00](self.impl), int32(spacing))

proc `spacing=`*(self: Box; spacing: int) =
  gtk_box_set_spacing(cast[ptr Box00](self.impl), int32(spacing))

proc gtk_dialog_get_content_area*(self: ptr Dialog00): ptr Box00 {.
    importc: "gtk_dialog_get_content_area", libprag.}

proc getContentArea*(self: Dialog): Box =
  let gobj = gtk_dialog_get_content_area(cast[ptr Dialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Box](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc contentArea*(self: Dialog): Box =
  let gobj = gtk_dialog_get_content_area(cast[ptr Dialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Box](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  BaselinePosition* {.size: sizeof(cint), pure.} = enum
    top = 0
    center = 1
    bottom = 2

proc gtk_box_get_baseline_position*(self: ptr Box00): BaselinePosition {.
    importc: "gtk_box_get_baseline_position", libprag.}

proc getBaselinePosition*(self: Box): BaselinePosition =
  gtk_box_get_baseline_position(cast[ptr Box00](self.impl))

proc baselinePosition*(self: Box): BaselinePosition =
  gtk_box_get_baseline_position(cast[ptr Box00](self.impl))

proc gtk_box_set_baseline_position*(self: ptr Box00; position: BaselinePosition) {.
    importc: "gtk_box_set_baseline_position", libprag.}

proc setBaselinePosition*(self: Box; position: BaselinePosition) =
  gtk_box_set_baseline_position(cast[ptr Box00](self.impl), position)

proc `baselinePosition=`*(self: Box; position: BaselinePosition) =
  gtk_box_set_baseline_position(cast[ptr Box00](self.impl), position)

type
  PackType* {.size: sizeof(cint), pure.} = enum
    start = 0
    `end` = 1

proc gtk_box_query_child_packing*(self: ptr Box00; child: ptr Widget00; expand: var gboolean; 
    fill: var gboolean; padding: var uint32; packType: var PackType) {.
    importc: "gtk_box_query_child_packing", libprag.}

proc queryChildPacking*(self: Box; child: Widget; expand: var bool; fill: var bool; 
    padding: var int; packType: var PackType) =
  var padding_00 = uint32(padding)
  var fill_00 = gboolean(fill)
  var expand_00 = gboolean(expand)
  gtk_box_query_child_packing(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), expand_00, fill_00, padding_00, packType)
  padding = int(padding_00)
  fill = toBool(fill_00)
  expand = toBool(expand_00)

proc gtk_box_set_child_packing*(self: ptr Box00; child: ptr Widget00; expand: gboolean; 
    fill: gboolean; padding: uint32; packType: PackType) {.
    importc: "gtk_box_set_child_packing", libprag.}

proc setChildPacking*(self: Box; child: Widget; expand: bool; fill: bool; 
    padding: int; packType: PackType) =
  gtk_box_set_child_packing(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), gboolean(expand), gboolean(fill), uint32(padding), packType)

type
  WindowGroupPrivate00* {.pure.} = object
  WindowGroupPrivate* = ref object
    impl*: ptr WindowGroupPrivate00

type
  WindowGroup* = ref object of gobject.Object
  WindowGroup00* = object of gobject.Object00
    priv1: ptr WindowGroupPrivate00

proc gtk_window_group_new*(): ptr WindowGroup00 {.
    importc: "gtk_window_group_new", libprag.}

proc newWindowGroup*(): WindowGroup =
  new(result, finalizeGObject)
  result.impl = gtk_window_group_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initWindowGroup*[T](result: var T) =
  assert(result is WindowGroup)
  new(result, finalizeGObject)
  result.impl = gtk_window_group_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_group_add_window*(self: ptr WindowGroup00; window: ptr Window00) {.
    importc: "gtk_window_group_add_window", libprag.}

proc addWindow*(self: WindowGroup; window: Window) =
  gtk_window_group_add_window(cast[ptr WindowGroup00](self.impl), cast[ptr Window00](window.impl))

proc gtk_window_group_get_current_device_grab*(self: ptr WindowGroup00; device: ptr gdk.Device00): ptr Widget00 {.
    importc: "gtk_window_group_get_current_device_grab", libprag.}

proc getCurrentDeviceGrab*(self: WindowGroup; device: gdk.Device): Widget =
  let gobj = gtk_window_group_get_current_device_grab(cast[ptr WindowGroup00](self.impl), cast[ptr gdk.Device00](device.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc currentDeviceGrab*(self: WindowGroup; device: gdk.Device): Widget =
  let gobj = gtk_window_group_get_current_device_grab(cast[ptr WindowGroup00](self.impl), cast[ptr gdk.Device00](device.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_group_get_current_grab*(self: ptr WindowGroup00): ptr Widget00 {.
    importc: "gtk_window_group_get_current_grab", libprag.}

proc getCurrentGrab*(self: WindowGroup): Widget =
  let gobj = gtk_window_group_get_current_grab(cast[ptr WindowGroup00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc currentGrab*(self: WindowGroup): Widget =
  let gobj = gtk_window_group_get_current_grab(cast[ptr WindowGroup00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_group_list_windows*(self: ptr WindowGroup00): ptr pointer {.
    importc: "gtk_window_group_list_windows", libprag.}

proc listWindows*(self: WindowGroup): ptr pointer =
  gtk_window_group_list_windows(cast[ptr WindowGroup00](self.impl))

proc gtk_window_group_remove_window*(self: ptr WindowGroup00; window: ptr Window00) {.
    importc: "gtk_window_group_remove_window", libprag.}

proc removeWindow*(self: WindowGroup; window: Window) =
  gtk_window_group_remove_window(cast[ptr WindowGroup00](self.impl), cast[ptr Window00](window.impl))

proc gtk_window_get_group*(self: ptr Window00): ptr WindowGroup00 {.
    importc: "gtk_window_get_group", libprag.}

proc getGroup*(self: Window): WindowGroup =
  let gobj = gtk_window_get_group(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[WindowGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc group*(self: Window): WindowGroup =
  let gobj = gtk_window_get_group(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[WindowGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  WindowType* {.size: sizeof(cint), pure.} = enum
    toplevel = 0
    popup = 1

proc gtk_window_new*(`type`: WindowType): ptr Window00 {.
    importc: "gtk_window_new", libprag.}

proc newWindow*(`type`: WindowType = WindowType.toplevel): Window =
  new(result, finalizeGObject)
  result.impl = gtk_window_new(`type`)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initWindow*[T](result: var T; `type`: WindowType = WindowType.toplevel) =
  assert(result is Window)
  new(result, finalizeGObject)
  result.impl = gtk_window_new(`type`)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_window_type*(self: ptr Window00): WindowType {.
    importc: "gtk_window_get_window_type", libprag.}

proc getWindowType*(self: Window): WindowType =
  gtk_window_get_window_type(cast[ptr Window00](self.impl))

proc windowType*(self: Window): WindowType =
  gtk_window_get_window_type(cast[ptr Window00](self.impl))

type
  ApplicationPrivate00* {.pure.} = object
  ApplicationPrivate* = ref object
    impl*: ptr ApplicationPrivate00

type
  Application* = ref object of gio.Application
  Application00* = object of gio.Application00
    priv9: ptr ApplicationPrivate00

proc scWindowAdded*(self: Application;  p: proc (self: ptr gobject.Object00; window: Window00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "window-added", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scWindowRemoved*(self: Application;  p: proc (self: ptr gobject.Object00; window: Window00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "window-removed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_application_new*(applicationId: cstring; flags: gio.ApplicationFlags): ptr Application00 {.
    importc: "gtk_application_new", libprag.}

proc newApplication*(applicationId: string; flags: gio.ApplicationFlags = {}): Application =
  new(result, finalizeGObject)
  result.impl = gtk_application_new(cstring(applicationId), flags)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initApplication*[T](result: var T; applicationId: string; flags: gio.ApplicationFlags = {}) =
  assert(result is Application)
  new(result, finalizeGObject)
  result.impl = gtk_application_new(cstring(applicationId), flags)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_add_accelerator*(self: ptr Application00; accelerator: cstring; actionName: cstring; 
    parameter: ptr glib.Variant00) {.
    importc: "gtk_application_add_accelerator", libprag.}

proc addAccelerator*(self: Application; accelerator: string; actionName: string; 
    parameter: glib.Variant) =
  gtk_application_add_accelerator(cast[ptr Application00](self.impl), cstring(accelerator), cstring(actionName), cast[ptr glib.Variant00](parameter.impl))

proc gtk_application_add_window*(self: ptr Application00; window: ptr Window00) {.
    importc: "gtk_application_add_window", libprag.}

proc addWindow*(self: Application; window: Window) =
  gtk_application_add_window(cast[ptr Application00](self.impl), cast[ptr Window00](window.impl))

proc gtk_application_get_accels_for_action*(self: ptr Application00; detailedActionName: cstring): cstringArray {.
    importc: "gtk_application_get_accels_for_action", libprag.}

proc getAccelsForAction*(self: Application; detailedActionName: string): cstringArray =
  gtk_application_get_accels_for_action(cast[ptr Application00](self.impl), cstring(detailedActionName))

proc accelsForAction*(self: Application; detailedActionName: string): cstringArray =
  gtk_application_get_accels_for_action(cast[ptr Application00](self.impl), cstring(detailedActionName))

proc gtk_application_get_actions_for_accel*(self: ptr Application00; accel: cstring): cstringArray {.
    importc: "gtk_application_get_actions_for_accel", libprag.}

proc getActionsForAccel*(self: Application; accel: string): cstringArray =
  gtk_application_get_actions_for_accel(cast[ptr Application00](self.impl), cstring(accel))

proc actionsForAccel*(self: Application; accel: string): cstringArray =
  gtk_application_get_actions_for_accel(cast[ptr Application00](self.impl), cstring(accel))

proc gtk_application_get_active_window*(self: ptr Application00): ptr Window00 {.
    importc: "gtk_application_get_active_window", libprag.}

proc getActiveWindow*(self: Application): Window =
  let gobj = gtk_application_get_active_window(cast[ptr Application00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc activeWindow*(self: Application): Window =
  let gobj = gtk_application_get_active_window(cast[ptr Application00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_app_menu*(self: ptr Application00): ptr gio.MenuModel00 {.
    importc: "gtk_application_get_app_menu", libprag.}

proc getAppMenu*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_app_menu(cast[ptr Application00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.MenuModel](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc appMenu*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_app_menu(cast[ptr Application00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.MenuModel](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_menu_by_id*(self: ptr Application00; id: cstring): ptr gio.Menu00 {.
    importc: "gtk_application_get_menu_by_id", libprag.}

proc getMenuById*(self: Application; id: string): gio.Menu =
  let gobj = gtk_application_get_menu_by_id(cast[ptr Application00](self.impl), cstring(id))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.Menu](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menuById*(self: Application; id: string): gio.Menu =
  let gobj = gtk_application_get_menu_by_id(cast[ptr Application00](self.impl), cstring(id))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.Menu](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_menubar*(self: ptr Application00): ptr gio.MenuModel00 {.
    importc: "gtk_application_get_menubar", libprag.}

proc getMenubar*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_menubar(cast[ptr Application00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.MenuModel](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menubar*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_menubar(cast[ptr Application00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.MenuModel](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_window_by_id*(self: ptr Application00; id: uint32): ptr Window00 {.
    importc: "gtk_application_get_window_by_id", libprag.}

proc getWindowById*(self: Application; id: int): Window =
  let gobj = gtk_application_get_window_by_id(cast[ptr Application00](self.impl), uint32(id))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc windowById*(self: Application; id: int): Window =
  let gobj = gtk_application_get_window_by_id(cast[ptr Application00](self.impl), uint32(id))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_windows*(self: ptr Application00): ptr pointer {.
    importc: "gtk_application_get_windows", libprag.}

proc getWindows*(self: Application): ptr pointer =
  gtk_application_get_windows(cast[ptr Application00](self.impl))

proc windows*(self: Application): ptr pointer =
  gtk_application_get_windows(cast[ptr Application00](self.impl))

proc gtk_application_list_action_descriptions*(self: ptr Application00): cstringArray {.
    importc: "gtk_application_list_action_descriptions", libprag.}

proc listActionDescriptions*(self: Application): cstringArray =
  gtk_application_list_action_descriptions(cast[ptr Application00](self.impl))

proc gtk_application_prefers_app_menu*(self: ptr Application00): gboolean {.
    importc: "gtk_application_prefers_app_menu", libprag.}

proc prefersAppMenu*(self: Application): bool =
  toBool(gtk_application_prefers_app_menu(cast[ptr Application00](self.impl)))

proc gtk_application_remove_accelerator*(self: ptr Application00; actionName: cstring; parameter: ptr glib.Variant00) {.
    importc: "gtk_application_remove_accelerator", libprag.}

proc removeAccelerator*(self: Application; actionName: string; parameter: glib.Variant) =
  gtk_application_remove_accelerator(cast[ptr Application00](self.impl), cstring(actionName), cast[ptr glib.Variant00](parameter.impl))

proc gtk_application_remove_window*(self: ptr Application00; window: ptr Window00) {.
    importc: "gtk_application_remove_window", libprag.}

proc removeWindow*(self: Application; window: Window) =
  gtk_application_remove_window(cast[ptr Application00](self.impl), cast[ptr Window00](window.impl))

proc gtk_application_set_accels_for_action*(self: ptr Application00; detailedActionName: cstring; 
    accels: cstringArray) {.
    importc: "gtk_application_set_accels_for_action", libprag.}

proc setAccelsForAction*(self: Application; detailedActionName: string; accels: cstringArray) =
  gtk_application_set_accels_for_action(cast[ptr Application00](self.impl), cstring(detailedActionName), accels)

proc gtk_application_set_app_menu*(self: ptr Application00; appMenu: ptr gio.MenuModel00) {.
    importc: "gtk_application_set_app_menu", libprag.}

proc setAppMenu*(self: Application; appMenu: gio.MenuModel) =
  gtk_application_set_app_menu(cast[ptr Application00](self.impl), cast[ptr gio.MenuModel00](appMenu.impl))

proc `appMenu=`*(self: Application; appMenu: gio.MenuModel) =
  gtk_application_set_app_menu(cast[ptr Application00](self.impl), cast[ptr gio.MenuModel00](appMenu.impl))

proc gtk_application_set_menubar*(self: ptr Application00; menubar: ptr gio.MenuModel00) {.
    importc: "gtk_application_set_menubar", libprag.}

proc setMenubar*(self: Application; menubar: gio.MenuModel) =
  gtk_application_set_menubar(cast[ptr Application00](self.impl), cast[ptr gio.MenuModel00](menubar.impl))

proc `menubar=`*(self: Application; menubar: gio.MenuModel) =
  gtk_application_set_menubar(cast[ptr Application00](self.impl), cast[ptr gio.MenuModel00](menubar.impl))

proc gtk_application_uninhibit*(self: ptr Application00; cookie: uint32) {.
    importc: "gtk_application_uninhibit", libprag.}

proc uninhibit*(self: Application; cookie: int) =
  gtk_application_uninhibit(cast[ptr Application00](self.impl), uint32(cookie))

proc gtk_window_get_application*(self: ptr Window00): ptr Application00 {.
    importc: "gtk_window_get_application", libprag.}

proc getApplication*(self: Window): Application =
  let gobj = gtk_window_get_application(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Application](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc application*(self: Window): Application =
  let gobj = gtk_window_get_application(cast[ptr Window00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Application](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_set_application*(self: ptr Window00; application: ptr Application00) {.
    importc: "gtk_window_set_application", libprag.}

proc setApplication*(self: Window; application: Application) =
  gtk_window_set_application(cast[ptr Window00](self.impl), cast[ptr Application00](application.impl))

proc `application=`*(self: Window; application: Application) =
  gtk_window_set_application(cast[ptr Window00](self.impl), cast[ptr Application00](application.impl))

type
  ApplicationInhibitFlag* {.size: sizeof(cint), pure.} = enum
    logout = 1
    switch = 2
    suspend = 3
    idle = 4

  ApplicationInhibitFlags* {.size: sizeof(cint).} = set[ApplicationInhibitFlag]

proc gtk_application_inhibit*(self: ptr Application00; window: ptr Window00; flags: ApplicationInhibitFlags; 
    reason: cstring): uint32 {.
    importc: "gtk_application_inhibit", libprag.}

proc inhibit*(self: Application; window: Window; flags: ApplicationInhibitFlags; 
    reason: string): int =
  int(gtk_application_inhibit(cast[ptr Application00](self.impl), cast[ptr Window00](window.impl), flags, cstring(reason)))

proc gtk_application_is_inhibited*(self: ptr Application00; flags: ApplicationInhibitFlags): gboolean {.
    importc: "gtk_application_is_inhibited", libprag.}

proc isInhibited*(self: Application; flags: ApplicationInhibitFlags): bool =
  toBool(gtk_application_is_inhibited(cast[ptr Application00](self.impl), flags))

type
  WindowPosition* {.size: sizeof(cint), pure.} = enum
    none = 0
    center = 1
    mouse = 2
    centerAlways = 3
    centerOnParent = 4

proc gtk_window_set_position*(self: ptr Window00; position: WindowPosition) {.
    importc: "gtk_window_set_position", libprag.}

proc setPosition*(self: Window; position: WindowPosition) =
  gtk_window_set_position(cast[ptr Window00](self.impl), position)

proc `position=`*(self: Window; position: WindowPosition) =
  gtk_window_set_position(cast[ptr Window00](self.impl), position)

type
  AdjustmentPrivate00* {.pure.} = object
  AdjustmentPrivate* = ref object
    impl*: ptr AdjustmentPrivate00

type
  Adjustment* = ref object of gobject.InitiallyUnowned
  Adjustment00* = object of gobject.InitiallyUnowned00
    priv1: ptr AdjustmentPrivate00

proc scChanged*(self: Adjustment;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scValueChanged*(self: Adjustment;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_adjustment_new*(value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble; 
    pageIncrement: cdouble; pageSize: cdouble): ptr Adjustment00 {.
    importc: "gtk_adjustment_new", libprag.}

proc newAdjustment*(value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble; 
    pageIncrement: cdouble; pageSize: cdouble): Adjustment =
  new(result, finalizeGObject)
  result.impl = gtk_adjustment_new(value, lower, upper, stepIncrement, pageIncrement, pageSize)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAdjustment*[T](result: var T; value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble; 
    pageIncrement: cdouble; pageSize: cdouble) =
  assert(result is Adjustment)
  new(result, finalizeGObject)
  result.impl = gtk_adjustment_new(value, lower, upper, stepIncrement, pageIncrement, pageSize)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_adjustment_changed*(self: ptr Adjustment00) {.
    importc: "gtk_adjustment_changed", libprag.}

proc changed*(self: Adjustment) =
  gtk_adjustment_changed(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_clamp_page*(self: ptr Adjustment00; lower: cdouble; upper: cdouble) {.
    importc: "gtk_adjustment_clamp_page", libprag.}

proc clampPage*(self: Adjustment; lower: cdouble; upper: cdouble) =
  gtk_adjustment_clamp_page(cast[ptr Adjustment00](self.impl), lower, upper)

proc gtk_adjustment_configure*(self: ptr Adjustment00; value: cdouble; lower: cdouble; 
    upper: cdouble; stepIncrement: cdouble; pageIncrement: cdouble; pageSize: cdouble) {.
    importc: "gtk_adjustment_configure", libprag.}

proc configure*(self: Adjustment; value: cdouble; lower: cdouble; 
    upper: cdouble; stepIncrement: cdouble; pageIncrement: cdouble; pageSize: cdouble) =
  gtk_adjustment_configure(cast[ptr Adjustment00](self.impl), value, lower, upper, stepIncrement, pageIncrement, pageSize)

proc gtk_adjustment_get_lower*(self: ptr Adjustment00): cdouble {.
    importc: "gtk_adjustment_get_lower", libprag.}

proc getLower*(self: Adjustment): cdouble =
  gtk_adjustment_get_lower(cast[ptr Adjustment00](self.impl))

proc lower*(self: Adjustment): cdouble =
  gtk_adjustment_get_lower(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_minimum_increment*(self: ptr Adjustment00): cdouble {.
    importc: "gtk_adjustment_get_minimum_increment", libprag.}

proc getMinimumIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_minimum_increment(cast[ptr Adjustment00](self.impl))

proc minimumIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_minimum_increment(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_page_increment*(self: ptr Adjustment00): cdouble {.
    importc: "gtk_adjustment_get_page_increment", libprag.}

proc getPageIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_increment(cast[ptr Adjustment00](self.impl))

proc pageIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_increment(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_page_size*(self: ptr Adjustment00): cdouble {.
    importc: "gtk_adjustment_get_page_size", libprag.}

proc getPageSize*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_size(cast[ptr Adjustment00](self.impl))

proc pageSize*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_size(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_step_increment*(self: ptr Adjustment00): cdouble {.
    importc: "gtk_adjustment_get_step_increment", libprag.}

proc getStepIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_step_increment(cast[ptr Adjustment00](self.impl))

proc stepIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_step_increment(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_upper*(self: ptr Adjustment00): cdouble {.
    importc: "gtk_adjustment_get_upper", libprag.}

proc getUpper*(self: Adjustment): cdouble =
  gtk_adjustment_get_upper(cast[ptr Adjustment00](self.impl))

proc upper*(self: Adjustment): cdouble =
  gtk_adjustment_get_upper(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_value*(self: ptr Adjustment00): cdouble {.
    importc: "gtk_adjustment_get_value", libprag.}

proc getValue*(self: Adjustment): cdouble =
  gtk_adjustment_get_value(cast[ptr Adjustment00](self.impl))

proc value*(self: Adjustment): cdouble =
  gtk_adjustment_get_value(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_set_lower*(self: ptr Adjustment00; lower: cdouble) {.
    importc: "gtk_adjustment_set_lower", libprag.}

proc setLower*(self: Adjustment; lower: cdouble) =
  gtk_adjustment_set_lower(cast[ptr Adjustment00](self.impl), lower)

proc `lower=`*(self: Adjustment; lower: cdouble) =
  gtk_adjustment_set_lower(cast[ptr Adjustment00](self.impl), lower)

proc gtk_adjustment_set_page_increment*(self: ptr Adjustment00; pageIncrement: cdouble) {.
    importc: "gtk_adjustment_set_page_increment", libprag.}

proc setPageIncrement*(self: Adjustment; pageIncrement: cdouble) =
  gtk_adjustment_set_page_increment(cast[ptr Adjustment00](self.impl), pageIncrement)

proc `pageIncrement=`*(self: Adjustment; pageIncrement: cdouble) =
  gtk_adjustment_set_page_increment(cast[ptr Adjustment00](self.impl), pageIncrement)

proc gtk_adjustment_set_page_size*(self: ptr Adjustment00; pageSize: cdouble) {.
    importc: "gtk_adjustment_set_page_size", libprag.}

proc setPageSize*(self: Adjustment; pageSize: cdouble) =
  gtk_adjustment_set_page_size(cast[ptr Adjustment00](self.impl), pageSize)

proc `pageSize=`*(self: Adjustment; pageSize: cdouble) =
  gtk_adjustment_set_page_size(cast[ptr Adjustment00](self.impl), pageSize)

proc gtk_adjustment_set_step_increment*(self: ptr Adjustment00; stepIncrement: cdouble) {.
    importc: "gtk_adjustment_set_step_increment", libprag.}

proc setStepIncrement*(self: Adjustment; stepIncrement: cdouble) =
  gtk_adjustment_set_step_increment(cast[ptr Adjustment00](self.impl), stepIncrement)

proc `stepIncrement=`*(self: Adjustment; stepIncrement: cdouble) =
  gtk_adjustment_set_step_increment(cast[ptr Adjustment00](self.impl), stepIncrement)

proc gtk_adjustment_set_upper*(self: ptr Adjustment00; upper: cdouble) {.
    importc: "gtk_adjustment_set_upper", libprag.}

proc setUpper*(self: Adjustment; upper: cdouble) =
  gtk_adjustment_set_upper(cast[ptr Adjustment00](self.impl), upper)

proc `upper=`*(self: Adjustment; upper: cdouble) =
  gtk_adjustment_set_upper(cast[ptr Adjustment00](self.impl), upper)

proc gtk_adjustment_set_value*(self: ptr Adjustment00; value: cdouble) {.
    importc: "gtk_adjustment_set_value", libprag.}

proc setValue*(self: Adjustment; value: cdouble) =
  gtk_adjustment_set_value(cast[ptr Adjustment00](self.impl), value)

proc `value=`*(self: Adjustment; value: cdouble) =
  gtk_adjustment_set_value(cast[ptr Adjustment00](self.impl), value)

proc gtk_adjustment_value_changed*(self: ptr Adjustment00) {.
    importc: "gtk_adjustment_value_changed", libprag.}

proc valueChanged*(self: Adjustment) =
  gtk_adjustment_value_changed(cast[ptr Adjustment00](self.impl))

proc gtk_container_get_focus_hadjustment*(self: ptr Container00): ptr Adjustment00 {.
    importc: "gtk_container_get_focus_hadjustment", libprag.}

proc getFocusHadjustment*(self: Container): Adjustment =
  let gobj = gtk_container_get_focus_hadjustment(cast[ptr Container00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusHadjustment*(self: Container): Adjustment =
  let gobj = gtk_container_get_focus_hadjustment(cast[ptr Container00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_container_get_focus_vadjustment*(self: ptr Container00): ptr Adjustment00 {.
    importc: "gtk_container_get_focus_vadjustment", libprag.}

proc getFocusVadjustment*(self: Container): Adjustment =
  let gobj = gtk_container_get_focus_vadjustment(cast[ptr Container00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusVadjustment*(self: Container): Adjustment =
  let gobj = gtk_container_get_focus_vadjustment(cast[ptr Container00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_container_set_focus_hadjustment*(self: ptr Container00; adjustment: ptr Adjustment00) {.
    importc: "gtk_container_set_focus_hadjustment", libprag.}

proc setFocusHadjustment*(self: Container; adjustment: Adjustment) =
  gtk_container_set_focus_hadjustment(cast[ptr Container00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `focusHadjustment=`*(self: Container; adjustment: Adjustment) =
  gtk_container_set_focus_hadjustment(cast[ptr Container00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_container_set_focus_vadjustment*(self: ptr Container00; adjustment: ptr Adjustment00) {.
    importc: "gtk_container_set_focus_vadjustment", libprag.}

proc setFocusVadjustment*(self: Container; adjustment: Adjustment) =
  gtk_container_set_focus_vadjustment(cast[ptr Container00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `focusVadjustment=`*(self: Container; adjustment: Adjustment) =
  gtk_container_set_focus_vadjustment(cast[ptr Container00](self.impl), cast[ptr Adjustment00](adjustment.impl))

type
  ResizeMode* {.size: sizeof(cint), pure.} = enum
    parent = 0
    queue = 1
    immediate = 2

proc gtk_container_get_resize_mode*(self: ptr Container00): ResizeMode {.
    importc: "gtk_container_get_resize_mode", libprag.}

proc getResizeMode*(self: Container): ResizeMode =
  gtk_container_get_resize_mode(cast[ptr Container00](self.impl))

proc resizeMode*(self: Container): ResizeMode =
  gtk_container_get_resize_mode(cast[ptr Container00](self.impl))

proc gtk_container_set_resize_mode*(self: ptr Container00; resizeMode: ResizeMode) {.
    importc: "gtk_container_set_resize_mode", libprag.}

proc setResizeMode*(self: Container; resizeMode: ResizeMode) =
  gtk_container_set_resize_mode(cast[ptr Container00](self.impl), resizeMode)

proc `resizeMode=`*(self: Container; resizeMode: ResizeMode) =
  gtk_container_set_resize_mode(cast[ptr Container00](self.impl), resizeMode)

type
  IconSet00* {.pure.} = object
  IconSet* = ref object
    impl*: ptr IconSet00

proc gtk_icon_set_new*(): ptr IconSet00 {.
    importc: "gtk_icon_set_new", libprag.}

proc newIconSet*(): IconSet =
  new(result)
  result.impl = gtk_icon_set_new()

proc initIconSet*[T](result: var T) =
  assert(result is IconSet)
  new(result)
  result.impl = gtk_icon_set_new()

proc gtk_icon_set_new_from_pixbuf*(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr IconSet00 {.
    importc: "gtk_icon_set_new_from_pixbuf", libprag.}

proc newIconSetFromPixbuf*(pixbuf: gdkpixbuf.Pixbuf): IconSet =
  new(result)
  result.impl = gtk_icon_set_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc initIconSetFromPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf) =
  assert(result is IconSet)
  new(result)
  result.impl = gtk_icon_set_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_icon_set_copy*(self: ptr IconSet00): ptr IconSet00 {.
    importc: "gtk_icon_set_copy", libprag.}

proc copy*(self: IconSet): IconSet =
  new(result)
  result.impl = gtk_icon_set_copy(cast[ptr IconSet00](self.impl))

proc gtk_icon_set_get_sizes*(self: ptr IconSet00; sizes: var int32Array; nSizes: var int32) {.
    importc: "gtk_icon_set_get_sizes", libprag.}

proc getSizes*(self: IconSet; sizes: var int32Array; nSizes: var int) =
  var nSizes_00 = int32(nSizes)
  gtk_icon_set_get_sizes(cast[ptr IconSet00](self.impl), sizes, nSizes_00)
  nSizes = int(nSizes_00)

proc sizes*(self: IconSet; sizes: var int32Array; nSizes: var int) =
  var nSizes_00 = int32(nSizes)
  gtk_icon_set_get_sizes(cast[ptr IconSet00](self.impl), sizes, nSizes_00)
  nSizes = int(nSizes_00)

proc gtk_icon_set_ref*(self: ptr IconSet00): ptr IconSet00 {.
    importc: "gtk_icon_set_ref", libprag.}

proc `ref`*(self: IconSet): IconSet =
  new(result)
  result.impl = gtk_icon_set_ref(cast[ptr IconSet00](self.impl))

proc gtk_icon_set_render_icon*(self: ptr IconSet00; style: ptr Style00; direction: TextDirection; 
    state: StateType; size: int32; widget: ptr Widget00; detail: cstring): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_set_render_icon", libprag.}

proc renderIcon*(self: IconSet; style: Style; direction: TextDirection; 
    state: StateType; size: int; widget: Widget; detail: string): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_set_render_icon(cast[ptr IconSet00](self.impl), cast[ptr Style00](style.impl), direction, state, int32(size), cast[ptr Widget00](widget.impl), cstring(detail))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_set_unref*(self: ptr IconSet00) {.
    importc: "gtk_icon_set_unref", libprag.}

proc unref*(self: IconSet) =
  gtk_icon_set_unref(cast[ptr IconSet00](self.impl))

proc gtk_style_lookup_icon_set*(self: ptr Style00; stockId: cstring): ptr IconSet00 {.
    importc: "gtk_style_lookup_icon_set", libprag.}

proc lookupIconSet*(self: Style; stockId: string): IconSet =
  new(result)
  result.impl = gtk_style_lookup_icon_set(cast[ptr Style00](self.impl), cstring(stockId))

type
  IconSource00* {.pure.} = object
  IconSource* = ref object
    impl*: ptr IconSource00

proc gtk_icon_source_new*(): ptr IconSource00 {.
    importc: "gtk_icon_source_new", libprag.}

proc newIconSource*(): IconSource =
  new(result)
  result.impl = gtk_icon_source_new()

proc initIconSource*[T](result: var T) =
  assert(result is IconSource)
  new(result)
  result.impl = gtk_icon_source_new()

proc gtk_icon_source_copy*(self: ptr IconSource00): ptr IconSource00 {.
    importc: "gtk_icon_source_copy", libprag.}

proc copy*(self: IconSource): IconSource =
  new(result)
  result.impl = gtk_icon_source_copy(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_free*(self: ptr IconSource00) {.
    importc: "gtk_icon_source_free", libprag.}

proc free*(self: IconSource) =
  gtk_icon_source_free(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_get_direction*(self: ptr IconSource00): TextDirection {.
    importc: "gtk_icon_source_get_direction", libprag.}

proc getDirection*(self: IconSource): TextDirection =
  gtk_icon_source_get_direction(cast[ptr IconSource00](self.impl))

proc direction*(self: IconSource): TextDirection =
  gtk_icon_source_get_direction(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_get_direction_wildcarded*(self: ptr IconSource00): gboolean {.
    importc: "gtk_icon_source_get_direction_wildcarded", libprag.}

proc getDirectionWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_direction_wildcarded(cast[ptr IconSource00](self.impl)))

proc directionWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_direction_wildcarded(cast[ptr IconSource00](self.impl)))

proc gtk_icon_source_get_filename*(self: ptr IconSource00): ucstring {.
    importc: "gtk_icon_source_get_filename", libprag.}

proc getFilename*(self: IconSource): ucstring =
  gtk_icon_source_get_filename(cast[ptr IconSource00](self.impl))

proc filename*(self: IconSource): ucstring =
  gtk_icon_source_get_filename(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_get_icon_name*(self: ptr IconSource00): cstring {.
    importc: "gtk_icon_source_get_icon_name", libprag.}

proc getIconName*(self: IconSource): string =
  let resul0 = gtk_icon_source_get_icon_name(cast[ptr IconSource00](self.impl))
  result = $resul0

proc iconName*(self: IconSource): string =
  let resul0 = gtk_icon_source_get_icon_name(cast[ptr IconSource00](self.impl))
  result = $resul0

proc gtk_icon_source_get_pixbuf*(self: ptr IconSource00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_source_get_pixbuf", libprag.}

proc getPixbuf*(self: IconSource): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_source_get_pixbuf(cast[ptr IconSource00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: IconSource): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_source_get_pixbuf(cast[ptr IconSource00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_source_get_size*(self: ptr IconSource00): int32 {.
    importc: "gtk_icon_source_get_size", libprag.}

proc getSize*(self: IconSource): int =
  int(gtk_icon_source_get_size(cast[ptr IconSource00](self.impl)))

proc size*(self: IconSource): int =
  int(gtk_icon_source_get_size(cast[ptr IconSource00](self.impl)))

proc gtk_icon_source_get_size_wildcarded*(self: ptr IconSource00): gboolean {.
    importc: "gtk_icon_source_get_size_wildcarded", libprag.}

proc getSizeWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_size_wildcarded(cast[ptr IconSource00](self.impl)))

proc sizeWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_size_wildcarded(cast[ptr IconSource00](self.impl)))

proc gtk_icon_source_get_state*(self: ptr IconSource00): StateType {.
    importc: "gtk_icon_source_get_state", libprag.}

proc getState*(self: IconSource): StateType =
  gtk_icon_source_get_state(cast[ptr IconSource00](self.impl))

proc state*(self: IconSource): StateType =
  gtk_icon_source_get_state(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_get_state_wildcarded*(self: ptr IconSource00): gboolean {.
    importc: "gtk_icon_source_get_state_wildcarded", libprag.}

proc getStateWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_state_wildcarded(cast[ptr IconSource00](self.impl)))

proc stateWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_state_wildcarded(cast[ptr IconSource00](self.impl)))

proc gtk_icon_source_set_direction*(self: ptr IconSource00; direction: TextDirection) {.
    importc: "gtk_icon_source_set_direction", libprag.}

proc setDirection*(self: IconSource; direction: TextDirection) =
  gtk_icon_source_set_direction(cast[ptr IconSource00](self.impl), direction)

proc `direction=`*(self: IconSource; direction: TextDirection) =
  gtk_icon_source_set_direction(cast[ptr IconSource00](self.impl), direction)

proc gtk_icon_source_set_direction_wildcarded*(self: ptr IconSource00; setting: gboolean) {.
    importc: "gtk_icon_source_set_direction_wildcarded", libprag.}

proc setDirectionWildcarded*(self: IconSource; setting: bool) =
  gtk_icon_source_set_direction_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc `directionWildcarded=`*(self: IconSource; setting: bool) =
  gtk_icon_source_set_direction_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc gtk_icon_source_set_filename*(self: ptr IconSource00; filename: ucstring) {.
    importc: "gtk_icon_source_set_filename", libprag.}

proc setFilename*(self: IconSource; filename: ucstring) =
  gtk_icon_source_set_filename(cast[ptr IconSource00](self.impl), filename)

proc `filename=`*(self: IconSource; filename: ucstring) =
  gtk_icon_source_set_filename(cast[ptr IconSource00](self.impl), filename)

proc gtk_icon_source_set_icon_name*(self: ptr IconSource00; iconName: cstring) {.
    importc: "gtk_icon_source_set_icon_name", libprag.}

proc setIconName*(self: IconSource; iconName: string) =
  gtk_icon_source_set_icon_name(cast[ptr IconSource00](self.impl), cstring(iconName))

proc `iconName=`*(self: IconSource; iconName: string) =
  gtk_icon_source_set_icon_name(cast[ptr IconSource00](self.impl), cstring(iconName))

proc gtk_icon_source_set_pixbuf*(self: ptr IconSource00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_icon_source_set_pixbuf", libprag.}

proc setPixbuf*(self: IconSource; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_icon_source_set_pixbuf(cast[ptr IconSource00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `pixbuf=`*(self: IconSource; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_icon_source_set_pixbuf(cast[ptr IconSource00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_icon_source_set_size*(self: ptr IconSource00; size: int32) {.
    importc: "gtk_icon_source_set_size", libprag.}

proc setSize*(self: IconSource; size: int) =
  gtk_icon_source_set_size(cast[ptr IconSource00](self.impl), int32(size))

proc `size=`*(self: IconSource; size: int) =
  gtk_icon_source_set_size(cast[ptr IconSource00](self.impl), int32(size))

proc gtk_icon_source_set_size_wildcarded*(self: ptr IconSource00; setting: gboolean) {.
    importc: "gtk_icon_source_set_size_wildcarded", libprag.}

proc setSizeWildcarded*(self: IconSource; setting: bool) =
  gtk_icon_source_set_size_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc `sizeWildcarded=`*(self: IconSource; setting: bool) =
  gtk_icon_source_set_size_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc gtk_icon_source_set_state*(self: ptr IconSource00; state: StateType) {.
    importc: "gtk_icon_source_set_state", libprag.}

proc setState*(self: IconSource; state: StateType) =
  gtk_icon_source_set_state(cast[ptr IconSource00](self.impl), state)

proc `state=`*(self: IconSource; state: StateType) =
  gtk_icon_source_set_state(cast[ptr IconSource00](self.impl), state)

proc gtk_icon_source_set_state_wildcarded*(self: ptr IconSource00; setting: gboolean) {.
    importc: "gtk_icon_source_set_state_wildcarded", libprag.}

proc setStateWildcarded*(self: IconSource; setting: bool) =
  gtk_icon_source_set_state_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc `stateWildcarded=`*(self: IconSource; setting: bool) =
  gtk_icon_source_set_state_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc gtk_style_render_icon*(self: ptr Style00; source: ptr IconSource00; direction: TextDirection; 
    state: StateType; size: int32; widget: ptr Widget00; detail: cstring): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_style_render_icon", libprag.}

proc renderIcon*(self: Style; source: IconSource; direction: TextDirection; 
    state: StateType; size: int; widget: Widget; detail: string): gdkpixbuf.Pixbuf =
  let gobj = gtk_style_render_icon(cast[ptr Style00](self.impl), cast[ptr IconSource00](source.impl), direction, state, int32(size), cast[ptr Widget00](widget.impl), cstring(detail))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_set_add_source*(self: ptr IconSet00; source: ptr IconSource00) {.
    importc: "gtk_icon_set_add_source", libprag.}

proc addSource*(self: IconSet; source: IconSource) =
  gtk_icon_set_add_source(cast[ptr IconSet00](self.impl), cast[ptr IconSource00](source.impl))

type
  Orientation* {.size: sizeof(cint), pure.} = enum
    horizontal = 0
    vertical = 1

proc gtk_widget_compute_expand*(self: ptr Widget00; orientation: Orientation): gboolean {.
    importc: "gtk_widget_compute_expand", libprag.}

proc computeExpand*(self: Widget; orientation: Orientation): bool =
  toBool(gtk_widget_compute_expand(cast[ptr Widget00](self.impl), orientation))

proc gtk_box_new*(orientation: Orientation; spacing: int32): ptr Box00 {.
    importc: "gtk_box_new", libprag.}

proc newBox*(orientation: Orientation; spacing: int): Box =
  new(result, finalizeGObject)
  result.impl = gtk_box_new(orientation, int32(spacing))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBox*[T](result: var T; orientation: Orientation; spacing: int) =
  assert(result is Box)
  new(result, finalizeGObject)
  result.impl = gtk_box_new(orientation, int32(spacing))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  DestDefaults* {.size: sizeof(cint), pure.} = enum
    motion = 1
    highlight = 2
    drop = 4
    all = 7

type
  TargetEntry00* {.pure.} = object
    target*: cstring
    flags*: uint32
    info*: uint32
  TargetEntry* = ref object
    impl*: ptr TargetEntry00

proc gtk_target_entry_new*(target: cstring; flags: uint32; info: uint32): ptr TargetEntry00 {.
    importc: "gtk_target_entry_new", libprag.}

proc newTargetEntry*(target: string; flags: int; info: int): TargetEntry =
  new(result)
  result.impl = gtk_target_entry_new(cstring(target), uint32(flags), uint32(info))

proc initTargetEntry*[T](result: var T; target: string; flags: int; info: int) =
  assert(result is TargetEntry)
  new(result)
  result.impl = gtk_target_entry_new(cstring(target), uint32(flags), uint32(info))

proc gtk_target_entry_copy*(self: ptr TargetEntry00): ptr TargetEntry00 {.
    importc: "gtk_target_entry_copy", libprag.}

proc copy*(self: TargetEntry): TargetEntry =
  new(result)
  result.impl = gtk_target_entry_copy(cast[ptr TargetEntry00](self.impl))

proc gtk_target_entry_free*(self: ptr TargetEntry00) {.
    importc: "gtk_target_entry_free", libprag.}

proc free*(self: TargetEntry) =
  gtk_target_entry_free(cast[ptr TargetEntry00](self.impl))

proc gtk_drag_dest_set*(self: ptr Widget00; flags: DestDefaults; targets: TargetEntry00Array; 
    nTargets: int32; actions: gdk.DragAction) {.
    importc: "gtk_drag_dest_set", libprag.}

proc dragDestSet*(self: Widget; flags: DestDefaults; targets: TargetEntry00Array; 
    nTargets: int; actions: gdk.DragAction) =
  gtk_drag_dest_set(cast[ptr Widget00](self.impl), flags, targets, int32(nTargets), actions)

proc gtk_drag_source_set*(self: ptr Widget00; startButtonMask: gdk.ModifierType; 
    targets: TargetEntry00Array; nTargets: int32; actions: gdk.DragAction) {.
    importc: "gtk_drag_source_set", libprag.}

proc dragSourceSet*(self: Widget; startButtonMask: gdk.ModifierType; targets: TargetEntry00Array; 
    nTargets: int; actions: gdk.DragAction) =
  gtk_drag_source_set(cast[ptr Widget00](self.impl), startButtonMask, targets, int32(nTargets), actions)

type
  TargetList00* {.pure.} = object
  TargetList* = ref object
    impl*: ptr TargetList00

proc gtk_target_list_new*(targets: TargetEntry00Array; ntargets: uint32): ptr TargetList00 {.
    importc: "gtk_target_list_new", libprag.}

proc newTargetList*(targets: TargetEntry00Array; ntargets: int): TargetList =
  new(result)
  result.impl = gtk_target_list_new(targets, uint32(ntargets))

proc initTargetList*[T](result: var T; targets: TargetEntry00Array; ntargets: int) =
  assert(result is TargetList)
  new(result)
  result.impl = gtk_target_list_new(targets, uint32(ntargets))

proc gtk_target_list_add*(self: ptr TargetList00; target: ptr gdk.Atom00; flags: uint32; 
    info: uint32) {.
    importc: "gtk_target_list_add", libprag.}

proc add*(self: TargetList; target: gdk.Atom; flags: int; info: int) =
  gtk_target_list_add(cast[ptr TargetList00](self.impl), cast[ptr gdk.Atom00](target.impl), uint32(flags), uint32(info))

proc gtk_target_list_add_image_targets*(self: ptr TargetList00; info: uint32; writable: gboolean) {.
    importc: "gtk_target_list_add_image_targets", libprag.}

proc addImageTargets*(self: TargetList; info: int; writable: bool) =
  gtk_target_list_add_image_targets(cast[ptr TargetList00](self.impl), uint32(info), gboolean(writable))

proc gtk_target_list_add_table*(self: ptr TargetList00; targets: TargetEntry00Array; 
    ntargets: uint32) {.
    importc: "gtk_target_list_add_table", libprag.}

proc addTable*(self: TargetList; targets: TargetEntry00Array; ntargets: int) =
  gtk_target_list_add_table(cast[ptr TargetList00](self.impl), targets, uint32(ntargets))

proc gtk_target_list_add_text_targets*(self: ptr TargetList00; info: uint32) {.
    importc: "gtk_target_list_add_text_targets", libprag.}

proc addTextTargets*(self: TargetList; info: int) =
  gtk_target_list_add_text_targets(cast[ptr TargetList00](self.impl), uint32(info))

proc gtk_target_list_add_uri_targets*(self: ptr TargetList00; info: uint32) {.
    importc: "gtk_target_list_add_uri_targets", libprag.}

proc addUriTargets*(self: TargetList; info: int) =
  gtk_target_list_add_uri_targets(cast[ptr TargetList00](self.impl), uint32(info))

proc gtk_target_list_find*(self: ptr TargetList00; target: ptr gdk.Atom00; info: var uint32): gboolean {.
    importc: "gtk_target_list_find", libprag.}

proc find*(self: TargetList; target: gdk.Atom; info: var int): bool =
  var info_00 = uint32(info)
  result = toBool(gtk_target_list_find(cast[ptr TargetList00](self.impl), cast[ptr gdk.Atom00](target.impl), info_00))
  info = int(info_00)

proc gtk_target_list_ref*(self: ptr TargetList00): ptr TargetList00 {.
    importc: "gtk_target_list_ref", libprag.}

proc `ref`*(self: TargetList): TargetList =
  new(result)
  result.impl = gtk_target_list_ref(cast[ptr TargetList00](self.impl))

proc gtk_target_list_remove*(self: ptr TargetList00; target: ptr gdk.Atom00) {.
    importc: "gtk_target_list_remove", libprag.}

proc remove*(self: TargetList; target: gdk.Atom) =
  gtk_target_list_remove(cast[ptr TargetList00](self.impl), cast[ptr gdk.Atom00](target.impl))

proc gtk_target_list_unref*(self: ptr TargetList00) {.
    importc: "gtk_target_list_unref", libprag.}

proc unref*(self: TargetList) =
  gtk_target_list_unref(cast[ptr TargetList00](self.impl))

proc gtk_drag_begin*(self: ptr Widget00; targets: ptr TargetList00; actions: gdk.DragAction; 
    button: int32; event: ptr gdk.Event00): ptr gdk.DragContext00 {.
    importc: "gtk_drag_begin", libprag.}

proc dragBegin*(self: Widget; targets: TargetList; actions: gdk.DragAction; 
    button: int; event: gdk.Event): gdk.DragContext =
  let gobj = gtk_drag_begin(cast[ptr Widget00](self.impl), cast[ptr TargetList00](targets.impl), actions, int32(button), cast[ptr gdk.Event00](event.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.DragContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_begin_with_coordinates*(self: ptr Widget00; targets: ptr TargetList00; actions: gdk.DragAction; 
    button: int32; event: ptr gdk.Event00; x: int32; y: int32): ptr gdk.DragContext00 {.
    importc: "gtk_drag_begin_with_coordinates", libprag.}

proc dragBeginWithCoordinates*(self: Widget; targets: TargetList; actions: gdk.DragAction; 
    button: int; event: gdk.Event; x: int; y: int): gdk.DragContext =
  let gobj = gtk_drag_begin_with_coordinates(cast[ptr Widget00](self.impl), cast[ptr TargetList00](targets.impl), actions, int32(button), cast[ptr gdk.Event00](event.impl), int32(x), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.DragContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_dest_find_target*(self: ptr Widget00; context: ptr gdk.DragContext00; 
    targetList: ptr TargetList00): ptr gdk.Atom00 {.
    importc: "gtk_drag_dest_find_target", libprag.}

proc dragDestFindTarget*(self: Widget; context: gdk.DragContext; targetList: TargetList): gdk.Atom =
  new(result)
  result.impl = gtk_drag_dest_find_target(cast[ptr Widget00](self.impl), cast[ptr gdk.DragContext00](context.impl), cast[ptr TargetList00](targetList.impl))

proc gtk_drag_dest_get_target_list*(self: ptr Widget00): ptr TargetList00 {.
    importc: "gtk_drag_dest_get_target_list", libprag.}

proc dragDestGetTargetList*(self: Widget): TargetList =
  new(result)
  result.impl = gtk_drag_dest_get_target_list(cast[ptr Widget00](self.impl))

proc gtk_drag_dest_set_target_list*(self: ptr Widget00; targetList: ptr TargetList00) {.
    importc: "gtk_drag_dest_set_target_list", libprag.}

proc dragDestSetTargetList*(self: Widget; targetList: TargetList) =
  gtk_drag_dest_set_target_list(cast[ptr Widget00](self.impl), cast[ptr TargetList00](targetList.impl))

proc gtk_drag_source_get_target_list*(self: ptr Widget00): ptr TargetList00 {.
    importc: "gtk_drag_source_get_target_list", libprag.}

proc dragSourceGetTargetList*(self: Widget): TargetList =
  new(result)
  result.impl = gtk_drag_source_get_target_list(cast[ptr Widget00](self.impl))

proc gtk_drag_source_set_target_list*(self: ptr Widget00; targetList: ptr TargetList00) {.
    importc: "gtk_drag_source_set_target_list", libprag.}

proc dragSourceSetTargetList*(self: Widget; targetList: TargetList) =
  gtk_drag_source_set_target_list(cast[ptr Widget00](self.impl), cast[ptr TargetList00](targetList.impl))

type
  Clipboard* = ref object of gobject.Object
  Clipboard00* = object of gobject.Object00

proc scOwnerChange*(self: Clipboard;  p: proc (self: ptr gobject.Object00; event: gdk.EventOwnerChange00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "owner-change", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_clipboard_get*(selection: ptr gdk.Atom00): ptr Clipboard00 {.
    importc: "gtk_clipboard_get", libprag.}

proc get*(selection: gdk.Atom): Clipboard =
  let gobj = gtk_clipboard_get(cast[ptr gdk.Atom00](selection.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Clipboard](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_get_default*(display: ptr gdk.Display00): ptr Clipboard00 {.
    importc: "gtk_clipboard_get_default", libprag.}

proc getDefault*(display: gdk.Display): Clipboard =
  let gobj = gtk_clipboard_get_default(cast[ptr gdk.Display00](display.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Clipboard](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc default*(display: gdk.Display): Clipboard =
  let gobj = gtk_clipboard_get_default(cast[ptr gdk.Display00](display.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Clipboard](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_get_for_display*(display: ptr gdk.Display00; selection: ptr gdk.Atom00): ptr Clipboard00 {.
    importc: "gtk_clipboard_get_for_display", libprag.}

proc getForDisplay*(display: gdk.Display; selection: gdk.Atom): Clipboard =
  let gobj = gtk_clipboard_get_for_display(cast[ptr gdk.Display00](display.impl), cast[ptr gdk.Atom00](selection.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Clipboard](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc forDisplay*(display: gdk.Display; selection: gdk.Atom): Clipboard =
  let gobj = gtk_clipboard_get_for_display(cast[ptr gdk.Display00](display.impl), cast[ptr gdk.Atom00](selection.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Clipboard](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_clear*(self: ptr Clipboard00) {.
    importc: "gtk_clipboard_clear", libprag.}

proc clear*(self: Clipboard) =
  gtk_clipboard_clear(cast[ptr Clipboard00](self.impl))

proc gtk_clipboard_get_display*(self: ptr Clipboard00): ptr gdk.Display00 {.
    importc: "gtk_clipboard_get_display", libprag.}

proc getDisplay*(self: Clipboard): gdk.Display =
  let gobj = gtk_clipboard_get_display(cast[ptr Clipboard00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Display](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: Clipboard): gdk.Display =
  let gobj = gtk_clipboard_get_display(cast[ptr Clipboard00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Display](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_get_owner*(self: ptr Clipboard00): ptr gobject.Object00 {.
    importc: "gtk_clipboard_get_owner", libprag.}

proc getOwner*(self: Clipboard): gobject.Object =
  let gobj = gtk_clipboard_get_owner(cast[ptr Clipboard00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gobject.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc owner*(self: Clipboard): gobject.Object =
  let gobj = gtk_clipboard_get_owner(cast[ptr Clipboard00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gobject.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_set_can_store*(self: ptr Clipboard00; targets: TargetEntry00Array; 
    nTargets: int32) {.
    importc: "gtk_clipboard_set_can_store", libprag.}

proc setCanStore*(self: Clipboard; targets: TargetEntry00Array; nTargets: int) =
  gtk_clipboard_set_can_store(cast[ptr Clipboard00](self.impl), targets, int32(nTargets))

proc gtk_clipboard_set_image*(self: ptr Clipboard00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_clipboard_set_image", libprag.}

proc setImage*(self: Clipboard; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_clipboard_set_image(cast[ptr Clipboard00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `image=`*(self: Clipboard; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_clipboard_set_image(cast[ptr Clipboard00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_clipboard_set_text*(self: ptr Clipboard00; text: cstring; len: int32) {.
    importc: "gtk_clipboard_set_text", libprag.}

proc setText*(self: Clipboard; text: string; len: int) =
  gtk_clipboard_set_text(cast[ptr Clipboard00](self.impl), cstring(text), int32(len))

proc gtk_clipboard_store*(self: ptr Clipboard00) {.
    importc: "gtk_clipboard_store", libprag.}

proc store*(self: Clipboard) =
  gtk_clipboard_store(cast[ptr Clipboard00](self.impl))

proc gtk_clipboard_wait_for_contents*(self: ptr Clipboard00; target: ptr gdk.Atom00): ptr SelectionData00 {.
    importc: "gtk_clipboard_wait_for_contents", libprag.}

proc waitForContents*(self: Clipboard; target: gdk.Atom): SelectionData =
  new(result)
  result.impl = gtk_clipboard_wait_for_contents(cast[ptr Clipboard00](self.impl), cast[ptr gdk.Atom00](target.impl))

proc gtk_clipboard_wait_for_image*(self: ptr Clipboard00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_clipboard_wait_for_image", libprag.}

proc waitForImage*(self: Clipboard): gdkpixbuf.Pixbuf =
  let gobj = gtk_clipboard_wait_for_image(cast[ptr Clipboard00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_wait_for_targets*(self: ptr Clipboard00; targets: var ptr gdk.Atom00Array; 
    nTargets: var int32): gboolean {.
    importc: "gtk_clipboard_wait_for_targets", libprag.}

proc waitForTargets*(self: Clipboard; targets: var ptr gdk.Atom00Array; 
    nTargets: var int): bool =
  var nTargets_00 = int32(nTargets)
  result = toBool(gtk_clipboard_wait_for_targets(cast[ptr Clipboard00](self.impl), targets, nTargets_00))
  nTargets = int(nTargets_00)

proc gtk_clipboard_wait_for_text*(self: ptr Clipboard00): cstring {.
    importc: "gtk_clipboard_wait_for_text", libprag.}

proc waitForText*(self: Clipboard): string =
  let resul0 = gtk_clipboard_wait_for_text(cast[ptr Clipboard00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_clipboard_wait_for_uris*(self: ptr Clipboard00): cstringArray {.
    importc: "gtk_clipboard_wait_for_uris", libprag.}

proc waitForUris*(self: Clipboard): cstringArray =
  gtk_clipboard_wait_for_uris(cast[ptr Clipboard00](self.impl))

proc gtk_clipboard_wait_is_image_available*(self: ptr Clipboard00): gboolean {.
    importc: "gtk_clipboard_wait_is_image_available", libprag.}

proc waitIsImageAvailable*(self: Clipboard): bool =
  toBool(gtk_clipboard_wait_is_image_available(cast[ptr Clipboard00](self.impl)))

proc gtk_clipboard_wait_is_target_available*(self: ptr Clipboard00; target: ptr gdk.Atom00): gboolean {.
    importc: "gtk_clipboard_wait_is_target_available", libprag.}

proc waitIsTargetAvailable*(self: Clipboard; target: gdk.Atom): bool =
  toBool(gtk_clipboard_wait_is_target_available(cast[ptr Clipboard00](self.impl), cast[ptr gdk.Atom00](target.impl)))

proc gtk_clipboard_wait_is_text_available*(self: ptr Clipboard00): gboolean {.
    importc: "gtk_clipboard_wait_is_text_available", libprag.}

proc waitIsTextAvailable*(self: Clipboard): bool =
  toBool(gtk_clipboard_wait_is_text_available(cast[ptr Clipboard00](self.impl)))

proc gtk_clipboard_wait_is_uris_available*(self: ptr Clipboard00): gboolean {.
    importc: "gtk_clipboard_wait_is_uris_available", libprag.}

proc waitIsUrisAvailable*(self: Clipboard): bool =
  toBool(gtk_clipboard_wait_is_uris_available(cast[ptr Clipboard00](self.impl)))

proc gtk_widget_get_clipboard*(self: ptr Widget00; selection: ptr gdk.Atom00): ptr Clipboard00 {.
    importc: "gtk_widget_get_clipboard", libprag.}

proc getClipboard*(self: Widget; selection: gdk.Atom): Clipboard =
  let gobj = gtk_widget_get_clipboard(cast[ptr Widget00](self.impl), cast[ptr gdk.Atom00](selection.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Clipboard](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc clipboard*(self: Widget; selection: gdk.Atom): Clipboard =
  let gobj = gtk_widget_get_clipboard(cast[ptr Widget00](self.impl), cast[ptr gdk.Atom00](selection.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Clipboard](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  WidgetPath00* {.pure.} = object
  WidgetPath* = ref object
    impl*: ptr WidgetPath00

proc gtk_widget_path_new*(): ptr WidgetPath00 {.
    importc: "gtk_widget_path_new", libprag.}

proc newWidgetPath*(): WidgetPath =
  new(result)
  result.impl = gtk_widget_path_new()

proc initWidgetPath*[T](result: var T) =
  assert(result is WidgetPath)
  new(result)
  result.impl = gtk_widget_path_new()

proc gtk_widget_path_append_for_widget*(self: ptr WidgetPath00; widget: ptr Widget00): int32 {.
    importc: "gtk_widget_path_append_for_widget", libprag.}

proc appendForWidget*(self: WidgetPath; widget: Widget): int =
  int(gtk_widget_path_append_for_widget(cast[ptr WidgetPath00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_widget_path_append_type*(self: ptr WidgetPath00; `type`: GType): int32 {.
    importc: "gtk_widget_path_append_type", libprag.}

proc appendType*(self: WidgetPath; `type`: GType): int =
  int(gtk_widget_path_append_type(cast[ptr WidgetPath00](self.impl), `type`))

proc gtk_widget_path_append_with_siblings*(self: ptr WidgetPath00; siblings: ptr WidgetPath00; 
    siblingIndex: uint32): int32 {.
    importc: "gtk_widget_path_append_with_siblings", libprag.}

proc appendWithSiblings*(self: WidgetPath; siblings: WidgetPath; siblingIndex: int): int =
  int(gtk_widget_path_append_with_siblings(cast[ptr WidgetPath00](self.impl), cast[ptr WidgetPath00](siblings.impl), uint32(siblingIndex)))

proc gtk_widget_path_copy*(self: ptr WidgetPath00): ptr WidgetPath00 {.
    importc: "gtk_widget_path_copy", libprag.}

proc copy*(self: WidgetPath): WidgetPath =
  new(result)
  result.impl = gtk_widget_path_copy(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_path_free*(self: ptr WidgetPath00) {.
    importc: "gtk_widget_path_free", libprag.}

proc free*(self: WidgetPath) =
  gtk_widget_path_free(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_path_get_object_type*(self: ptr WidgetPath00): GType {.
    importc: "gtk_widget_path_get_object_type", libprag.}

proc getObjectType*(self: WidgetPath): GType =
  gtk_widget_path_get_object_type(cast[ptr WidgetPath00](self.impl))

proc objectType*(self: WidgetPath): GType =
  gtk_widget_path_get_object_type(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_path_has_parent*(self: ptr WidgetPath00; `type`: GType): gboolean {.
    importc: "gtk_widget_path_has_parent", libprag.}

proc hasParent*(self: WidgetPath; `type`: GType): bool =
  toBool(gtk_widget_path_has_parent(cast[ptr WidgetPath00](self.impl), `type`))

proc gtk_widget_path_is_type*(self: ptr WidgetPath00; `type`: GType): gboolean {.
    importc: "gtk_widget_path_is_type", libprag.}

proc isType*(self: WidgetPath; `type`: GType): bool =
  toBool(gtk_widget_path_is_type(cast[ptr WidgetPath00](self.impl), `type`))

proc gtk_widget_path_iter_add_class*(self: ptr WidgetPath00; pos: int32; name: cstring) {.
    importc: "gtk_widget_path_iter_add_class", libprag.}

proc iterAddClass*(self: WidgetPath; pos: int; name: string) =
  gtk_widget_path_iter_add_class(cast[ptr WidgetPath00](self.impl), int32(pos), cstring(name))

proc gtk_widget_path_iter_clear_classes*(self: ptr WidgetPath00; pos: int32) {.
    importc: "gtk_widget_path_iter_clear_classes", libprag.}

proc iterClearClasses*(self: WidgetPath; pos: int) =
  gtk_widget_path_iter_clear_classes(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_clear_regions*(self: ptr WidgetPath00; pos: int32) {.
    importc: "gtk_widget_path_iter_clear_regions", libprag.}

proc iterClearRegions*(self: WidgetPath; pos: int) =
  gtk_widget_path_iter_clear_regions(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_get_name*(self: ptr WidgetPath00; pos: int32): cstring {.
    importc: "gtk_widget_path_iter_get_name", libprag.}

proc iterGetName*(self: WidgetPath; pos: int): string =
  let resul0 = gtk_widget_path_iter_get_name(cast[ptr WidgetPath00](self.impl), int32(pos))
  result = $resul0

proc gtk_widget_path_iter_get_object_name*(self: ptr WidgetPath00; pos: int32): cstring {.
    importc: "gtk_widget_path_iter_get_object_name", libprag.}

proc iterGetObjectName*(self: WidgetPath; pos: int): string =
  let resul0 = gtk_widget_path_iter_get_object_name(cast[ptr WidgetPath00](self.impl), int32(pos))
  result = $resul0

proc gtk_widget_path_iter_get_object_type*(self: ptr WidgetPath00; pos: int32): GType {.
    importc: "gtk_widget_path_iter_get_object_type", libprag.}

proc iterGetObjectType*(self: WidgetPath; pos: int): GType =
  gtk_widget_path_iter_get_object_type(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_get_sibling_index*(self: ptr WidgetPath00; pos: int32): uint32 {.
    importc: "gtk_widget_path_iter_get_sibling_index", libprag.}

proc iterGetSiblingIndex*(self: WidgetPath; pos: int): int =
  int(gtk_widget_path_iter_get_sibling_index(cast[ptr WidgetPath00](self.impl), int32(pos)))

proc gtk_widget_path_iter_get_siblings*(self: ptr WidgetPath00; pos: int32): ptr WidgetPath00 {.
    importc: "gtk_widget_path_iter_get_siblings", libprag.}

proc iterGetSiblings*(self: WidgetPath; pos: int): WidgetPath =
  new(result)
  result.impl = gtk_widget_path_iter_get_siblings(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_get_state*(self: ptr WidgetPath00; pos: int32): StateFlags {.
    importc: "gtk_widget_path_iter_get_state", libprag.}

proc iterGetState*(self: WidgetPath; pos: int): StateFlags =
  gtk_widget_path_iter_get_state(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_has_class*(self: ptr WidgetPath00; pos: int32; name: cstring): gboolean {.
    importc: "gtk_widget_path_iter_has_class", libprag.}

proc iterHasClass*(self: WidgetPath; pos: int; name: string): bool =
  toBool(gtk_widget_path_iter_has_class(cast[ptr WidgetPath00](self.impl), int32(pos), cstring(name)))

proc gtk_widget_path_iter_has_name*(self: ptr WidgetPath00; pos: int32; name: cstring): gboolean {.
    importc: "gtk_widget_path_iter_has_name", libprag.}

proc iterHasName*(self: WidgetPath; pos: int; name: string): bool =
  toBool(gtk_widget_path_iter_has_name(cast[ptr WidgetPath00](self.impl), int32(pos), cstring(name)))

proc gtk_widget_path_iter_has_qclass*(self: ptr WidgetPath00; pos: int32; qname: uint32): gboolean {.
    importc: "gtk_widget_path_iter_has_qclass", libprag.}

proc iterHasQclass*(self: WidgetPath; pos: int; qname: int): bool =
  toBool(gtk_widget_path_iter_has_qclass(cast[ptr WidgetPath00](self.impl), int32(pos), uint32(qname)))

proc gtk_widget_path_iter_has_qname*(self: ptr WidgetPath00; pos: int32; qname: uint32): gboolean {.
    importc: "gtk_widget_path_iter_has_qname", libprag.}

proc iterHasQname*(self: WidgetPath; pos: int; qname: int): bool =
  toBool(gtk_widget_path_iter_has_qname(cast[ptr WidgetPath00](self.impl), int32(pos), uint32(qname)))

proc gtk_widget_path_iter_list_classes*(self: ptr WidgetPath00; pos: int32): ptr pointer {.
    importc: "gtk_widget_path_iter_list_classes", libprag.}

proc iterListClasses*(self: WidgetPath; pos: int): ptr pointer =
  gtk_widget_path_iter_list_classes(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_list_regions*(self: ptr WidgetPath00; pos: int32): ptr pointer {.
    importc: "gtk_widget_path_iter_list_regions", libprag.}

proc iterListRegions*(self: WidgetPath; pos: int): ptr pointer =
  gtk_widget_path_iter_list_regions(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_remove_class*(self: ptr WidgetPath00; pos: int32; name: cstring) {.
    importc: "gtk_widget_path_iter_remove_class", libprag.}

proc iterRemoveClass*(self: WidgetPath; pos: int; name: string) =
  gtk_widget_path_iter_remove_class(cast[ptr WidgetPath00](self.impl), int32(pos), cstring(name))

proc gtk_widget_path_iter_remove_region*(self: ptr WidgetPath00; pos: int32; name: cstring) {.
    importc: "gtk_widget_path_iter_remove_region", libprag.}

proc iterRemoveRegion*(self: WidgetPath; pos: int; name: string) =
  gtk_widget_path_iter_remove_region(cast[ptr WidgetPath00](self.impl), int32(pos), cstring(name))

proc gtk_widget_path_iter_set_name*(self: ptr WidgetPath00; pos: int32; name: cstring) {.
    importc: "gtk_widget_path_iter_set_name", libprag.}

proc iterSetName*(self: WidgetPath; pos: int; name: string) =
  gtk_widget_path_iter_set_name(cast[ptr WidgetPath00](self.impl), int32(pos), cstring(name))

proc gtk_widget_path_iter_set_object_name*(self: ptr WidgetPath00; pos: int32; name: cstring) {.
    importc: "gtk_widget_path_iter_set_object_name", libprag.}

proc iterSetObjectName*(self: WidgetPath; pos: int; name: string) =
  gtk_widget_path_iter_set_object_name(cast[ptr WidgetPath00](self.impl), int32(pos), cstring(name))

proc gtk_widget_path_iter_set_object_type*(self: ptr WidgetPath00; pos: int32; `type`: GType) {.
    importc: "gtk_widget_path_iter_set_object_type", libprag.}

proc iterSetObjectType*(self: WidgetPath; pos: int; `type`: GType) =
  gtk_widget_path_iter_set_object_type(cast[ptr WidgetPath00](self.impl), int32(pos), `type`)

proc gtk_widget_path_iter_set_state*(self: ptr WidgetPath00; pos: int32; state: StateFlags) {.
    importc: "gtk_widget_path_iter_set_state", libprag.}

proc iterSetState*(self: WidgetPath; pos: int; state: StateFlags) =
  gtk_widget_path_iter_set_state(cast[ptr WidgetPath00](self.impl), int32(pos), state)

proc gtk_widget_path_length*(self: ptr WidgetPath00): int32 {.
    importc: "gtk_widget_path_length", libprag.}

proc length*(self: WidgetPath): int =
  int(gtk_widget_path_length(cast[ptr WidgetPath00](self.impl)))

proc gtk_widget_path_prepend_type*(self: ptr WidgetPath00; `type`: GType) {.
    importc: "gtk_widget_path_prepend_type", libprag.}

proc prependType*(self: WidgetPath; `type`: GType) =
  gtk_widget_path_prepend_type(cast[ptr WidgetPath00](self.impl), `type`)

proc gtk_widget_path_ref*(self: ptr WidgetPath00): ptr WidgetPath00 {.
    importc: "gtk_widget_path_ref", libprag.}

proc `ref`*(self: WidgetPath): WidgetPath =
  new(result)
  result.impl = gtk_widget_path_ref(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_path_to_string*(self: ptr WidgetPath00): cstring {.
    importc: "gtk_widget_path_to_string", libprag.}

proc toString*(self: WidgetPath): string =
  let resul0 = gtk_widget_path_to_string(cast[ptr WidgetPath00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_widget_path_unref*(self: ptr WidgetPath00) {.
    importc: "gtk_widget_path_unref", libprag.}

proc unref*(self: WidgetPath) =
  gtk_widget_path_unref(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_get_path*(self: ptr Widget00): ptr WidgetPath00 {.
    importc: "gtk_widget_get_path", libprag.}

proc getPath*(self: Widget): WidgetPath =
  new(result)
  result.impl = gtk_widget_get_path(cast[ptr Widget00](self.impl))

proc path*(self: Widget): WidgetPath =
  new(result)
  result.impl = gtk_widget_get_path(cast[ptr Widget00](self.impl))

proc gtk_container_get_path_for_child*(self: ptr Container00; child: ptr Widget00): ptr WidgetPath00 {.
    importc: "gtk_container_get_path_for_child", libprag.}

proc getPathForChild*(self: Container; child: Widget): WidgetPath =
  new(result)
  result.impl = gtk_container_get_path_for_child(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl))

proc pathForChild*(self: Container; child: Widget): WidgetPath =
  new(result)
  result.impl = gtk_container_get_path_for_child(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl))

type
  RegionFlag* {.size: sizeof(cint), pure.} = enum
    even = 1
    odd = 2
    first = 3
    last = 4
    only = 5
    sorted = 6

  RegionFlags* {.size: sizeof(cint).} = set[RegionFlag]

proc gtk_widget_path_iter_add_region*(self: ptr WidgetPath00; pos: int32; name: cstring; 
    flags: RegionFlags) {.
    importc: "gtk_widget_path_iter_add_region", libprag.}

proc iterAddRegion*(self: WidgetPath; pos: int; name: string; flags: RegionFlags) =
  gtk_widget_path_iter_add_region(cast[ptr WidgetPath00](self.impl), int32(pos), cstring(name), flags)

proc gtk_widget_path_iter_has_qregion*(self: ptr WidgetPath00; pos: int32; qname: uint32; 
    flags: var RegionFlags): gboolean {.
    importc: "gtk_widget_path_iter_has_qregion", libprag.}

proc iterHasQregion*(self: WidgetPath; pos: int; qname: int; flags: var RegionFlags): bool =
  toBool(gtk_widget_path_iter_has_qregion(cast[ptr WidgetPath00](self.impl), int32(pos), uint32(qname), flags))

proc gtk_widget_path_iter_has_region*(self: ptr WidgetPath00; pos: int32; name: cstring; 
    flags: var RegionFlags): gboolean {.
    importc: "gtk_widget_path_iter_has_region", libprag.}

proc iterHasRegion*(self: WidgetPath; pos: int; name: string; flags: var RegionFlags): bool =
  toBool(gtk_widget_path_iter_has_region(cast[ptr WidgetPath00](self.impl), int32(pos), cstring(name), flags))

type
  SizeRequestMode* {.size: sizeof(cint), pure.} = enum
    heightForWidth = 0
    widthForHeight = 1
    constantSize = 2

proc gtk_widget_get_request_mode*(self: ptr Widget00): SizeRequestMode {.
    importc: "gtk_widget_get_request_mode", libprag.}

proc getRequestMode*(self: Widget): SizeRequestMode =
  gtk_widget_get_request_mode(cast[ptr Widget00](self.impl))

proc requestMode*(self: Widget): SizeRequestMode =
  gtk_widget_get_request_mode(cast[ptr Widget00](self.impl))

type
  SettingsPrivate00* {.pure.} = object
  SettingsPrivate* = ref object
    impl*: ptr SettingsPrivate00

type
  Settings* = ref object of gobject.Object
  Settings00* = object of gobject.Object00
    priv1: ptr SettingsPrivate00

proc gtk_settings_get_default*(): ptr Settings00 {.
    importc: "gtk_settings_get_default", libprag.}

proc getDefault*(): Settings =
  let gobj = gtk_settings_get_default()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Settings](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc default*(): Settings =
  let gobj = gtk_settings_get_default()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Settings](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_settings_get_for_screen*(screen: ptr gdk.Screen00): ptr Settings00 {.
    importc: "gtk_settings_get_for_screen", libprag.}

proc getForScreen*(screen: gdk.Screen): Settings =
  let gobj = gtk_settings_get_for_screen(cast[ptr gdk.Screen00](screen.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Settings](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc forScreen*(screen: gdk.Screen): Settings =
  let gobj = gtk_settings_get_for_screen(cast[ptr gdk.Screen00](screen.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Settings](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_settings_install_property*(pspec: ptr gobject.ParamSpec00) {.
    importc: "gtk_settings_install_property", libprag.}

proc installProperty*(pspec: gobject.ParamSpec) =
  gtk_settings_install_property(cast[ptr gobject.ParamSpec00](pspec.impl))

proc gtk_settings_reset_property*(self: ptr Settings00; name: cstring) {.
    importc: "gtk_settings_reset_property", libprag.}

proc resetProperty*(self: Settings; name: string) =
  gtk_settings_reset_property(cast[ptr Settings00](self.impl), cstring(name))

proc gtk_settings_set_double_property*(self: ptr Settings00; name: cstring; vDouble: cdouble; 
    origin: cstring) {.
    importc: "gtk_settings_set_double_property", libprag.}

proc setDoubleProperty*(self: Settings; name: string; vDouble: cdouble; origin: string) =
  gtk_settings_set_double_property(cast[ptr Settings00](self.impl), cstring(name), vDouble, cstring(origin))

proc gtk_settings_set_long_property*(self: ptr Settings00; name: cstring; vLong: int64; 
    origin: cstring) {.
    importc: "gtk_settings_set_long_property", libprag.}

proc setLongProperty*(self: Settings; name: string; vLong: int64; origin: string) =
  gtk_settings_set_long_property(cast[ptr Settings00](self.impl), cstring(name), vLong, cstring(origin))

proc gtk_settings_set_string_property*(self: ptr Settings00; name: cstring; vString: cstring; 
    origin: cstring) {.
    importc: "gtk_settings_set_string_property", libprag.}

proc setStringProperty*(self: Settings; name: string; vString: string; origin: string) =
  gtk_settings_set_string_property(cast[ptr Settings00](self.impl), cstring(name), cstring(vString), cstring(origin))

proc gtk_widget_get_settings*(self: ptr Widget00): ptr Settings00 {.
    importc: "gtk_widget_get_settings", libprag.}

proc getSettings*(self: Widget): Settings =
  let gobj = gtk_widget_get_settings(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Settings](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc `tings=`*(self: Widget): Settings =
  let gobj = gtk_widget_get_settings(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Settings](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SettingsValue00* {.pure.} = object
    origin*: cstring
    value*: gobject.Value00
  SettingsValue* = ref object
    impl*: ptr SettingsValue00

proc gtk_settings_set_property_value*(self: ptr Settings00; name: cstring; svalue: ptr SettingsValue00) {.
    importc: "gtk_settings_set_property_value", libprag.}

proc setPropertyValue*(self: Settings; name: string; svalue: SettingsValue) =
  gtk_settings_set_property_value(cast[ptr Settings00](self.impl), cstring(name), cast[ptr SettingsValue00](svalue.impl))

type
  StyleContextPrivate00* {.pure.} = object
  StyleContextPrivate* = ref object
    impl*: ptr StyleContextPrivate00

type
  StyleContext* = ref object of gobject.Object
  StyleContext00* = object of gobject.Object00
    priv1: ptr StyleContextPrivate00

proc scChanged*(self: StyleContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_style_context_new*(): ptr StyleContext00 {.
    importc: "gtk_style_context_new", libprag.}

proc newStyleContext*(): StyleContext =
  new(result, finalizeGObject)
  result.impl = gtk_style_context_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStyleContext*[T](result: var T) =
  assert(result is StyleContext)
  new(result, finalizeGObject)
  result.impl = gtk_style_context_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_context_reset_widgets*(screen: ptr gdk.Screen00) {.
    importc: "gtk_style_context_reset_widgets", libprag.}

proc resetWidgets*(screen: gdk.Screen) =
  gtk_style_context_reset_widgets(cast[ptr gdk.Screen00](screen.impl))

proc gtk_style_context_add_class*(self: ptr StyleContext00; className: cstring) {.
    importc: "gtk_style_context_add_class", libprag.}

proc addClass*(self: StyleContext; className: string) =
  gtk_style_context_add_class(cast[ptr StyleContext00](self.impl), cstring(className))

proc gtk_style_context_add_region*(self: ptr StyleContext00; regionName: cstring; flags: RegionFlags) {.
    importc: "gtk_style_context_add_region", libprag.}

proc addRegion*(self: StyleContext; regionName: string; flags: RegionFlags) =
  gtk_style_context_add_region(cast[ptr StyleContext00](self.impl), cstring(regionName), flags)

proc gtk_style_context_cancel_animations*(self: ptr StyleContext00; regionId: pointer) {.
    importc: "gtk_style_context_cancel_animations", libprag.}

proc cancelAnimations*(self: StyleContext; regionId: pointer) =
  gtk_style_context_cancel_animations(cast[ptr StyleContext00](self.impl), regionId)

proc gtk_style_context_get_background_color*(self: ptr StyleContext00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_style_context_get_background_color", libprag.}

proc getBackgroundColor*(self: ptr StyleContext00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_style_context_get_background_color", libprag.}

proc backgroundColor*(self: ptr StyleContext00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_style_context_get_background_color", libprag.}

proc gtk_style_context_get_border_color*(self: ptr StyleContext00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_style_context_get_border_color", libprag.}

proc getBorderColor*(self: ptr StyleContext00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_style_context_get_border_color", libprag.}

proc borderColor*(self: ptr StyleContext00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_style_context_get_border_color", libprag.}

proc gtk_style_context_get_color*(self: ptr StyleContext00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_style_context_get_color", libprag.}

proc getColor*(self: ptr StyleContext00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_style_context_get_color", libprag.}

proc color*(self: ptr StyleContext00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_style_context_get_color", libprag.}

proc gtk_style_context_get_direction*(self: ptr StyleContext00): TextDirection {.
    importc: "gtk_style_context_get_direction", libprag.}

proc getDirection*(self: StyleContext): TextDirection =
  gtk_style_context_get_direction(cast[ptr StyleContext00](self.impl))

proc direction*(self: StyleContext): TextDirection =
  gtk_style_context_get_direction(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_get_font*(self: ptr StyleContext00; state: StateFlags): ptr pango.FontDescription00 {.
    importc: "gtk_style_context_get_font", libprag.}

proc getFont*(self: StyleContext; state: StateFlags): pango.FontDescription =
  new(result)
  result.impl = gtk_style_context_get_font(cast[ptr StyleContext00](self.impl), state)

proc font*(self: StyleContext; state: StateFlags): pango.FontDescription =
  new(result)
  result.impl = gtk_style_context_get_font(cast[ptr StyleContext00](self.impl), state)

proc gtk_style_context_get_frame_clock*(self: ptr StyleContext00): ptr gdk.FrameClock00 {.
    importc: "gtk_style_context_get_frame_clock", libprag.}

proc getFrameClock*(self: StyleContext): gdk.FrameClock =
  let gobj = gtk_style_context_get_frame_clock(cast[ptr StyleContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.FrameClock](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc frameClock*(self: StyleContext): gdk.FrameClock =
  let gobj = gtk_style_context_get_frame_clock(cast[ptr StyleContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.FrameClock](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_context_get_parent*(self: ptr StyleContext00): ptr StyleContext00 {.
    importc: "gtk_style_context_get_parent", libprag.}

proc getParent*(self: StyleContext): StyleContext =
  let gobj = gtk_style_context_get_parent(cast[ptr StyleContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[StyleContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parent*(self: StyleContext): StyleContext =
  let gobj = gtk_style_context_get_parent(cast[ptr StyleContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[StyleContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_context_get_path*(self: ptr StyleContext00): ptr WidgetPath00 {.
    importc: "gtk_style_context_get_path", libprag.}

proc getPath*(self: StyleContext): WidgetPath =
  new(result)
  result.impl = gtk_style_context_get_path(cast[ptr StyleContext00](self.impl))

proc path*(self: StyleContext): WidgetPath =
  new(result)
  result.impl = gtk_style_context_get_path(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_get_property*(self: ptr StyleContext00; property: cstring; state: StateFlags; 
    value: var gobject.Value00) {.
    importc: "gtk_style_context_get_property", libprag.}

proc getProperty*(self: ptr StyleContext00; property: cstring; state: StateFlags; 
    value: var gobject.Value00) {.
    importc: "gtk_style_context_get_property", libprag.}

proc property*(self: ptr StyleContext00; property: cstring; state: StateFlags; 
    value: var gobject.Value00) {.
    importc: "gtk_style_context_get_property", libprag.}

proc gtk_style_context_get_scale*(self: ptr StyleContext00): int32 {.
    importc: "gtk_style_context_get_scale", libprag.}

proc getScale*(self: StyleContext): int =
  int(gtk_style_context_get_scale(cast[ptr StyleContext00](self.impl)))

proc scale*(self: StyleContext): int =
  int(gtk_style_context_get_scale(cast[ptr StyleContext00](self.impl)))

proc gtk_style_context_get_screen*(self: ptr StyleContext00): ptr gdk.Screen00 {.
    importc: "gtk_style_context_get_screen", libprag.}

proc getScreen*(self: StyleContext): gdk.Screen =
  let gobj = gtk_style_context_get_screen(cast[ptr StyleContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: StyleContext): gdk.Screen =
  let gobj = gtk_style_context_get_screen(cast[ptr StyleContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_context_get_state*(self: ptr StyleContext00): StateFlags {.
    importc: "gtk_style_context_get_state", libprag.}

proc getState*(self: StyleContext): StateFlags =
  gtk_style_context_get_state(cast[ptr StyleContext00](self.impl))

proc state*(self: StyleContext): StateFlags =
  gtk_style_context_get_state(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_get_style_property*(self: ptr StyleContext00; propertyName: cstring; value: ptr gobject.Value00) {.
    importc: "gtk_style_context_get_style_property", libprag.}

proc getStyleProperty*(self: StyleContext; propertyName: string; value: gobject.Value) =
  gtk_style_context_get_style_property(cast[ptr StyleContext00](self.impl), cstring(propertyName), cast[ptr gobject.Value00](value.impl))

proc styleProperty*(self: StyleContext; propertyName: string; value: gobject.Value) =
  gtk_style_context_get_style_property(cast[ptr StyleContext00](self.impl), cstring(propertyName), cast[ptr gobject.Value00](value.impl))

proc gtk_style_context_has_class*(self: ptr StyleContext00; className: cstring): gboolean {.
    importc: "gtk_style_context_has_class", libprag.}

proc hasClass*(self: StyleContext; className: string): bool =
  toBool(gtk_style_context_has_class(cast[ptr StyleContext00](self.impl), cstring(className)))

proc gtk_style_context_has_region*(self: ptr StyleContext00; regionName: cstring; flagsReturn: var RegionFlags): gboolean {.
    importc: "gtk_style_context_has_region", libprag.}

proc hasRegion*(self: StyleContext; regionName: string; flagsReturn: var RegionFlags): bool =
  toBool(gtk_style_context_has_region(cast[ptr StyleContext00](self.impl), cstring(regionName), flagsReturn))

proc gtk_style_context_invalidate*(self: ptr StyleContext00) {.
    importc: "gtk_style_context_invalidate", libprag.}

proc invalidate*(self: StyleContext) =
  gtk_style_context_invalidate(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_list_classes*(self: ptr StyleContext00): ptr pointer {.
    importc: "gtk_style_context_list_classes", libprag.}

proc listClasses*(self: StyleContext): ptr pointer =
  gtk_style_context_list_classes(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_list_regions*(self: ptr StyleContext00): ptr pointer {.
    importc: "gtk_style_context_list_regions", libprag.}

proc listRegions*(self: StyleContext): ptr pointer =
  gtk_style_context_list_regions(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_lookup_color*(self: ptr StyleContext00; colorName: cstring; color: var gdk.RGBA00): gboolean {.
    importc: "gtk_style_context_lookup_color", libprag.}

proc lookupColor*(self: ptr StyleContext00; colorName: cstring; color: var gdk.RGBA00): gboolean {.
    importc: "gtk_style_context_lookup_color", libprag.}

proc gtk_style_context_lookup_icon_set*(self: ptr StyleContext00; stockId: cstring): ptr IconSet00 {.
    importc: "gtk_style_context_lookup_icon_set", libprag.}

proc lookupIconSet*(self: StyleContext; stockId: string): IconSet =
  new(result)
  result.impl = gtk_style_context_lookup_icon_set(cast[ptr StyleContext00](self.impl), cstring(stockId))

proc gtk_style_context_notify_state_change*(self: ptr StyleContext00; window: ptr gdk.Window00; 
    regionId: pointer; state: StateType; stateValue: gboolean) {.
    importc: "gtk_style_context_notify_state_change", libprag.}

proc notifyStateChange*(self: StyleContext; window: gdk.Window; regionId: pointer; 
    state: StateType; stateValue: bool) =
  gtk_style_context_notify_state_change(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Window00](window.impl), regionId, state, gboolean(stateValue))

proc gtk_style_context_pop_animatable_region*(self: ptr StyleContext00) {.
    importc: "gtk_style_context_pop_animatable_region", libprag.}

proc popAnimatableRegion*(self: StyleContext) =
  gtk_style_context_pop_animatable_region(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_push_animatable_region*(self: ptr StyleContext00; regionId: pointer) {.
    importc: "gtk_style_context_push_animatable_region", libprag.}

proc pushAnimatableRegion*(self: StyleContext; regionId: pointer) =
  gtk_style_context_push_animatable_region(cast[ptr StyleContext00](self.impl), regionId)

proc gtk_style_context_remove_class*(self: ptr StyleContext00; className: cstring) {.
    importc: "gtk_style_context_remove_class", libprag.}

proc removeClass*(self: StyleContext; className: string) =
  gtk_style_context_remove_class(cast[ptr StyleContext00](self.impl), cstring(className))

proc gtk_style_context_remove_region*(self: ptr StyleContext00; regionName: cstring) {.
    importc: "gtk_style_context_remove_region", libprag.}

proc removeRegion*(self: StyleContext; regionName: string) =
  gtk_style_context_remove_region(cast[ptr StyleContext00](self.impl), cstring(regionName))

proc gtk_style_context_restore*(self: ptr StyleContext00) {.
    importc: "gtk_style_context_restore", libprag.}

proc restore*(self: StyleContext) =
  gtk_style_context_restore(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_save*(self: ptr StyleContext00) {.
    importc: "gtk_style_context_save", libprag.}

proc save*(self: StyleContext) =
  gtk_style_context_save(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_scroll_animations*(self: ptr StyleContext00; window: ptr gdk.Window00; 
    dx: int32; dy: int32) {.
    importc: "gtk_style_context_scroll_animations", libprag.}

proc scrollAnimations*(self: StyleContext; window: gdk.Window; dx: int; dy: int) =
  gtk_style_context_scroll_animations(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Window00](window.impl), int32(dx), int32(dy))

proc gtk_style_context_set_background*(self: ptr StyleContext00; window: ptr gdk.Window00) {.
    importc: "gtk_style_context_set_background", libprag.}

proc setBackground*(self: StyleContext; window: gdk.Window) =
  gtk_style_context_set_background(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Window00](window.impl))

proc `background=`*(self: StyleContext; window: gdk.Window) =
  gtk_style_context_set_background(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_style_context_set_direction*(self: ptr StyleContext00; direction: TextDirection) {.
    importc: "gtk_style_context_set_direction", libprag.}

proc setDirection*(self: StyleContext; direction: TextDirection) =
  gtk_style_context_set_direction(cast[ptr StyleContext00](self.impl), direction)

proc `direction=`*(self: StyleContext; direction: TextDirection) =
  gtk_style_context_set_direction(cast[ptr StyleContext00](self.impl), direction)

proc gtk_style_context_set_frame_clock*(self: ptr StyleContext00; frameClock: ptr gdk.FrameClock00) {.
    importc: "gtk_style_context_set_frame_clock", libprag.}

proc setFrameClock*(self: StyleContext; frameClock: gdk.FrameClock) =
  gtk_style_context_set_frame_clock(cast[ptr StyleContext00](self.impl), cast[ptr gdk.FrameClock00](frameClock.impl))

proc `frameClock=`*(self: StyleContext; frameClock: gdk.FrameClock) =
  gtk_style_context_set_frame_clock(cast[ptr StyleContext00](self.impl), cast[ptr gdk.FrameClock00](frameClock.impl))

proc gtk_style_context_set_parent*(self: ptr StyleContext00; parent: ptr StyleContext00) {.
    importc: "gtk_style_context_set_parent", libprag.}

proc setParent*(self: StyleContext; parent: StyleContext) =
  gtk_style_context_set_parent(cast[ptr StyleContext00](self.impl), cast[ptr StyleContext00](parent.impl))

proc `parent=`*(self: StyleContext; parent: StyleContext) =
  gtk_style_context_set_parent(cast[ptr StyleContext00](self.impl), cast[ptr StyleContext00](parent.impl))

proc gtk_style_context_set_path*(self: ptr StyleContext00; path: ptr WidgetPath00) {.
    importc: "gtk_style_context_set_path", libprag.}

proc setPath*(self: StyleContext; path: WidgetPath) =
  gtk_style_context_set_path(cast[ptr StyleContext00](self.impl), cast[ptr WidgetPath00](path.impl))

proc `path=`*(self: StyleContext; path: WidgetPath) =
  gtk_style_context_set_path(cast[ptr StyleContext00](self.impl), cast[ptr WidgetPath00](path.impl))

proc gtk_style_context_set_scale*(self: ptr StyleContext00; scale: int32) {.
    importc: "gtk_style_context_set_scale", libprag.}

proc setScale*(self: StyleContext; scale: int) =
  gtk_style_context_set_scale(cast[ptr StyleContext00](self.impl), int32(scale))

proc `scale=`*(self: StyleContext; scale: int) =
  gtk_style_context_set_scale(cast[ptr StyleContext00](self.impl), int32(scale))

proc gtk_style_context_set_screen*(self: ptr StyleContext00; screen: ptr gdk.Screen00) {.
    importc: "gtk_style_context_set_screen", libprag.}

proc setScreen*(self: StyleContext; screen: gdk.Screen) =
  gtk_style_context_set_screen(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: StyleContext; screen: gdk.Screen) =
  gtk_style_context_set_screen(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc gtk_style_context_set_state*(self: ptr StyleContext00; flags: StateFlags) {.
    importc: "gtk_style_context_set_state", libprag.}

proc setState*(self: StyleContext; flags: StateFlags) =
  gtk_style_context_set_state(cast[ptr StyleContext00](self.impl), flags)

proc `state=`*(self: StyleContext; flags: StateFlags) =
  gtk_style_context_set_state(cast[ptr StyleContext00](self.impl), flags)

proc gtk_style_context_state_is_running*(self: ptr StyleContext00; state: StateType; progress: var cdouble): gboolean {.
    importc: "gtk_style_context_state_is_running", libprag.}

proc stateIsRunning*(self: StyleContext; state: StateType; progress: var cdouble): bool =
  toBool(gtk_style_context_state_is_running(cast[ptr StyleContext00](self.impl), state, progress))

proc gtk_widget_get_style_context*(self: ptr Widget00): ptr StyleContext00 {.
    importc: "gtk_widget_get_style_context", libprag.}

proc getStyleContext*(self: Widget): StyleContext =
  let gobj = gtk_widget_get_style_context(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[StyleContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc styleContext*(self: Widget): StyleContext =
  let gobj = gtk_widget_get_style_context(cast[ptr Widget00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[StyleContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_set_render_icon_pixbuf*(self: ptr IconSet00; context: ptr StyleContext00; 
    size: int32): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_set_render_icon_pixbuf", libprag.}

proc renderIconPixbuf*(self: IconSet; context: StyleContext; size: int): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_set_render_icon_pixbuf(cast[ptr IconSet00](self.impl), cast[ptr StyleContext00](context.impl), int32(size))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_set_render_icon_surface*(self: ptr IconSet00; context: ptr StyleContext00; 
    size: int32; scale: int32; forWindow: ptr gdk.Window00): ptr cairo.Surface00 {.
    importc: "gtk_icon_set_render_icon_surface", libprag.}

proc renderIconSurface*(self: IconSet; context: StyleContext; size: int; scale: int; 
    forWindow: gdk.Window): cairo.Surface =
  new(result)
  result.impl = gtk_icon_set_render_icon_surface(cast[ptr IconSet00](self.impl), cast[ptr StyleContext00](context.impl), int32(size), int32(scale), cast[ptr gdk.Window00](forWindow.impl))

type
  Border00* {.pure.} = object
    left*: int16
    right*: int16
    top*: int16
    bottom*: int16
  Border* = ref object
    impl*: ptr Border00

proc gtk_border_new*(): ptr Border00 {.
    importc: "gtk_border_new", libprag.}

proc newBorder*(): Border =
  new(result)
  result.impl = gtk_border_new()

proc initBorder*[T](result: var T) =
  assert(result is Border)
  new(result)
  result.impl = gtk_border_new()

proc gtk_border_copy*(self: ptr Border00): ptr Border00 {.
    importc: "gtk_border_copy", libprag.}

proc copy*(self: Border): Border =
  new(result)
  result.impl = gtk_border_copy(cast[ptr Border00](self.impl))

proc gtk_border_free*(self: ptr Border00) {.
    importc: "gtk_border_free", libprag.}

proc free*(self: Border) =
  gtk_border_free(cast[ptr Border00](self.impl))

proc gtk_style_context_get_border*(self: ptr StyleContext00; state: StateFlags; border: var Border00) {.
    importc: "gtk_style_context_get_border", libprag.}

proc getBorder*(self: ptr StyleContext00; state: StateFlags; border: var Border00) {.
    importc: "gtk_style_context_get_border", libprag.}

proc border*(self: ptr StyleContext00; state: StateFlags; border: var Border00) {.
    importc: "gtk_style_context_get_border", libprag.}

proc gtk_style_context_get_margin*(self: ptr StyleContext00; state: StateFlags; margin: var Border00) {.
    importc: "gtk_style_context_get_margin", libprag.}

proc getMargin*(self: ptr StyleContext00; state: StateFlags; margin: var Border00) {.
    importc: "gtk_style_context_get_margin", libprag.}

proc margin*(self: ptr StyleContext00; state: StateFlags; margin: var Border00) {.
    importc: "gtk_style_context_get_margin", libprag.}

proc gtk_style_context_get_padding*(self: ptr StyleContext00; state: StateFlags; padding: var Border00) {.
    importc: "gtk_style_context_get_padding", libprag.}

proc getPadding*(self: ptr StyleContext00; state: StateFlags; padding: var Border00) {.
    importc: "gtk_style_context_get_padding", libprag.}

proc padding*(self: ptr StyleContext00; state: StateFlags; padding: var Border00) {.
    importc: "gtk_style_context_get_padding", libprag.}

type
  CssSection00* {.pure.} = object
  CssSection* = ref object
    impl*: ptr CssSection00

proc gtk_css_section_get_end_line*(self: ptr CssSection00): uint32 {.
    importc: "gtk_css_section_get_end_line", libprag.}

proc getEndLine*(self: CssSection): int =
  int(gtk_css_section_get_end_line(cast[ptr CssSection00](self.impl)))

proc endLine*(self: CssSection): int =
  int(gtk_css_section_get_end_line(cast[ptr CssSection00](self.impl)))

proc gtk_css_section_get_end_position*(self: ptr CssSection00): uint32 {.
    importc: "gtk_css_section_get_end_position", libprag.}

proc getEndPosition*(self: CssSection): int =
  int(gtk_css_section_get_end_position(cast[ptr CssSection00](self.impl)))

proc endPosition*(self: CssSection): int =
  int(gtk_css_section_get_end_position(cast[ptr CssSection00](self.impl)))

proc gtk_css_section_get_file*(self: ptr CssSection00): ptr gio.File00 {.
    importc: "gtk_css_section_get_file", libprag.}

proc getFile*(self: CssSection): gio.File =
  new(result)
  result.impl = gtk_css_section_get_file(cast[ptr CssSection00](self.impl))

proc file*(self: CssSection): gio.File =
  new(result)
  result.impl = gtk_css_section_get_file(cast[ptr CssSection00](self.impl))

proc gtk_css_section_get_parent*(self: ptr CssSection00): ptr CssSection00 {.
    importc: "gtk_css_section_get_parent", libprag.}

proc getParent*(self: CssSection): CssSection =
  new(result)
  result.impl = gtk_css_section_get_parent(cast[ptr CssSection00](self.impl))

proc parent*(self: CssSection): CssSection =
  new(result)
  result.impl = gtk_css_section_get_parent(cast[ptr CssSection00](self.impl))

proc gtk_css_section_get_start_line*(self: ptr CssSection00): uint32 {.
    importc: "gtk_css_section_get_start_line", libprag.}

proc getStartLine*(self: CssSection): int =
  int(gtk_css_section_get_start_line(cast[ptr CssSection00](self.impl)))

proc startLine*(self: CssSection): int =
  int(gtk_css_section_get_start_line(cast[ptr CssSection00](self.impl)))

proc gtk_css_section_get_start_position*(self: ptr CssSection00): uint32 {.
    importc: "gtk_css_section_get_start_position", libprag.}

proc getStartPosition*(self: CssSection): int =
  int(gtk_css_section_get_start_position(cast[ptr CssSection00](self.impl)))

proc startPosition*(self: CssSection): int =
  int(gtk_css_section_get_start_position(cast[ptr CssSection00](self.impl)))

proc gtk_css_section_ref*(self: ptr CssSection00): ptr CssSection00 {.
    importc: "gtk_css_section_ref", libprag.}

proc `ref`*(self: CssSection): CssSection =
  new(result)
  result.impl = gtk_css_section_ref(cast[ptr CssSection00](self.impl))

proc gtk_css_section_unref*(self: ptr CssSection00) {.
    importc: "gtk_css_section_unref", libprag.}

proc unref*(self: CssSection) =
  gtk_css_section_unref(cast[ptr CssSection00](self.impl))

proc gtk_style_context_get_section*(self: ptr StyleContext00; property: cstring): ptr CssSection00 {.
    importc: "gtk_style_context_get_section", libprag.}

proc getSection*(self: StyleContext; property: string): CssSection =
  new(result)
  result.impl = gtk_style_context_get_section(cast[ptr StyleContext00](self.impl), cstring(property))

proc section*(self: StyleContext; property: string): CssSection =
  new(result)
  result.impl = gtk_style_context_get_section(cast[ptr StyleContext00](self.impl), cstring(property))

type
  CssSectionType* {.size: sizeof(cint), pure.} = enum
    document = 0
    `import` = 1
    colorDefinition = 2
    bindingSet = 3
    ruleset = 4
    selector = 5
    declaration = 6
    value = 7
    keyframes = 8

proc gtk_css_section_get_section_type*(self: ptr CssSection00): CssSectionType {.
    importc: "gtk_css_section_get_section_type", libprag.}

proc getSectionType*(self: CssSection): CssSectionType =
  gtk_css_section_get_section_type(cast[ptr CssSection00](self.impl))

proc sectionType*(self: CssSection): CssSectionType =
  gtk_css_section_get_section_type(cast[ptr CssSection00](self.impl))

type
  StyleProvider00* {.pure.} = object
  StyleProvider* = ref object
    impl*: ptr StyleProvider00

proc gtk_style_provider_get_style_property*(self: ptr StyleProvider00; path: ptr WidgetPath00; 
    state: StateFlags; pspec: ptr gobject.ParamSpec00; value: var gobject.Value00): gboolean {.
    importc: "gtk_style_provider_get_style_property", libprag.}

proc getStyleProperty*(self: ptr StyleProvider00; path: ptr WidgetPath00; 
    state: StateFlags; pspec: ptr gobject.ParamSpec00; value: var gobject.Value00): gboolean {.
    importc: "gtk_style_provider_get_style_property", libprag.}

proc styleProperty*(self: ptr StyleProvider00; path: ptr WidgetPath00; 
    state: StateFlags; pspec: ptr gobject.ParamSpec00; value: var gobject.Value00): gboolean {.
    importc: "gtk_style_provider_get_style_property", libprag.}

proc gtk_style_context_add_provider_for_screen*(screen: ptr gdk.Screen00; provider: ptr StyleProvider00; 
    priority: uint32) {.
    importc: "gtk_style_context_add_provider_for_screen", libprag.}

proc addProviderForScreen*(screen: gdk.Screen; provider: StyleProvider; priority: int) =
  gtk_style_context_add_provider_for_screen(cast[ptr gdk.Screen00](screen.impl), cast[ptr StyleProvider00](provider.impl), uint32(priority))

proc gtk_style_context_remove_provider_for_screen*(screen: ptr gdk.Screen00; provider: ptr StyleProvider00) {.
    importc: "gtk_style_context_remove_provider_for_screen", libprag.}

proc removeProviderForScreen*(screen: gdk.Screen; provider: StyleProvider) =
  gtk_style_context_remove_provider_for_screen(cast[ptr gdk.Screen00](screen.impl), cast[ptr StyleProvider00](provider.impl))

proc gtk_style_context_add_provider*(self: ptr StyleContext00; provider: ptr StyleProvider00; 
    priority: uint32) {.
    importc: "gtk_style_context_add_provider", libprag.}

proc addProvider*(self: StyleContext; provider: StyleProvider; priority: int) =
  gtk_style_context_add_provider(cast[ptr StyleContext00](self.impl), cast[ptr StyleProvider00](provider.impl), uint32(priority))

proc gtk_style_context_remove_provider*(self: ptr StyleContext00; provider: ptr StyleProvider00) {.
    importc: "gtk_style_context_remove_provider", libprag.}

proc removeProvider*(self: StyleContext; provider: StyleProvider) =
  gtk_style_context_remove_provider(cast[ptr StyleContext00](self.impl), cast[ptr StyleProvider00](provider.impl))

type
  IconFactoryPrivate00* {.pure.} = object
  IconFactoryPrivate* = ref object
    impl*: ptr IconFactoryPrivate00

type
  IconFactory* = ref object of gobject.Object
  IconFactory00* = object of gobject.Object00
    priv1: ptr IconFactoryPrivate00

proc gtk_icon_factory_new*(): ptr IconFactory00 {.
    importc: "gtk_icon_factory_new", libprag.}

proc newIconFactory*(): IconFactory =
  new(result, finalizeGObject)
  result.impl = gtk_icon_factory_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconFactory*[T](result: var T) =
  assert(result is IconFactory)
  new(result, finalizeGObject)
  result.impl = gtk_icon_factory_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_factory_lookup_default*(stockId: cstring): ptr IconSet00 {.
    importc: "gtk_icon_factory_lookup_default", libprag.}

proc lookupDefault*(stockId: string): IconSet =
  new(result)
  result.impl = gtk_icon_factory_lookup_default(cstring(stockId))

proc gtk_icon_factory_add*(self: ptr IconFactory00; stockId: cstring; iconSet: ptr IconSet00) {.
    importc: "gtk_icon_factory_add", libprag.}

proc add*(self: IconFactory; stockId: string; iconSet: IconSet) =
  gtk_icon_factory_add(cast[ptr IconFactory00](self.impl), cstring(stockId), cast[ptr IconSet00](iconSet.impl))

proc gtk_icon_factory_add_default*(self: ptr IconFactory00) {.
    importc: "gtk_icon_factory_add_default", libprag.}

proc addDefault*(self: IconFactory) =
  gtk_icon_factory_add_default(cast[ptr IconFactory00](self.impl))

proc gtk_icon_factory_lookup*(self: ptr IconFactory00; stockId: cstring): ptr IconSet00 {.
    importc: "gtk_icon_factory_lookup", libprag.}

proc lookup*(self: IconFactory; stockId: string): IconSet =
  new(result)
  result.impl = gtk_icon_factory_lookup(cast[ptr IconFactory00](self.impl), cstring(stockId))

proc gtk_icon_factory_remove_default*(self: ptr IconFactory00) {.
    importc: "gtk_icon_factory_remove_default", libprag.}

proc removeDefault*(self: IconFactory) =
  gtk_icon_factory_remove_default(cast[ptr IconFactory00](self.impl))

proc gtk_style_provider_get_icon_factory*(self: ptr StyleProvider00; path: ptr WidgetPath00): ptr IconFactory00 {.
    importc: "gtk_style_provider_get_icon_factory", libprag.}

proc getIconFactory*(self: StyleProvider; path: WidgetPath): IconFactory =
  let gobj = gtk_style_provider_get_icon_factory(cast[ptr StyleProvider00](self.impl), cast[ptr WidgetPath00](path.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconFactory](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc iconFactory*(self: StyleProvider; path: WidgetPath): IconFactory =
  let gobj = gtk_style_provider_get_icon_factory(cast[ptr StyleProvider00](self.impl), cast[ptr WidgetPath00](path.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconFactory](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  StylePropertiesPrivate00* {.pure.} = object
  StylePropertiesPrivate* = ref object
    impl*: ptr StylePropertiesPrivate00

type
  StyleProperties* = ref object of gobject.Object
  StyleProperties00* = object of gobject.Object00
    priv1: ptr StylePropertiesPrivate00

proc gtk_style_properties_new*(): ptr StyleProperties00 {.
    importc: "gtk_style_properties_new", libprag.}

proc newStyleProperties*(): StyleProperties =
  new(result, finalizeGObject)
  result.impl = gtk_style_properties_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStyleProperties*[T](result: var T) =
  assert(result is StyleProperties)
  new(result, finalizeGObject)
  result.impl = gtk_style_properties_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_properties_clear*(self: ptr StyleProperties00) {.
    importc: "gtk_style_properties_clear", libprag.}

proc clear*(self: StyleProperties) =
  gtk_style_properties_clear(cast[ptr StyleProperties00](self.impl))

proc gtk_style_properties_get_property*(self: ptr StyleProperties00; property: cstring; state: StateFlags; 
    value: var gobject.Value00): gboolean {.
    importc: "gtk_style_properties_get_property", libprag.}

proc getProperty*(self: ptr StyleProperties00; property: cstring; state: StateFlags; 
    value: var gobject.Value00): gboolean {.
    importc: "gtk_style_properties_get_property", libprag.}

proc property*(self: ptr StyleProperties00; property: cstring; state: StateFlags; 
    value: var gobject.Value00): gboolean {.
    importc: "gtk_style_properties_get_property", libprag.}

proc gtk_style_properties_merge*(self: ptr StyleProperties00; propsToMerge: ptr StyleProperties00; 
    replace: gboolean) {.
    importc: "gtk_style_properties_merge", libprag.}

proc merge*(self: StyleProperties; propsToMerge: StyleProperties; 
    replace: bool) =
  gtk_style_properties_merge(cast[ptr StyleProperties00](self.impl), cast[ptr StyleProperties00](propsToMerge.impl), gboolean(replace))

proc gtk_style_properties_set_property*(self: ptr StyleProperties00; property: cstring; state: StateFlags; 
    value: ptr gobject.Value00) {.
    importc: "gtk_style_properties_set_property", libprag.}

proc setProperty*(self: StyleProperties; property: string; state: StateFlags; 
    value: gobject.Value) =
  gtk_style_properties_set_property(cast[ptr StyleProperties00](self.impl), cstring(property), state, cast[ptr gobject.Value00](value.impl))

proc gtk_style_properties_unset_property*(self: ptr StyleProperties00; property: cstring; state: StateFlags) {.
    importc: "gtk_style_properties_unset_property", libprag.}

proc unsetProperty*(self: StyleProperties; property: string; state: StateFlags) =
  gtk_style_properties_unset_property(cast[ptr StyleProperties00](self.impl), cstring(property), state)

proc gtk_style_provider_get_style*(self: ptr StyleProvider00; path: ptr WidgetPath00): ptr StyleProperties00 {.
    importc: "gtk_style_provider_get_style", libprag.}

proc getStyle*(self: StyleProvider; path: WidgetPath): StyleProperties =
  let gobj = gtk_style_provider_get_style(cast[ptr StyleProvider00](self.impl), cast[ptr WidgetPath00](path.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[StyleProperties](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc style*(self: StyleProvider; path: WidgetPath): StyleProperties =
  let gobj = gtk_style_provider_get_style(cast[ptr StyleProvider00](self.impl), cast[ptr WidgetPath00](path.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[StyleProperties](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SymbolicColor00* {.pure.} = object
  SymbolicColor* = ref object
    impl*: ptr SymbolicColor00

proc gtk_symbolic_color_new_alpha*(color: ptr SymbolicColor00; factor: cdouble): ptr SymbolicColor00 {.
    importc: "gtk_symbolic_color_new_alpha", libprag.}

proc newSymbolicColorAlpha*(color: SymbolicColor; factor: cdouble): SymbolicColor =
  new(result)
  result.impl = gtk_symbolic_color_new_alpha(cast[ptr SymbolicColor00](color.impl), factor)

proc initSymbolicColorAlpha*[T](result: var T; color: SymbolicColor; factor: cdouble) =
  assert(result is SymbolicColor)
  new(result)
  result.impl = gtk_symbolic_color_new_alpha(cast[ptr SymbolicColor00](color.impl), factor)

proc gtk_symbolic_color_new_literal*(color: ptr gdk.RGBA00): ptr SymbolicColor00 {.
    importc: "gtk_symbolic_color_new_literal", libprag.}

proc newSymbolicColorLiteral*(color: gdk.RGBA): SymbolicColor =
  new(result)
  result.impl = gtk_symbolic_color_new_literal(cast[ptr gdk.RGBA00](color.impl))

proc initSymbolicColorLiteral*[T](result: var T; color: gdk.RGBA) =
  assert(result is SymbolicColor)
  new(result)
  result.impl = gtk_symbolic_color_new_literal(cast[ptr gdk.RGBA00](color.impl))

proc gtk_symbolic_color_new_mix*(color1: ptr SymbolicColor00; color2: ptr SymbolicColor00; 
    factor: cdouble): ptr SymbolicColor00 {.
    importc: "gtk_symbolic_color_new_mix", libprag.}

proc newSymbolicColorMix*(color1: SymbolicColor; color2: SymbolicColor; factor: cdouble): SymbolicColor =
  new(result)
  result.impl = gtk_symbolic_color_new_mix(cast[ptr SymbolicColor00](color1.impl), cast[ptr SymbolicColor00](color2.impl), factor)

proc initSymbolicColorMix*[T](result: var T; color1: SymbolicColor; color2: SymbolicColor; factor: cdouble) =
  assert(result is SymbolicColor)
  new(result)
  result.impl = gtk_symbolic_color_new_mix(cast[ptr SymbolicColor00](color1.impl), cast[ptr SymbolicColor00](color2.impl), factor)

proc gtk_symbolic_color_new_name*(name: cstring): ptr SymbolicColor00 {.
    importc: "gtk_symbolic_color_new_name", libprag.}

proc newSymbolicColorName*(name: string): SymbolicColor =
  new(result)
  result.impl = gtk_symbolic_color_new_name(cstring(name))

proc initSymbolicColorName*[T](result: var T; name: string) =
  assert(result is SymbolicColor)
  new(result)
  result.impl = gtk_symbolic_color_new_name(cstring(name))

proc gtk_symbolic_color_new_shade*(color: ptr SymbolicColor00; factor: cdouble): ptr SymbolicColor00 {.
    importc: "gtk_symbolic_color_new_shade", libprag.}

proc newSymbolicColorShade*(color: SymbolicColor; factor: cdouble): SymbolicColor =
  new(result)
  result.impl = gtk_symbolic_color_new_shade(cast[ptr SymbolicColor00](color.impl), factor)

proc initSymbolicColorShade*[T](result: var T; color: SymbolicColor; factor: cdouble) =
  assert(result is SymbolicColor)
  new(result)
  result.impl = gtk_symbolic_color_new_shade(cast[ptr SymbolicColor00](color.impl), factor)

proc gtk_symbolic_color_new_win32*(themeClass: cstring; id: int32): ptr SymbolicColor00 {.
    importc: "gtk_symbolic_color_new_win32", libprag.}

proc newSymbolicColorWin32*(themeClass: string; id: int): SymbolicColor =
  new(result)
  result.impl = gtk_symbolic_color_new_win32(cstring(themeClass), int32(id))

proc initSymbolicColorWin32*[T](result: var T; themeClass: string; id: int) =
  assert(result is SymbolicColor)
  new(result)
  result.impl = gtk_symbolic_color_new_win32(cstring(themeClass), int32(id))

proc gtk_symbolic_color_ref*(self: ptr SymbolicColor00): ptr SymbolicColor00 {.
    importc: "gtk_symbolic_color_ref", libprag.}

proc `ref`*(self: SymbolicColor): SymbolicColor =
  new(result)
  result.impl = gtk_symbolic_color_ref(cast[ptr SymbolicColor00](self.impl))

proc gtk_symbolic_color_resolve*(self: ptr SymbolicColor00; props: ptr StyleProperties00; 
    resolvedColor: var gdk.RGBA00): gboolean {.
    importc: "gtk_symbolic_color_resolve", libprag.}

proc resolve*(self: ptr SymbolicColor00; props: ptr StyleProperties00; 
    resolvedColor: var gdk.RGBA00): gboolean {.
    importc: "gtk_symbolic_color_resolve", libprag.}

proc gtk_symbolic_color_to_string*(self: ptr SymbolicColor00): cstring {.
    importc: "gtk_symbolic_color_to_string", libprag.}

proc toString*(self: SymbolicColor): string =
  let resul0 = gtk_symbolic_color_to_string(cast[ptr SymbolicColor00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_symbolic_color_unref*(self: ptr SymbolicColor00) {.
    importc: "gtk_symbolic_color_unref", libprag.}

proc unref*(self: SymbolicColor) =
  gtk_symbolic_color_unref(cast[ptr SymbolicColor00](self.impl))

proc gtk_style_properties_lookup_color*(self: ptr StyleProperties00; name: cstring): ptr SymbolicColor00 {.
    importc: "gtk_style_properties_lookup_color", libprag.}

proc lookupColor*(self: StyleProperties; name: string): SymbolicColor =
  new(result)
  result.impl = gtk_style_properties_lookup_color(cast[ptr StyleProperties00](self.impl), cstring(name))

proc gtk_style_properties_map_color*(self: ptr StyleProperties00; name: cstring; color: ptr SymbolicColor00) {.
    importc: "gtk_style_properties_map_color", libprag.}

proc mapColor*(self: StyleProperties; name: string; color: SymbolicColor) =
  gtk_style_properties_map_color(cast[ptr StyleProperties00](self.impl), cstring(name), cast[ptr SymbolicColor00](color.impl))

type
  JunctionSides* {.size: sizeof(cint), pure.} = enum
    none = 0
    cornerTopleft = 1
    cornerTopright = 2
    top = 3
    cornerBottomleft = 4
    left = 5
    cornerBottomright = 8
    right = 10
    bottom = 12

proc gtk_style_context_get_junction_sides*(self: ptr StyleContext00): JunctionSides {.
    importc: "gtk_style_context_get_junction_sides", libprag.}

proc getJunctionSides*(self: StyleContext): JunctionSides =
  gtk_style_context_get_junction_sides(cast[ptr StyleContext00](self.impl))

proc junctionSides*(self: StyleContext): JunctionSides =
  gtk_style_context_get_junction_sides(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_set_junction_sides*(self: ptr StyleContext00; sides: JunctionSides) {.
    importc: "gtk_style_context_set_junction_sides", libprag.}

proc setJunctionSides*(self: StyleContext; sides: JunctionSides) =
  gtk_style_context_set_junction_sides(cast[ptr StyleContext00](self.impl), sides)

proc `junctionSides=`*(self: StyleContext; sides: JunctionSides) =
  gtk_style_context_set_junction_sides(cast[ptr StyleContext00](self.impl), sides)

type
  StyleContextPrintFlag* {.size: sizeof(cint), pure.} = enum
    recurse = 1
    showStyle = 2

  StyleContextPrintFlags* {.size: sizeof(cint).} = set[StyleContextPrintFlag]

proc gtk_style_context_to_string*(self: ptr StyleContext00; flags: StyleContextPrintFlags): cstring {.
    importc: "gtk_style_context_to_string", libprag.}

proc toString*(self: StyleContext; flags: StyleContextPrintFlags): string =
  let resul0 = gtk_style_context_to_string(cast[ptr StyleContext00](self.impl), flags)
  result = $resul0
  cogfree(resul0)

type
  AccelGroupPrivate00* {.pure.} = object
  AccelGroupPrivate* = ref object
    impl*: ptr AccelGroupPrivate00

type
  AccelGroup* = ref object of gobject.Object
  AccelGroup00* = object of gobject.Object00
    priv1: ptr AccelGroupPrivate00

proc scAccelActivate*(self: AccelGroup;  p: proc (self: ptr gobject.Object00; acceleratable: gobject.Object00; keyval: uint32; modifier: gdk.ModifierType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "accel-activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scAccelChanged*(self: AccelGroup;  p: proc (self: ptr gobject.Object00; keyval: uint32; modifier: gdk.ModifierType; accelClosure: gobject.Closure00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "accel-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_accel_group_new*(): ptr AccelGroup00 {.
    importc: "gtk_accel_group_new", libprag.}

proc newAccelGroup*(): AccelGroup =
  new(result, finalizeGObject)
  result.impl = gtk_accel_group_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAccelGroup*[T](result: var T) =
  assert(result is AccelGroup)
  new(result, finalizeGObject)
  result.impl = gtk_accel_group_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accel_group_from_accel_closure*(closure: ptr gobject.Closure00): ptr AccelGroup00 {.
    importc: "gtk_accel_group_from_accel_closure", libprag.}

proc fromAccelClosure*(closure: gobject.Closure): AccelGroup =
  let gobj = gtk_accel_group_from_accel_closure(cast[ptr gobject.Closure00](closure.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[AccelGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accel_group_activate*(self: ptr AccelGroup00; accelQuark: uint32; acceleratable: ptr gobject.Object00; 
    accelKey: uint32; accelMods: gdk.ModifierType): gboolean {.
    importc: "gtk_accel_group_activate", libprag.}

proc activate*(self: AccelGroup; accelQuark: int; acceleratable: gobject.Object; 
    accelKey: int; accelMods: gdk.ModifierType): bool =
  toBool(gtk_accel_group_activate(cast[ptr AccelGroup00](self.impl), uint32(accelQuark), cast[ptr gobject.Object00](acceleratable.impl), uint32(accelKey), accelMods))

proc gtk_accel_group_connect_by_path*(self: ptr AccelGroup00; accelPath: cstring; closure: ptr gobject.Closure00) {.
    importc: "gtk_accel_group_connect_by_path", libprag.}

proc connectByPath*(self: AccelGroup; accelPath: string; closure: gobject.Closure) =
  gtk_accel_group_connect_by_path(cast[ptr AccelGroup00](self.impl), cstring(accelPath), cast[ptr gobject.Closure00](closure.impl))

proc gtk_accel_group_disconnect*(self: ptr AccelGroup00; closure: ptr gobject.Closure00): gboolean {.
    importc: "gtk_accel_group_disconnect", libprag.}

proc disconnect*(self: AccelGroup; closure: gobject.Closure): bool =
  toBool(gtk_accel_group_disconnect(cast[ptr AccelGroup00](self.impl), cast[ptr gobject.Closure00](closure.impl)))

proc gtk_accel_group_disconnect_key*(self: ptr AccelGroup00; accelKey: uint32; accelMods: gdk.ModifierType): gboolean {.
    importc: "gtk_accel_group_disconnect_key", libprag.}

proc disconnectKey*(self: AccelGroup; accelKey: int; accelMods: gdk.ModifierType): bool =
  toBool(gtk_accel_group_disconnect_key(cast[ptr AccelGroup00](self.impl), uint32(accelKey), accelMods))

proc gtk_accel_group_get_is_locked*(self: ptr AccelGroup00): gboolean {.
    importc: "gtk_accel_group_get_is_locked", libprag.}

proc getIsLocked*(self: AccelGroup): bool =
  toBool(gtk_accel_group_get_is_locked(cast[ptr AccelGroup00](self.impl)))

proc isLocked*(self: AccelGroup): bool =
  toBool(gtk_accel_group_get_is_locked(cast[ptr AccelGroup00](self.impl)))

proc gtk_accel_group_get_modifier_mask*(self: ptr AccelGroup00): gdk.ModifierType {.
    importc: "gtk_accel_group_get_modifier_mask", libprag.}

proc getModifierMask*(self: AccelGroup): gdk.ModifierType =
  gtk_accel_group_get_modifier_mask(cast[ptr AccelGroup00](self.impl))

proc modifierMask*(self: AccelGroup): gdk.ModifierType =
  gtk_accel_group_get_modifier_mask(cast[ptr AccelGroup00](self.impl))

proc gtk_accel_group_lock*(self: ptr AccelGroup00) {.
    importc: "gtk_accel_group_lock", libprag.}

proc lock*(self: AccelGroup) =
  gtk_accel_group_lock(cast[ptr AccelGroup00](self.impl))

proc gtk_accel_group_unlock*(self: ptr AccelGroup00) {.
    importc: "gtk_accel_group_unlock", libprag.}

proc unlock*(self: AccelGroup) =
  gtk_accel_group_unlock(cast[ptr AccelGroup00](self.impl))

proc gtk_widget_remove_accelerator*(self: ptr Widget00; accelGroup: ptr AccelGroup00; 
    accelKey: uint32; accelMods: gdk.ModifierType): gboolean {.
    importc: "gtk_widget_remove_accelerator", libprag.}

proc removeAccelerator*(self: Widget; accelGroup: AccelGroup; accelKey: int; 
    accelMods: gdk.ModifierType): bool =
  toBool(gtk_widget_remove_accelerator(cast[ptr Widget00](self.impl), cast[ptr AccelGroup00](accelGroup.impl), uint32(accelKey), accelMods))

proc gtk_widget_set_accel_path*(self: ptr Widget00; accelPath: cstring; accelGroup: ptr AccelGroup00) {.
    importc: "gtk_widget_set_accel_path", libprag.}

proc setAccelPath*(self: Widget; accelPath: string; accelGroup: AccelGroup) =
  gtk_widget_set_accel_path(cast[ptr Widget00](self.impl), cstring(accelPath), cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_window_add_accel_group*(self: ptr Window00; accelGroup: ptr AccelGroup00) {.
    importc: "gtk_window_add_accel_group", libprag.}

proc addAccelGroup*(self: Window; accelGroup: AccelGroup) =
  gtk_window_add_accel_group(cast[ptr Window00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_window_remove_accel_group*(self: ptr Window00; accelGroup: ptr AccelGroup00) {.
    importc: "gtk_window_remove_accel_group", libprag.}

proc removeAccelGroup*(self: Window; accelGroup: AccelGroup) =
  gtk_window_remove_accel_group(cast[ptr Window00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

type
  AccelFlags* {.size: sizeof(cint), pure.} = enum
    visible = 1
    locked = 2
    mask = 7

proc gtk_widget_add_accelerator*(self: ptr Widget00; accelSignal: cstring; accelGroup: ptr AccelGroup00; 
    accelKey: uint32; accelMods: gdk.ModifierType; accelFlags: AccelFlags) {.
    importc: "gtk_widget_add_accelerator", libprag.}

proc addAccelerator*(self: Widget; accelSignal: string; accelGroup: AccelGroup; 
    accelKey: int; accelMods: gdk.ModifierType; accelFlags: AccelFlags) =
  gtk_widget_add_accelerator(cast[ptr Widget00](self.impl), cstring(accelSignal), cast[ptr AccelGroup00](accelGroup.impl), uint32(accelKey), accelMods, accelFlags)

proc gtk_accel_group_connect*(self: ptr AccelGroup00; accelKey: uint32; accelMods: gdk.ModifierType; 
    accelFlags: AccelFlags; closure: ptr gobject.Closure00) {.
    importc: "gtk_accel_group_connect", libprag.}

proc connect*(self: AccelGroup; accelKey: int; accelMods: gdk.ModifierType; 
    accelFlags: AccelFlags; closure: gobject.Closure) =
  gtk_accel_group_connect(cast[ptr AccelGroup00](self.impl), uint32(accelKey), accelMods, accelFlags, cast[ptr gobject.Closure00](closure.impl))

type
  AccelKey00* {.pure.} = object
    accelKey*: uint32
    accelMods*: gdk.ModifierType
    accelFlags*: uint32
  AccelKey* = ref object
    impl*: ptr AccelKey00

type
  AccelGroupEntry00* {.pure.} = object
    key*: AccelKey00
    closure*: ptr gobject.Closure00
    accelPathQuark*: uint32
  AccelGroupEntry* = ref object
    impl*: ptr AccelGroupEntry00

proc gtk_accel_group_query*(self: ptr AccelGroup00; accelKey: uint32; accelMods: gdk.ModifierType; 
    nEntries: var uint32): AccelGroupEntry00Array {.
    importc: "gtk_accel_group_query", libprag.}

proc query*(self: AccelGroup; accelKey: int; accelMods: gdk.ModifierType; 
    nEntries: var int): AccelGroupEntry00Array =
  var nEntries_00 = uint32(nEntries)
  result = gtk_accel_group_query(cast[ptr AccelGroup00](self.impl), uint32(accelKey), accelMods, nEntries_00)
  nEntries = int(nEntries_00)

type
  Align* {.size: sizeof(cint), pure.} = enum
    fill = 0
    start = 1
    `end` = 2
    center = 3
    baseline = 4

proc gtk_widget_get_halign*(self: ptr Widget00): Align {.
    importc: "gtk_widget_get_halign", libprag.}

proc getHalign*(self: Widget): Align =
  gtk_widget_get_halign(cast[ptr Widget00](self.impl))

proc halign*(self: Widget): Align =
  gtk_widget_get_halign(cast[ptr Widget00](self.impl))

proc gtk_widget_get_valign*(self: ptr Widget00): Align {.
    importc: "gtk_widget_get_valign", libprag.}

proc getValign*(self: Widget): Align =
  gtk_widget_get_valign(cast[ptr Widget00](self.impl))

proc valign*(self: Widget): Align =
  gtk_widget_get_valign(cast[ptr Widget00](self.impl))

proc gtk_widget_get_valign_with_baseline*(self: ptr Widget00): Align {.
    importc: "gtk_widget_get_valign_with_baseline", libprag.}

proc getValignWithBaseline*(self: Widget): Align =
  gtk_widget_get_valign_with_baseline(cast[ptr Widget00](self.impl))

proc valignWithBaseline*(self: Widget): Align =
  gtk_widget_get_valign_with_baseline(cast[ptr Widget00](self.impl))

proc gtk_widget_set_halign*(self: ptr Widget00; align: Align) {.
    importc: "gtk_widget_set_halign", libprag.}

proc setHalign*(self: Widget; align: Align) =
  gtk_widget_set_halign(cast[ptr Widget00](self.impl), align)

proc `halign=`*(self: Widget; align: Align) =
  gtk_widget_set_halign(cast[ptr Widget00](self.impl), align)

proc gtk_widget_set_valign*(self: ptr Widget00; align: Align) {.
    importc: "gtk_widget_set_valign", libprag.}

proc setValign*(self: Widget; align: Align) =
  gtk_widget_set_valign(cast[ptr Widget00](self.impl), align)

proc `valign=`*(self: Widget; align: Align) =
  gtk_widget_set_valign(cast[ptr Widget00](self.impl), align)

type
  Requisition00* {.pure.} = object
    width*: int32
    height*: int32
  Requisition* = ref object
    impl*: ptr Requisition00

proc gtk_requisition_new*(): ptr Requisition00 {.
    importc: "gtk_requisition_new", libprag.}

proc newRequisition*(): Requisition =
  new(result)
  result.impl = gtk_requisition_new()

proc initRequisition*[T](result: var T) =
  assert(result is Requisition)
  new(result)
  result.impl = gtk_requisition_new()

proc gtk_requisition_copy*(self: ptr Requisition00): ptr Requisition00 {.
    importc: "gtk_requisition_copy", libprag.}

proc copy*(self: Requisition): Requisition =
  new(result)
  result.impl = gtk_requisition_copy(cast[ptr Requisition00](self.impl))

proc gtk_requisition_free*(self: ptr Requisition00) {.
    importc: "gtk_requisition_free", libprag.}

proc free*(self: Requisition) =
  gtk_requisition_free(cast[ptr Requisition00](self.impl))

proc gtk_widget_get_child_requisition*(self: ptr Widget00; requisition: var Requisition00) {.
    importc: "gtk_widget_get_child_requisition", libprag.}

proc getChildRequisition*(self: ptr Widget00; requisition: var Requisition00) {.
    importc: "gtk_widget_get_child_requisition", libprag.}

proc childRequisition*(self: ptr Widget00; requisition: var Requisition00) {.
    importc: "gtk_widget_get_child_requisition", libprag.}

proc gtk_widget_get_preferred_size*(self: ptr Widget00; minimumSize: var Requisition00; 
    naturalSize: var Requisition00) {.
    importc: "gtk_widget_get_preferred_size", libprag.}

proc getPreferredSize*(self: ptr Widget00; minimumSize: var Requisition00; 
    naturalSize: var Requisition00) {.
    importc: "gtk_widget_get_preferred_size", libprag.}

proc preferredSize*(self: ptr Widget00; minimumSize: var Requisition00; 
    naturalSize: var Requisition00) {.
    importc: "gtk_widget_get_preferred_size", libprag.}

proc gtk_widget_get_requisition*(self: ptr Widget00; requisition: var Requisition00) {.
    importc: "gtk_widget_get_requisition", libprag.}

proc getRequisition*(self: ptr Widget00; requisition: var Requisition00) {.
    importc: "gtk_widget_get_requisition", libprag.}

proc requisition*(self: ptr Widget00; requisition: var Requisition00) {.
    importc: "gtk_widget_get_requisition", libprag.}

proc gtk_widget_size_request*(self: ptr Widget00; requisition: var Requisition00) {.
    importc: "gtk_widget_size_request", libprag.}

proc sizeRequest*(self: ptr Widget00; requisition: var Requisition00) {.
    importc: "gtk_widget_size_request", libprag.}

type
  TextBufferPrivate00* {.pure.} = object
  TextBufferPrivate* = ref object
    impl*: ptr TextBufferPrivate00

type
  TextTagPrivate00* {.pure.} = object
  TextTagPrivate* = ref object
    impl*: ptr TextTagPrivate00

type
  TextIter00* {.pure.} = object
    dummy1*: pointer
    dummy2*: pointer
    dummy3*: int32
    dummy4*: int32
    dummy5*: int32
    dummy6*: int32
    dummy7*: int32
    dummy8*: int32
    dummy9*: pointer
    dummy10*: pointer
    dummy11*: int32
    dummy12*: int32
    dummy13*: int32
    dummy14*: pointer
  TextIter* = ref object
    impl*: ptr TextIter00

proc gtk_text_iter_assign*(self: ptr TextIter00; other: ptr TextIter00) {.
    importc: "gtk_text_iter_assign", libprag.}

proc assign*(self: TextIter; other: TextIter) =
  gtk_text_iter_assign(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](other.impl))

proc gtk_text_iter_backward_char*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_char", libprag.}

proc backwardChar*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_char(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_backward_chars*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_backward_chars", libprag.}

proc backwardChars*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_chars(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_backward_cursor_position*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_cursor_position", libprag.}

proc backwardCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_cursor_position(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_backward_cursor_positions*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_backward_cursor_positions", libprag.}

proc backwardCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_cursor_positions(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_backward_line*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_line", libprag.}

proc backwardLine*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_line(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_backward_lines*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_backward_lines", libprag.}

proc backwardLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_lines(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_backward_sentence_start*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_sentence_start", libprag.}

proc backwardSentenceStart*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_sentence_start(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_backward_sentence_starts*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_backward_sentence_starts", libprag.}

proc backwardSentenceStarts*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_sentence_starts(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_backward_visible_cursor_position*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_visible_cursor_position", libprag.}

proc backwardVisibleCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_visible_cursor_position(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_backward_visible_cursor_positions*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_backward_visible_cursor_positions", libprag.}

proc backwardVisibleCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_visible_cursor_positions(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_backward_visible_line*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_visible_line", libprag.}

proc backwardVisibleLine*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_visible_line(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_backward_visible_lines*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_backward_visible_lines", libprag.}

proc backwardVisibleLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_visible_lines(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_backward_visible_word_start*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_visible_word_start", libprag.}

proc backwardVisibleWordStart*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_visible_word_start(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_backward_visible_word_starts*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_backward_visible_word_starts", libprag.}

proc backwardVisibleWordStarts*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_visible_word_starts(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_backward_word_start*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_word_start", libprag.}

proc backwardWordStart*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_word_start(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_backward_word_starts*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_backward_word_starts", libprag.}

proc backwardWordStarts*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_word_starts(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_can_insert*(self: ptr TextIter00; defaultEditability: gboolean): gboolean {.
    importc: "gtk_text_iter_can_insert", libprag.}

proc canInsert*(self: TextIter; defaultEditability: bool): bool =
  toBool(gtk_text_iter_can_insert(cast[ptr TextIter00](self.impl), gboolean(defaultEditability)))

proc gtk_text_iter_compare*(self: ptr TextIter00; rhs: ptr TextIter00): int32 {.
    importc: "gtk_text_iter_compare", libprag.}

proc compare*(self: TextIter; rhs: TextIter): int =
  int(gtk_text_iter_compare(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](rhs.impl)))

proc gtk_text_iter_copy*(self: ptr TextIter00): ptr TextIter00 {.
    importc: "gtk_text_iter_copy", libprag.}

proc copy*(self: TextIter): TextIter =
  new(result)
  result.impl = gtk_text_iter_copy(cast[ptr TextIter00](self.impl))

proc gtk_text_iter_editable*(self: ptr TextIter00; defaultSetting: gboolean): gboolean {.
    importc: "gtk_text_iter_editable", libprag.}

proc editable*(self: TextIter; defaultSetting: bool): bool =
  toBool(gtk_text_iter_editable(cast[ptr TextIter00](self.impl), gboolean(defaultSetting)))

proc gtk_text_iter_ends_line*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_ends_line", libprag.}

proc endsLine*(self: TextIter): bool =
  toBool(gtk_text_iter_ends_line(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_ends_sentence*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_ends_sentence", libprag.}

proc endsSentence*(self: TextIter): bool =
  toBool(gtk_text_iter_ends_sentence(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_ends_word*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_ends_word", libprag.}

proc endsWord*(self: TextIter): bool =
  toBool(gtk_text_iter_ends_word(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_equal*(self: ptr TextIter00; rhs: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_equal", libprag.}

proc equal*(self: TextIter; rhs: TextIter): bool =
  toBool(gtk_text_iter_equal(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](rhs.impl)))

proc gtk_text_iter_forward_char*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_char", libprag.}

proc forwardChar*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_char(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_forward_chars*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_forward_chars", libprag.}

proc forwardChars*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_chars(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_forward_cursor_position*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_cursor_position", libprag.}

proc forwardCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_cursor_position(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_forward_cursor_positions*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_forward_cursor_positions", libprag.}

proc forwardCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_cursor_positions(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_forward_line*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_line", libprag.}

proc forwardLine*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_line(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_forward_lines*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_forward_lines", libprag.}

proc forwardLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_lines(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_forward_sentence_end*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_sentence_end", libprag.}

proc forwardSentenceEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_sentence_end(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_forward_sentence_ends*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_forward_sentence_ends", libprag.}

proc forwardSentenceEnds*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_sentence_ends(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_forward_to_end*(self: ptr TextIter00) {.
    importc: "gtk_text_iter_forward_to_end", libprag.}

proc forwardToEnd*(self: TextIter) =
  gtk_text_iter_forward_to_end(cast[ptr TextIter00](self.impl))

proc gtk_text_iter_forward_to_line_end*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_to_line_end", libprag.}

proc forwardToLineEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_to_line_end(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_forward_visible_cursor_position*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_visible_cursor_position", libprag.}

proc forwardVisibleCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_visible_cursor_position(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_forward_visible_cursor_positions*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_forward_visible_cursor_positions", libprag.}

proc forwardVisibleCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_visible_cursor_positions(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_forward_visible_line*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_visible_line", libprag.}

proc forwardVisibleLine*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_visible_line(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_forward_visible_lines*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_forward_visible_lines", libprag.}

proc forwardVisibleLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_visible_lines(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_forward_visible_word_end*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_visible_word_end", libprag.}

proc forwardVisibleWordEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_visible_word_end(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_forward_visible_word_ends*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_forward_visible_word_ends", libprag.}

proc forwardVisibleWordEnds*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_visible_word_ends(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_forward_word_end*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_word_end", libprag.}

proc forwardWordEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_word_end(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_forward_word_ends*(self: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_iter_forward_word_ends", libprag.}

proc forwardWordEnds*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_word_ends(cast[ptr TextIter00](self.impl), int32(count)))

proc gtk_text_iter_free*(self: ptr TextIter00) {.
    importc: "gtk_text_iter_free", libprag.}

proc free*(self: TextIter) =
  gtk_text_iter_free(cast[ptr TextIter00](self.impl))

proc gtk_text_iter_get_bytes_in_line*(self: ptr TextIter00): int32 {.
    importc: "gtk_text_iter_get_bytes_in_line", libprag.}

proc getBytesInLine*(self: TextIter): int =
  int(gtk_text_iter_get_bytes_in_line(cast[ptr TextIter00](self.impl)))

proc bytesInLine*(self: TextIter): int =
  int(gtk_text_iter_get_bytes_in_line(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_get_char*(self: ptr TextIter00): gunichar {.
    importc: "gtk_text_iter_get_char", libprag.}

proc getChar*(self: TextIter): gunichar =
  gtk_text_iter_get_char(cast[ptr TextIter00](self.impl))

proc char*(self: TextIter): gunichar =
  gtk_text_iter_get_char(cast[ptr TextIter00](self.impl))

proc gtk_text_iter_get_chars_in_line*(self: ptr TextIter00): int32 {.
    importc: "gtk_text_iter_get_chars_in_line", libprag.}

proc getCharsInLine*(self: TextIter): int =
  int(gtk_text_iter_get_chars_in_line(cast[ptr TextIter00](self.impl)))

proc charsInLine*(self: TextIter): int =
  int(gtk_text_iter_get_chars_in_line(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_get_language*(self: ptr TextIter00): ptr pango.Language00 {.
    importc: "gtk_text_iter_get_language", libprag.}

proc getLanguage*(self: TextIter): pango.Language =
  new(result)
  result.impl = gtk_text_iter_get_language(cast[ptr TextIter00](self.impl))

proc language*(self: TextIter): pango.Language =
  new(result)
  result.impl = gtk_text_iter_get_language(cast[ptr TextIter00](self.impl))

proc gtk_text_iter_get_line*(self: ptr TextIter00): int32 {.
    importc: "gtk_text_iter_get_line", libprag.}

proc getLine*(self: TextIter): int =
  int(gtk_text_iter_get_line(cast[ptr TextIter00](self.impl)))

proc line*(self: TextIter): int =
  int(gtk_text_iter_get_line(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_get_line_index*(self: ptr TextIter00): int32 {.
    importc: "gtk_text_iter_get_line_index", libprag.}

proc getLineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_line_index(cast[ptr TextIter00](self.impl)))

proc lineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_line_index(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_get_line_offset*(self: ptr TextIter00): int32 {.
    importc: "gtk_text_iter_get_line_offset", libprag.}

proc getLineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_line_offset(cast[ptr TextIter00](self.impl)))

proc lineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_line_offset(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_get_marks*(self: ptr TextIter00): ptr pointer {.
    importc: "gtk_text_iter_get_marks", libprag.}

proc getMarks*(self: TextIter): ptr pointer =
  gtk_text_iter_get_marks(cast[ptr TextIter00](self.impl))

proc marks*(self: TextIter): ptr pointer =
  gtk_text_iter_get_marks(cast[ptr TextIter00](self.impl))

proc gtk_text_iter_get_offset*(self: ptr TextIter00): int32 {.
    importc: "gtk_text_iter_get_offset", libprag.}

proc getOffset*(self: TextIter): int =
  int(gtk_text_iter_get_offset(cast[ptr TextIter00](self.impl)))

proc offset*(self: TextIter): int =
  int(gtk_text_iter_get_offset(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_get_pixbuf*(self: ptr TextIter00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_text_iter_get_pixbuf", libprag.}

proc getPixbuf*(self: TextIter): gdkpixbuf.Pixbuf =
  let gobj = gtk_text_iter_get_pixbuf(cast[ptr TextIter00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: TextIter): gdkpixbuf.Pixbuf =
  let gobj = gtk_text_iter_get_pixbuf(cast[ptr TextIter00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_iter_get_slice*(self: ptr TextIter00; `end`: ptr TextIter00): cstring {.
    importc: "gtk_text_iter_get_slice", libprag.}

proc getSlice*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_slice(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](`end`.impl))
  result = $resul0
  cogfree(resul0)

proc slice*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_slice(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](`end`.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_get_tags*(self: ptr TextIter00): ptr pointer {.
    importc: "gtk_text_iter_get_tags", libprag.}

proc getTags*(self: TextIter): ptr pointer =
  gtk_text_iter_get_tags(cast[ptr TextIter00](self.impl))

proc tags*(self: TextIter): ptr pointer =
  gtk_text_iter_get_tags(cast[ptr TextIter00](self.impl))

proc gtk_text_iter_get_text*(self: ptr TextIter00; `end`: ptr TextIter00): cstring {.
    importc: "gtk_text_iter_get_text", libprag.}

proc getText*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_text(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](`end`.impl))
  result = $resul0
  cogfree(resul0)

proc text*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_text(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](`end`.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_get_toggled_tags*(self: ptr TextIter00; toggledOn: gboolean): ptr pointer {.
    importc: "gtk_text_iter_get_toggled_tags", libprag.}

proc getToggledTags*(self: TextIter; toggledOn: bool): ptr pointer =
  gtk_text_iter_get_toggled_tags(cast[ptr TextIter00](self.impl), gboolean(toggledOn))

proc toggledTags*(self: TextIter; toggledOn: bool): ptr pointer =
  gtk_text_iter_get_toggled_tags(cast[ptr TextIter00](self.impl), gboolean(toggledOn))

proc gtk_text_iter_get_visible_line_index*(self: ptr TextIter00): int32 {.
    importc: "gtk_text_iter_get_visible_line_index", libprag.}

proc getVisibleLineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_index(cast[ptr TextIter00](self.impl)))

proc visibleLineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_index(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_get_visible_line_offset*(self: ptr TextIter00): int32 {.
    importc: "gtk_text_iter_get_visible_line_offset", libprag.}

proc getVisibleLineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_offset(cast[ptr TextIter00](self.impl)))

proc visibleLineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_offset(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_get_visible_slice*(self: ptr TextIter00; `end`: ptr TextIter00): cstring {.
    importc: "gtk_text_iter_get_visible_slice", libprag.}

proc getVisibleSlice*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_visible_slice(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](`end`.impl))
  result = $resul0
  cogfree(resul0)

proc visibleSlice*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_visible_slice(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](`end`.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_get_visible_text*(self: ptr TextIter00; `end`: ptr TextIter00): cstring {.
    importc: "gtk_text_iter_get_visible_text", libprag.}

proc getVisibleText*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_visible_text(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](`end`.impl))
  result = $resul0
  cogfree(resul0)

proc visibleText*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_visible_text(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](`end`.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_in_range*(self: ptr TextIter00; start: ptr TextIter00; `end`: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_in_range", libprag.}

proc inRange*(self: TextIter; start: TextIter; `end`: TextIter): bool =
  toBool(gtk_text_iter_in_range(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl)))

proc gtk_text_iter_inside_sentence*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_inside_sentence", libprag.}

proc insideSentence*(self: TextIter): bool =
  toBool(gtk_text_iter_inside_sentence(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_inside_word*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_inside_word", libprag.}

proc insideWord*(self: TextIter): bool =
  toBool(gtk_text_iter_inside_word(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_is_cursor_position*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_is_cursor_position", libprag.}

proc isCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_is_cursor_position(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_is_end*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_is_end", libprag.}

proc isEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_is_end(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_is_start*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_is_start", libprag.}

proc isStart*(self: TextIter): bool =
  toBool(gtk_text_iter_is_start(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_order*(self: ptr TextIter00; second: ptr TextIter00) {.
    importc: "gtk_text_iter_order", libprag.}

proc order*(self: TextIter; second: TextIter) =
  gtk_text_iter_order(cast[ptr TextIter00](self.impl), cast[ptr TextIter00](second.impl))

proc gtk_text_iter_set_line*(self: ptr TextIter00; lineNumber: int32) {.
    importc: "gtk_text_iter_set_line", libprag.}

proc setLine*(self: TextIter; lineNumber: int) =
  gtk_text_iter_set_line(cast[ptr TextIter00](self.impl), int32(lineNumber))

proc `line=`*(self: TextIter; lineNumber: int) =
  gtk_text_iter_set_line(cast[ptr TextIter00](self.impl), int32(lineNumber))

proc gtk_text_iter_set_line_index*(self: ptr TextIter00; byteOnLine: int32) {.
    importc: "gtk_text_iter_set_line_index", libprag.}

proc setLineIndex*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_line_index(cast[ptr TextIter00](self.impl), int32(byteOnLine))

proc `lineIndex=`*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_line_index(cast[ptr TextIter00](self.impl), int32(byteOnLine))

proc gtk_text_iter_set_line_offset*(self: ptr TextIter00; charOnLine: int32) {.
    importc: "gtk_text_iter_set_line_offset", libprag.}

proc setLineOffset*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_line_offset(cast[ptr TextIter00](self.impl), int32(charOnLine))

proc `lineOffset=`*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_line_offset(cast[ptr TextIter00](self.impl), int32(charOnLine))

proc gtk_text_iter_set_offset*(self: ptr TextIter00; charOffset: int32) {.
    importc: "gtk_text_iter_set_offset", libprag.}

proc setOffset*(self: TextIter; charOffset: int) =
  gtk_text_iter_set_offset(cast[ptr TextIter00](self.impl), int32(charOffset))

proc `offset=`*(self: TextIter; charOffset: int) =
  gtk_text_iter_set_offset(cast[ptr TextIter00](self.impl), int32(charOffset))

proc gtk_text_iter_set_visible_line_index*(self: ptr TextIter00; byteOnLine: int32) {.
    importc: "gtk_text_iter_set_visible_line_index", libprag.}

proc setVisibleLineIndex*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_visible_line_index(cast[ptr TextIter00](self.impl), int32(byteOnLine))

proc `visibleLineIndex=`*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_visible_line_index(cast[ptr TextIter00](self.impl), int32(byteOnLine))

proc gtk_text_iter_set_visible_line_offset*(self: ptr TextIter00; charOnLine: int32) {.
    importc: "gtk_text_iter_set_visible_line_offset", libprag.}

proc setVisibleLineOffset*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_visible_line_offset(cast[ptr TextIter00](self.impl), int32(charOnLine))

proc `visibleLineOffset=`*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_visible_line_offset(cast[ptr TextIter00](self.impl), int32(charOnLine))

proc gtk_text_iter_starts_line*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_starts_line", libprag.}

proc startsLine*(self: TextIter): bool =
  toBool(gtk_text_iter_starts_line(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_starts_sentence*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_starts_sentence", libprag.}

proc startsSentence*(self: TextIter): bool =
  toBool(gtk_text_iter_starts_sentence(cast[ptr TextIter00](self.impl)))

proc gtk_text_iter_starts_word*(self: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_starts_word", libprag.}

proc startsWord*(self: TextIter): bool =
  toBool(gtk_text_iter_starts_word(cast[ptr TextIter00](self.impl)))

type
  TextTag* = ref object of gobject.Object
  TextTag00* = object of gobject.Object00
    priv1: ptr TextTagPrivate00

proc scEvent*(self: TextTag;  p: proc (self: ptr gobject.Object00; `object`: gobject.Object00; event: gdk.Event00; iter: TextIter00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_text_tag_new*(name: cstring): ptr TextTag00 {.
    importc: "gtk_text_tag_new", libprag.}

proc newTextTag*(name: string): TextTag =
  new(result, finalizeGObject)
  result.impl = gtk_text_tag_new(cstring(name))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextTag*[T](result: var T; name: string) =
  assert(result is TextTag)
  new(result, finalizeGObject)
  result.impl = gtk_text_tag_new(cstring(name))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_tag_changed*(self: ptr TextTag00; sizeChanged: gboolean) {.
    importc: "gtk_text_tag_changed", libprag.}

proc changed*(self: TextTag; sizeChanged: bool) =
  gtk_text_tag_changed(cast[ptr TextTag00](self.impl), gboolean(sizeChanged))

proc gtk_text_tag_event*(self: ptr TextTag00; eventObject: ptr gobject.Object00; 
    event: ptr gdk.Event00; iter: ptr TextIter00): gboolean {.
    importc: "gtk_text_tag_event", libprag.}

proc event*(self: TextTag; eventObject: gobject.Object; event: gdk.Event; 
    iter: TextIter): bool =
  toBool(gtk_text_tag_event(cast[ptr TextTag00](self.impl), cast[ptr gobject.Object00](eventObject.impl), cast[ptr gdk.Event00](event.impl), cast[ptr TextIter00](iter.impl)))

proc gtk_text_tag_get_priority*(self: ptr TextTag00): int32 {.
    importc: "gtk_text_tag_get_priority", libprag.}

proc getPriority*(self: TextTag): int =
  int(gtk_text_tag_get_priority(cast[ptr TextTag00](self.impl)))

proc priority*(self: TextTag): int =
  int(gtk_text_tag_get_priority(cast[ptr TextTag00](self.impl)))

proc gtk_text_tag_set_priority*(self: ptr TextTag00; priority: int32) {.
    importc: "gtk_text_tag_set_priority", libprag.}

proc setPriority*(self: TextTag; priority: int) =
  gtk_text_tag_set_priority(cast[ptr TextTag00](self.impl), int32(priority))

proc `priority=`*(self: TextTag; priority: int) =
  gtk_text_tag_set_priority(cast[ptr TextTag00](self.impl), int32(priority))

proc gtk_text_iter_backward_to_tag_toggle*(self: ptr TextIter00; tag: ptr TextTag00): gboolean {.
    importc: "gtk_text_iter_backward_to_tag_toggle", libprag.}

proc backwardToTagToggle*(self: TextIter; tag: TextTag): bool =
  toBool(gtk_text_iter_backward_to_tag_toggle(cast[ptr TextIter00](self.impl), cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_begins_tag*(self: ptr TextIter00; tag: ptr TextTag00): gboolean {.
    importc: "gtk_text_iter_begins_tag", libprag.}

proc beginsTag*(self: TextIter; tag: TextTag): bool =
  toBool(gtk_text_iter_begins_tag(cast[ptr TextIter00](self.impl), cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_ends_tag*(self: ptr TextIter00; tag: ptr TextTag00): gboolean {.
    importc: "gtk_text_iter_ends_tag", libprag.}

proc endsTag*(self: TextIter; tag: TextTag): bool =
  toBool(gtk_text_iter_ends_tag(cast[ptr TextIter00](self.impl), cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_forward_to_tag_toggle*(self: ptr TextIter00; tag: ptr TextTag00): gboolean {.
    importc: "gtk_text_iter_forward_to_tag_toggle", libprag.}

proc forwardToTagToggle*(self: TextIter; tag: TextTag): bool =
  toBool(gtk_text_iter_forward_to_tag_toggle(cast[ptr TextIter00](self.impl), cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_has_tag*(self: ptr TextIter00; tag: ptr TextTag00): gboolean {.
    importc: "gtk_text_iter_has_tag", libprag.}

proc hasTag*(self: TextIter; tag: TextTag): bool =
  toBool(gtk_text_iter_has_tag(cast[ptr TextIter00](self.impl), cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_starts_tag*(self: ptr TextIter00; tag: ptr TextTag00): gboolean {.
    importc: "gtk_text_iter_starts_tag", libprag.}

proc startsTag*(self: TextIter; tag: TextTag): bool =
  toBool(gtk_text_iter_starts_tag(cast[ptr TextIter00](self.impl), cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_toggles_tag*(self: ptr TextIter00; tag: ptr TextTag00): gboolean {.
    importc: "gtk_text_iter_toggles_tag", libprag.}

proc togglesTag*(self: TextIter; tag: TextTag): bool =
  toBool(gtk_text_iter_toggles_tag(cast[ptr TextIter00](self.impl), cast[ptr TextTag00](tag.impl)))

type
  TextSearchFlag* {.size: sizeof(cint), pure.} = enum
    visibleOnly = 1
    textOnly = 2
    caseInsensitive = 3

  TextSearchFlags* {.size: sizeof(cint).} = set[TextSearchFlag]

proc gtk_text_iter_backward_search*(self: ptr TextIter00; str: cstring; flags: TextSearchFlags; 
    matchStart: var TextIter00; matchEnd: var TextIter00; limit: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_search", libprag.}

proc backwardSearch*(self: ptr TextIter00; str: cstring; flags: TextSearchFlags; 
    matchStart: var TextIter00; matchEnd: var TextIter00; limit: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_search", libprag.}

proc gtk_text_iter_forward_search*(self: ptr TextIter00; str: cstring; flags: TextSearchFlags; 
    matchStart: var TextIter00; matchEnd: var TextIter00; limit: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_search", libprag.}

proc forwardSearch*(self: ptr TextIter00; str: cstring; flags: TextSearchFlags; 
    matchStart: var TextIter00; matchEnd: var TextIter00; limit: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_search", libprag.}

type
  TextAppearance00* {.pure.} = object
    bgColor*: gdk.Color00
    fgColor*: gdk.Color00
    rise*: int32
    underline*: uint32
    strikethrough*: uint32
    drawBg*: uint32
    insideSelection*: uint32
    isText*: uint32
  TextAppearance* = ref object
    impl*: ptr TextAppearance00

type
  Justification* {.size: sizeof(cint), pure.} = enum
    left = 0
    right = 1
    center = 2
    fill = 3

type
  WrapMode* {.size: sizeof(cint), pure.} = enum
    none = 0
    char = 1
    word = 2
    wordChar = 3

type
  TextAttributes00* {.pure.} = object
    refcount*: uint32
    appearance*: TextAppearance00
    justification*: Justification
    direction*: TextDirection
    font*: ptr pango.FontDescription00
    fontScale*: cdouble
    leftMargin*: int32
    rightMargin*: int32
    indent*: int32
    pixelsAboveLines*: int32
    pixelsBelowLines*: int32
    pixelsInsideWrap*: int32
    tabs*: ptr pango.TabArray00
    wrapMode*: WrapMode
    language*: ptr pango.Language00
    pgBgColor*: ptr gdk.Color00
    invisible*: uint32
    bgFullHeight*: uint32
    editable*: uint32
    noFallback*: uint32
    pgBgRgba*: ptr gdk.RGBA00
    letterSpacing*: int32
  TextAttributes* = ref object
    impl*: ptr TextAttributes00

proc gtk_text_attributes_new*(): ptr TextAttributes00 {.
    importc: "gtk_text_attributes_new", libprag.}

proc newTextAttributes*(): TextAttributes =
  new(result)
  result.impl = gtk_text_attributes_new()

proc initTextAttributes*[T](result: var T) =
  assert(result is TextAttributes)
  new(result)
  result.impl = gtk_text_attributes_new()

proc gtk_text_attributes_copy*(self: ptr TextAttributes00): ptr TextAttributes00 {.
    importc: "gtk_text_attributes_copy", libprag.}

proc copy*(self: TextAttributes): TextAttributes =
  new(result)
  result.impl = gtk_text_attributes_copy(cast[ptr TextAttributes00](self.impl))

proc gtk_text_attributes_copy_values*(self: ptr TextAttributes00; dest: ptr TextAttributes00) {.
    importc: "gtk_text_attributes_copy_values", libprag.}

proc copyValues*(self: TextAttributes; dest: TextAttributes) =
  gtk_text_attributes_copy_values(cast[ptr TextAttributes00](self.impl), cast[ptr TextAttributes00](dest.impl))

proc gtk_text_attributes_ref*(self: ptr TextAttributes00): ptr TextAttributes00 {.
    importc: "gtk_text_attributes_ref", libprag.}

proc `ref`*(self: TextAttributes): TextAttributes =
  new(result)
  result.impl = gtk_text_attributes_ref(cast[ptr TextAttributes00](self.impl))

proc gtk_text_attributes_unref*(self: ptr TextAttributes00) {.
    importc: "gtk_text_attributes_unref", libprag.}

proc unref*(self: TextAttributes) =
  gtk_text_attributes_unref(cast[ptr TextAttributes00](self.impl))

proc gtk_text_iter_get_attributes*(self: ptr TextIter00; values: var TextAttributes00): gboolean {.
    importc: "gtk_text_iter_get_attributes", libprag.}

proc getAttributes*(self: ptr TextIter00; values: var TextAttributes00): gboolean {.
    importc: "gtk_text_iter_get_attributes", libprag.}

proc attributes*(self: ptr TextIter00; values: var TextAttributes00): gboolean {.
    importc: "gtk_text_iter_get_attributes", libprag.}

type
  TextChildAnchor* = ref object of gobject.Object
  TextChildAnchor00* = object of gobject.Object00
    segment*: pointer

proc gtk_text_child_anchor_new*(): ptr TextChildAnchor00 {.
    importc: "gtk_text_child_anchor_new", libprag.}

proc newTextChildAnchor*(): TextChildAnchor =
  new(result, finalizeGObject)
  result.impl = gtk_text_child_anchor_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextChildAnchor*[T](result: var T) =
  assert(result is TextChildAnchor)
  new(result, finalizeGObject)
  result.impl = gtk_text_child_anchor_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_child_anchor_get_deleted*(self: ptr TextChildAnchor00): gboolean {.
    importc: "gtk_text_child_anchor_get_deleted", libprag.}

proc getDeleted*(self: TextChildAnchor): bool =
  toBool(gtk_text_child_anchor_get_deleted(cast[ptr TextChildAnchor00](self.impl)))

proc deleted*(self: TextChildAnchor): bool =
  toBool(gtk_text_child_anchor_get_deleted(cast[ptr TextChildAnchor00](self.impl)))

proc gtk_text_child_anchor_get_widgets*(self: ptr TextChildAnchor00): ptr pointer {.
    importc: "gtk_text_child_anchor_get_widgets", libprag.}

proc getWidgets*(self: TextChildAnchor): ptr pointer =
  gtk_text_child_anchor_get_widgets(cast[ptr TextChildAnchor00](self.impl))

proc widgets*(self: TextChildAnchor): ptr pointer =
  gtk_text_child_anchor_get_widgets(cast[ptr TextChildAnchor00](self.impl))

proc gtk_text_iter_get_child_anchor*(self: ptr TextIter00): ptr TextChildAnchor00 {.
    importc: "gtk_text_iter_get_child_anchor", libprag.}

proc getChildAnchor*(self: TextIter): TextChildAnchor =
  let gobj = gtk_text_iter_get_child_anchor(cast[ptr TextIter00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextChildAnchor](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc childAnchor*(self: TextIter): TextChildAnchor =
  let gobj = gtk_text_iter_get_child_anchor(cast[ptr TextIter00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextChildAnchor](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TextMark* = ref object of gobject.Object
  TextMark00* = object of gobject.Object00
    segment*: pointer

proc gtk_text_mark_new*(name: cstring; leftGravity: gboolean): ptr TextMark00 {.
    importc: "gtk_text_mark_new", libprag.}

proc newTextMark*(name: string; leftGravity: bool): TextMark =
  new(result, finalizeGObject)
  result.impl = gtk_text_mark_new(cstring(name), gboolean(leftGravity))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextMark*[T](result: var T; name: string; leftGravity: bool) =
  assert(result is TextMark)
  new(result, finalizeGObject)
  result.impl = gtk_text_mark_new(cstring(name), gboolean(leftGravity))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_mark_get_deleted*(self: ptr TextMark00): gboolean {.
    importc: "gtk_text_mark_get_deleted", libprag.}

proc getDeleted*(self: TextMark): bool =
  toBool(gtk_text_mark_get_deleted(cast[ptr TextMark00](self.impl)))

proc deleted*(self: TextMark): bool =
  toBool(gtk_text_mark_get_deleted(cast[ptr TextMark00](self.impl)))

proc gtk_text_mark_get_left_gravity*(self: ptr TextMark00): gboolean {.
    importc: "gtk_text_mark_get_left_gravity", libprag.}

proc getLeftGravity*(self: TextMark): bool =
  toBool(gtk_text_mark_get_left_gravity(cast[ptr TextMark00](self.impl)))

proc leftGravity*(self: TextMark): bool =
  toBool(gtk_text_mark_get_left_gravity(cast[ptr TextMark00](self.impl)))

proc gtk_text_mark_get_name*(self: ptr TextMark00): cstring {.
    importc: "gtk_text_mark_get_name", libprag.}

proc getName*(self: TextMark): string =
  let resul0 = gtk_text_mark_get_name(cast[ptr TextMark00](self.impl))
  result = $resul0

proc name*(self: TextMark): string =
  let resul0 = gtk_text_mark_get_name(cast[ptr TextMark00](self.impl))
  result = $resul0

proc gtk_text_mark_get_visible*(self: ptr TextMark00): gboolean {.
    importc: "gtk_text_mark_get_visible", libprag.}

proc getVisible*(self: TextMark): bool =
  toBool(gtk_text_mark_get_visible(cast[ptr TextMark00](self.impl)))

proc visible*(self: TextMark): bool =
  toBool(gtk_text_mark_get_visible(cast[ptr TextMark00](self.impl)))

proc gtk_text_mark_set_visible*(self: ptr TextMark00; setting: gboolean) {.
    importc: "gtk_text_mark_set_visible", libprag.}

proc setVisible*(self: TextMark; setting: bool) =
  gtk_text_mark_set_visible(cast[ptr TextMark00](self.impl), gboolean(setting))

proc `visible=`*(self: TextMark; setting: bool) =
  gtk_text_mark_set_visible(cast[ptr TextMark00](self.impl), gboolean(setting))

type
  TextBuffer* = ref object of gobject.Object
  TextBuffer00* = object of gobject.Object00
    priv1: ptr TextBufferPrivate00

proc scApplyTag*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; tag: TextTag00; start: TextIter00; `end`: TextIter00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "apply-tag", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scBeginUserAction*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "begin-user-action", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scChanged*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDeleteRange*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; start: TextIter00; `end`: TextIter00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "delete-range", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEndUserAction*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "end-user-action", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scInsertChildAnchor*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; location: TextIter00; anchor: TextChildAnchor00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "insert-child-anchor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scInsertPixbuf*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; location: TextIter00; pixbuf: gdkpixbuf.Pixbuf00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "insert-pixbuf", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scInsertText*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; location: TextIter00; text: cstring; len: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "insert-text", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMarkDeleted*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; mark: TextMark00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "mark-deleted", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMarkSet*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; location: TextIter00; mark: TextMark00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "mark-set", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scModifiedChanged*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "modified-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPasteDone*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; clipboard: Clipboard00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "paste-done", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRemoveTag*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; tag: TextTag00; start: TextIter00; `end`: TextIter00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "remove-tag", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_text_buffer_add_mark*(self: ptr TextBuffer00; mark: ptr TextMark00; where: ptr TextIter00) {.
    importc: "gtk_text_buffer_add_mark", libprag.}

proc addMark*(self: TextBuffer; mark: TextMark; where: TextIter) =
  gtk_text_buffer_add_mark(cast[ptr TextBuffer00](self.impl), cast[ptr TextMark00](mark.impl), cast[ptr TextIter00](where.impl))

proc gtk_text_buffer_add_selection_clipboard*(self: ptr TextBuffer00; clipboard: ptr Clipboard00) {.
    importc: "gtk_text_buffer_add_selection_clipboard", libprag.}

proc addSelectionClipboard*(self: TextBuffer; clipboard: Clipboard) =
  gtk_text_buffer_add_selection_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl))

proc gtk_text_buffer_apply_tag*(self: ptr TextBuffer00; tag: ptr TextTag00; start: ptr TextIter00; 
    `end`: ptr TextIter00) {.
    importc: "gtk_text_buffer_apply_tag", libprag.}

proc applyTag*(self: TextBuffer; tag: TextTag; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_apply_tag(cast[ptr TextBuffer00](self.impl), cast[ptr TextTag00](tag.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl))

proc gtk_text_buffer_apply_tag_by_name*(self: ptr TextBuffer00; name: cstring; start: ptr TextIter00; 
    `end`: ptr TextIter00) {.
    importc: "gtk_text_buffer_apply_tag_by_name", libprag.}

proc applyTagByName*(self: TextBuffer; name: string; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_apply_tag_by_name(cast[ptr TextBuffer00](self.impl), cstring(name), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl))

proc gtk_text_buffer_backspace*(self: ptr TextBuffer00; iter: ptr TextIter00; interactive: gboolean; 
    defaultEditable: gboolean): gboolean {.
    importc: "gtk_text_buffer_backspace", libprag.}

proc backspace*(self: TextBuffer; iter: TextIter; interactive: bool; 
    defaultEditable: bool): bool =
  toBool(gtk_text_buffer_backspace(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](iter.impl), gboolean(interactive), gboolean(defaultEditable)))

proc gtk_text_buffer_begin_user_action*(self: ptr TextBuffer00) {.
    importc: "gtk_text_buffer_begin_user_action", libprag.}

proc beginUserAction*(self: TextBuffer) =
  gtk_text_buffer_begin_user_action(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_copy_clipboard*(self: ptr TextBuffer00; clipboard: ptr Clipboard00) {.
    importc: "gtk_text_buffer_copy_clipboard", libprag.}

proc copyClipboard*(self: TextBuffer; clipboard: Clipboard) =
  gtk_text_buffer_copy_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl))

proc gtk_text_buffer_create_child_anchor*(self: ptr TextBuffer00; iter: ptr TextIter00): ptr TextChildAnchor00 {.
    importc: "gtk_text_buffer_create_child_anchor", libprag.}

proc createChildAnchor*(self: TextBuffer; iter: TextIter): TextChildAnchor =
  let gobj = gtk_text_buffer_create_child_anchor(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](iter.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextChildAnchor](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_create_mark*(self: ptr TextBuffer00; markName: cstring; where: ptr TextIter00; 
    leftGravity: gboolean): ptr TextMark00 {.
    importc: "gtk_text_buffer_create_mark", libprag.}

proc createMark*(self: TextBuffer; markName: string; where: TextIter; 
    leftGravity: bool): TextMark =
  let gobj = gtk_text_buffer_create_mark(cast[ptr TextBuffer00](self.impl), cstring(markName), cast[ptr TextIter00](where.impl), gboolean(leftGravity))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextMark](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_cut_clipboard*(self: ptr TextBuffer00; clipboard: ptr Clipboard00; 
    defaultEditable: gboolean) {.
    importc: "gtk_text_buffer_cut_clipboard", libprag.}

proc cutClipboard*(self: TextBuffer; clipboard: Clipboard; defaultEditable: bool) =
  gtk_text_buffer_cut_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl), gboolean(defaultEditable))

proc gtk_text_buffer_delete*(self: ptr TextBuffer00; start: ptr TextIter00; `end`: ptr TextIter00) {.
    importc: "gtk_text_buffer_delete", libprag.}

proc delete*(self: TextBuffer; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_delete(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl))

proc gtk_text_buffer_delete_interactive*(self: ptr TextBuffer00; startIter: ptr TextIter00; 
    endIter: ptr TextIter00; defaultEditable: gboolean): gboolean {.
    importc: "gtk_text_buffer_delete_interactive", libprag.}

proc deleteInteractive*(self: TextBuffer; startIter: TextIter; endIter: TextIter; 
    defaultEditable: bool): bool =
  toBool(gtk_text_buffer_delete_interactive(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](startIter.impl), cast[ptr TextIter00](endIter.impl), gboolean(defaultEditable)))

proc gtk_text_buffer_delete_mark*(self: ptr TextBuffer00; mark: ptr TextMark00) {.
    importc: "gtk_text_buffer_delete_mark", libprag.}

proc deleteMark*(self: TextBuffer; mark: TextMark) =
  gtk_text_buffer_delete_mark(cast[ptr TextBuffer00](self.impl), cast[ptr TextMark00](mark.impl))

proc gtk_text_buffer_delete_mark_by_name*(self: ptr TextBuffer00; name: cstring) {.
    importc: "gtk_text_buffer_delete_mark_by_name", libprag.}

proc deleteMarkByName*(self: TextBuffer; name: string) =
  gtk_text_buffer_delete_mark_by_name(cast[ptr TextBuffer00](self.impl), cstring(name))

proc gtk_text_buffer_delete_selection*(self: ptr TextBuffer00; interactive: gboolean; defaultEditable: gboolean): gboolean {.
    importc: "gtk_text_buffer_delete_selection", libprag.}

proc deleteSelection*(self: TextBuffer; interactive: bool; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_delete_selection(cast[ptr TextBuffer00](self.impl), gboolean(interactive), gboolean(defaultEditable)))

proc gtk_text_buffer_deserialize*(self: ptr TextBuffer00; contentBuffer: ptr TextBuffer00; 
    format: ptr gdk.Atom00; iter: ptr TextIter00; data: uint8Array; length: uint64): gboolean {.
    importc: "gtk_text_buffer_deserialize", libprag.}

proc deserialize*(self: TextBuffer; contentBuffer: TextBuffer; format: gdk.Atom; 
    iter: TextIter; data: uint8Array; length: uint64): bool =
  toBool(gtk_text_buffer_deserialize(cast[ptr TextBuffer00](self.impl), cast[ptr TextBuffer00](contentBuffer.impl), cast[ptr gdk.Atom00](format.impl), cast[ptr TextIter00](iter.impl), data, length))

proc gtk_text_buffer_deserialize_get_can_create_tags*(self: ptr TextBuffer00; format: ptr gdk.Atom00): gboolean {.
    importc: "gtk_text_buffer_deserialize_get_can_create_tags", libprag.}

proc deserializeGetCanCreateTags*(self: TextBuffer; format: gdk.Atom): bool =
  toBool(gtk_text_buffer_deserialize_get_can_create_tags(cast[ptr TextBuffer00](self.impl), cast[ptr gdk.Atom00](format.impl)))

proc gtk_text_buffer_deserialize_set_can_create_tags*(self: ptr TextBuffer00; format: ptr gdk.Atom00; canCreateTags: gboolean) {.
    importc: "gtk_text_buffer_deserialize_set_can_create_tags", libprag.}

proc deserializeSetCanCreateTags*(self: TextBuffer; format: gdk.Atom; canCreateTags: bool) =
  gtk_text_buffer_deserialize_set_can_create_tags(cast[ptr TextBuffer00](self.impl), cast[ptr gdk.Atom00](format.impl), gboolean(canCreateTags))

proc gtk_text_buffer_end_user_action*(self: ptr TextBuffer00) {.
    importc: "gtk_text_buffer_end_user_action", libprag.}

proc endUserAction*(self: TextBuffer) =
  gtk_text_buffer_end_user_action(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_get_bounds*(self: ptr TextBuffer00; start: var TextIter00; `end`: var TextIter00) {.
    importc: "gtk_text_buffer_get_bounds", libprag.}

proc getBounds*(self: ptr TextBuffer00; start: var TextIter00; `end`: var TextIter00) {.
    importc: "gtk_text_buffer_get_bounds", libprag.}

proc bounds*(self: ptr TextBuffer00; start: var TextIter00; `end`: var TextIter00) {.
    importc: "gtk_text_buffer_get_bounds", libprag.}

proc gtk_text_buffer_get_char_count*(self: ptr TextBuffer00): int32 {.
    importc: "gtk_text_buffer_get_char_count", libprag.}

proc getCharCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_char_count(cast[ptr TextBuffer00](self.impl)))

proc charCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_char_count(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_copy_target_list*(self: ptr TextBuffer00): ptr TargetList00 {.
    importc: "gtk_text_buffer_get_copy_target_list", libprag.}

proc getCopyTargetList*(self: TextBuffer): TargetList =
  new(result)
  result.impl = gtk_text_buffer_get_copy_target_list(cast[ptr TextBuffer00](self.impl))

proc copyTargetList*(self: TextBuffer): TargetList =
  new(result)
  result.impl = gtk_text_buffer_get_copy_target_list(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_get_deserialize_formats*(self: ptr TextBuffer00; nFormats: var int32): ptr gdk.Atom00Array {.
    importc: "gtk_text_buffer_get_deserialize_formats", libprag.}

proc getDeserializeFormats*(self: TextBuffer; nFormats: var int): ptr gdk.Atom00Array =
  var nFormats_00 = int32(nFormats)
  result = gtk_text_buffer_get_deserialize_formats(cast[ptr TextBuffer00](self.impl), nFormats_00)
  nFormats = int(nFormats_00)

proc deserializeFormats*(self: TextBuffer; nFormats: var int): ptr gdk.Atom00Array =
  var nFormats_00 = int32(nFormats)
  result = gtk_text_buffer_get_deserialize_formats(cast[ptr TextBuffer00](self.impl), nFormats_00)
  nFormats = int(nFormats_00)

proc gtk_text_buffer_get_end_iter*(self: ptr TextBuffer00; iter: var TextIter00) {.
    importc: "gtk_text_buffer_get_end_iter", libprag.}

proc getEndIter*(self: ptr TextBuffer00; iter: var TextIter00) {.
    importc: "gtk_text_buffer_get_end_iter", libprag.}

proc endIter*(self: ptr TextBuffer00; iter: var TextIter00) {.
    importc: "gtk_text_buffer_get_end_iter", libprag.}

proc gtk_text_buffer_get_has_selection*(self: ptr TextBuffer00): gboolean {.
    importc: "gtk_text_buffer_get_has_selection", libprag.}

proc getHasSelection*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_has_selection(cast[ptr TextBuffer00](self.impl)))

proc hasSelection*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_has_selection(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_insert*(self: ptr TextBuffer00): ptr TextMark00 {.
    importc: "gtk_text_buffer_get_insert", libprag.}

proc getInsert*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_insert(cast[ptr TextBuffer00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextMark](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc insert*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_insert(cast[ptr TextBuffer00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextMark](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_iter_at_child_anchor*(self: ptr TextBuffer00; iter: var TextIter00; anchor: ptr TextChildAnchor00) {.
    importc: "gtk_text_buffer_get_iter_at_child_anchor", libprag.}

proc getIterAtChildAnchor*(self: ptr TextBuffer00; iter: var TextIter00; anchor: ptr TextChildAnchor00) {.
    importc: "gtk_text_buffer_get_iter_at_child_anchor", libprag.}

proc iterAtChildAnchor*(self: ptr TextBuffer00; iter: var TextIter00; anchor: ptr TextChildAnchor00) {.
    importc: "gtk_text_buffer_get_iter_at_child_anchor", libprag.}

proc gtk_text_buffer_get_iter_at_line*(self: ptr TextBuffer00; iter: var TextIter00; lineNumber: int32) {.
    importc: "gtk_text_buffer_get_iter_at_line", libprag.}

proc getIterAtLine*(self: ptr TextBuffer00; iter: var TextIter00; lineNumber: int32) {.
    importc: "gtk_text_buffer_get_iter_at_line", libprag.}

proc iterAtLine*(self: ptr TextBuffer00; iter: var TextIter00; lineNumber: int32) {.
    importc: "gtk_text_buffer_get_iter_at_line", libprag.}

proc gtk_text_buffer_get_iter_at_line_index*(self: ptr TextBuffer00; iter: var TextIter00; lineNumber: int32; 
    byteIndex: int32) {.
    importc: "gtk_text_buffer_get_iter_at_line_index", libprag.}

proc getIterAtLineIndex*(self: ptr TextBuffer00; iter: var TextIter00; lineNumber: int32; 
    byteIndex: int32) {.
    importc: "gtk_text_buffer_get_iter_at_line_index", libprag.}

proc iterAtLineIndex*(self: ptr TextBuffer00; iter: var TextIter00; lineNumber: int32; 
    byteIndex: int32) {.
    importc: "gtk_text_buffer_get_iter_at_line_index", libprag.}

proc gtk_text_buffer_get_iter_at_line_offset*(self: ptr TextBuffer00; iter: var TextIter00; lineNumber: int32; 
    charOffset: int32) {.
    importc: "gtk_text_buffer_get_iter_at_line_offset", libprag.}

proc getIterAtLineOffset*(self: ptr TextBuffer00; iter: var TextIter00; lineNumber: int32; 
    charOffset: int32) {.
    importc: "gtk_text_buffer_get_iter_at_line_offset", libprag.}

proc iterAtLineOffset*(self: ptr TextBuffer00; iter: var TextIter00; lineNumber: int32; 
    charOffset: int32) {.
    importc: "gtk_text_buffer_get_iter_at_line_offset", libprag.}

proc gtk_text_buffer_get_iter_at_mark*(self: ptr TextBuffer00; iter: var TextIter00; mark: ptr TextMark00) {.
    importc: "gtk_text_buffer_get_iter_at_mark", libprag.}

proc getIterAtMark*(self: ptr TextBuffer00; iter: var TextIter00; mark: ptr TextMark00) {.
    importc: "gtk_text_buffer_get_iter_at_mark", libprag.}

proc iterAtMark*(self: ptr TextBuffer00; iter: var TextIter00; mark: ptr TextMark00) {.
    importc: "gtk_text_buffer_get_iter_at_mark", libprag.}

proc gtk_text_buffer_get_iter_at_offset*(self: ptr TextBuffer00; iter: var TextIter00; charOffset: int32) {.
    importc: "gtk_text_buffer_get_iter_at_offset", libprag.}

proc getIterAtOffset*(self: ptr TextBuffer00; iter: var TextIter00; charOffset: int32) {.
    importc: "gtk_text_buffer_get_iter_at_offset", libprag.}

proc iterAtOffset*(self: ptr TextBuffer00; iter: var TextIter00; charOffset: int32) {.
    importc: "gtk_text_buffer_get_iter_at_offset", libprag.}

proc gtk_text_buffer_get_line_count*(self: ptr TextBuffer00): int32 {.
    importc: "gtk_text_buffer_get_line_count", libprag.}

proc getLineCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_line_count(cast[ptr TextBuffer00](self.impl)))

proc lineCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_line_count(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_mark*(self: ptr TextBuffer00; name: cstring): ptr TextMark00 {.
    importc: "gtk_text_buffer_get_mark", libprag.}

proc getMark*(self: TextBuffer; name: string): TextMark =
  let gobj = gtk_text_buffer_get_mark(cast[ptr TextBuffer00](self.impl), cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextMark](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc mark*(self: TextBuffer; name: string): TextMark =
  let gobj = gtk_text_buffer_get_mark(cast[ptr TextBuffer00](self.impl), cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextMark](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_modified*(self: ptr TextBuffer00): gboolean {.
    importc: "gtk_text_buffer_get_modified", libprag.}

proc getModified*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_modified(cast[ptr TextBuffer00](self.impl)))

proc modified*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_modified(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_paste_target_list*(self: ptr TextBuffer00): ptr TargetList00 {.
    importc: "gtk_text_buffer_get_paste_target_list", libprag.}

proc getPasteTargetList*(self: TextBuffer): TargetList =
  new(result)
  result.impl = gtk_text_buffer_get_paste_target_list(cast[ptr TextBuffer00](self.impl))

proc pasteTargetList*(self: TextBuffer): TargetList =
  new(result)
  result.impl = gtk_text_buffer_get_paste_target_list(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_get_selection_bound*(self: ptr TextBuffer00): ptr TextMark00 {.
    importc: "gtk_text_buffer_get_selection_bound", libprag.}

proc getSelectionBound*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_selection_bound(cast[ptr TextBuffer00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextMark](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectionBound*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_selection_bound(cast[ptr TextBuffer00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextMark](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_selection_bounds*(self: ptr TextBuffer00; start: var TextIter00; `end`: var TextIter00): gboolean {.
    importc: "gtk_text_buffer_get_selection_bounds", libprag.}

proc getSelectionBounds*(self: ptr TextBuffer00; start: var TextIter00; `end`: var TextIter00): gboolean {.
    importc: "gtk_text_buffer_get_selection_bounds", libprag.}

proc selectionBounds*(self: ptr TextBuffer00; start: var TextIter00; `end`: var TextIter00): gboolean {.
    importc: "gtk_text_buffer_get_selection_bounds", libprag.}

proc gtk_text_buffer_get_serialize_formats*(self: ptr TextBuffer00; nFormats: var int32): ptr gdk.Atom00Array {.
    importc: "gtk_text_buffer_get_serialize_formats", libprag.}

proc getSerializeFormats*(self: TextBuffer; nFormats: var int): ptr gdk.Atom00Array =
  var nFormats_00 = int32(nFormats)
  result = gtk_text_buffer_get_serialize_formats(cast[ptr TextBuffer00](self.impl), nFormats_00)
  nFormats = int(nFormats_00)

proc serializeFormats*(self: TextBuffer; nFormats: var int): ptr gdk.Atom00Array =
  var nFormats_00 = int32(nFormats)
  result = gtk_text_buffer_get_serialize_formats(cast[ptr TextBuffer00](self.impl), nFormats_00)
  nFormats = int(nFormats_00)

proc gtk_text_buffer_get_slice*(self: ptr TextBuffer00; start: ptr TextIter00; `end`: ptr TextIter00; 
    includeHiddenChars: gboolean): cstring {.
    importc: "gtk_text_buffer_get_slice", libprag.}

proc getSlice*(self: TextBuffer; start: TextIter; `end`: TextIter; 
    includeHiddenChars: bool): string =
  let resul0 = gtk_text_buffer_get_slice(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl), gboolean(includeHiddenChars))
  result = $resul0
  cogfree(resul0)

proc slice*(self: TextBuffer; start: TextIter; `end`: TextIter; 
    includeHiddenChars: bool): string =
  let resul0 = gtk_text_buffer_get_slice(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl), gboolean(includeHiddenChars))
  result = $resul0
  cogfree(resul0)

proc gtk_text_buffer_get_start_iter*(self: ptr TextBuffer00; iter: var TextIter00) {.
    importc: "gtk_text_buffer_get_start_iter", libprag.}

proc getStartIter*(self: ptr TextBuffer00; iter: var TextIter00) {.
    importc: "gtk_text_buffer_get_start_iter", libprag.}

proc startIter*(self: ptr TextBuffer00; iter: var TextIter00) {.
    importc: "gtk_text_buffer_get_start_iter", libprag.}

proc gtk_text_buffer_get_text*(self: ptr TextBuffer00; start: ptr TextIter00; `end`: ptr TextIter00; 
    includeHiddenChars: gboolean): cstring {.
    importc: "gtk_text_buffer_get_text", libprag.}

proc getText*(self: TextBuffer; start: TextIter; `end`: TextIter; 
    includeHiddenChars: bool): string =
  let resul0 = gtk_text_buffer_get_text(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl), gboolean(includeHiddenChars))
  result = $resul0
  cogfree(resul0)

proc text*(self: TextBuffer; start: TextIter; `end`: TextIter; 
    includeHiddenChars: bool): string =
  let resul0 = gtk_text_buffer_get_text(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl), gboolean(includeHiddenChars))
  result = $resul0
  cogfree(resul0)

proc gtk_text_buffer_insert*(self: ptr TextBuffer00; iter: ptr TextIter00; text: cstring; 
    len: int32) {.
    importc: "gtk_text_buffer_insert", libprag.}

proc insert*(self: TextBuffer; iter: TextIter; text: string; len: int) =
  gtk_text_buffer_insert(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](iter.impl), cstring(text), int32(len))

proc gtk_text_buffer_insert_at_cursor*(self: ptr TextBuffer00; text: cstring; len: int32) {.
    importc: "gtk_text_buffer_insert_at_cursor", libprag.}

proc insertAtCursor*(self: TextBuffer; text: string; len: int) =
  gtk_text_buffer_insert_at_cursor(cast[ptr TextBuffer00](self.impl), cstring(text), int32(len))

proc gtk_text_buffer_insert_child_anchor*(self: ptr TextBuffer00; iter: ptr TextIter00; anchor: ptr TextChildAnchor00) {.
    importc: "gtk_text_buffer_insert_child_anchor", libprag.}

proc insertChildAnchor*(self: TextBuffer; iter: TextIter; anchor: TextChildAnchor) =
  gtk_text_buffer_insert_child_anchor(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](iter.impl), cast[ptr TextChildAnchor00](anchor.impl))

proc gtk_text_buffer_insert_interactive*(self: ptr TextBuffer00; iter: ptr TextIter00; text: cstring; 
    len: int32; defaultEditable: gboolean): gboolean {.
    importc: "gtk_text_buffer_insert_interactive", libprag.}

proc insertInteractive*(self: TextBuffer; iter: TextIter; text: string; len: int; 
    defaultEditable: bool): bool =
  toBool(gtk_text_buffer_insert_interactive(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](iter.impl), cstring(text), int32(len), gboolean(defaultEditable)))

proc gtk_text_buffer_insert_interactive_at_cursor*(self: ptr TextBuffer00; text: cstring; len: int32; 
    defaultEditable: gboolean): gboolean {.
    importc: "gtk_text_buffer_insert_interactive_at_cursor", libprag.}

proc insertInteractiveAtCursor*(self: TextBuffer; text: string; len: int; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_insert_interactive_at_cursor(cast[ptr TextBuffer00](self.impl), cstring(text), int32(len), gboolean(defaultEditable)))

proc gtk_text_buffer_insert_markup*(self: ptr TextBuffer00; iter: ptr TextIter00; markup: cstring; 
    len: int32) {.
    importc: "gtk_text_buffer_insert_markup", libprag.}

proc insertMarkup*(self: TextBuffer; iter: TextIter; markup: string; 
    len: int) =
  gtk_text_buffer_insert_markup(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](iter.impl), cstring(markup), int32(len))

proc gtk_text_buffer_insert_pixbuf*(self: ptr TextBuffer00; iter: ptr TextIter00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_text_buffer_insert_pixbuf", libprag.}

proc insertPixbuf*(self: TextBuffer; iter: TextIter; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_text_buffer_insert_pixbuf(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](iter.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_text_buffer_insert_range*(self: ptr TextBuffer00; iter: ptr TextIter00; start: ptr TextIter00; 
    `end`: ptr TextIter00) {.
    importc: "gtk_text_buffer_insert_range", libprag.}

proc insertRange*(self: TextBuffer; iter: TextIter; start: TextIter; 
    `end`: TextIter) =
  gtk_text_buffer_insert_range(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](iter.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl))

proc gtk_text_buffer_insert_range_interactive*(self: ptr TextBuffer00; iter: ptr TextIter00; start: ptr TextIter00; 
    `end`: ptr TextIter00; defaultEditable: gboolean): gboolean {.
    importc: "gtk_text_buffer_insert_range_interactive", libprag.}

proc insertRangeInteractive*(self: TextBuffer; iter: TextIter; start: TextIter; 
    `end`: TextIter; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_insert_range_interactive(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](iter.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl), gboolean(defaultEditable)))

proc gtk_text_buffer_move_mark*(self: ptr TextBuffer00; mark: ptr TextMark00; where: ptr TextIter00) {.
    importc: "gtk_text_buffer_move_mark", libprag.}

proc moveMark*(self: TextBuffer; mark: TextMark; where: TextIter) =
  gtk_text_buffer_move_mark(cast[ptr TextBuffer00](self.impl), cast[ptr TextMark00](mark.impl), cast[ptr TextIter00](where.impl))

proc gtk_text_buffer_move_mark_by_name*(self: ptr TextBuffer00; name: cstring; where: ptr TextIter00) {.
    importc: "gtk_text_buffer_move_mark_by_name", libprag.}

proc moveMarkByName*(self: TextBuffer; name: string; where: TextIter) =
  gtk_text_buffer_move_mark_by_name(cast[ptr TextBuffer00](self.impl), cstring(name), cast[ptr TextIter00](where.impl))

proc gtk_text_buffer_paste_clipboard*(self: ptr TextBuffer00; clipboard: ptr Clipboard00; 
    overrideLocation: ptr TextIter00; defaultEditable: gboolean) {.
    importc: "gtk_text_buffer_paste_clipboard", libprag.}

proc pasteClipboard*(self: TextBuffer; clipboard: Clipboard; overrideLocation: TextIter; 
    defaultEditable: bool) =
  gtk_text_buffer_paste_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl), cast[ptr TextIter00](overrideLocation.impl), gboolean(defaultEditable))

proc gtk_text_buffer_place_cursor*(self: ptr TextBuffer00; where: ptr TextIter00) {.
    importc: "gtk_text_buffer_place_cursor", libprag.}

proc placeCursor*(self: TextBuffer; where: TextIter) =
  gtk_text_buffer_place_cursor(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](where.impl))

proc gtk_text_buffer_register_deserialize_tagset*(self: ptr TextBuffer00; tagsetName: cstring): ptr gdk.Atom00 {.
    importc: "gtk_text_buffer_register_deserialize_tagset", libprag.}

proc registerDeserializeTagset*(self: TextBuffer; tagsetName: string): gdk.Atom =
  new(result)
  result.impl = gtk_text_buffer_register_deserialize_tagset(cast[ptr TextBuffer00](self.impl), cstring(tagsetName))

proc gtk_text_buffer_register_serialize_tagset*(self: ptr TextBuffer00; tagsetName: cstring): ptr gdk.Atom00 {.
    importc: "gtk_text_buffer_register_serialize_tagset", libprag.}

proc registerSerializeTagset*(self: TextBuffer; tagsetName: string): gdk.Atom =
  new(result)
  result.impl = gtk_text_buffer_register_serialize_tagset(cast[ptr TextBuffer00](self.impl), cstring(tagsetName))

proc gtk_text_buffer_remove_all_tags*(self: ptr TextBuffer00; start: ptr TextIter00; `end`: ptr TextIter00) {.
    importc: "gtk_text_buffer_remove_all_tags", libprag.}

proc removeAllTags*(self: TextBuffer; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_remove_all_tags(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl))

proc gtk_text_buffer_remove_selection_clipboard*(self: ptr TextBuffer00; clipboard: ptr Clipboard00) {.
    importc: "gtk_text_buffer_remove_selection_clipboard", libprag.}

proc removeSelectionClipboard*(self: TextBuffer; clipboard: Clipboard) =
  gtk_text_buffer_remove_selection_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl))

proc gtk_text_buffer_remove_tag*(self: ptr TextBuffer00; tag: ptr TextTag00; start: ptr TextIter00; 
    `end`: ptr TextIter00) {.
    importc: "gtk_text_buffer_remove_tag", libprag.}

proc removeTag*(self: TextBuffer; tag: TextTag; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_remove_tag(cast[ptr TextBuffer00](self.impl), cast[ptr TextTag00](tag.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl))

proc gtk_text_buffer_remove_tag_by_name*(self: ptr TextBuffer00; name: cstring; start: ptr TextIter00; 
    `end`: ptr TextIter00) {.
    importc: "gtk_text_buffer_remove_tag_by_name", libprag.}

proc removeTagByName*(self: TextBuffer; name: string; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_remove_tag_by_name(cast[ptr TextBuffer00](self.impl), cstring(name), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl))

proc gtk_text_buffer_select_range*(self: ptr TextBuffer00; ins: ptr TextIter00; bound: ptr TextIter00) {.
    importc: "gtk_text_buffer_select_range", libprag.}

proc selectRange*(self: TextBuffer; ins: TextIter; bound: TextIter) =
  gtk_text_buffer_select_range(cast[ptr TextBuffer00](self.impl), cast[ptr TextIter00](ins.impl), cast[ptr TextIter00](bound.impl))

proc gtk_text_buffer_serialize*(self: ptr TextBuffer00; contentBuffer: ptr TextBuffer00; 
    format: ptr gdk.Atom00; start: ptr TextIter00; `end`: ptr TextIter00; length: var uint64): uint8Array {.
    importc: "gtk_text_buffer_serialize", libprag.}

proc serialize*(self: TextBuffer; contentBuffer: TextBuffer; format: gdk.Atom; 
    start: TextIter; `end`: TextIter; length: var uint64): uint8Array =
  gtk_text_buffer_serialize(cast[ptr TextBuffer00](self.impl), cast[ptr TextBuffer00](contentBuffer.impl), cast[ptr gdk.Atom00](format.impl), cast[ptr TextIter00](start.impl), cast[ptr TextIter00](`end`.impl), length)

proc gtk_text_buffer_set_modified*(self: ptr TextBuffer00; setting: gboolean) {.
    importc: "gtk_text_buffer_set_modified", libprag.}

proc setModified*(self: TextBuffer; setting: bool) =
  gtk_text_buffer_set_modified(cast[ptr TextBuffer00](self.impl), gboolean(setting))

proc `modified=`*(self: TextBuffer; setting: bool) =
  gtk_text_buffer_set_modified(cast[ptr TextBuffer00](self.impl), gboolean(setting))

proc gtk_text_buffer_set_text*(self: ptr TextBuffer00; text: cstring; len: int32) {.
    importc: "gtk_text_buffer_set_text", libprag.}

proc setText*(self: TextBuffer; text: string; len: int) =
  gtk_text_buffer_set_text(cast[ptr TextBuffer00](self.impl), cstring(text), int32(len))

proc gtk_text_buffer_unregister_deserialize_format*(self: ptr TextBuffer00; format: ptr gdk.Atom00) {.
    importc: "gtk_text_buffer_unregister_deserialize_format", libprag.}

proc unregisterDeserializeFormat*(self: TextBuffer; format: gdk.Atom) =
  gtk_text_buffer_unregister_deserialize_format(cast[ptr TextBuffer00](self.impl), cast[ptr gdk.Atom00](format.impl))

proc gtk_text_buffer_unregister_serialize_format*(self: ptr TextBuffer00; format: ptr gdk.Atom00) {.
    importc: "gtk_text_buffer_unregister_serialize_format", libprag.}

proc unregisterSerializeFormat*(self: TextBuffer; format: gdk.Atom) =
  gtk_text_buffer_unregister_serialize_format(cast[ptr TextBuffer00](self.impl), cast[ptr gdk.Atom00](format.impl))

proc gtk_selection_data_targets_include_rich_text*(self: ptr SelectionData00; buffer: ptr TextBuffer00): gboolean {.
    importc: "gtk_selection_data_targets_include_rich_text", libprag.}

proc targetsIncludeRichText*(self: SelectionData; buffer: TextBuffer): bool =
  toBool(gtk_selection_data_targets_include_rich_text(cast[ptr SelectionData00](self.impl), cast[ptr TextBuffer00](buffer.impl)))

proc gtk_target_list_add_rich_text_targets*(self: ptr TargetList00; info: uint32; deserializable: gboolean; 
    buffer: ptr TextBuffer00) {.
    importc: "gtk_target_list_add_rich_text_targets", libprag.}

proc addRichTextTargets*(self: TargetList; info: int; deserializable: bool; 
    buffer: TextBuffer) =
  gtk_target_list_add_rich_text_targets(cast[ptr TargetList00](self.impl), uint32(info), gboolean(deserializable), cast[ptr TextBuffer00](buffer.impl))

proc gtk_clipboard_wait_for_rich_text*(self: ptr Clipboard00; buffer: ptr TextBuffer00; format: var ptr gdk.Atom00; 
    length: var uint64): uint8Array {.
    importc: "gtk_clipboard_wait_for_rich_text", libprag.}

proc waitForRichText*(self: ptr Clipboard00; buffer: ptr TextBuffer00; format: var ptr gdk.Atom00; 
    length: var uint64): uint8Array {.
    importc: "gtk_clipboard_wait_for_rich_text", libprag.}

proc gtk_clipboard_wait_is_rich_text_available*(self: ptr Clipboard00; buffer: ptr TextBuffer00): gboolean {.
    importc: "gtk_clipboard_wait_is_rich_text_available", libprag.}

proc waitIsRichTextAvailable*(self: Clipboard; buffer: TextBuffer): bool =
  toBool(gtk_clipboard_wait_is_rich_text_available(cast[ptr Clipboard00](self.impl), cast[ptr TextBuffer00](buffer.impl)))

proc gtk_text_iter_get_buffer*(self: ptr TextIter00): ptr TextBuffer00 {.
    importc: "gtk_text_iter_get_buffer", libprag.}

proc getBuffer*(self: TextIter): TextBuffer =
  let gobj = gtk_text_iter_get_buffer(cast[ptr TextIter00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextBuffer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: TextIter): TextBuffer =
  let gobj = gtk_text_iter_get_buffer(cast[ptr TextIter00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextBuffer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_mark_get_buffer*(self: ptr TextMark00): ptr TextBuffer00 {.
    importc: "gtk_text_mark_get_buffer", libprag.}

proc getBuffer*(self: TextMark): TextBuffer =
  let gobj = gtk_text_mark_get_buffer(cast[ptr TextMark00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextBuffer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: TextMark): TextBuffer =
  let gobj = gtk_text_mark_get_buffer(cast[ptr TextMark00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextBuffer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TextTagTablePrivate00* {.pure.} = object
  TextTagTablePrivate* = ref object
    impl*: ptr TextTagTablePrivate00

type
  TextTagTable* = ref object of gobject.Object
  TextTagTable00* = object of gobject.Object00
    priv1: ptr TextTagTablePrivate00

proc scTagAdded*(self: TextTagTable;  p: proc (self: ptr gobject.Object00; tag: TextTag00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "tag-added", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scTagChanged*(self: TextTagTable;  p: proc (self: ptr gobject.Object00; tag: TextTag00; sizeChanged: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "tag-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scTagRemoved*(self: TextTagTable;  p: proc (self: ptr gobject.Object00; tag: TextTag00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "tag-removed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_text_tag_table_new*(): ptr TextTagTable00 {.
    importc: "gtk_text_tag_table_new", libprag.}

proc newTextTagTable*(): TextTagTable =
  new(result, finalizeGObject)
  result.impl = gtk_text_tag_table_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextTagTable*[T](result: var T) =
  assert(result is TextTagTable)
  new(result, finalizeGObject)
  result.impl = gtk_text_tag_table_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_tag_table_add*(self: ptr TextTagTable00; tag: ptr TextTag00): gboolean {.
    importc: "gtk_text_tag_table_add", libprag.}

proc add*(self: TextTagTable; tag: TextTag): bool =
  toBool(gtk_text_tag_table_add(cast[ptr TextTagTable00](self.impl), cast[ptr TextTag00](tag.impl)))

proc gtk_text_tag_table_get_size*(self: ptr TextTagTable00): int32 {.
    importc: "gtk_text_tag_table_get_size", libprag.}

proc getSize*(self: TextTagTable): int =
  int(gtk_text_tag_table_get_size(cast[ptr TextTagTable00](self.impl)))

proc size*(self: TextTagTable): int =
  int(gtk_text_tag_table_get_size(cast[ptr TextTagTable00](self.impl)))

proc gtk_text_tag_table_lookup*(self: ptr TextTagTable00; name: cstring): ptr TextTag00 {.
    importc: "gtk_text_tag_table_lookup", libprag.}

proc lookup*(self: TextTagTable; name: string): TextTag =
  let gobj = gtk_text_tag_table_lookup(cast[ptr TextTagTable00](self.impl), cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextTag](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_tag_table_remove*(self: ptr TextTagTable00; tag: ptr TextTag00) {.
    importc: "gtk_text_tag_table_remove", libprag.}

proc remove*(self: TextTagTable; tag: TextTag) =
  gtk_text_tag_table_remove(cast[ptr TextTagTable00](self.impl), cast[ptr TextTag00](tag.impl))

proc gtk_text_buffer_new*(table: ptr TextTagTable00): ptr TextBuffer00 {.
    importc: "gtk_text_buffer_new", libprag.}

proc newTextBuffer*(table: TextTagTable): TextBuffer =
  new(result, finalizeGObject)
  result.impl = gtk_text_buffer_new(cast[ptr TextTagTable00](table.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextBuffer*[T](result: var T; table: TextTagTable) =
  assert(result is TextBuffer)
  new(result, finalizeGObject)
  result.impl = gtk_text_buffer_new(cast[ptr TextTagTable00](table.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_tag_table*(self: ptr TextBuffer00): ptr TextTagTable00 {.
    importc: "gtk_text_buffer_get_tag_table", libprag.}

proc getTagTable*(self: TextBuffer): TextTagTable =
  let gobj = gtk_text_buffer_get_tag_table(cast[ptr TextBuffer00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextTagTable](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc tagTable*(self: TextBuffer): TextTagTable =
  let gobj = gtk_text_buffer_get_tag_table(cast[ptr TextBuffer00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextTagTable](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  WidgetClassPrivate00* {.pure.} = object
  WidgetClassPrivate* = ref object
    impl*: ptr WidgetClassPrivate00

type
  WidgetClass00* {.pure.} = object
    parentClass*: gobject.InitiallyUnownedClass00
    activateSignal*: uint32
    dispatchChildPropertiesChanged*: proc(widget: ptr Widget00; nPspecs: uint32; pspecs: ptr gobject.ParamSpec00) {.cdecl.}
    destroy*: proc(widget: ptr Widget00) {.cdecl.}
    show*: proc(widget: ptr Widget00) {.cdecl.}
    showAll*: proc(widget: ptr Widget00) {.cdecl.}
    hide*: proc(widget: ptr Widget00) {.cdecl.}
    map*: proc(widget: ptr Widget00) {.cdecl.}
    unmap*: proc(widget: ptr Widget00) {.cdecl.}
    realize*: proc(widget: ptr Widget00) {.cdecl.}
    unrealize*: proc(widget: ptr Widget00) {.cdecl.}
    sizeAllocate*: proc(widget: ptr Widget00; allocation: ptr gdk.Rectangle00) {.cdecl.}
    stateChanged*: proc(widget: ptr Widget00; previousState: StateType) {.cdecl.}
    stateFlagsChanged*: proc(widget: ptr Widget00; previousStateFlags: StateFlags) {.cdecl.}
    parentSet*: proc(widget: ptr Widget00; previousParent: ptr Widget00) {.cdecl.}
    hierarchyChanged*: proc(widget: ptr Widget00; previousToplevel: ptr Widget00) {.cdecl.}
    styleSet*: proc(widget: ptr Widget00; previousStyle: ptr Style00) {.cdecl.}
    directionChanged*: proc(widget: ptr Widget00; previousDirection: TextDirection) {.cdecl.}
    grabNotify*: proc(widget: ptr Widget00; wasGrabbed: gboolean) {.cdecl.}
    childNotify*: proc(widget: ptr Widget00; childProperty: ptr gobject.ParamSpec00) {.cdecl.}
    draw*: proc(widget: ptr Widget00; cr: ptr cairo.Context00): gboolean {.cdecl.}
    getRequestMode*: proc(widget: ptr Widget00): SizeRequestMode {.cdecl.}
    getPreferredHeight*: proc(widget: ptr Widget00; minimumHeight: var int32; naturalHeight: var int32) {.cdecl.}
    getPreferredWidthForHeight*: proc(widget: ptr Widget00; height: int32; minimumWidth: var int32; 
    naturalWidth: var int32) {.cdecl.}
    getPreferredWidth*: proc(widget: ptr Widget00; minimumWidth: var int32; naturalWidth: var int32) {.cdecl.}
    getPreferredHeightForWidth*: proc(widget: ptr Widget00; width: int32; minimumHeight: var int32; 
    naturalHeight: var int32) {.cdecl.}
    mnemonicActivate*: proc(widget: ptr Widget00; groupCycling: gboolean): gboolean {.cdecl.}
    grabFocus*: proc(widget: ptr Widget00) {.cdecl.}
    focus*: proc(widget: ptr Widget00; direction: DirectionType): gboolean {.cdecl.}
    moveFocus*: proc(widget: ptr Widget00; direction: DirectionType) {.cdecl.}
    keynavFailed*: proc(widget: ptr Widget00; direction: DirectionType): gboolean {.cdecl.}
    event*: proc(widget: ptr Widget00; event: ptr gdk.Event00): gboolean {.cdecl.}
    buttonPressEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventButton00): gboolean {.cdecl.}
    buttonReleaseEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventButton00): gboolean {.cdecl.}
    scrollEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventScroll00): gboolean {.cdecl.}
    motionNotifyEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventMotion00): gboolean {.cdecl.}
    deleteEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventAny00): gboolean {.cdecl.}
    destroyEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventAny00): gboolean {.cdecl.}
    keyPressEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventKey00): gboolean {.cdecl.}
    keyReleaseEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventKey00): gboolean {.cdecl.}
    enterNotifyEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventCrossing00): gboolean {.cdecl.}
    leaveNotifyEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventCrossing00): gboolean {.cdecl.}
    configureEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventConfigure00): gboolean {.cdecl.}
    focusInEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventFocus00): gboolean {.cdecl.}
    focusOutEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventFocus00): gboolean {.cdecl.}
    mapEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventAny00): gboolean {.cdecl.}
    unmapEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventAny00): gboolean {.cdecl.}
    propertyNotifyEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventProperty00): gboolean {.cdecl.}
    selectionClearEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventSelection00): gboolean {.cdecl.}
    selectionRequestEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventSelection00): gboolean {.cdecl.}
    selectionNotifyEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventSelection00): gboolean {.cdecl.}
    proximityInEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventProximity00): gboolean {.cdecl.}
    proximityOutEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventProximity00): gboolean {.cdecl.}
    visibilityNotifyEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventVisibility00): gboolean {.cdecl.}
    windowStateEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventWindowState00): gboolean {.cdecl.}
    damageEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventExpose00): gboolean {.cdecl.}
    grabBrokenEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventGrabBroken00): gboolean {.cdecl.}
    selectionGet*: proc(widget: ptr Widget00; selectionData: ptr SelectionData00; 
    info: uint32; time: uint32) {.cdecl.}
    selectionReceived*: proc(widget: ptr Widget00; selectionData: ptr SelectionData00; 
    time: uint32) {.cdecl.}
    dragBegin*: proc(widget: ptr Widget00; context: ptr gdk.DragContext00) {.cdecl.}
    dragEnd*: proc(widget: ptr Widget00; context: ptr gdk.DragContext00) {.cdecl.}
    dragDataGet*: proc(widget: ptr Widget00; context: ptr gdk.DragContext00; 
    selectionData: ptr SelectionData00; info: uint32; time: uint32) {.cdecl.}
    dragDataDelete*: proc(widget: ptr Widget00; context: ptr gdk.DragContext00) {.cdecl.}
    dragLeave*: proc(widget: ptr Widget00; context: ptr gdk.DragContext00; 
    time: uint32) {.cdecl.}
    dragMotion*: proc(widget: ptr Widget00; context: ptr gdk.DragContext00; 
    x: int32; y: int32; time: uint32): gboolean {.cdecl.}
    dragDrop*: proc(widget: ptr Widget00; context: ptr gdk.DragContext00; 
    x: int32; y: int32; time: uint32): gboolean {.cdecl.}
    dragDataReceived*: proc(widget: ptr Widget00; context: ptr gdk.DragContext00; 
    x: int32; y: int32; selectionData: ptr SelectionData00; info: uint32; time: uint32) {.cdecl.}
    dragFailed*: proc(widget: ptr Widget00; context: ptr gdk.DragContext00; 
    resu: DragResult): gboolean {.cdecl.}
    popupMenu*: proc(widget: ptr Widget00): gboolean {.cdecl.}
    showHelp*: proc(widget: ptr Widget00; helpType: WidgetHelpType): gboolean {.cdecl.}
    getAccessible*: proc(widget: ptr Widget00): ptr atk.Object00 {.cdecl.}
    screenChanged*: proc(widget: ptr Widget00; previousScreen: ptr gdk.Screen00) {.cdecl.}
    canActivateAccel*: proc(widget: ptr Widget00; signalId: uint32): gboolean {.cdecl.}
    compositedChanged*: proc(widget: ptr Widget00) {.cdecl.}
    queryTooltip*: proc(widget: ptr Widget00; x: int32; y: int32; keyboardTooltip: gboolean; 
    tooltip: ptr Tooltip00): gboolean {.cdecl.}
    computeExpand*: proc(widget: ptr Widget00; hexpandP: ptr gboolean; vexpandP: ptr gboolean) {.cdecl.}
    adjustSizeRequest*: proc(widget: ptr Widget00; orientation: Orientation; minimumSize: ptr int32; 
    naturalSize: ptr int32) {.cdecl.}
    adjustSizeAllocation*: proc(widget: ptr Widget00; orientation: Orientation; minimumSize: ptr int32; 
    naturalSize: ptr int32; allocatedPos: ptr int32; allocatedSize: ptr int32) {.cdecl.}
    styleUpdated*: proc(widget: ptr Widget00) {.cdecl.}
    touchEvent*: proc(widget: ptr Widget00; event: ptr gdk.EventTouch00): gboolean {.cdecl.}
    getPreferredHeightAndBaselineForWidth*: proc(widget: ptr Widget00; width: int32; minimumHeight: var int32; 
    naturalHeight: var int32; minimumBaseline: var int32; naturalBaseline: var int32) {.cdecl.}
    adjustBaselineRequest*: proc(widget: ptr Widget00; minimumBaseline: ptr int32; 
    naturalBaseline: ptr int32) {.cdecl.}
    adjustBaselineAllocation*: proc(widget: ptr Widget00; baseline: ptr int32) {.cdecl.}
    queueDrawRegion*: proc(widget: ptr Widget00; region: ptr cairo.Region00) {.cdecl.}
    priv*: ptr WidgetClassPrivate00
    gtkReserved6*: pointer
    gtkReserved7*: pointer
  WidgetClass* = ref object
    impl*: ptr WidgetClass00

proc gtk_widget_class_bind_template_child_full*(self: ptr WidgetClass00; name: cstring; internalChild: gboolean; 
    structOffset: int64) {.
    importc: "gtk_widget_class_bind_template_child_full", libprag.}

proc bindTemplateChildFull*(self: WidgetClass; name: string; internalChild: bool; 
    structOffset: int64) =
  gtk_widget_class_bind_template_child_full(cast[ptr WidgetClass00](self.impl), cstring(name), gboolean(internalChild), structOffset)

proc gtk_widget_class_find_style_property*(self: ptr WidgetClass00; propertyName: cstring): ptr gobject.ParamSpec00 {.
    importc: "gtk_widget_class_find_style_property", libprag.}

proc gtk_widget_class_get_css_name*(self: ptr WidgetClass00): cstring {.
    importc: "gtk_widget_class_get_css_name", libprag.}

proc getCssName*(self: WidgetClass): string =
  let resul0 = gtk_widget_class_get_css_name(cast[ptr WidgetClass00](self.impl))
  result = $resul0

proc cssName*(self: WidgetClass): string =
  let resul0 = gtk_widget_class_get_css_name(cast[ptr WidgetClass00](self.impl))
  result = $resul0

proc gtk_widget_class_install_style_property*(self: ptr WidgetClass00; pspec: ptr gobject.ParamSpec00) {.
    importc: "gtk_widget_class_install_style_property", libprag.}

proc installStyleProperty*(self: WidgetClass; pspec: gobject.ParamSpec) =
  gtk_widget_class_install_style_property(cast[ptr WidgetClass00](self.impl), cast[ptr gobject.ParamSpec00](pspec.impl))

proc gtk_widget_class_list_style_properties*(self: ptr WidgetClass00; nProperties: var uint32): ptr gobject.ParamSpec00Array {.
    importc: "gtk_widget_class_list_style_properties", libprag.}

proc listStyleProperties*(self: WidgetClass; nProperties: var int): ptr gobject.ParamSpec00Array =
  var nProperties_00 = uint32(nProperties)
  result = gtk_widget_class_list_style_properties(cast[ptr WidgetClass00](self.impl), nProperties_00)
  nProperties = int(nProperties_00)

proc gtk_widget_class_set_accessible_role*(self: ptr WidgetClass00; role: atk.Role) {.
    importc: "gtk_widget_class_set_accessible_role", libprag.}

proc setAccessibleRole*(self: WidgetClass; role: atk.Role) =
  gtk_widget_class_set_accessible_role(cast[ptr WidgetClass00](self.impl), role)

proc `accessibleRole=`*(self: WidgetClass; role: atk.Role) =
  gtk_widget_class_set_accessible_role(cast[ptr WidgetClass00](self.impl), role)

proc gtk_widget_class_set_accessible_type*(self: ptr WidgetClass00; `type`: GType) {.
    importc: "gtk_widget_class_set_accessible_type", libprag.}

proc setAccessibleType*(self: WidgetClass; `type`: GType) =
  gtk_widget_class_set_accessible_type(cast[ptr WidgetClass00](self.impl), `type`)

proc `accessibleType=`*(self: WidgetClass; `type`: GType) =
  gtk_widget_class_set_accessible_type(cast[ptr WidgetClass00](self.impl), `type`)

proc gtk_widget_class_set_css_name*(self: ptr WidgetClass00; name: cstring) {.
    importc: "gtk_widget_class_set_css_name", libprag.}

proc setCssName*(self: WidgetClass; name: string) =
  gtk_widget_class_set_css_name(cast[ptr WidgetClass00](self.impl), cstring(name))

proc `cssName=`*(self: WidgetClass; name: string) =
  gtk_widget_class_set_css_name(cast[ptr WidgetClass00](self.impl), cstring(name))

proc gtk_widget_class_set_template*(self: ptr WidgetClass00; templateBytes: ptr glib.Bytes00) {.
    importc: "gtk_widget_class_set_template", libprag.}

proc setTemplate*(self: WidgetClass; templateBytes: glib.Bytes) =
  gtk_widget_class_set_template(cast[ptr WidgetClass00](self.impl), cast[ptr glib.Bytes00](templateBytes.impl))

proc `template=`*(self: WidgetClass; templateBytes: glib.Bytes) =
  gtk_widget_class_set_template(cast[ptr WidgetClass00](self.impl), cast[ptr glib.Bytes00](templateBytes.impl))

proc gtk_widget_class_set_template_from_resource*(self: ptr WidgetClass00; resourceName: cstring) {.
    importc: "gtk_widget_class_set_template_from_resource", libprag.}

proc setTemplateFromResource*(self: WidgetClass; resourceName: string) =
  gtk_widget_class_set_template_from_resource(cast[ptr WidgetClass00](self.impl), cstring(resourceName))

proc `templateFromResource=`*(self: WidgetClass; resourceName: string) =
  gtk_widget_class_set_template_from_resource(cast[ptr WidgetClass00](self.impl), cstring(resourceName))

type
  AccelGroupActivate* = proc (accelGroup: ptr AccelGroup00; acceleratable: ptr gobject.Object00; 
    keyval: uint32; modifier: gdk.ModifierType): gboolean {.cdecl.}

type
  AccelGroupClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    accelChanged*: proc(accelGroup: ptr AccelGroup00; keyval: uint32; modifier: gdk.ModifierType; 
    accelClosure: ptr gobject.Closure00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  AccelGroupClass* = ref object
    impl*: ptr AccelGroupClass00

type
  AccelGroupFindFunc* = proc (key: ptr AccelKey00; closure: ptr gobject.Closure00; 
    data: pointer): gboolean {.cdecl.}

proc gtk_accel_group_find*(self: ptr AccelGroup00; findFunc: AccelGroupFindFunc; 
    data: pointer): ptr AccelKey00 {.
    importc: "gtk_accel_group_find", libprag.}

proc find*(self: AccelGroup; findFunc: AccelGroupFindFunc; data: pointer): AccelKey =
  new(result)
  result.impl = gtk_accel_group_find(cast[ptr AccelGroup00](self.impl), findFunc, data)

type
  MiscPrivate00* {.pure.} = object
  MiscPrivate* = ref object
    impl*: ptr MiscPrivate00

type
  Misc* = ref object of Widget
  Misc00* = object of Widget00
    priv2: ptr MiscPrivate00

proc gtk_misc_get_alignment*(self: ptr Misc00; xalign: var cfloat; yalign: var cfloat) {.
    importc: "gtk_misc_get_alignment", libprag.}

proc getAlignment*(self: Misc; xalign: var cfloat; yalign: var cfloat) =
  gtk_misc_get_alignment(cast[ptr Misc00](self.impl), xalign, yalign)

proc alignment*(self: Misc; xalign: var cfloat; yalign: var cfloat) =
  gtk_misc_get_alignment(cast[ptr Misc00](self.impl), xalign, yalign)

proc gtk_misc_get_padding*(self: ptr Misc00; xpad: var int32; ypad: var int32) {.
    importc: "gtk_misc_get_padding", libprag.}

proc getPadding*(self: Misc; xpad: var int; ypad: var int) =
  var xpad_00 = int32(xpad)
  var ypad_00 = int32(ypad)
  gtk_misc_get_padding(cast[ptr Misc00](self.impl), xpad_00, ypad_00)
  xpad = int(xpad_00)
  ypad = int(ypad_00)

proc padding*(self: Misc; xpad: var int; ypad: var int) =
  var xpad_00 = int32(xpad)
  var ypad_00 = int32(ypad)
  gtk_misc_get_padding(cast[ptr Misc00](self.impl), xpad_00, ypad_00)
  xpad = int(xpad_00)
  ypad = int(ypad_00)

proc gtk_misc_set_alignment*(self: ptr Misc00; xalign: cfloat; yalign: cfloat) {.
    importc: "gtk_misc_set_alignment", libprag.}

proc setAlignment*(self: Misc; xalign: cfloat; yalign: cfloat) =
  gtk_misc_set_alignment(cast[ptr Misc00](self.impl), xalign, yalign)

proc gtk_misc_set_padding*(self: ptr Misc00; xpad: int32; ypad: int32) {.
    importc: "gtk_misc_set_padding", libprag.}

proc setPadding*(self: Misc; xpad: int; ypad: int) =
  gtk_misc_set_padding(cast[ptr Misc00](self.impl), int32(xpad), int32(ypad))

type
  LabelPrivate00* {.pure.} = object
  LabelPrivate* = ref object
    impl*: ptr LabelPrivate00

type
  MovementStep* {.size: sizeof(cint), pure.} = enum
    logicalPositions = 0
    visualPositions = 1
    words = 2
    displayLines = 3
    displayLineEnds = 4
    paragraphs = 5
    paragraphEnds = 6
    pages = 7
    bufferEnds = 8
    horizontalPages = 9

type
  MenuShellPrivate00* {.pure.} = object
  MenuShellPrivate* = ref object
    impl*: ptr MenuShellPrivate00

type
  MenuDirectionType* {.size: sizeof(cint), pure.} = enum
    parent = 0
    child = 1
    next = 2
    prev = 3

type
  MenuShell* = ref object of Container
  MenuShell00* = object of Container00
    priv3: ptr MenuShellPrivate00

proc scActivateCurrent*(self: MenuShell;  p: proc (self: ptr gobject.Object00; forceHide: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-current", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCancel*(self: MenuShell;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cancel", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCycleFocus*(self: MenuShell;  p: proc (self: ptr gobject.Object00; direction: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cycle-focus", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDeactivate*(self: MenuShell;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "deactivate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scInsert*(self: MenuShell;  p: proc (self: ptr gobject.Object00; child: Widget00; position: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "insert", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveCurrent*(self: MenuShell;  p: proc (self: ptr gobject.Object00; direction: MenuDirectionType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-current", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveSelected*(self: MenuShell;  p: proc (self: ptr gobject.Object00; distance: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-selected", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectionDone*(self: MenuShell;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "selection-done", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_menu_shell_activate_item*(self: ptr MenuShell00; menuItem: ptr Widget00; forceDeactivate: gboolean) {.
    importc: "gtk_menu_shell_activate_item", libprag.}

proc activateItem*(self: MenuShell; menuItem: Widget; forceDeactivate: bool) =
  gtk_menu_shell_activate_item(cast[ptr MenuShell00](self.impl), cast[ptr Widget00](menuItem.impl), gboolean(forceDeactivate))

proc gtk_menu_shell_bind_model*(self: ptr MenuShell00; model: ptr gio.MenuModel00; 
    actionNamespace: cstring; withSeparators: gboolean) {.
    importc: "gtk_menu_shell_bind_model", libprag.}

proc bindModel*(self: MenuShell; model: gio.MenuModel; actionNamespace: string; 
    withSeparators: bool) =
  gtk_menu_shell_bind_model(cast[ptr MenuShell00](self.impl), cast[ptr gio.MenuModel00](model.impl), cstring(actionNamespace), gboolean(withSeparators))

proc gtk_menu_shell_cancel*(self: ptr MenuShell00) {.
    importc: "gtk_menu_shell_cancel", libprag.}

proc cancel*(self: MenuShell) =
  gtk_menu_shell_cancel(cast[ptr MenuShell00](self.impl))

proc gtk_menu_shell_deactivate*(self: ptr MenuShell00) {.
    importc: "gtk_menu_shell_deactivate", libprag.}

proc deactivate*(self: MenuShell) =
  gtk_menu_shell_deactivate(cast[ptr MenuShell00](self.impl))

proc gtk_menu_shell_deselect*(self: ptr MenuShell00) {.
    importc: "gtk_menu_shell_deselect", libprag.}

proc deselect*(self: MenuShell) =
  gtk_menu_shell_deselect(cast[ptr MenuShell00](self.impl))

proc gtk_menu_shell_get_parent_shell*(self: ptr MenuShell00): ptr Widget00 {.
    importc: "gtk_menu_shell_get_parent_shell", libprag.}

proc getParentShell*(self: MenuShell): Widget =
  let gobj = gtk_menu_shell_get_parent_shell(cast[ptr MenuShell00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parentShell*(self: MenuShell): Widget =
  let gobj = gtk_menu_shell_get_parent_shell(cast[ptr MenuShell00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_shell_get_selected_item*(self: ptr MenuShell00): ptr Widget00 {.
    importc: "gtk_menu_shell_get_selected_item", libprag.}

proc getSelectedItem*(self: MenuShell): Widget =
  let gobj = gtk_menu_shell_get_selected_item(cast[ptr MenuShell00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectedItem*(self: MenuShell): Widget =
  let gobj = gtk_menu_shell_get_selected_item(cast[ptr MenuShell00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_shell_get_take_focus*(self: ptr MenuShell00): gboolean {.
    importc: "gtk_menu_shell_get_take_focus", libprag.}

proc getTakeFocus*(self: MenuShell): bool =
  toBool(gtk_menu_shell_get_take_focus(cast[ptr MenuShell00](self.impl)))

proc takeFocus*(self: MenuShell): bool =
  toBool(gtk_menu_shell_get_take_focus(cast[ptr MenuShell00](self.impl)))

proc gtk_menu_shell_insert*(self: ptr MenuShell00; child: ptr Widget00; position: int32) {.
    importc: "gtk_menu_shell_insert", libprag.}

proc insert*(self: MenuShell; child: Widget; position: int) =
  gtk_menu_shell_insert(cast[ptr MenuShell00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_menu_shell_prepend*(self: ptr MenuShell00; child: ptr Widget00) {.
    importc: "gtk_menu_shell_prepend", libprag.}

proc prepend*(self: MenuShell; child: Widget) =
  gtk_menu_shell_prepend(cast[ptr MenuShell00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_menu_shell_select_first*(self: ptr MenuShell00; searchSensitive: gboolean) {.
    importc: "gtk_menu_shell_select_first", libprag.}

proc selectFirst*(self: MenuShell; searchSensitive: bool) =
  gtk_menu_shell_select_first(cast[ptr MenuShell00](self.impl), gboolean(searchSensitive))

proc gtk_menu_shell_select_item*(self: ptr MenuShell00; menuItem: ptr Widget00) {.
    importc: "gtk_menu_shell_select_item", libprag.}

proc selectItem*(self: MenuShell; menuItem: Widget) =
  gtk_menu_shell_select_item(cast[ptr MenuShell00](self.impl), cast[ptr Widget00](menuItem.impl))

proc gtk_menu_shell_set_take_focus*(self: ptr MenuShell00; takeFocus: gboolean) {.
    importc: "gtk_menu_shell_set_take_focus", libprag.}

proc setTakeFocus*(self: MenuShell; takeFocus: bool) =
  gtk_menu_shell_set_take_focus(cast[ptr MenuShell00](self.impl), gboolean(takeFocus))

proc `takeFocus=`*(self: MenuShell; takeFocus: bool) =
  gtk_menu_shell_set_take_focus(cast[ptr MenuShell00](self.impl), gboolean(takeFocus))

type
  MenuPrivate00* {.pure.} = object
  MenuPrivate* = ref object
    impl*: ptr MenuPrivate00

type
  ScrollType* {.size: sizeof(cint), pure.} = enum
    none = 0
    jump = 1
    stepBackward = 2
    stepForward = 3
    pageBackward = 4
    pageForward = 5
    stepUp = 6
    stepDown = 7
    pageUp = 8
    pageDown = 9
    stepLeft = 10
    stepRight = 11
    pageLeft = 12
    pageRight = 13
    start = 14
    `end` = 15

type
  Menu* = ref object of MenuShell
  Menu00* = object of MenuShell00
    priv4: ptr MenuPrivate00

proc scMoveScroll*(self: Menu;  p: proc (self: ptr gobject.Object00; scrollType: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-scroll", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPoppedUp*(self: Menu;  p: proc (self: ptr gobject.Object00; flippedRect: pointer; finalRect: pointer; flippedX: gboolean; 
    flippedY: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "popped-up", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_menu_new*(): ptr Menu00 {.
    importc: "gtk_menu_new", libprag.}

proc newMenu*(): Menu =
  new(result, finalizeGObject)
  result.impl = gtk_menu_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenu*[T](result: var T) =
  assert(result is Menu)
  new(result, finalizeGObject)
  result.impl = gtk_menu_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_new_from_model*(model: ptr gio.MenuModel00): ptr Menu00 {.
    importc: "gtk_menu_new_from_model", libprag.}

proc newMenuFromModel*(model: gio.MenuModel): Menu =
  new(result, finalizeGObject)
  result.impl = gtk_menu_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuFromModel*[T](result: var T; model: gio.MenuModel) =
  assert(result is Menu)
  new(result, finalizeGObject)
  result.impl = gtk_menu_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_get_for_attach_widget*(widget: ptr Widget00): ptr pointer {.
    importc: "gtk_menu_get_for_attach_widget", libprag.}

proc getForAttachWidget*(widget: Widget): ptr pointer =
  gtk_menu_get_for_attach_widget(cast[ptr Widget00](widget.impl))

proc forAttachWidget*(widget: Widget): ptr pointer =
  gtk_menu_get_for_attach_widget(cast[ptr Widget00](widget.impl))

proc gtk_menu_attach*(self: ptr Menu00; child: ptr Widget00; leftAttach: uint32; 
    rightAttach: uint32; topAttach: uint32; bottomAttach: uint32) {.
    importc: "gtk_menu_attach", libprag.}

proc attach*(self: Menu; child: Widget; leftAttach: int; rightAttach: int; 
    topAttach: int; bottomAttach: int) =
  gtk_menu_attach(cast[ptr Menu00](self.impl), cast[ptr Widget00](child.impl), uint32(leftAttach), uint32(rightAttach), uint32(topAttach), uint32(bottomAttach))

proc gtk_menu_detach*(self: ptr Menu00) {.
    importc: "gtk_menu_detach", libprag.}

proc detach*(self: Menu) =
  gtk_menu_detach(cast[ptr Menu00](self.impl))

proc gtk_menu_get_accel_group*(self: ptr Menu00): ptr AccelGroup00 {.
    importc: "gtk_menu_get_accel_group", libprag.}

proc getAccelGroup*(self: Menu): AccelGroup =
  let gobj = gtk_menu_get_accel_group(cast[ptr Menu00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[AccelGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accelGroup*(self: Menu): AccelGroup =
  let gobj = gtk_menu_get_accel_group(cast[ptr Menu00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[AccelGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_get_accel_path*(self: ptr Menu00): cstring {.
    importc: "gtk_menu_get_accel_path", libprag.}

proc getAccelPath*(self: Menu): string =
  let resul0 = gtk_menu_get_accel_path(cast[ptr Menu00](self.impl))
  result = $resul0

proc accelPath*(self: Menu): string =
  let resul0 = gtk_menu_get_accel_path(cast[ptr Menu00](self.impl))
  result = $resul0

proc gtk_menu_get_active*(self: ptr Menu00): ptr Widget00 {.
    importc: "gtk_menu_get_active", libprag.}

proc getActive*(self: Menu): Widget =
  let gobj = gtk_menu_get_active(cast[ptr Menu00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc active*(self: Menu): Widget =
  let gobj = gtk_menu_get_active(cast[ptr Menu00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_get_attach_widget*(self: ptr Menu00): ptr Widget00 {.
    importc: "gtk_menu_get_attach_widget", libprag.}

proc getAttachWidget*(self: Menu): Widget =
  let gobj = gtk_menu_get_attach_widget(cast[ptr Menu00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc attachWidget*(self: Menu): Widget =
  let gobj = gtk_menu_get_attach_widget(cast[ptr Menu00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_get_monitor*(self: ptr Menu00): int32 {.
    importc: "gtk_menu_get_monitor", libprag.}

proc getMonitor*(self: Menu): int =
  int(gtk_menu_get_monitor(cast[ptr Menu00](self.impl)))

proc monitor*(self: Menu): int =
  int(gtk_menu_get_monitor(cast[ptr Menu00](self.impl)))

proc gtk_menu_get_reserve_toggle_size*(self: ptr Menu00): gboolean {.
    importc: "gtk_menu_get_reserve_toggle_size", libprag.}

proc getReserveToggleSize*(self: Menu): bool =
  toBool(gtk_menu_get_reserve_toggle_size(cast[ptr Menu00](self.impl)))

proc reserveToggleSize*(self: Menu): bool =
  toBool(gtk_menu_get_reserve_toggle_size(cast[ptr Menu00](self.impl)))

proc gtk_menu_get_tearoff_state*(self: ptr Menu00): gboolean {.
    importc: "gtk_menu_get_tearoff_state", libprag.}

proc getTearoffState*(self: Menu): bool =
  toBool(gtk_menu_get_tearoff_state(cast[ptr Menu00](self.impl)))

proc tearoffState*(self: Menu): bool =
  toBool(gtk_menu_get_tearoff_state(cast[ptr Menu00](self.impl)))

proc gtk_menu_get_title*(self: ptr Menu00): cstring {.
    importc: "gtk_menu_get_title", libprag.}

proc getTitle*(self: Menu): string =
  let resul0 = gtk_menu_get_title(cast[ptr Menu00](self.impl))
  result = $resul0

proc title*(self: Menu): string =
  let resul0 = gtk_menu_get_title(cast[ptr Menu00](self.impl))
  result = $resul0

proc gtk_menu_place_on_monitor*(self: ptr Menu00; monitor: ptr gdk.Monitor00) {.
    importc: "gtk_menu_place_on_monitor", libprag.}

proc placeOnMonitor*(self: Menu; monitor: gdk.Monitor) =
  gtk_menu_place_on_monitor(cast[ptr Menu00](self.impl), cast[ptr gdk.Monitor00](monitor.impl))

proc gtk_menu_popdown*(self: ptr Menu00) {.
    importc: "gtk_menu_popdown", libprag.}

proc popdown*(self: Menu) =
  gtk_menu_popdown(cast[ptr Menu00](self.impl))

proc gtk_menu_popup_at_pointer*(self: ptr Menu00; triggerEvent: ptr gdk.Event00) {.
    importc: "gtk_menu_popup_at_pointer", libprag.}

proc popupAtPointer*(self: Menu; triggerEvent: gdk.Event) =
  gtk_menu_popup_at_pointer(cast[ptr Menu00](self.impl), cast[ptr gdk.Event00](triggerEvent.impl))

proc gtk_menu_popup_at_rect*(self: ptr Menu00; rectWindow: ptr gdk.Window00; rect: ptr gdk.Rectangle00; 
    rectAnchor: gdk.Gravity; menuAnchor: gdk.Gravity; triggerEvent: ptr gdk.Event00) {.
    importc: "gtk_menu_popup_at_rect", libprag.}

proc popupAtRect*(self: Menu; rectWindow: gdk.Window; rect: gdk.Rectangle; 
    rectAnchor: gdk.Gravity; menuAnchor: gdk.Gravity; triggerEvent: gdk.Event) =
  gtk_menu_popup_at_rect(cast[ptr Menu00](self.impl), cast[ptr gdk.Window00](rectWindow.impl), cast[ptr gdk.Rectangle00](rect.impl), rectAnchor, menuAnchor, cast[ptr gdk.Event00](triggerEvent.impl))

proc gtk_menu_popup_at_widget*(self: ptr Menu00; widget: ptr Widget00; widgetAnchor: gdk.Gravity; 
    menuAnchor: gdk.Gravity; triggerEvent: ptr gdk.Event00) {.
    importc: "gtk_menu_popup_at_widget", libprag.}

proc popupAtWidget*(self: Menu; widget: Widget; widgetAnchor: gdk.Gravity; 
    menuAnchor: gdk.Gravity; triggerEvent: gdk.Event) =
  gtk_menu_popup_at_widget(cast[ptr Menu00](self.impl), cast[ptr Widget00](widget.impl), widgetAnchor, menuAnchor, cast[ptr gdk.Event00](triggerEvent.impl))

proc gtk_menu_reorder_child*(self: ptr Menu00; child: ptr Widget00; position: int32) {.
    importc: "gtk_menu_reorder_child", libprag.}

proc reorderChild*(self: Menu; child: Widget; position: int) =
  gtk_menu_reorder_child(cast[ptr Menu00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_menu_reposition*(self: ptr Menu00) {.
    importc: "gtk_menu_reposition", libprag.}

proc reposition*(self: Menu) =
  gtk_menu_reposition(cast[ptr Menu00](self.impl))

proc gtk_menu_set_accel_group*(self: ptr Menu00; accelGroup: ptr AccelGroup00) {.
    importc: "gtk_menu_set_accel_group", libprag.}

proc setAccelGroup*(self: Menu; accelGroup: AccelGroup) =
  gtk_menu_set_accel_group(cast[ptr Menu00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc `accelGroup=`*(self: Menu; accelGroup: AccelGroup) =
  gtk_menu_set_accel_group(cast[ptr Menu00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_menu_set_accel_path*(self: ptr Menu00; accelPath: cstring) {.
    importc: "gtk_menu_set_accel_path", libprag.}

proc setAccelPath*(self: Menu; accelPath: string) =
  gtk_menu_set_accel_path(cast[ptr Menu00](self.impl), cstring(accelPath))

proc `accelPath=`*(self: Menu; accelPath: string) =
  gtk_menu_set_accel_path(cast[ptr Menu00](self.impl), cstring(accelPath))

proc gtk_menu_set_active*(self: ptr Menu00; index: uint32) {.
    importc: "gtk_menu_set_active", libprag.}

proc setActive*(self: Menu; index: int) =
  gtk_menu_set_active(cast[ptr Menu00](self.impl), uint32(index))

proc `active=`*(self: Menu; index: int) =
  gtk_menu_set_active(cast[ptr Menu00](self.impl), uint32(index))

proc gtk_menu_set_monitor*(self: ptr Menu00; monitorNum: int32) {.
    importc: "gtk_menu_set_monitor", libprag.}

proc setMonitor*(self: Menu; monitorNum: int) =
  gtk_menu_set_monitor(cast[ptr Menu00](self.impl), int32(monitorNum))

proc `monitor=`*(self: Menu; monitorNum: int) =
  gtk_menu_set_monitor(cast[ptr Menu00](self.impl), int32(monitorNum))

proc gtk_menu_set_reserve_toggle_size*(self: ptr Menu00; reserveToggleSize: gboolean) {.
    importc: "gtk_menu_set_reserve_toggle_size", libprag.}

proc setReserveToggleSize*(self: Menu; reserveToggleSize: bool) =
  gtk_menu_set_reserve_toggle_size(cast[ptr Menu00](self.impl), gboolean(reserveToggleSize))

proc `reserveToggleSize=`*(self: Menu; reserveToggleSize: bool) =
  gtk_menu_set_reserve_toggle_size(cast[ptr Menu00](self.impl), gboolean(reserveToggleSize))

proc gtk_menu_set_screen*(self: ptr Menu00; screen: ptr gdk.Screen00) {.
    importc: "gtk_menu_set_screen", libprag.}

proc setScreen*(self: Menu; screen: gdk.Screen) =
  gtk_menu_set_screen(cast[ptr Menu00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: Menu; screen: gdk.Screen) =
  gtk_menu_set_screen(cast[ptr Menu00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc gtk_menu_set_tearoff_state*(self: ptr Menu00; tornOff: gboolean) {.
    importc: "gtk_menu_set_tearoff_state", libprag.}

proc setTearoffState*(self: Menu; tornOff: bool) =
  gtk_menu_set_tearoff_state(cast[ptr Menu00](self.impl), gboolean(tornOff))

proc `tearoffState=`*(self: Menu; tornOff: bool) =
  gtk_menu_set_tearoff_state(cast[ptr Menu00](self.impl), gboolean(tornOff))

proc gtk_menu_set_title*(self: ptr Menu00; title: cstring) {.
    importc: "gtk_menu_set_title", libprag.}

proc setTitle*(self: Menu; title: string) =
  gtk_menu_set_title(cast[ptr Menu00](self.impl), cstring(title))

proc `title=`*(self: Menu; title: string) =
  gtk_menu_set_title(cast[ptr Menu00](self.impl), cstring(title))

type
  Label* = ref object of Misc
  Label00* = object of Misc00
    priv3: ptr LabelPrivate00

proc scActivateCurrentLink*(self: Label;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-current-link", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scActivateLink*(self: Label;  p: proc (self: ptr gobject.Object00; uri: cstring; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-link", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCopyClipboard*(self: Label;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "copy-clipboard", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveCursor*(self: Label;  p: proc (self: ptr gobject.Object00; step: MovementStep; count: int32; extendSelection: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopulatePopup*(self: Label;  p: proc (self: ptr gobject.Object00; menu: Menu00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_label_new*(str: cstring): ptr Label00 {.
    importc: "gtk_label_new", libprag.}

proc newLabel*(str: string): Label =
  new(result, finalizeGObject)
  result.impl = gtk_label_new(cstring(str))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLabel*[T](result: var T; str: string) =
  assert(result is Label)
  new(result, finalizeGObject)
  result.impl = gtk_label_new(cstring(str))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_new_with_mnemonic*(str: cstring): ptr Label00 {.
    importc: "gtk_label_new_with_mnemonic", libprag.}

proc newLabelWithMnemonic*(str: string): Label =
  new(result, finalizeGObject)
  result.impl = gtk_label_new_with_mnemonic(cstring(str))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLabelWithMnemonic*[T](result: var T; str: string) =
  assert(result is Label)
  new(result, finalizeGObject)
  result.impl = gtk_label_new_with_mnemonic(cstring(str))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_angle*(self: ptr Label00): cdouble {.
    importc: "gtk_label_get_angle", libprag.}

proc getAngle*(self: Label): cdouble =
  gtk_label_get_angle(cast[ptr Label00](self.impl))

proc angle*(self: Label): cdouble =
  gtk_label_get_angle(cast[ptr Label00](self.impl))

proc gtk_label_get_attributes*(self: ptr Label00): ptr pango.AttrList00 {.
    importc: "gtk_label_get_attributes", libprag.}

proc getAttributes*(self: Label): pango.AttrList =
  new(result)
  result.impl = gtk_label_get_attributes(cast[ptr Label00](self.impl))

proc attributes*(self: Label): pango.AttrList =
  new(result)
  result.impl = gtk_label_get_attributes(cast[ptr Label00](self.impl))

proc gtk_label_get_current_uri*(self: ptr Label00): cstring {.
    importc: "gtk_label_get_current_uri", libprag.}

proc getCurrentUri*(self: Label): string =
  let resul0 = gtk_label_get_current_uri(cast[ptr Label00](self.impl))
  result = $resul0

proc currentUri*(self: Label): string =
  let resul0 = gtk_label_get_current_uri(cast[ptr Label00](self.impl))
  result = $resul0

proc gtk_label_get_ellipsize*(self: ptr Label00): pango.EllipsizeMode {.
    importc: "gtk_label_get_ellipsize", libprag.}

proc getEllipsize*(self: Label): pango.EllipsizeMode =
  gtk_label_get_ellipsize(cast[ptr Label00](self.impl))

proc ellipsize*(self: Label): pango.EllipsizeMode =
  gtk_label_get_ellipsize(cast[ptr Label00](self.impl))

proc gtk_label_get_justify*(self: ptr Label00): Justification {.
    importc: "gtk_label_get_justify", libprag.}

proc getJustify*(self: Label): Justification =
  gtk_label_get_justify(cast[ptr Label00](self.impl))

proc justify*(self: Label): Justification =
  gtk_label_get_justify(cast[ptr Label00](self.impl))

proc gtk_label_get_label*(self: ptr Label00): cstring {.
    importc: "gtk_label_get_label", libprag.}

proc getLabel*(self: Label): string =
  let resul0 = gtk_label_get_label(cast[ptr Label00](self.impl))
  result = $resul0

proc label*(self: Label): string =
  let resul0 = gtk_label_get_label(cast[ptr Label00](self.impl))
  result = $resul0

proc gtk_label_get_layout*(self: ptr Label00): ptr pango.Layout00 {.
    importc: "gtk_label_get_layout", libprag.}

proc getLayout*(self: Label): pango.Layout =
  let gobj = gtk_label_get_layout(cast[ptr Label00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Layout](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layout*(self: Label): pango.Layout =
  let gobj = gtk_label_get_layout(cast[ptr Label00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Layout](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_layout_offsets*(self: ptr Label00; x: var int32; y: var int32) {.
    importc: "gtk_label_get_layout_offsets", libprag.}

proc getLayoutOffsets*(self: Label; x: var int; y: var int) =
  var y_00 = int32(y)
  var x_00 = int32(x)
  gtk_label_get_layout_offsets(cast[ptr Label00](self.impl), x_00, y_00)
  y = int(y_00)
  x = int(x_00)

proc layoutOffsets*(self: Label; x: var int; y: var int) =
  var y_00 = int32(y)
  var x_00 = int32(x)
  gtk_label_get_layout_offsets(cast[ptr Label00](self.impl), x_00, y_00)
  y = int(y_00)
  x = int(x_00)

proc gtk_label_get_line_wrap*(self: ptr Label00): gboolean {.
    importc: "gtk_label_get_line_wrap", libprag.}

proc getLineWrap*(self: Label): bool =
  toBool(gtk_label_get_line_wrap(cast[ptr Label00](self.impl)))

proc lineWrap*(self: Label): bool =
  toBool(gtk_label_get_line_wrap(cast[ptr Label00](self.impl)))

proc gtk_label_get_line_wrap_mode*(self: ptr Label00): pango.WrapMode {.
    importc: "gtk_label_get_line_wrap_mode", libprag.}

proc getLineWrapMode*(self: Label): pango.WrapMode =
  gtk_label_get_line_wrap_mode(cast[ptr Label00](self.impl))

proc lineWrapMode*(self: Label): pango.WrapMode =
  gtk_label_get_line_wrap_mode(cast[ptr Label00](self.impl))

proc gtk_label_get_lines*(self: ptr Label00): int32 {.
    importc: "gtk_label_get_lines", libprag.}

proc getLines*(self: Label): int =
  int(gtk_label_get_lines(cast[ptr Label00](self.impl)))

proc lines*(self: Label): int =
  int(gtk_label_get_lines(cast[ptr Label00](self.impl)))

proc gtk_label_get_max_width_chars*(self: ptr Label00): int32 {.
    importc: "gtk_label_get_max_width_chars", libprag.}

proc getMaxWidthChars*(self: Label): int =
  int(gtk_label_get_max_width_chars(cast[ptr Label00](self.impl)))

proc maxWidthChars*(self: Label): int =
  int(gtk_label_get_max_width_chars(cast[ptr Label00](self.impl)))

proc gtk_label_get_mnemonic_keyval*(self: ptr Label00): uint32 {.
    importc: "gtk_label_get_mnemonic_keyval", libprag.}

proc getMnemonicKeyval*(self: Label): int =
  int(gtk_label_get_mnemonic_keyval(cast[ptr Label00](self.impl)))

proc mnemonicKeyval*(self: Label): int =
  int(gtk_label_get_mnemonic_keyval(cast[ptr Label00](self.impl)))

proc gtk_label_get_mnemonic_widget*(self: ptr Label00): ptr Widget00 {.
    importc: "gtk_label_get_mnemonic_widget", libprag.}

proc getMnemonicWidget*(self: Label): Widget =
  let gobj = gtk_label_get_mnemonic_widget(cast[ptr Label00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc mnemonicWidget*(self: Label): Widget =
  let gobj = gtk_label_get_mnemonic_widget(cast[ptr Label00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_selectable*(self: ptr Label00): gboolean {.
    importc: "gtk_label_get_selectable", libprag.}

proc getSelectable*(self: Label): bool =
  toBool(gtk_label_get_selectable(cast[ptr Label00](self.impl)))

proc selectable*(self: Label): bool =
  toBool(gtk_label_get_selectable(cast[ptr Label00](self.impl)))

proc gtk_label_get_selection_bounds*(self: ptr Label00; start: var int32; `end`: var int32): gboolean {.
    importc: "gtk_label_get_selection_bounds", libprag.}

proc getSelectionBounds*(self: Label; start: var int; `end`: var int): bool =
  var end_00 = int32(`end`)
  var start_00 = int32(start)
  result = toBool(gtk_label_get_selection_bounds(cast[ptr Label00](self.impl), start_00, end_00))
  `end` = int(end_00)
  start = int(start_00)

proc selectionBounds*(self: Label; start: var int; `end`: var int): bool =
  var end_00 = int32(`end`)
  var start_00 = int32(start)
  result = toBool(gtk_label_get_selection_bounds(cast[ptr Label00](self.impl), start_00, end_00))
  `end` = int(end_00)
  start = int(start_00)

proc gtk_label_get_single_line_mode*(self: ptr Label00): gboolean {.
    importc: "gtk_label_get_single_line_mode", libprag.}

proc getSingleLineMode*(self: Label): bool =
  toBool(gtk_label_get_single_line_mode(cast[ptr Label00](self.impl)))

proc singleLineMode*(self: Label): bool =
  toBool(gtk_label_get_single_line_mode(cast[ptr Label00](self.impl)))

proc gtk_label_get_text*(self: ptr Label00): cstring {.
    importc: "gtk_label_get_text", libprag.}

proc getText*(self: Label): string =
  let resul0 = gtk_label_get_text(cast[ptr Label00](self.impl))
  result = $resul0

proc text*(self: Label): string =
  let resul0 = gtk_label_get_text(cast[ptr Label00](self.impl))
  result = $resul0

proc gtk_label_get_track_visited_links*(self: ptr Label00): gboolean {.
    importc: "gtk_label_get_track_visited_links", libprag.}

proc getTrackVisitedLinks*(self: Label): bool =
  toBool(gtk_label_get_track_visited_links(cast[ptr Label00](self.impl)))

proc trackVisitedLinks*(self: Label): bool =
  toBool(gtk_label_get_track_visited_links(cast[ptr Label00](self.impl)))

proc gtk_label_get_use_markup*(self: ptr Label00): gboolean {.
    importc: "gtk_label_get_use_markup", libprag.}

proc getUseMarkup*(self: Label): bool =
  toBool(gtk_label_get_use_markup(cast[ptr Label00](self.impl)))

proc useMarkup*(self: Label): bool =
  toBool(gtk_label_get_use_markup(cast[ptr Label00](self.impl)))

proc gtk_label_get_use_underline*(self: ptr Label00): gboolean {.
    importc: "gtk_label_get_use_underline", libprag.}

proc getUseUnderline*(self: Label): bool =
  toBool(gtk_label_get_use_underline(cast[ptr Label00](self.impl)))

proc useUnderline*(self: Label): bool =
  toBool(gtk_label_get_use_underline(cast[ptr Label00](self.impl)))

proc gtk_label_get_width_chars*(self: ptr Label00): int32 {.
    importc: "gtk_label_get_width_chars", libprag.}

proc getWidthChars*(self: Label): int =
  int(gtk_label_get_width_chars(cast[ptr Label00](self.impl)))

proc widthChars*(self: Label): int =
  int(gtk_label_get_width_chars(cast[ptr Label00](self.impl)))

proc gtk_label_get_xalign*(self: ptr Label00): cfloat {.
    importc: "gtk_label_get_xalign", libprag.}

proc getXalign*(self: Label): cfloat =
  gtk_label_get_xalign(cast[ptr Label00](self.impl))

proc xalign*(self: Label): cfloat =
  gtk_label_get_xalign(cast[ptr Label00](self.impl))

proc gtk_label_get_yalign*(self: ptr Label00): cfloat {.
    importc: "gtk_label_get_yalign", libprag.}

proc getYalign*(self: Label): cfloat =
  gtk_label_get_yalign(cast[ptr Label00](self.impl))

proc yalign*(self: Label): cfloat =
  gtk_label_get_yalign(cast[ptr Label00](self.impl))

proc gtk_label_select_region*(self: ptr Label00; startOffset: int32; endOffset: int32) {.
    importc: "gtk_label_select_region", libprag.}

proc selectRegion*(self: Label; startOffset: int; endOffset: int) =
  gtk_label_select_region(cast[ptr Label00](self.impl), int32(startOffset), int32(endOffset))

proc gtk_label_set_angle*(self: ptr Label00; angle: cdouble) {.
    importc: "gtk_label_set_angle", libprag.}

proc setAngle*(self: Label; angle: cdouble) =
  gtk_label_set_angle(cast[ptr Label00](self.impl), angle)

proc `angle=`*(self: Label; angle: cdouble) =
  gtk_label_set_angle(cast[ptr Label00](self.impl), angle)

proc gtk_label_set_attributes*(self: ptr Label00; attrs: ptr pango.AttrList00) {.
    importc: "gtk_label_set_attributes", libprag.}

proc setAttributes*(self: Label; attrs: pango.AttrList) =
  gtk_label_set_attributes(cast[ptr Label00](self.impl), cast[ptr pango.AttrList00](attrs.impl))

proc `attributes=`*(self: Label; attrs: pango.AttrList) =
  gtk_label_set_attributes(cast[ptr Label00](self.impl), cast[ptr pango.AttrList00](attrs.impl))

proc gtk_label_set_ellipsize*(self: ptr Label00; mode: pango.EllipsizeMode) {.
    importc: "gtk_label_set_ellipsize", libprag.}

proc setEllipsize*(self: Label; mode: pango.EllipsizeMode) =
  gtk_label_set_ellipsize(cast[ptr Label00](self.impl), mode)

proc `ellipsize=`*(self: Label; mode: pango.EllipsizeMode) =
  gtk_label_set_ellipsize(cast[ptr Label00](self.impl), mode)

proc gtk_label_set_justify*(self: ptr Label00; jtype: Justification) {.
    importc: "gtk_label_set_justify", libprag.}

proc setJustify*(self: Label; jtype: Justification) =
  gtk_label_set_justify(cast[ptr Label00](self.impl), jtype)

proc `justify=`*(self: Label; jtype: Justification) =
  gtk_label_set_justify(cast[ptr Label00](self.impl), jtype)

proc gtk_label_set_label*(self: ptr Label00; str: cstring) {.
    importc: "gtk_label_set_label", libprag.}

proc setLabel*(self: Label; str: string) =
  gtk_label_set_label(cast[ptr Label00](self.impl), cstring(str))

proc `label=`*(self: Label; str: string) =
  gtk_label_set_label(cast[ptr Label00](self.impl), cstring(str))

proc gtk_label_set_line_wrap*(self: ptr Label00; wrap: gboolean) {.
    importc: "gtk_label_set_line_wrap", libprag.}

proc setLineWrap*(self: Label; wrap: bool) =
  gtk_label_set_line_wrap(cast[ptr Label00](self.impl), gboolean(wrap))

proc `lineWrap=`*(self: Label; wrap: bool) =
  gtk_label_set_line_wrap(cast[ptr Label00](self.impl), gboolean(wrap))

proc gtk_label_set_line_wrap_mode*(self: ptr Label00; wrapMode: pango.WrapMode) {.
    importc: "gtk_label_set_line_wrap_mode", libprag.}

proc setLineWrapMode*(self: Label; wrapMode: pango.WrapMode) =
  gtk_label_set_line_wrap_mode(cast[ptr Label00](self.impl), wrapMode)

proc `lineWrapMode=`*(self: Label; wrapMode: pango.WrapMode) =
  gtk_label_set_line_wrap_mode(cast[ptr Label00](self.impl), wrapMode)

proc gtk_label_set_lines*(self: ptr Label00; lines: int32) {.
    importc: "gtk_label_set_lines", libprag.}

proc setLines*(self: Label; lines: int) =
  gtk_label_set_lines(cast[ptr Label00](self.impl), int32(lines))

proc `lines=`*(self: Label; lines: int) =
  gtk_label_set_lines(cast[ptr Label00](self.impl), int32(lines))

proc gtk_label_set_markup*(self: ptr Label00; str: cstring) {.
    importc: "gtk_label_set_markup", libprag.}

proc setMarkup*(self: Label; str: string) =
  gtk_label_set_markup(cast[ptr Label00](self.impl), cstring(str))

proc `markup=`*(self: Label; str: string) =
  gtk_label_set_markup(cast[ptr Label00](self.impl), cstring(str))

proc gtk_label_set_markup_with_mnemonic*(self: ptr Label00; str: cstring) {.
    importc: "gtk_label_set_markup_with_mnemonic", libprag.}

proc setMarkupWithMnemonic*(self: Label; str: string) =
  gtk_label_set_markup_with_mnemonic(cast[ptr Label00](self.impl), cstring(str))

proc `markupWithMnemonic=`*(self: Label; str: string) =
  gtk_label_set_markup_with_mnemonic(cast[ptr Label00](self.impl), cstring(str))

proc gtk_label_set_max_width_chars*(self: ptr Label00; nChars: int32) {.
    importc: "gtk_label_set_max_width_chars", libprag.}

proc setMaxWidthChars*(self: Label; nChars: int) =
  gtk_label_set_max_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc `maxWidthChars=`*(self: Label; nChars: int) =
  gtk_label_set_max_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc gtk_label_set_mnemonic_widget*(self: ptr Label00; widget: ptr Widget00) {.
    importc: "gtk_label_set_mnemonic_widget", libprag.}

proc setMnemonicWidget*(self: Label; widget: Widget) =
  gtk_label_set_mnemonic_widget(cast[ptr Label00](self.impl), cast[ptr Widget00](widget.impl))

proc `mnemonicWidget=`*(self: Label; widget: Widget) =
  gtk_label_set_mnemonic_widget(cast[ptr Label00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_label_set_pattern*(self: ptr Label00; pattern: cstring) {.
    importc: "gtk_label_set_pattern", libprag.}

proc setPattern*(self: Label; pattern: string) =
  gtk_label_set_pattern(cast[ptr Label00](self.impl), cstring(pattern))

proc `pattern=`*(self: Label; pattern: string) =
  gtk_label_set_pattern(cast[ptr Label00](self.impl), cstring(pattern))

proc gtk_label_set_selectable*(self: ptr Label00; setting: gboolean) {.
    importc: "gtk_label_set_selectable", libprag.}

proc setSelectable*(self: Label; setting: bool) =
  gtk_label_set_selectable(cast[ptr Label00](self.impl), gboolean(setting))

proc `selectable=`*(self: Label; setting: bool) =
  gtk_label_set_selectable(cast[ptr Label00](self.impl), gboolean(setting))

proc gtk_label_set_single_line_mode*(self: ptr Label00; singleLineMode: gboolean) {.
    importc: "gtk_label_set_single_line_mode", libprag.}

proc setSingleLineMode*(self: Label; singleLineMode: bool) =
  gtk_label_set_single_line_mode(cast[ptr Label00](self.impl), gboolean(singleLineMode))

proc `singleLineMode=`*(self: Label; singleLineMode: bool) =
  gtk_label_set_single_line_mode(cast[ptr Label00](self.impl), gboolean(singleLineMode))

proc gtk_label_set_text*(self: ptr Label00; str: cstring) {.
    importc: "gtk_label_set_text", libprag.}

proc setText*(self: Label; str: string) =
  gtk_label_set_text(cast[ptr Label00](self.impl), cstring(str))

proc `text=`*(self: Label; str: string) =
  gtk_label_set_text(cast[ptr Label00](self.impl), cstring(str))

proc gtk_label_set_text_with_mnemonic*(self: ptr Label00; str: cstring) {.
    importc: "gtk_label_set_text_with_mnemonic", libprag.}

proc setTextWithMnemonic*(self: Label; str: string) =
  gtk_label_set_text_with_mnemonic(cast[ptr Label00](self.impl), cstring(str))

proc `textWithMnemonic=`*(self: Label; str: string) =
  gtk_label_set_text_with_mnemonic(cast[ptr Label00](self.impl), cstring(str))

proc gtk_label_set_track_visited_links*(self: ptr Label00; trackLinks: gboolean) {.
    importc: "gtk_label_set_track_visited_links", libprag.}

proc setTrackVisitedLinks*(self: Label; trackLinks: bool) =
  gtk_label_set_track_visited_links(cast[ptr Label00](self.impl), gboolean(trackLinks))

proc `trackVisitedLinks=`*(self: Label; trackLinks: bool) =
  gtk_label_set_track_visited_links(cast[ptr Label00](self.impl), gboolean(trackLinks))

proc gtk_label_set_use_markup*(self: ptr Label00; setting: gboolean) {.
    importc: "gtk_label_set_use_markup", libprag.}

proc setUseMarkup*(self: Label; setting: bool) =
  gtk_label_set_use_markup(cast[ptr Label00](self.impl), gboolean(setting))

proc `useMarkup=`*(self: Label; setting: bool) =
  gtk_label_set_use_markup(cast[ptr Label00](self.impl), gboolean(setting))

proc gtk_label_set_use_underline*(self: ptr Label00; setting: gboolean) {.
    importc: "gtk_label_set_use_underline", libprag.}

proc setUseUnderline*(self: Label; setting: bool) =
  gtk_label_set_use_underline(cast[ptr Label00](self.impl), gboolean(setting))

proc `useUnderline=`*(self: Label; setting: bool) =
  gtk_label_set_use_underline(cast[ptr Label00](self.impl), gboolean(setting))

proc gtk_label_set_width_chars*(self: ptr Label00; nChars: int32) {.
    importc: "gtk_label_set_width_chars", libprag.}

proc setWidthChars*(self: Label; nChars: int) =
  gtk_label_set_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc `widthChars=`*(self: Label; nChars: int) =
  gtk_label_set_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc gtk_label_set_xalign*(self: ptr Label00; xalign: cfloat) {.
    importc: "gtk_label_set_xalign", libprag.}

proc setXalign*(self: Label; xalign: cfloat) =
  gtk_label_set_xalign(cast[ptr Label00](self.impl), xalign)

proc `xalign=`*(self: Label; xalign: cfloat) =
  gtk_label_set_xalign(cast[ptr Label00](self.impl), xalign)

proc gtk_label_set_yalign*(self: ptr Label00; yalign: cfloat) {.
    importc: "gtk_label_set_yalign", libprag.}

proc setYalign*(self: Label; yalign: cfloat) =
  gtk_label_set_yalign(cast[ptr Label00](self.impl), yalign)

proc `yalign=`*(self: Label; yalign: cfloat) =
  gtk_label_set_yalign(cast[ptr Label00](self.impl), yalign)

type
  AccelLabelPrivate00* {.pure.} = object
  AccelLabelPrivate* = ref object
    impl*: ptr AccelLabelPrivate00

type
  AccelLabel* = ref object of Label
  AccelLabel00* = object of Label00
    priv4: ptr AccelLabelPrivate00

proc gtk_accel_label_new*(string: cstring): ptr AccelLabel00 {.
    importc: "gtk_accel_label_new", libprag.}

proc newAccelLabel*(string: string): AccelLabel =
  new(result, finalizeGObject)
  result.impl = gtk_accel_label_new(cstring(string))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAccelLabel*[T](result: var T; string: string) =
  assert(result is AccelLabel)
  new(result, finalizeGObject)
  result.impl = gtk_accel_label_new(cstring(string))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accel_label_get_accel*(self: ptr AccelLabel00; acceleratorKey: var uint32; 
    acceleratorMods: var gdk.ModifierType) {.
    importc: "gtk_accel_label_get_accel", libprag.}

proc getAccel*(self: AccelLabel; acceleratorKey: var int; acceleratorMods: var gdk.ModifierType) =
  var acceleratorKey_00 = uint32(acceleratorKey)
  gtk_accel_label_get_accel(cast[ptr AccelLabel00](self.impl), acceleratorKey_00, acceleratorMods)
  acceleratorKey = int(acceleratorKey_00)

proc accel*(self: AccelLabel; acceleratorKey: var int; acceleratorMods: var gdk.ModifierType) =
  var acceleratorKey_00 = uint32(acceleratorKey)
  gtk_accel_label_get_accel(cast[ptr AccelLabel00](self.impl), acceleratorKey_00, acceleratorMods)
  acceleratorKey = int(acceleratorKey_00)

proc gtk_accel_label_get_accel_widget*(self: ptr AccelLabel00): ptr Widget00 {.
    importc: "gtk_accel_label_get_accel_widget", libprag.}

proc getAccelWidget*(self: AccelLabel): Widget =
  let gobj = gtk_accel_label_get_accel_widget(cast[ptr AccelLabel00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accelWidget*(self: AccelLabel): Widget =
  let gobj = gtk_accel_label_get_accel_widget(cast[ptr AccelLabel00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accel_label_get_accel_width*(self: ptr AccelLabel00): uint32 {.
    importc: "gtk_accel_label_get_accel_width", libprag.}

proc getAccelWidth*(self: AccelLabel): int =
  int(gtk_accel_label_get_accel_width(cast[ptr AccelLabel00](self.impl)))

proc accelWidth*(self: AccelLabel): int =
  int(gtk_accel_label_get_accel_width(cast[ptr AccelLabel00](self.impl)))

proc gtk_accel_label_refetch*(self: ptr AccelLabel00): gboolean {.
    importc: "gtk_accel_label_refetch", libprag.}

proc refetch*(self: AccelLabel): bool =
  toBool(gtk_accel_label_refetch(cast[ptr AccelLabel00](self.impl)))

proc gtk_accel_label_set_accel*(self: ptr AccelLabel00; acceleratorKey: uint32; acceleratorMods: gdk.ModifierType) {.
    importc: "gtk_accel_label_set_accel", libprag.}

proc setAccel*(self: AccelLabel; acceleratorKey: int; acceleratorMods: gdk.ModifierType) =
  gtk_accel_label_set_accel(cast[ptr AccelLabel00](self.impl), uint32(acceleratorKey), acceleratorMods)

proc gtk_accel_label_set_accel_closure*(self: ptr AccelLabel00; accelClosure: ptr gobject.Closure00) {.
    importc: "gtk_accel_label_set_accel_closure", libprag.}

proc setAccelClosure*(self: AccelLabel; accelClosure: gobject.Closure) =
  gtk_accel_label_set_accel_closure(cast[ptr AccelLabel00](self.impl), cast[ptr gobject.Closure00](accelClosure.impl))

proc `accelClosure=`*(self: AccelLabel; accelClosure: gobject.Closure) =
  gtk_accel_label_set_accel_closure(cast[ptr AccelLabel00](self.impl), cast[ptr gobject.Closure00](accelClosure.impl))

proc gtk_accel_label_set_accel_widget*(self: ptr AccelLabel00; accelWidget: ptr Widget00) {.
    importc: "gtk_accel_label_set_accel_widget", libprag.}

proc setAccelWidget*(self: AccelLabel; accelWidget: Widget) =
  gtk_accel_label_set_accel_widget(cast[ptr AccelLabel00](self.impl), cast[ptr Widget00](accelWidget.impl))

proc `accelWidget=`*(self: AccelLabel; accelWidget: Widget) =
  gtk_accel_label_set_accel_widget(cast[ptr AccelLabel00](self.impl), cast[ptr Widget00](accelWidget.impl))

type
  MenuItemPrivate00* {.pure.} = object
  MenuItemPrivate* = ref object
    impl*: ptr MenuItemPrivate00

type
  MenuItem* = ref object of Bin
  MenuItem00* = object of Bin00
    priv4: ptr MenuItemPrivate00

proc scActivate*(self: MenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scActivateItem*(self: MenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-item", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDeselect*(self: MenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "deselect", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelect*(self: MenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleSizeAllocate*(self: MenuItem;  p: proc (self: ptr gobject.Object00; `object`: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-size-allocate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleSizeRequest*(self: MenuItem;  p: proc (self: ptr gobject.Object00; `object`: pointer; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-size-request", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_menu_item_new*(): ptr MenuItem00 {.
    importc: "gtk_menu_item_new", libprag.}

proc newMenuItem*(): MenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuItem*[T](result: var T) =
  assert(result is MenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_item_new_with_label*(label: cstring): ptr MenuItem00 {.
    importc: "gtk_menu_item_new_with_label", libprag.}

proc newMenuItemWithLabel*(label: string): MenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_menu_item_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuItemWithLabel*[T](result: var T; label: string) =
  assert(result is MenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_menu_item_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_item_new_with_mnemonic*(label: cstring): ptr MenuItem00 {.
    importc: "gtk_menu_item_new_with_mnemonic", libprag.}

proc newMenuItemWithMnemonic*(label: string): MenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_menu_item_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuItemWithMnemonic*[T](result: var T; label: string) =
  assert(result is MenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_menu_item_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_item_activate*(self: ptr MenuItem00) {.
    importc: "gtk_menu_item_activate", libprag.}

proc activate*(self: MenuItem) =
  gtk_menu_item_activate(cast[ptr MenuItem00](self.impl))

proc gtk_menu_item_deselect*(self: ptr MenuItem00) {.
    importc: "gtk_menu_item_deselect", libprag.}

proc deselect*(self: MenuItem) =
  gtk_menu_item_deselect(cast[ptr MenuItem00](self.impl))

proc gtk_menu_item_get_accel_path*(self: ptr MenuItem00): cstring {.
    importc: "gtk_menu_item_get_accel_path", libprag.}

proc getAccelPath*(self: MenuItem): string =
  let resul0 = gtk_menu_item_get_accel_path(cast[ptr MenuItem00](self.impl))
  result = $resul0

proc accelPath*(self: MenuItem): string =
  let resul0 = gtk_menu_item_get_accel_path(cast[ptr MenuItem00](self.impl))
  result = $resul0

proc gtk_menu_item_get_label*(self: ptr MenuItem00): cstring {.
    importc: "gtk_menu_item_get_label", libprag.}

proc getLabel*(self: MenuItem): string =
  let resul0 = gtk_menu_item_get_label(cast[ptr MenuItem00](self.impl))
  result = $resul0

proc label*(self: MenuItem): string =
  let resul0 = gtk_menu_item_get_label(cast[ptr MenuItem00](self.impl))
  result = $resul0

proc gtk_menu_item_get_reserve_indicator*(self: ptr MenuItem00): gboolean {.
    importc: "gtk_menu_item_get_reserve_indicator", libprag.}

proc getReserveIndicator*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_reserve_indicator(cast[ptr MenuItem00](self.impl)))

proc reserveIndicator*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_reserve_indicator(cast[ptr MenuItem00](self.impl)))

proc gtk_menu_item_get_right_justified*(self: ptr MenuItem00): gboolean {.
    importc: "gtk_menu_item_get_right_justified", libprag.}

proc getRightJustified*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_right_justified(cast[ptr MenuItem00](self.impl)))

proc rightJustified*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_right_justified(cast[ptr MenuItem00](self.impl)))

proc gtk_menu_item_get_submenu*(self: ptr MenuItem00): ptr Widget00 {.
    importc: "gtk_menu_item_get_submenu", libprag.}

proc getSubmenu*(self: MenuItem): Widget =
  let gobj = gtk_menu_item_get_submenu(cast[ptr MenuItem00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc submenu*(self: MenuItem): Widget =
  let gobj = gtk_menu_item_get_submenu(cast[ptr MenuItem00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_item_get_use_underline*(self: ptr MenuItem00): gboolean {.
    importc: "gtk_menu_item_get_use_underline", libprag.}

proc getUseUnderline*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_use_underline(cast[ptr MenuItem00](self.impl)))

proc useUnderline*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_use_underline(cast[ptr MenuItem00](self.impl)))

proc gtk_menu_item_select*(self: ptr MenuItem00) {.
    importc: "gtk_menu_item_select", libprag.}

proc select*(self: MenuItem) =
  gtk_menu_item_select(cast[ptr MenuItem00](self.impl))

proc gtk_menu_item_set_accel_path*(self: ptr MenuItem00; accelPath: cstring) {.
    importc: "gtk_menu_item_set_accel_path", libprag.}

proc setAccelPath*(self: MenuItem; accelPath: string) =
  gtk_menu_item_set_accel_path(cast[ptr MenuItem00](self.impl), cstring(accelPath))

proc `accelPath=`*(self: MenuItem; accelPath: string) =
  gtk_menu_item_set_accel_path(cast[ptr MenuItem00](self.impl), cstring(accelPath))

proc gtk_menu_item_set_label*(self: ptr MenuItem00; label: cstring) {.
    importc: "gtk_menu_item_set_label", libprag.}

proc setLabel*(self: MenuItem; label: string) =
  gtk_menu_item_set_label(cast[ptr MenuItem00](self.impl), cstring(label))

proc `label=`*(self: MenuItem; label: string) =
  gtk_menu_item_set_label(cast[ptr MenuItem00](self.impl), cstring(label))

proc gtk_menu_item_set_reserve_indicator*(self: ptr MenuItem00; reserve: gboolean) {.
    importc: "gtk_menu_item_set_reserve_indicator", libprag.}

proc setReserveIndicator*(self: MenuItem; reserve: bool) =
  gtk_menu_item_set_reserve_indicator(cast[ptr MenuItem00](self.impl), gboolean(reserve))

proc `reserveIndicator=`*(self: MenuItem; reserve: bool) =
  gtk_menu_item_set_reserve_indicator(cast[ptr MenuItem00](self.impl), gboolean(reserve))

proc gtk_menu_item_set_right_justified*(self: ptr MenuItem00; rightJustified: gboolean) {.
    importc: "gtk_menu_item_set_right_justified", libprag.}

proc setRightJustified*(self: MenuItem; rightJustified: bool) =
  gtk_menu_item_set_right_justified(cast[ptr MenuItem00](self.impl), gboolean(rightJustified))

proc `rightJustified=`*(self: MenuItem; rightJustified: bool) =
  gtk_menu_item_set_right_justified(cast[ptr MenuItem00](self.impl), gboolean(rightJustified))

proc gtk_menu_item_set_submenu*(self: ptr MenuItem00; submenu: ptr Menu00) {.
    importc: "gtk_menu_item_set_submenu", libprag.}

proc setSubmenu*(self: MenuItem; submenu: Menu) =
  gtk_menu_item_set_submenu(cast[ptr MenuItem00](self.impl), cast[ptr Menu00](submenu.impl))

proc `submenu=`*(self: MenuItem; submenu: Menu) =
  gtk_menu_item_set_submenu(cast[ptr MenuItem00](self.impl), cast[ptr Menu00](submenu.impl))

proc gtk_menu_item_set_use_underline*(self: ptr MenuItem00; setting: gboolean) {.
    importc: "gtk_menu_item_set_use_underline", libprag.}

proc setUseUnderline*(self: MenuItem; setting: bool) =
  gtk_menu_item_set_use_underline(cast[ptr MenuItem00](self.impl), gboolean(setting))

proc `useUnderline=`*(self: MenuItem; setting: bool) =
  gtk_menu_item_set_use_underline(cast[ptr MenuItem00](self.impl), gboolean(setting))

proc gtk_menu_item_toggle_size_allocate*(self: ptr MenuItem00; allocation: int32) {.
    importc: "gtk_menu_item_toggle_size_allocate", libprag.}

proc toggleSizeAllocate*(self: MenuItem; allocation: int) =
  gtk_menu_item_toggle_size_allocate(cast[ptr MenuItem00](self.impl), int32(allocation))

proc gtk_menu_item_toggle_size_request*(self: ptr MenuItem00; requisition: int32) {.
    importc: "gtk_menu_item_toggle_size_request", libprag.}

proc toggleSizeRequest*(self: MenuItem; requisition: int) =
  gtk_menu_item_toggle_size_request(cast[ptr MenuItem00](self.impl), int32(requisition))

proc gtk_menu_shell_append*(self: ptr MenuShell00; child: ptr MenuItem00) {.
    importc: "gtk_menu_shell_append", libprag.}

proc append*(self: MenuShell; child: MenuItem) =
  gtk_menu_shell_append(cast[ptr MenuShell00](self.impl), cast[ptr MenuItem00](child.impl))

type
  MiscClass00* {.pure.} = object
    parentClass*: WidgetClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  MiscClass* = ref object
    impl*: ptr MiscClass00

type
  LabelClass00* {.pure.} = object
    parentClass*: MiscClass00
    moveCursor*: proc(label: ptr Label00; step: MovementStep; count: int32; 
    extendSelection: gboolean) {.cdecl.}
    copyClipboard*: proc(label: ptr Label00) {.cdecl.}
    populatePopup*: proc(label: ptr Label00; menu: ptr Menu00) {.cdecl.}
    activateLink*: proc(label: ptr Label00; uri: cstring): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  LabelClass* = ref object
    impl*: ptr LabelClass00

type
  AccelLabelClass00* {.pure.} = object
    parentClass*: LabelClass00
    signalQuote1*: cstring
    signalQuote2*: cstring
    modNameShift*: cstring
    modNameControl*: cstring
    modNameAlt*: cstring
    modSeparator*: cstring
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  AccelLabelClass* = ref object
    impl*: ptr AccelLabelClass00

type
  AccelMap* = ref object of gobject.Object
  AccelMap00* = object of gobject.Object00

proc scChanged*(self: AccelMap;  p: proc (self: ptr gobject.Object00; accelPath: cstring; accelKey: uint32; accelMods: gdk.ModifierType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_accel_map_add_entry*(accelPath: cstring; accelKey: uint32; accelMods: gdk.ModifierType) {.
    importc: "gtk_accel_map_add_entry", libprag.}

proc addEntry*(accelPath: cstring; accelKey: uint32; accelMods: gdk.ModifierType) {.
    importc: "gtk_accel_map_add_entry", libprag.}

proc gtk_accel_map_add_filter*(filterPattern: cstring) {.
    importc: "gtk_accel_map_add_filter", libprag.}

proc addFilter*(filterPattern: cstring) {.
    importc: "gtk_accel_map_add_filter", libprag.}

proc gtk_accel_map_change_entry*(accelPath: cstring; accelKey: uint32; accelMods: gdk.ModifierType; 
    replace: gboolean): gboolean {.
    importc: "gtk_accel_map_change_entry", libprag.}

proc changeEntry*(accelPath: cstring; accelKey: uint32; accelMods: gdk.ModifierType; 
    replace: gboolean): gboolean {.
    importc: "gtk_accel_map_change_entry", libprag.}

proc gtk_accel_map_get*(): ptr AccelMap00 {.
    importc: "gtk_accel_map_get", libprag.}

proc get*(): AccelMap =
  let gobj = gtk_accel_map_get()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[AccelMap](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accel_map_load*(fileName: ucstring) {.
    importc: "gtk_accel_map_load", libprag.}

proc load*(fileName: ucstring) {.
    importc: "gtk_accel_map_load", libprag.}

proc gtk_accel_map_load_fd*(fd: int32) {.
    importc: "gtk_accel_map_load_fd", libprag.}

proc loadFd*(fd: int32) {.
    importc: "gtk_accel_map_load_fd", libprag.}

proc gtk_accel_map_load_scanner*(scanner: ptr glib.Scanner00) {.
    importc: "gtk_accel_map_load_scanner", libprag.}

proc loadScanner*(scanner: glib.Scanner) =
  gtk_accel_map_load_scanner(cast[ptr glib.Scanner00](scanner.impl))

proc gtk_accel_map_lock_path*(accelPath: cstring) {.
    importc: "gtk_accel_map_lock_path", libprag.}

proc lockPath*(accelPath: cstring) {.
    importc: "gtk_accel_map_lock_path", libprag.}

proc gtk_accel_map_lookup_entry*(accelPath: cstring; key: var AccelKey00): gboolean {.
    importc: "gtk_accel_map_lookup_entry", libprag.}

proc lookupEntry*(accelPath: cstring; key: var AccelKey00): gboolean {.
    importc: "gtk_accel_map_lookup_entry", libprag.}

proc gtk_accel_map_save*(fileName: ucstring) {.
    importc: "gtk_accel_map_save", libprag.}

proc save*(fileName: ucstring) {.
    importc: "gtk_accel_map_save", libprag.}

proc gtk_accel_map_save_fd*(fd: int32) {.
    importc: "gtk_accel_map_save_fd", libprag.}

proc saveFd*(fd: int32) {.
    importc: "gtk_accel_map_save_fd", libprag.}

proc gtk_accel_map_unlock_path*(accelPath: cstring) {.
    importc: "gtk_accel_map_unlock_path", libprag.}

proc unlockPath*(accelPath: cstring) {.
    importc: "gtk_accel_map_unlock_path", libprag.}

type
  AccelMapClass00* {.pure.} = object
  AccelMapClass* = ref object
    impl*: ptr AccelMapClass00

type
  AccelMapForeach* = proc (data: pointer; accelPath: cstring; accelKey: uint32; 
    accelMods: gdk.ModifierType; changed: gboolean) {.cdecl.}

proc gtk_accel_map_foreach*(data: pointer; foreachFunc: AccelMapForeach) {.
    importc: "gtk_accel_map_foreach", libprag.}

proc foreach*(data: pointer; foreachFunc: AccelMapForeach) {.
    importc: "gtk_accel_map_foreach", libprag.}

proc gtk_accel_map_foreach_unfiltered*(data: pointer; foreachFunc: AccelMapForeach) {.
    importc: "gtk_accel_map_foreach_unfiltered", libprag.}

proc foreachUnfiltered*(data: pointer; foreachFunc: AccelMapForeach) {.
    importc: "gtk_accel_map_foreach_unfiltered", libprag.}

type
  AccessiblePrivate00* {.pure.} = object
  AccessiblePrivate* = ref object
    impl*: ptr AccessiblePrivate00

type
  Accessible* = ref object of atk.Object
  Accessible00* = object of atk.Object00
    priv1: ptr AccessiblePrivate00

proc gtk_accessible_connect_widget_destroyed*(self: ptr Accessible00) {.
    importc: "gtk_accessible_connect_widget_destroyed", libprag.}

proc connectWidgetDestroyed*(self: Accessible) =
  gtk_accessible_connect_widget_destroyed(cast[ptr Accessible00](self.impl))

proc gtk_accessible_get_widget*(self: ptr Accessible00): ptr Widget00 {.
    importc: "gtk_accessible_get_widget", libprag.}

proc getWidget*(self: Accessible): Widget =
  let gobj = gtk_accessible_get_widget(cast[ptr Accessible00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: Accessible): Widget =
  let gobj = gtk_accessible_get_widget(cast[ptr Accessible00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accessible_set_widget*(self: ptr Accessible00; widget: ptr Widget00) {.
    importc: "gtk_accessible_set_widget", libprag.}

proc setWidget*(self: Accessible; widget: Widget) =
  gtk_accessible_set_widget(cast[ptr Accessible00](self.impl), cast[ptr Widget00](widget.impl))

proc `widget=`*(self: Accessible; widget: Widget) =
  gtk_accessible_set_widget(cast[ptr Accessible00](self.impl), cast[ptr Widget00](widget.impl))

type
  AccessibleClass00* {.pure.} = object
    parentClass*: atk.ObjectClass00
    connectWidgetDestroyed*: proc(accessible: ptr Accessible00) {.cdecl.}
    widgetSet*: proc(accessible: ptr Accessible00) {.cdecl.}
    widgetUnset*: proc(accessible: ptr Accessible00) {.cdecl.}
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  AccessibleClass* = ref object
    impl*: ptr AccessibleClass00

type
  ActionPrivate00* {.pure.} = object
  ActionPrivate* = ref object
    impl*: ptr ActionPrivate00

type
  Action* = ref object of gobject.Object
  Action00* = object of gobject.Object00
    privateData1: ptr ActionPrivate00

proc scActivate*(self: Action;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_action_new*(name: cstring; label: cstring; tooltip: cstring; stockId: cstring): ptr Action00 {.
    importc: "gtk_action_new", libprag.}

proc newAction*(name: string; label: string; tooltip: string; stockId: string): Action =
  new(result, finalizeGObject)
  result.impl = gtk_action_new(cstring(name), cstring(label), cstring(tooltip), cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAction*[T](result: var T; name: string; label: string; tooltip: string; stockId: string) =
  assert(result is Action)
  new(result, finalizeGObject)
  result.impl = gtk_action_new(cstring(name), cstring(label), cstring(tooltip), cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_activate*(self: ptr Action00) {.
    importc: "gtk_action_activate", libprag.}

proc activate*(self: Action) =
  gtk_action_activate(cast[ptr Action00](self.impl))

proc gtk_action_block_activate*(self: ptr Action00) {.
    importc: "gtk_action_block_activate", libprag.}

proc blockActivate*(self: Action) =
  gtk_action_block_activate(cast[ptr Action00](self.impl))

proc gtk_action_connect_accelerator*(self: ptr Action00) {.
    importc: "gtk_action_connect_accelerator", libprag.}

proc connectAccelerator*(self: Action) =
  gtk_action_connect_accelerator(cast[ptr Action00](self.impl))

proc gtk_action_create_icon*(self: ptr Action00; iconSize: int32): ptr Widget00 {.
    importc: "gtk_action_create_icon", libprag.}

proc createIcon*(self: Action; iconSize: int): Widget =
  let gobj = gtk_action_create_icon(cast[ptr Action00](self.impl), int32(iconSize))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_create_menu*(self: ptr Action00): ptr Widget00 {.
    importc: "gtk_action_create_menu", libprag.}

proc createMenu*(self: Action): Widget =
  let gobj = gtk_action_create_menu(cast[ptr Action00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_create_menu_item*(self: ptr Action00): ptr Widget00 {.
    importc: "gtk_action_create_menu_item", libprag.}

proc createMenuItem*(self: Action): Widget =
  let gobj = gtk_action_create_menu_item(cast[ptr Action00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_create_tool_item*(self: ptr Action00): ptr Widget00 {.
    importc: "gtk_action_create_tool_item", libprag.}

proc createToolItem*(self: Action): Widget =
  let gobj = gtk_action_create_tool_item(cast[ptr Action00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_disconnect_accelerator*(self: ptr Action00) {.
    importc: "gtk_action_disconnect_accelerator", libprag.}

proc disconnectAccelerator*(self: Action) =
  gtk_action_disconnect_accelerator(cast[ptr Action00](self.impl))

proc gtk_action_get_accel_closure*(self: ptr Action00): ptr gobject.Closure00 {.
    importc: "gtk_action_get_accel_closure", libprag.}

proc getAccelClosure*(self: Action): gobject.Closure =
  new(result)
  result.impl = gtk_action_get_accel_closure(cast[ptr Action00](self.impl))

proc accelClosure*(self: Action): gobject.Closure =
  new(result)
  result.impl = gtk_action_get_accel_closure(cast[ptr Action00](self.impl))

proc gtk_action_get_accel_path*(self: ptr Action00): cstring {.
    importc: "gtk_action_get_accel_path", libprag.}

proc getAccelPath*(self: Action): string =
  let resul0 = gtk_action_get_accel_path(cast[ptr Action00](self.impl))
  result = $resul0

proc accelPath*(self: Action): string =
  let resul0 = gtk_action_get_accel_path(cast[ptr Action00](self.impl))
  result = $resul0

proc gtk_action_get_always_show_image*(self: ptr Action00): gboolean {.
    importc: "gtk_action_get_always_show_image", libprag.}

proc getAlwaysShowImage*(self: Action): bool =
  toBool(gtk_action_get_always_show_image(cast[ptr Action00](self.impl)))

proc alwaysShowImage*(self: Action): bool =
  toBool(gtk_action_get_always_show_image(cast[ptr Action00](self.impl)))

proc gtk_action_get_gicon*(self: ptr Action00): ptr gio.Icon00 {.
    importc: "gtk_action_get_gicon", libprag.}

proc getGicon*(self: Action): gio.Icon =
  new(result)
  result.impl = gtk_action_get_gicon(cast[ptr Action00](self.impl))

proc gicon*(self: Action): gio.Icon =
  new(result)
  result.impl = gtk_action_get_gicon(cast[ptr Action00](self.impl))

proc gtk_action_get_icon_name*(self: ptr Action00): cstring {.
    importc: "gtk_action_get_icon_name", libprag.}

proc getIconName*(self: Action): string =
  let resul0 = gtk_action_get_icon_name(cast[ptr Action00](self.impl))
  result = $resul0

proc iconName*(self: Action): string =
  let resul0 = gtk_action_get_icon_name(cast[ptr Action00](self.impl))
  result = $resul0

proc gtk_action_get_is_important*(self: ptr Action00): gboolean {.
    importc: "gtk_action_get_is_important", libprag.}

proc getIsImportant*(self: Action): bool =
  toBool(gtk_action_get_is_important(cast[ptr Action00](self.impl)))

proc isImportant*(self: Action): bool =
  toBool(gtk_action_get_is_important(cast[ptr Action00](self.impl)))

proc gtk_action_get_label*(self: ptr Action00): cstring {.
    importc: "gtk_action_get_label", libprag.}

proc getLabel*(self: Action): string =
  let resul0 = gtk_action_get_label(cast[ptr Action00](self.impl))
  result = $resul0

proc label*(self: Action): string =
  let resul0 = gtk_action_get_label(cast[ptr Action00](self.impl))
  result = $resul0

proc gtk_action_get_name*(self: ptr Action00): cstring {.
    importc: "gtk_action_get_name", libprag.}

proc getName*(self: Action): string =
  let resul0 = gtk_action_get_name(cast[ptr Action00](self.impl))
  result = $resul0

proc name*(self: Action): string =
  let resul0 = gtk_action_get_name(cast[ptr Action00](self.impl))
  result = $resul0

proc gtk_action_get_proxies*(self: ptr Action00): ptr pointer {.
    importc: "gtk_action_get_proxies", libprag.}

proc getProxies*(self: Action): ptr pointer =
  gtk_action_get_proxies(cast[ptr Action00](self.impl))

proc proxies*(self: Action): ptr pointer =
  gtk_action_get_proxies(cast[ptr Action00](self.impl))

proc gtk_action_get_sensitive*(self: ptr Action00): gboolean {.
    importc: "gtk_action_get_sensitive", libprag.}

proc getSensitive*(self: Action): bool =
  toBool(gtk_action_get_sensitive(cast[ptr Action00](self.impl)))

proc sensitive*(self: Action): bool =
  toBool(gtk_action_get_sensitive(cast[ptr Action00](self.impl)))

proc gtk_action_get_short_label*(self: ptr Action00): cstring {.
    importc: "gtk_action_get_short_label", libprag.}

proc getShortLabel*(self: Action): string =
  let resul0 = gtk_action_get_short_label(cast[ptr Action00](self.impl))
  result = $resul0

proc shortLabel*(self: Action): string =
  let resul0 = gtk_action_get_short_label(cast[ptr Action00](self.impl))
  result = $resul0

proc gtk_action_get_stock_id*(self: ptr Action00): cstring {.
    importc: "gtk_action_get_stock_id", libprag.}

proc getStockId*(self: Action): string =
  let resul0 = gtk_action_get_stock_id(cast[ptr Action00](self.impl))
  result = $resul0

proc stockId*(self: Action): string =
  let resul0 = gtk_action_get_stock_id(cast[ptr Action00](self.impl))
  result = $resul0

proc gtk_action_get_tooltip*(self: ptr Action00): cstring {.
    importc: "gtk_action_get_tooltip", libprag.}

proc getTooltip*(self: Action): string =
  let resul0 = gtk_action_get_tooltip(cast[ptr Action00](self.impl))
  result = $resul0

proc tooltip*(self: Action): string =
  let resul0 = gtk_action_get_tooltip(cast[ptr Action00](self.impl))
  result = $resul0

proc gtk_action_get_visible*(self: ptr Action00): gboolean {.
    importc: "gtk_action_get_visible", libprag.}

proc getVisible*(self: Action): bool =
  toBool(gtk_action_get_visible(cast[ptr Action00](self.impl)))

proc visible*(self: Action): bool =
  toBool(gtk_action_get_visible(cast[ptr Action00](self.impl)))

proc gtk_action_get_visible_horizontal*(self: ptr Action00): gboolean {.
    importc: "gtk_action_get_visible_horizontal", libprag.}

proc getVisibleHorizontal*(self: Action): bool =
  toBool(gtk_action_get_visible_horizontal(cast[ptr Action00](self.impl)))

proc visibleHorizontal*(self: Action): bool =
  toBool(gtk_action_get_visible_horizontal(cast[ptr Action00](self.impl)))

proc gtk_action_get_visible_vertical*(self: ptr Action00): gboolean {.
    importc: "gtk_action_get_visible_vertical", libprag.}

proc getVisibleVertical*(self: Action): bool =
  toBool(gtk_action_get_visible_vertical(cast[ptr Action00](self.impl)))

proc visibleVertical*(self: Action): bool =
  toBool(gtk_action_get_visible_vertical(cast[ptr Action00](self.impl)))

proc gtk_action_is_sensitive*(self: ptr Action00): gboolean {.
    importc: "gtk_action_is_sensitive", libprag.}

proc isSensitive*(self: Action): bool =
  toBool(gtk_action_is_sensitive(cast[ptr Action00](self.impl)))

proc gtk_action_is_visible*(self: ptr Action00): gboolean {.
    importc: "gtk_action_is_visible", libprag.}

proc isVisible*(self: Action): bool =
  toBool(gtk_action_is_visible(cast[ptr Action00](self.impl)))

proc gtk_action_set_accel_group*(self: ptr Action00; accelGroup: ptr AccelGroup00) {.
    importc: "gtk_action_set_accel_group", libprag.}

proc setAccelGroup*(self: Action; accelGroup: AccelGroup) =
  gtk_action_set_accel_group(cast[ptr Action00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc `accelGroup=`*(self: Action; accelGroup: AccelGroup) =
  gtk_action_set_accel_group(cast[ptr Action00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_action_set_accel_path*(self: ptr Action00; accelPath: cstring) {.
    importc: "gtk_action_set_accel_path", libprag.}

proc setAccelPath*(self: Action; accelPath: string) =
  gtk_action_set_accel_path(cast[ptr Action00](self.impl), cstring(accelPath))

proc `accelPath=`*(self: Action; accelPath: string) =
  gtk_action_set_accel_path(cast[ptr Action00](self.impl), cstring(accelPath))

proc gtk_action_set_always_show_image*(self: ptr Action00; alwaysShow: gboolean) {.
    importc: "gtk_action_set_always_show_image", libprag.}

proc setAlwaysShowImage*(self: Action; alwaysShow: bool) =
  gtk_action_set_always_show_image(cast[ptr Action00](self.impl), gboolean(alwaysShow))

proc `alwaysShowImage=`*(self: Action; alwaysShow: bool) =
  gtk_action_set_always_show_image(cast[ptr Action00](self.impl), gboolean(alwaysShow))

proc gtk_action_set_gicon*(self: ptr Action00; icon: ptr gio.Icon00) {.
    importc: "gtk_action_set_gicon", libprag.}

proc setGicon*(self: Action; icon: gio.Icon) =
  gtk_action_set_gicon(cast[ptr Action00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc `gicon=`*(self: Action; icon: gio.Icon) =
  gtk_action_set_gicon(cast[ptr Action00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc gtk_action_set_icon_name*(self: ptr Action00; iconName: cstring) {.
    importc: "gtk_action_set_icon_name", libprag.}

proc setIconName*(self: Action; iconName: string) =
  gtk_action_set_icon_name(cast[ptr Action00](self.impl), cstring(iconName))

proc `iconName=`*(self: Action; iconName: string) =
  gtk_action_set_icon_name(cast[ptr Action00](self.impl), cstring(iconName))

proc gtk_action_set_is_important*(self: ptr Action00; isImportant: gboolean) {.
    importc: "gtk_action_set_is_important", libprag.}

proc setIsImportant*(self: Action; isImportant: bool) =
  gtk_action_set_is_important(cast[ptr Action00](self.impl), gboolean(isImportant))

proc `isImportant=`*(self: Action; isImportant: bool) =
  gtk_action_set_is_important(cast[ptr Action00](self.impl), gboolean(isImportant))

proc gtk_action_set_label*(self: ptr Action00; label: cstring) {.
    importc: "gtk_action_set_label", libprag.}

proc setLabel*(self: Action; label: string) =
  gtk_action_set_label(cast[ptr Action00](self.impl), cstring(label))

proc `label=`*(self: Action; label: string) =
  gtk_action_set_label(cast[ptr Action00](self.impl), cstring(label))

proc gtk_action_set_sensitive*(self: ptr Action00; sensitive: gboolean) {.
    importc: "gtk_action_set_sensitive", libprag.}

proc setSensitive*(self: Action; sensitive: bool) =
  gtk_action_set_sensitive(cast[ptr Action00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: Action; sensitive: bool) =
  gtk_action_set_sensitive(cast[ptr Action00](self.impl), gboolean(sensitive))

proc gtk_action_set_short_label*(self: ptr Action00; shortLabel: cstring) {.
    importc: "gtk_action_set_short_label", libprag.}

proc setShortLabel*(self: Action; shortLabel: string) =
  gtk_action_set_short_label(cast[ptr Action00](self.impl), cstring(shortLabel))

proc `shortLabel=`*(self: Action; shortLabel: string) =
  gtk_action_set_short_label(cast[ptr Action00](self.impl), cstring(shortLabel))

proc gtk_action_set_stock_id*(self: ptr Action00; stockId: cstring) {.
    importc: "gtk_action_set_stock_id", libprag.}

proc setStockId*(self: Action; stockId: string) =
  gtk_action_set_stock_id(cast[ptr Action00](self.impl), cstring(stockId))

proc `stockId=`*(self: Action; stockId: string) =
  gtk_action_set_stock_id(cast[ptr Action00](self.impl), cstring(stockId))

proc gtk_action_set_tooltip*(self: ptr Action00; tooltip: cstring) {.
    importc: "gtk_action_set_tooltip", libprag.}

proc setTooltip*(self: Action; tooltip: string) =
  gtk_action_set_tooltip(cast[ptr Action00](self.impl), cstring(tooltip))

proc `tooltip=`*(self: Action; tooltip: string) =
  gtk_action_set_tooltip(cast[ptr Action00](self.impl), cstring(tooltip))

proc gtk_action_set_visible*(self: ptr Action00; visible: gboolean) {.
    importc: "gtk_action_set_visible", libprag.}

proc setVisible*(self: Action; visible: bool) =
  gtk_action_set_visible(cast[ptr Action00](self.impl), gboolean(visible))

proc `visible=`*(self: Action; visible: bool) =
  gtk_action_set_visible(cast[ptr Action00](self.impl), gboolean(visible))

proc gtk_action_set_visible_horizontal*(self: ptr Action00; visibleHorizontal: gboolean) {.
    importc: "gtk_action_set_visible_horizontal", libprag.}

proc setVisibleHorizontal*(self: Action; visibleHorizontal: bool) =
  gtk_action_set_visible_horizontal(cast[ptr Action00](self.impl), gboolean(visibleHorizontal))

proc `visibleHorizontal=`*(self: Action; visibleHorizontal: bool) =
  gtk_action_set_visible_horizontal(cast[ptr Action00](self.impl), gboolean(visibleHorizontal))

proc gtk_action_set_visible_vertical*(self: ptr Action00; visibleVertical: gboolean) {.
    importc: "gtk_action_set_visible_vertical", libprag.}

proc setVisibleVertical*(self: Action; visibleVertical: bool) =
  gtk_action_set_visible_vertical(cast[ptr Action00](self.impl), gboolean(visibleVertical))

proc `visibleVertical=`*(self: Action; visibleVertical: bool) =
  gtk_action_set_visible_vertical(cast[ptr Action00](self.impl), gboolean(visibleVertical))

proc gtk_action_unblock_activate*(self: ptr Action00) {.
    importc: "gtk_action_unblock_activate", libprag.}

proc unblockActivate*(self: Action) =
  gtk_action_unblock_activate(cast[ptr Action00](self.impl))

type
  ActionBar* = ref object of Bin
  ActionBar00* = object of Bin00

proc gtk_action_bar_new*(): ptr ActionBar00 {.
    importc: "gtk_action_bar_new", libprag.}

proc newActionBar*(): ActionBar =
  new(result, finalizeGObject)
  result.impl = gtk_action_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initActionBar*[T](result: var T) =
  assert(result is ActionBar)
  new(result, finalizeGObject)
  result.impl = gtk_action_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_bar_get_center_widget*(self: ptr ActionBar00): ptr Widget00 {.
    importc: "gtk_action_bar_get_center_widget", libprag.}

proc getCenterWidget*(self: ActionBar): Widget =
  let gobj = gtk_action_bar_get_center_widget(cast[ptr ActionBar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc centerWidget*(self: ActionBar): Widget =
  let gobj = gtk_action_bar_get_center_widget(cast[ptr ActionBar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_bar_pack_end*(self: ptr ActionBar00; child: ptr Widget00) {.
    importc: "gtk_action_bar_pack_end", libprag.}

proc packEnd*(self: ActionBar; child: Widget) =
  gtk_action_bar_pack_end(cast[ptr ActionBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_action_bar_pack_start*(self: ptr ActionBar00; child: ptr Widget00) {.
    importc: "gtk_action_bar_pack_start", libprag.}

proc packStart*(self: ActionBar; child: Widget) =
  gtk_action_bar_pack_start(cast[ptr ActionBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_action_bar_set_center_widget*(self: ptr ActionBar00; centerWidget: ptr Widget00) {.
    importc: "gtk_action_bar_set_center_widget", libprag.}

proc setCenterWidget*(self: ActionBar; centerWidget: Widget) =
  gtk_action_bar_set_center_widget(cast[ptr ActionBar00](self.impl), cast[ptr Widget00](centerWidget.impl))

proc `centerWidget=`*(self: ActionBar; centerWidget: Widget) =
  gtk_action_bar_set_center_widget(cast[ptr ActionBar00](self.impl), cast[ptr Widget00](centerWidget.impl))

type
  ActionBarPrivate00* {.pure.} = object
  ActionBarPrivate* = ref object
    impl*: ptr ActionBarPrivate00

type
  ActionClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    activate*: proc(action: ptr Action00) {.cdecl.}
    menuItemType*: GType
    toolbarItemType*: GType
    createMenuItem*: proc(action: ptr Action00): ptr Widget00 {.cdecl.}
    createToolItem*: proc(action: ptr Action00): ptr Widget00 {.cdecl.}
    connectProxy*: proc(action: ptr Action00; proxy: ptr Widget00) {.cdecl.}
    disconnectProxy*: proc(action: ptr Action00; proxy: ptr Widget00) {.cdecl.}
    createMenu*: proc(action: ptr Action00): ptr Widget00 {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ActionClass* = ref object
    impl*: ptr ActionClass00

type
  ActionGroupPrivate00* {.pure.} = object
  ActionGroupPrivate* = ref object
    impl*: ptr ActionGroupPrivate00

type
  ActionGroup* = ref object of gobject.Object
  ActionGroup00* = object of gobject.Object00
    priv1: ptr ActionGroupPrivate00

proc scConnectProxy*(self: ActionGroup;  p: proc (self: ptr gobject.Object00; action: Action00; proxy: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "connect-proxy", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDisconnectProxy*(self: ActionGroup;  p: proc (self: ptr gobject.Object00; action: Action00; proxy: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "disconnect-proxy", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPostActivate*(self: ActionGroup;  p: proc (self: ptr gobject.Object00; action: Action00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "post-activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPreActivate*(self: ActionGroup;  p: proc (self: ptr gobject.Object00; action: Action00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "pre-activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_action_group_new*(name: cstring): ptr ActionGroup00 {.
    importc: "gtk_action_group_new", libprag.}

proc newActionGroup*(name: string): ActionGroup =
  new(result, finalizeGObject)
  result.impl = gtk_action_group_new(cstring(name))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initActionGroup*[T](result: var T; name: string) =
  assert(result is ActionGroup)
  new(result, finalizeGObject)
  result.impl = gtk_action_group_new(cstring(name))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_group_add_action*(self: ptr ActionGroup00; action: ptr Action00) {.
    importc: "gtk_action_group_add_action", libprag.}

proc addAction*(self: ActionGroup; action: Action) =
  gtk_action_group_add_action(cast[ptr ActionGroup00](self.impl), cast[ptr Action00](action.impl))

proc gtk_action_group_add_action_with_accel*(self: ptr ActionGroup00; action: ptr Action00; accelerator: cstring) {.
    importc: "gtk_action_group_add_action_with_accel", libprag.}

proc addActionWithAccel*(self: ActionGroup; action: Action; accelerator: string) =
  gtk_action_group_add_action_with_accel(cast[ptr ActionGroup00](self.impl), cast[ptr Action00](action.impl), cstring(accelerator))

proc gtk_action_group_get_accel_group*(self: ptr ActionGroup00): ptr AccelGroup00 {.
    importc: "gtk_action_group_get_accel_group", libprag.}

proc getAccelGroup*(self: ActionGroup): AccelGroup =
  let gobj = gtk_action_group_get_accel_group(cast[ptr ActionGroup00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[AccelGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accelGroup*(self: ActionGroup): AccelGroup =
  let gobj = gtk_action_group_get_accel_group(cast[ptr ActionGroup00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[AccelGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_group_get_action*(self: ptr ActionGroup00; actionName: cstring): ptr Action00 {.
    importc: "gtk_action_group_get_action", libprag.}

proc getAction*(self: ActionGroup; actionName: string): Action =
  let gobj = gtk_action_group_get_action(cast[ptr ActionGroup00](self.impl), cstring(actionName))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Action](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc action*(self: ActionGroup; actionName: string): Action =
  let gobj = gtk_action_group_get_action(cast[ptr ActionGroup00](self.impl), cstring(actionName))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Action](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_group_get_name*(self: ptr ActionGroup00): cstring {.
    importc: "gtk_action_group_get_name", libprag.}

proc getName*(self: ActionGroup): string =
  let resul0 = gtk_action_group_get_name(cast[ptr ActionGroup00](self.impl))
  result = $resul0

proc name*(self: ActionGroup): string =
  let resul0 = gtk_action_group_get_name(cast[ptr ActionGroup00](self.impl))
  result = $resul0

proc gtk_action_group_get_sensitive*(self: ptr ActionGroup00): gboolean {.
    importc: "gtk_action_group_get_sensitive", libprag.}

proc getSensitive*(self: ActionGroup): bool =
  toBool(gtk_action_group_get_sensitive(cast[ptr ActionGroup00](self.impl)))

proc sensitive*(self: ActionGroup): bool =
  toBool(gtk_action_group_get_sensitive(cast[ptr ActionGroup00](self.impl)))

proc gtk_action_group_get_visible*(self: ptr ActionGroup00): gboolean {.
    importc: "gtk_action_group_get_visible", libprag.}

proc getVisible*(self: ActionGroup): bool =
  toBool(gtk_action_group_get_visible(cast[ptr ActionGroup00](self.impl)))

proc visible*(self: ActionGroup): bool =
  toBool(gtk_action_group_get_visible(cast[ptr ActionGroup00](self.impl)))

proc gtk_action_group_list_actions*(self: ptr ActionGroup00): ptr pointer {.
    importc: "gtk_action_group_list_actions", libprag.}

proc listActions*(self: ActionGroup): ptr pointer =
  gtk_action_group_list_actions(cast[ptr ActionGroup00](self.impl))

proc gtk_action_group_remove_action*(self: ptr ActionGroup00; action: ptr Action00) {.
    importc: "gtk_action_group_remove_action", libprag.}

proc removeAction*(self: ActionGroup; action: Action) =
  gtk_action_group_remove_action(cast[ptr ActionGroup00](self.impl), cast[ptr Action00](action.impl))

proc gtk_action_group_set_accel_group*(self: ptr ActionGroup00; accelGroup: ptr AccelGroup00) {.
    importc: "gtk_action_group_set_accel_group", libprag.}

proc setAccelGroup*(self: ActionGroup; accelGroup: AccelGroup) =
  gtk_action_group_set_accel_group(cast[ptr ActionGroup00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc `accelGroup=`*(self: ActionGroup; accelGroup: AccelGroup) =
  gtk_action_group_set_accel_group(cast[ptr ActionGroup00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_action_group_set_sensitive*(self: ptr ActionGroup00; sensitive: gboolean) {.
    importc: "gtk_action_group_set_sensitive", libprag.}

proc setSensitive*(self: ActionGroup; sensitive: bool) =
  gtk_action_group_set_sensitive(cast[ptr ActionGroup00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: ActionGroup; sensitive: bool) =
  gtk_action_group_set_sensitive(cast[ptr ActionGroup00](self.impl), gboolean(sensitive))

proc gtk_action_group_set_translation_domain*(self: ptr ActionGroup00; domain: cstring) {.
    importc: "gtk_action_group_set_translation_domain", libprag.}

proc setTranslationDomain*(self: ActionGroup; domain: string) =
  gtk_action_group_set_translation_domain(cast[ptr ActionGroup00](self.impl), cstring(domain))

proc `translationDomain=`*(self: ActionGroup; domain: string) =
  gtk_action_group_set_translation_domain(cast[ptr ActionGroup00](self.impl), cstring(domain))

proc gtk_action_group_set_visible*(self: ptr ActionGroup00; visible: gboolean) {.
    importc: "gtk_action_group_set_visible", libprag.}

proc setVisible*(self: ActionGroup; visible: bool) =
  gtk_action_group_set_visible(cast[ptr ActionGroup00](self.impl), gboolean(visible))

proc `visible=`*(self: ActionGroup; visible: bool) =
  gtk_action_group_set_visible(cast[ptr ActionGroup00](self.impl), gboolean(visible))

proc gtk_action_group_translate_string*(self: ptr ActionGroup00; string: cstring): cstring {.
    importc: "gtk_action_group_translate_string", libprag.}

proc translateString*(self: ActionGroup; string: string): string =
  let resul0 = gtk_action_group_translate_string(cast[ptr ActionGroup00](self.impl), cstring(string))
  result = $resul0

type
  ActionGroupClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    getAction*: proc(actionGroup: ptr ActionGroup00; actionName: cstring): ptr Action00 {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ActionGroupClass* = ref object
    impl*: ptr ActionGroupClass00

type
  Actionable00* {.pure.} = object
  Actionable* = ref object
    impl*: ptr Actionable00

proc gtk_actionable_get_action_name*(self: ptr Actionable00): cstring {.
    importc: "gtk_actionable_get_action_name", libprag.}

proc getActionName*(self: Actionable): string =
  let resul0 = gtk_actionable_get_action_name(cast[ptr Actionable00](self.impl))
  result = $resul0

proc actionName*(self: Actionable): string =
  let resul0 = gtk_actionable_get_action_name(cast[ptr Actionable00](self.impl))
  result = $resul0

proc gtk_actionable_get_action_target_value*(self: ptr Actionable00): ptr glib.Variant00 {.
    importc: "gtk_actionable_get_action_target_value", libprag.}

proc getActionTargetValue*(self: Actionable): glib.Variant =
  new(result)
  result.impl = gtk_actionable_get_action_target_value(cast[ptr Actionable00](self.impl))

proc actionTargetValue*(self: Actionable): glib.Variant =
  new(result)
  result.impl = gtk_actionable_get_action_target_value(cast[ptr Actionable00](self.impl))

proc gtk_actionable_set_action_name*(self: ptr Actionable00; actionName: cstring) {.
    importc: "gtk_actionable_set_action_name", libprag.}

proc setActionName*(self: Actionable; actionName: string) =
  gtk_actionable_set_action_name(cast[ptr Actionable00](self.impl), cstring(actionName))

proc `actionName=`*(self: Actionable; actionName: string) =
  gtk_actionable_set_action_name(cast[ptr Actionable00](self.impl), cstring(actionName))

proc gtk_actionable_set_action_target_value*(self: ptr Actionable00; targetValue: ptr glib.Variant00) {.
    importc: "gtk_actionable_set_action_target_value", libprag.}

proc setActionTargetValue*(self: Actionable; targetValue: glib.Variant) =
  gtk_actionable_set_action_target_value(cast[ptr Actionable00](self.impl), cast[ptr glib.Variant00](targetValue.impl))

proc `actionTargetValue=`*(self: Actionable; targetValue: glib.Variant) =
  gtk_actionable_set_action_target_value(cast[ptr Actionable00](self.impl), cast[ptr glib.Variant00](targetValue.impl))

proc gtk_actionable_set_detailed_action_name*(self: ptr Actionable00; detailedActionName: cstring) {.
    importc: "gtk_actionable_set_detailed_action_name", libprag.}

proc setDetailedActionName*(self: Actionable; detailedActionName: string) =
  gtk_actionable_set_detailed_action_name(cast[ptr Actionable00](self.impl), cstring(detailedActionName))

proc `detailedActionName=`*(self: Actionable; detailedActionName: string) =
  gtk_actionable_set_detailed_action_name(cast[ptr Actionable00](self.impl), cstring(detailedActionName))

type
  ActionableInterface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    getActionName*: proc(actionable: ptr Actionable00): cstring {.cdecl.}
    setActionName*: proc(actionable: ptr Actionable00; actionName: cstring) {.cdecl.}
    getActionTargetValue*: proc(actionable: ptr Actionable00): ptr glib.Variant00 {.cdecl.}
    setActionTargetValue*: proc(actionable: ptr Actionable00; targetValue: ptr glib.Variant00) {.cdecl.}
  ActionableInterface* = ref object
    impl*: ptr ActionableInterface00

type
  Activatable00* {.pure.} = object
  Activatable* = ref object
    impl*: ptr Activatable00

proc gtk_activatable_do_set_related_action*(self: ptr Activatable00; action: ptr Action00) {.
    importc: "gtk_activatable_do_set_related_action", libprag.}

proc doSetRelatedAction*(self: Activatable; action: Action) =
  gtk_activatable_do_set_related_action(cast[ptr Activatable00](self.impl), cast[ptr Action00](action.impl))

proc gtk_activatable_get_related_action*(self: ptr Activatable00): ptr Action00 {.
    importc: "gtk_activatable_get_related_action", libprag.}

proc getRelatedAction*(self: Activatable): Action =
  let gobj = gtk_activatable_get_related_action(cast[ptr Activatable00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Action](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc relatedAction*(self: Activatable): Action =
  let gobj = gtk_activatable_get_related_action(cast[ptr Activatable00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Action](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_activatable_get_use_action_appearance*(self: ptr Activatable00): gboolean {.
    importc: "gtk_activatable_get_use_action_appearance", libprag.}

proc getUseActionAppearance*(self: Activatable): bool =
  toBool(gtk_activatable_get_use_action_appearance(cast[ptr Activatable00](self.impl)))

proc useActionAppearance*(self: Activatable): bool =
  toBool(gtk_activatable_get_use_action_appearance(cast[ptr Activatable00](self.impl)))

proc gtk_activatable_set_related_action*(self: ptr Activatable00; action: ptr Action00) {.
    importc: "gtk_activatable_set_related_action", libprag.}

proc setRelatedAction*(self: Activatable; action: Action) =
  gtk_activatable_set_related_action(cast[ptr Activatable00](self.impl), cast[ptr Action00](action.impl))

proc `relatedAction=`*(self: Activatable; action: Action) =
  gtk_activatable_set_related_action(cast[ptr Activatable00](self.impl), cast[ptr Action00](action.impl))

proc gtk_activatable_set_use_action_appearance*(self: ptr Activatable00; useAppearance: gboolean) {.
    importc: "gtk_activatable_set_use_action_appearance", libprag.}

proc setUseActionAppearance*(self: Activatable; useAppearance: bool) =
  gtk_activatable_set_use_action_appearance(cast[ptr Activatable00](self.impl), gboolean(useAppearance))

proc `useActionAppearance=`*(self: Activatable; useAppearance: bool) =
  gtk_activatable_set_use_action_appearance(cast[ptr Activatable00](self.impl), gboolean(useAppearance))

proc gtk_activatable_sync_action_properties*(self: ptr Activatable00; action: ptr Action00) {.
    importc: "gtk_activatable_sync_action_properties", libprag.}

proc syncActionProperties*(self: Activatable; action: Action) =
  gtk_activatable_sync_action_properties(cast[ptr Activatable00](self.impl), cast[ptr Action00](action.impl))

type
  ActivatableIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    update*: proc(activatable: ptr Activatable00; action: ptr Action00; 
    propertyName: cstring) {.cdecl.}
    syncActionProperties*: proc(activatable: ptr Activatable00; action: ptr Action00) {.cdecl.}
  ActivatableIface* = ref object
    impl*: ptr ActivatableIface00

type
  AdjustmentClass00* {.pure.} = object
    parentClass*: gobject.InitiallyUnownedClass00
    changed*: proc(adjustment: ptr Adjustment00) {.cdecl.}
    valueChanged*: proc(adjustment: ptr Adjustment00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  AdjustmentClass* = ref object
    impl*: ptr AdjustmentClass00

type
  AlignmentPrivate00* {.pure.} = object
  AlignmentPrivate* = ref object
    impl*: ptr AlignmentPrivate00

type
  Alignment* = ref object of Bin
  Alignment00* = object of Bin00
    priv4: ptr AlignmentPrivate00

proc gtk_alignment_new*(xalign: cfloat; yalign: cfloat; xscale: cfloat; yscale: cfloat): ptr Alignment00 {.
    importc: "gtk_alignment_new", libprag.}

proc newAlignment*(xalign: cfloat; yalign: cfloat; xscale: cfloat; yscale: cfloat): Alignment =
  new(result, finalizeGObject)
  result.impl = gtk_alignment_new(xalign, yalign, xscale, yscale)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAlignment*[T](result: var T; xalign: cfloat; yalign: cfloat; xscale: cfloat; yscale: cfloat) =
  assert(result is Alignment)
  new(result, finalizeGObject)
  result.impl = gtk_alignment_new(xalign, yalign, xscale, yscale)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_alignment_get_padding*(self: ptr Alignment00; paddingTop: var uint32; paddingBottom: var uint32; 
    paddingLeft: var uint32; paddingRight: var uint32) {.
    importc: "gtk_alignment_get_padding", libprag.}

proc getPadding*(self: Alignment; paddingTop: var int; paddingBottom: var int; 
    paddingLeft: var int; paddingRight: var int) =
  var paddingRight_00 = uint32(paddingRight)
  var paddingBottom_00 = uint32(paddingBottom)
  var paddingTop_00 = uint32(paddingTop)
  var paddingLeft_00 = uint32(paddingLeft)
  gtk_alignment_get_padding(cast[ptr Alignment00](self.impl), paddingTop_00, paddingBottom_00, paddingLeft_00, paddingRight_00)
  paddingRight = int(paddingRight_00)
  paddingBottom = int(paddingBottom_00)
  paddingTop = int(paddingTop_00)
  paddingLeft = int(paddingLeft_00)

proc padding*(self: Alignment; paddingTop: var int; paddingBottom: var int; 
    paddingLeft: var int; paddingRight: var int) =
  var paddingRight_00 = uint32(paddingRight)
  var paddingBottom_00 = uint32(paddingBottom)
  var paddingTop_00 = uint32(paddingTop)
  var paddingLeft_00 = uint32(paddingLeft)
  gtk_alignment_get_padding(cast[ptr Alignment00](self.impl), paddingTop_00, paddingBottom_00, paddingLeft_00, paddingRight_00)
  paddingRight = int(paddingRight_00)
  paddingBottom = int(paddingBottom_00)
  paddingTop = int(paddingTop_00)
  paddingLeft = int(paddingLeft_00)

proc gtk_alignment_set*(self: ptr Alignment00; xalign: cfloat; yalign: cfloat; 
    xscale: cfloat; yscale: cfloat) {.
    importc: "gtk_alignment_set", libprag.}

proc set*(self: Alignment; xalign: cfloat; yalign: cfloat; xscale: cfloat; 
    yscale: cfloat) =
  gtk_alignment_set(cast[ptr Alignment00](self.impl), xalign, yalign, xscale, yscale)

proc gtk_alignment_set_padding*(self: ptr Alignment00; paddingTop: uint32; paddingBottom: uint32; 
    paddingLeft: uint32; paddingRight: uint32) {.
    importc: "gtk_alignment_set_padding", libprag.}

proc setPadding*(self: Alignment; paddingTop: int; paddingBottom: int; 
    paddingLeft: int; paddingRight: int) =
  gtk_alignment_set_padding(cast[ptr Alignment00](self.impl), uint32(paddingTop), uint32(paddingBottom), uint32(paddingLeft), uint32(paddingRight))


type
  ComboBoxPrivate00* {.pure.} = object
  ComboBoxPrivate* = ref object
    impl*: ptr ComboBoxPrivate00

type
  ComboBox* = ref object of Bin
  ComboBox00* = object of Bin00
    priv4: ptr ComboBoxPrivate00

proc scChanged*(self: ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scFormatEntryText*(self: ComboBox;  p: proc (self: ptr gobject.Object00; path: cstring; xdata: pointer): cstring {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "format-entry-text", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveActive*(self: ComboBox;  p: proc (self: ptr gobject.Object00; scrollType: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-active", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopdown*(self: ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "popdown", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopup*(self: ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "popup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_combo_box_new*(): ptr ComboBox00 {.
    importc: "gtk_combo_box_new", libprag.}

proc newComboBox*(): ComboBox =
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBox*[T](result: var T) =
  assert(result is ComboBox)
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_entry*(): ptr ComboBox00 {.
    importc: "gtk_combo_box_new_with_entry", libprag.}

proc newComboBoxWithEntry*(): ComboBox =
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_entry()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithEntry*[T](result: var T) =
  assert(result is ComboBox)
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_entry()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_get_active*(self: ptr ComboBox00): int32 {.
    importc: "gtk_combo_box_get_active", libprag.}

proc getActive*(self: ComboBox): int =
  int(gtk_combo_box_get_active(cast[ptr ComboBox00](self.impl)))

proc active*(self: ComboBox): int =
  int(gtk_combo_box_get_active(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_active_id*(self: ptr ComboBox00): cstring {.
    importc: "gtk_combo_box_get_active_id", libprag.}

proc getActiveId*(self: ComboBox): string =
  let resul0 = gtk_combo_box_get_active_id(cast[ptr ComboBox00](self.impl))
  result = $resul0

proc activeId*(self: ComboBox): string =
  let resul0 = gtk_combo_box_get_active_id(cast[ptr ComboBox00](self.impl))
  result = $resul0

proc gtk_combo_box_get_add_tearoffs*(self: ptr ComboBox00): gboolean {.
    importc: "gtk_combo_box_get_add_tearoffs", libprag.}

proc getAddTearoffs*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_add_tearoffs(cast[ptr ComboBox00](self.impl)))

proc addTearoffs*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_add_tearoffs(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_column_span_column*(self: ptr ComboBox00): int32 {.
    importc: "gtk_combo_box_get_column_span_column", libprag.}

proc getColumnSpanColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_column_span_column(cast[ptr ComboBox00](self.impl)))

proc columnSpanColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_column_span_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_entry_text_column*(self: ptr ComboBox00): int32 {.
    importc: "gtk_combo_box_get_entry_text_column", libprag.}

proc getEntryTextColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_entry_text_column(cast[ptr ComboBox00](self.impl)))

proc entryTextColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_entry_text_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_focus_on_click*(self: ptr ComboBox00): gboolean {.
    importc: "gtk_combo_box_get_focus_on_click", libprag.}

proc getFocusOnClick*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_focus_on_click(cast[ptr ComboBox00](self.impl)))

proc focusOnClick*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_focus_on_click(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_has_entry*(self: ptr ComboBox00): gboolean {.
    importc: "gtk_combo_box_get_has_entry", libprag.}

proc getHasEntry*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_has_entry(cast[ptr ComboBox00](self.impl)))

proc hasEntry*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_has_entry(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_id_column*(self: ptr ComboBox00): int32 {.
    importc: "gtk_combo_box_get_id_column", libprag.}

proc getIdColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_id_column(cast[ptr ComboBox00](self.impl)))

proc idColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_id_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_popup_accessible*(self: ptr ComboBox00): ptr atk.Object00 {.
    importc: "gtk_combo_box_get_popup_accessible", libprag.}

proc getPopupAccessible*(self: ComboBox): atk.Object =
  let gobj = gtk_combo_box_get_popup_accessible(cast[ptr ComboBox00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[atk.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popupAccessible*(self: ComboBox): atk.Object =
  let gobj = gtk_combo_box_get_popup_accessible(cast[ptr ComboBox00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[atk.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_get_popup_fixed_width*(self: ptr ComboBox00): gboolean {.
    importc: "gtk_combo_box_get_popup_fixed_width", libprag.}

proc getPopupFixedWidth*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_popup_fixed_width(cast[ptr ComboBox00](self.impl)))

proc popupFixedWidth*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_popup_fixed_width(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_row_span_column*(self: ptr ComboBox00): int32 {.
    importc: "gtk_combo_box_get_row_span_column", libprag.}

proc getRowSpanColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_row_span_column(cast[ptr ComboBox00](self.impl)))

proc rowSpanColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_row_span_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_title*(self: ptr ComboBox00): cstring {.
    importc: "gtk_combo_box_get_title", libprag.}

proc getTitle*(self: ComboBox): string =
  let resul0 = gtk_combo_box_get_title(cast[ptr ComboBox00](self.impl))
  result = $resul0

proc title*(self: ComboBox): string =
  let resul0 = gtk_combo_box_get_title(cast[ptr ComboBox00](self.impl))
  result = $resul0

proc gtk_combo_box_get_wrap_width*(self: ptr ComboBox00): int32 {.
    importc: "gtk_combo_box_get_wrap_width", libprag.}

proc getWrapWidth*(self: ComboBox): int =
  int(gtk_combo_box_get_wrap_width(cast[ptr ComboBox00](self.impl)))

proc wrapWidth*(self: ComboBox): int =
  int(gtk_combo_box_get_wrap_width(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_popdown*(self: ptr ComboBox00) {.
    importc: "gtk_combo_box_popdown", libprag.}

proc popdown*(self: ComboBox) =
  gtk_combo_box_popdown(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_popup*(self: ptr ComboBox00) {.
    importc: "gtk_combo_box_popup", libprag.}

proc popup*(self: ComboBox) =
  gtk_combo_box_popup(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_popup_for_device*(self: ptr ComboBox00; device: ptr gdk.Device00) {.
    importc: "gtk_combo_box_popup_for_device", libprag.}

proc popupForDevice*(self: ComboBox; device: gdk.Device) =
  gtk_combo_box_popup_for_device(cast[ptr ComboBox00](self.impl), cast[ptr gdk.Device00](device.impl))

proc gtk_combo_box_set_active*(self: ptr ComboBox00; index: int32) {.
    importc: "gtk_combo_box_set_active", libprag.}

proc setActive*(self: ComboBox; index: int) =
  gtk_combo_box_set_active(cast[ptr ComboBox00](self.impl), int32(index))

proc `active=`*(self: ComboBox; index: int) =
  gtk_combo_box_set_active(cast[ptr ComboBox00](self.impl), int32(index))

proc gtk_combo_box_set_active_id*(self: ptr ComboBox00; activeId: cstring): gboolean {.
    importc: "gtk_combo_box_set_active_id", libprag.}

proc setActiveId*(self: ComboBox; activeId: string): bool =
  toBool(gtk_combo_box_set_active_id(cast[ptr ComboBox00](self.impl), cstring(activeId)))

proc `activeId=`*(self: ComboBox; activeId: string): bool =
  toBool(gtk_combo_box_set_active_id(cast[ptr ComboBox00](self.impl), cstring(activeId)))

proc gtk_combo_box_set_add_tearoffs*(self: ptr ComboBox00; addTearoffs: gboolean) {.
    importc: "gtk_combo_box_set_add_tearoffs", libprag.}

proc setAddTearoffs*(self: ComboBox; addTearoffs: bool) =
  gtk_combo_box_set_add_tearoffs(cast[ptr ComboBox00](self.impl), gboolean(addTearoffs))

proc `addTearoffs=`*(self: ComboBox; addTearoffs: bool) =
  gtk_combo_box_set_add_tearoffs(cast[ptr ComboBox00](self.impl), gboolean(addTearoffs))

proc gtk_combo_box_set_column_span_column*(self: ptr ComboBox00; columnSpan: int32) {.
    importc: "gtk_combo_box_set_column_span_column", libprag.}

proc setColumnSpanColumn*(self: ComboBox; columnSpan: int) =
  gtk_combo_box_set_column_span_column(cast[ptr ComboBox00](self.impl), int32(columnSpan))

proc `columnSpanColumn=`*(self: ComboBox; columnSpan: int) =
  gtk_combo_box_set_column_span_column(cast[ptr ComboBox00](self.impl), int32(columnSpan))

proc gtk_combo_box_set_entry_text_column*(self: ptr ComboBox00; textColumn: int32) {.
    importc: "gtk_combo_box_set_entry_text_column", libprag.}

proc setEntryTextColumn*(self: ComboBox; textColumn: int) =
  gtk_combo_box_set_entry_text_column(cast[ptr ComboBox00](self.impl), int32(textColumn))

proc `entryTextColumn=`*(self: ComboBox; textColumn: int) =
  gtk_combo_box_set_entry_text_column(cast[ptr ComboBox00](self.impl), int32(textColumn))

proc gtk_combo_box_set_focus_on_click*(self: ptr ComboBox00; focusOnClick: gboolean) {.
    importc: "gtk_combo_box_set_focus_on_click", libprag.}

proc setFocusOnClick*(self: ComboBox; focusOnClick: bool) =
  gtk_combo_box_set_focus_on_click(cast[ptr ComboBox00](self.impl), gboolean(focusOnClick))

proc `focusOnClick=`*(self: ComboBox; focusOnClick: bool) =
  gtk_combo_box_set_focus_on_click(cast[ptr ComboBox00](self.impl), gboolean(focusOnClick))

proc gtk_combo_box_set_id_column*(self: ptr ComboBox00; idColumn: int32) {.
    importc: "gtk_combo_box_set_id_column", libprag.}

proc setIdColumn*(self: ComboBox; idColumn: int) =
  gtk_combo_box_set_id_column(cast[ptr ComboBox00](self.impl), int32(idColumn))

proc `idColumn=`*(self: ComboBox; idColumn: int) =
  gtk_combo_box_set_id_column(cast[ptr ComboBox00](self.impl), int32(idColumn))

proc gtk_combo_box_set_popup_fixed_width*(self: ptr ComboBox00; fixed: gboolean) {.
    importc: "gtk_combo_box_set_popup_fixed_width", libprag.}

proc setPopupFixedWidth*(self: ComboBox; fixed: bool) =
  gtk_combo_box_set_popup_fixed_width(cast[ptr ComboBox00](self.impl), gboolean(fixed))

proc `popupFixedWidth=`*(self: ComboBox; fixed: bool) =
  gtk_combo_box_set_popup_fixed_width(cast[ptr ComboBox00](self.impl), gboolean(fixed))

proc gtk_combo_box_set_row_span_column*(self: ptr ComboBox00; rowSpan: int32) {.
    importc: "gtk_combo_box_set_row_span_column", libprag.}

proc setRowSpanColumn*(self: ComboBox; rowSpan: int) =
  gtk_combo_box_set_row_span_column(cast[ptr ComboBox00](self.impl), int32(rowSpan))

proc `rowSpanColumn=`*(self: ComboBox; rowSpan: int) =
  gtk_combo_box_set_row_span_column(cast[ptr ComboBox00](self.impl), int32(rowSpan))

proc gtk_combo_box_set_title*(self: ptr ComboBox00; title: cstring) {.
    importc: "gtk_combo_box_set_title", libprag.}

proc setTitle*(self: ComboBox; title: string) =
  gtk_combo_box_set_title(cast[ptr ComboBox00](self.impl), cstring(title))

proc `title=`*(self: ComboBox; title: string) =
  gtk_combo_box_set_title(cast[ptr ComboBox00](self.impl), cstring(title))

proc gtk_combo_box_set_wrap_width*(self: ptr ComboBox00; width: int32) {.
    importc: "gtk_combo_box_set_wrap_width", libprag.}

proc setWrapWidth*(self: ComboBox; width: int) =
  gtk_combo_box_set_wrap_width(cast[ptr ComboBox00](self.impl), int32(width))

proc `wrapWidth=`*(self: ComboBox; width: int) =
  gtk_combo_box_set_wrap_width(cast[ptr ComboBox00](self.impl), int32(width))

type
  AppChooserButtonPrivate00* {.pure.} = object
  AppChooserButtonPrivate* = ref object
    impl*: ptr AppChooserButtonPrivate00

type
  AppChooserButton* = ref object of ComboBox
  AppChooserButton00* = object of ComboBox00
    priv5: ptr AppChooserButtonPrivate00

proc scCustomItemActivated*(self: AppChooserButton;  p: proc (self: ptr gobject.Object00; itemName: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "custom-item-activated", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_app_chooser_button_new*(contentType: cstring): ptr AppChooserButton00 {.
    importc: "gtk_app_chooser_button_new", libprag.}

proc newAppChooserButton*(contentType: string): AppChooserButton =
  new(result, finalizeGObject)
  result.impl = gtk_app_chooser_button_new(cstring(contentType))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserButton*[T](result: var T; contentType: string) =
  assert(result is AppChooserButton)
  new(result, finalizeGObject)
  result.impl = gtk_app_chooser_button_new(cstring(contentType))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_button_append_custom_item*(self: ptr AppChooserButton00; name: cstring; label: cstring; 
    icon: ptr gio.Icon00) {.
    importc: "gtk_app_chooser_button_append_custom_item", libprag.}

proc appendCustomItem*(self: AppChooserButton; name: string; label: string; 
    icon: gio.Icon) =
  gtk_app_chooser_button_append_custom_item(cast[ptr AppChooserButton00](self.impl), cstring(name), cstring(label), cast[ptr gio.Icon00](icon.impl))

proc gtk_app_chooser_button_append_separator*(self: ptr AppChooserButton00) {.
    importc: "gtk_app_chooser_button_append_separator", libprag.}

proc appendSeparator*(self: AppChooserButton) =
  gtk_app_chooser_button_append_separator(cast[ptr AppChooserButton00](self.impl))

proc gtk_app_chooser_button_get_heading*(self: ptr AppChooserButton00): cstring {.
    importc: "gtk_app_chooser_button_get_heading", libprag.}

proc getHeading*(self: AppChooserButton): string =
  let resul0 = gtk_app_chooser_button_get_heading(cast[ptr AppChooserButton00](self.impl))
  result = $resul0

proc heading*(self: AppChooserButton): string =
  let resul0 = gtk_app_chooser_button_get_heading(cast[ptr AppChooserButton00](self.impl))
  result = $resul0

proc gtk_app_chooser_button_get_show_default_item*(self: ptr AppChooserButton00): gboolean {.
    importc: "gtk_app_chooser_button_get_show_default_item", libprag.}

proc getShowDefaultItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_default_item(cast[ptr AppChooserButton00](self.impl)))

proc showDefaultItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_default_item(cast[ptr AppChooserButton00](self.impl)))

proc gtk_app_chooser_button_get_show_dialog_item*(self: ptr AppChooserButton00): gboolean {.
    importc: "gtk_app_chooser_button_get_show_dialog_item", libprag.}

proc getShowDialogItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_dialog_item(cast[ptr AppChooserButton00](self.impl)))

proc showDialogItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_dialog_item(cast[ptr AppChooserButton00](self.impl)))

proc gtk_app_chooser_button_set_active_custom_item*(self: ptr AppChooserButton00; name: cstring) {.
    importc: "gtk_app_chooser_button_set_active_custom_item", libprag.}

proc setActiveCustomItem*(self: AppChooserButton; name: string) =
  gtk_app_chooser_button_set_active_custom_item(cast[ptr AppChooserButton00](self.impl), cstring(name))

proc `activeCustomItem=`*(self: AppChooserButton; name: string) =
  gtk_app_chooser_button_set_active_custom_item(cast[ptr AppChooserButton00](self.impl), cstring(name))

proc gtk_app_chooser_button_set_heading*(self: ptr AppChooserButton00; heading: cstring) {.
    importc: "gtk_app_chooser_button_set_heading", libprag.}

proc setHeading*(self: AppChooserButton; heading: string) =
  gtk_app_chooser_button_set_heading(cast[ptr AppChooserButton00](self.impl), cstring(heading))

proc `heading=`*(self: AppChooserButton; heading: string) =
  gtk_app_chooser_button_set_heading(cast[ptr AppChooserButton00](self.impl), cstring(heading))

proc gtk_app_chooser_button_set_show_default_item*(self: ptr AppChooserButton00; setting: gboolean) {.
    importc: "gtk_app_chooser_button_set_show_default_item", libprag.}

proc setShowDefaultItem*(self: AppChooserButton; setting: bool) =
  gtk_app_chooser_button_set_show_default_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

proc `showDefaultItem=`*(self: AppChooserButton; setting: bool) =
  gtk_app_chooser_button_set_show_default_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

proc gtk_app_chooser_button_set_show_dialog_item*(self: ptr AppChooserButton00; setting: gboolean) {.
    importc: "gtk_app_chooser_button_set_show_dialog_item", libprag.}

proc setShowDialogItem*(self: AppChooserButton; setting: bool) =
  gtk_app_chooser_button_set_show_dialog_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

proc `showDialogItem=`*(self: AppChooserButton; setting: bool) =
  gtk_app_chooser_button_set_show_dialog_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

type
  CellAreaPrivate00* {.pure.} = object
  CellAreaPrivate* = ref object
    impl*: ptr CellAreaPrivate00

type
  CellRendererPrivate00* {.pure.} = object
  CellRendererPrivate* = ref object
    impl*: ptr CellRendererPrivate00

type
  CellEditable00* {.pure.} = object
  CellEditable* = ref object
    impl*: ptr CellEditable00

proc gtk_cell_editable_editing_done*(self: ptr CellEditable00) {.
    importc: "gtk_cell_editable_editing_done", libprag.}

proc editingDone*(self: CellEditable) =
  gtk_cell_editable_editing_done(cast[ptr CellEditable00](self.impl))

proc gtk_cell_editable_remove_widget*(self: ptr CellEditable00) {.
    importc: "gtk_cell_editable_remove_widget", libprag.}

proc removeWidget*(self: CellEditable) =
  gtk_cell_editable_remove_widget(cast[ptr CellEditable00](self.impl))

proc gtk_cell_editable_start_editing*(self: ptr CellEditable00; event: ptr gdk.Event00) {.
    importc: "gtk_cell_editable_start_editing", libprag.}

proc startEditing*(self: CellEditable; event: gdk.Event) =
  gtk_cell_editable_start_editing(cast[ptr CellEditable00](self.impl), cast[ptr gdk.Event00](event.impl))

type
  CellRenderer* = ref object of gobject.InitiallyUnowned
  CellRenderer00* = object of gobject.InitiallyUnowned00
    priv1: ptr CellRendererPrivate00

proc scEditingCanceled*(self: CellRenderer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "editing-canceled", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEditingStarted*(self: CellRenderer;  p: proc (self: ptr gobject.Object00; editable: CellEditable00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "editing-started", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_cell_renderer_get_alignment*(self: ptr CellRenderer00; xalign: var cfloat; yalign: var cfloat) {.
    importc: "gtk_cell_renderer_get_alignment", libprag.}

proc getAlignment*(self: CellRenderer; xalign: var cfloat; yalign: var cfloat) =
  gtk_cell_renderer_get_alignment(cast[ptr CellRenderer00](self.impl), xalign, yalign)

proc alignment*(self: CellRenderer; xalign: var cfloat; yalign: var cfloat) =
  gtk_cell_renderer_get_alignment(cast[ptr CellRenderer00](self.impl), xalign, yalign)

proc gtk_cell_renderer_get_fixed_size*(self: ptr CellRenderer00; width: var int32; height: var int32) {.
    importc: "gtk_cell_renderer_get_fixed_size", libprag.}

proc getFixedSize*(self: CellRenderer; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_cell_renderer_get_fixed_size(cast[ptr CellRenderer00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc fixedSize*(self: CellRenderer; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_cell_renderer_get_fixed_size(cast[ptr CellRenderer00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc gtk_cell_renderer_get_padding*(self: ptr CellRenderer00; xpad: var int32; ypad: var int32) {.
    importc: "gtk_cell_renderer_get_padding", libprag.}

proc getPadding*(self: CellRenderer; xpad: var int; ypad: var int) =
  var xpad_00 = int32(xpad)
  var ypad_00 = int32(ypad)
  gtk_cell_renderer_get_padding(cast[ptr CellRenderer00](self.impl), xpad_00, ypad_00)
  xpad = int(xpad_00)
  ypad = int(ypad_00)

proc padding*(self: CellRenderer; xpad: var int; ypad: var int) =
  var xpad_00 = int32(xpad)
  var ypad_00 = int32(ypad)
  gtk_cell_renderer_get_padding(cast[ptr CellRenderer00](self.impl), xpad_00, ypad_00)
  xpad = int(xpad_00)
  ypad = int(ypad_00)

proc gtk_cell_renderer_get_preferred_height*(self: ptr CellRenderer00; widget: ptr Widget00; minimumSize: var int32; 
    naturalSize: var int32) {.
    importc: "gtk_cell_renderer_get_preferred_height", libprag.}

proc getPreferredHeight*(self: CellRenderer; widget: Widget; minimumSize: var int; 
    naturalSize: var int) =
  var minimumSize_00 = int32(minimumSize)
  var naturalSize_00 = int32(naturalSize)
  gtk_cell_renderer_get_preferred_height(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize_00, naturalSize_00)
  minimumSize = int(minimumSize_00)
  naturalSize = int(naturalSize_00)

proc preferredHeight*(self: CellRenderer; widget: Widget; minimumSize: var int; 
    naturalSize: var int) =
  var minimumSize_00 = int32(minimumSize)
  var naturalSize_00 = int32(naturalSize)
  gtk_cell_renderer_get_preferred_height(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize_00, naturalSize_00)
  minimumSize = int(minimumSize_00)
  naturalSize = int(naturalSize_00)

proc gtk_cell_renderer_get_preferred_height_for_width*(self: ptr CellRenderer00; widget: ptr Widget00; width: int32; 
    minimumHeight: var int32; naturalHeight: var int32) {.
    importc: "gtk_cell_renderer_get_preferred_height_for_width", libprag.}

proc getPreferredHeightForWidth*(self: CellRenderer; widget: Widget; width: int; minimumHeight: var int; 
    naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_renderer_get_preferred_height_for_width(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), int32(width), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc preferredHeightForWidth*(self: CellRenderer; widget: Widget; width: int; minimumHeight: var int; 
    naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_renderer_get_preferred_height_for_width(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), int32(width), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc gtk_cell_renderer_get_preferred_size*(self: ptr CellRenderer00; widget: ptr Widget00; minimumSize: var Requisition00; 
    naturalSize: var Requisition00) {.
    importc: "gtk_cell_renderer_get_preferred_size", libprag.}

proc getPreferredSize*(self: ptr CellRenderer00; widget: ptr Widget00; minimumSize: var Requisition00; 
    naturalSize: var Requisition00) {.
    importc: "gtk_cell_renderer_get_preferred_size", libprag.}

proc preferredSize*(self: ptr CellRenderer00; widget: ptr Widget00; minimumSize: var Requisition00; 
    naturalSize: var Requisition00) {.
    importc: "gtk_cell_renderer_get_preferred_size", libprag.}

proc gtk_cell_renderer_get_preferred_width*(self: ptr CellRenderer00; widget: ptr Widget00; minimumSize: var int32; 
    naturalSize: var int32) {.
    importc: "gtk_cell_renderer_get_preferred_width", libprag.}

proc getPreferredWidth*(self: CellRenderer; widget: Widget; minimumSize: var int; 
    naturalSize: var int) =
  var minimumSize_00 = int32(minimumSize)
  var naturalSize_00 = int32(naturalSize)
  gtk_cell_renderer_get_preferred_width(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize_00, naturalSize_00)
  minimumSize = int(minimumSize_00)
  naturalSize = int(naturalSize_00)

proc preferredWidth*(self: CellRenderer; widget: Widget; minimumSize: var int; 
    naturalSize: var int) =
  var minimumSize_00 = int32(minimumSize)
  var naturalSize_00 = int32(naturalSize)
  gtk_cell_renderer_get_preferred_width(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize_00, naturalSize_00)
  minimumSize = int(minimumSize_00)
  naturalSize = int(naturalSize_00)

proc gtk_cell_renderer_get_preferred_width_for_height*(self: ptr CellRenderer00; widget: ptr Widget00; height: int32; 
    minimumWidth: var int32; naturalWidth: var int32) {.
    importc: "gtk_cell_renderer_get_preferred_width_for_height", libprag.}

proc getPreferredWidthForHeight*(self: CellRenderer; widget: Widget; height: int; minimumWidth: var int; 
    naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_renderer_get_preferred_width_for_height(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), int32(height), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc preferredWidthForHeight*(self: CellRenderer; widget: Widget; height: int; minimumWidth: var int; 
    naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_renderer_get_preferred_width_for_height(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), int32(height), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc gtk_cell_renderer_get_request_mode*(self: ptr CellRenderer00): SizeRequestMode {.
    importc: "gtk_cell_renderer_get_request_mode", libprag.}

proc getRequestMode*(self: CellRenderer): SizeRequestMode =
  gtk_cell_renderer_get_request_mode(cast[ptr CellRenderer00](self.impl))

proc requestMode*(self: CellRenderer): SizeRequestMode =
  gtk_cell_renderer_get_request_mode(cast[ptr CellRenderer00](self.impl))

proc gtk_cell_renderer_get_sensitive*(self: ptr CellRenderer00): gboolean {.
    importc: "gtk_cell_renderer_get_sensitive", libprag.}

proc getSensitive*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_sensitive(cast[ptr CellRenderer00](self.impl)))

proc sensitive*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_sensitive(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_get_size*(self: ptr CellRenderer00; widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; 
    xOffset: var int32; yOffset: var int32; width: var int32; height: var int32) {.
    importc: "gtk_cell_renderer_get_size", libprag.}

proc getSize*(self: CellRenderer; widget: Widget; cellArea: gdk.Rectangle; 
    xOffset: var int; yOffset: var int; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  var yOffset_00 = int32(yOffset)
  var xOffset_00 = int32(xOffset)
  gtk_cell_renderer_get_size(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Rectangle00](cellArea.impl), xOffset_00, yOffset_00, width_00, height_00)
  height = int(height_00)
  width = int(width_00)
  yOffset = int(yOffset_00)
  xOffset = int(xOffset_00)

proc size*(self: CellRenderer; widget: Widget; cellArea: gdk.Rectangle; 
    xOffset: var int; yOffset: var int; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  var yOffset_00 = int32(yOffset)
  var xOffset_00 = int32(xOffset)
  gtk_cell_renderer_get_size(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Rectangle00](cellArea.impl), xOffset_00, yOffset_00, width_00, height_00)
  height = int(height_00)
  width = int(width_00)
  yOffset = int(yOffset_00)
  xOffset = int(xOffset_00)

proc gtk_cell_renderer_get_visible*(self: ptr CellRenderer00): gboolean {.
    importc: "gtk_cell_renderer_get_visible", libprag.}

proc getVisible*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_visible(cast[ptr CellRenderer00](self.impl)))

proc visible*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_visible(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_is_activatable*(self: ptr CellRenderer00): gboolean {.
    importc: "gtk_cell_renderer_is_activatable", libprag.}

proc isActivatable*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_is_activatable(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_set_alignment*(self: ptr CellRenderer00; xalign: cfloat; yalign: cfloat) {.
    importc: "gtk_cell_renderer_set_alignment", libprag.}

proc setAlignment*(self: CellRenderer; xalign: cfloat; yalign: cfloat) =
  gtk_cell_renderer_set_alignment(cast[ptr CellRenderer00](self.impl), xalign, yalign)

proc gtk_cell_renderer_set_fixed_size*(self: ptr CellRenderer00; width: int32; height: int32) {.
    importc: "gtk_cell_renderer_set_fixed_size", libprag.}

proc setFixedSize*(self: CellRenderer; width: int; height: int) =
  gtk_cell_renderer_set_fixed_size(cast[ptr CellRenderer00](self.impl), int32(width), int32(height))

proc gtk_cell_renderer_set_padding*(self: ptr CellRenderer00; xpad: int32; ypad: int32) {.
    importc: "gtk_cell_renderer_set_padding", libprag.}

proc setPadding*(self: CellRenderer; xpad: int; ypad: int) =
  gtk_cell_renderer_set_padding(cast[ptr CellRenderer00](self.impl), int32(xpad), int32(ypad))

proc gtk_cell_renderer_set_sensitive*(self: ptr CellRenderer00; sensitive: gboolean) {.
    importc: "gtk_cell_renderer_set_sensitive", libprag.}

proc setSensitive*(self: CellRenderer; sensitive: bool) =
  gtk_cell_renderer_set_sensitive(cast[ptr CellRenderer00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: CellRenderer; sensitive: bool) =
  gtk_cell_renderer_set_sensitive(cast[ptr CellRenderer00](self.impl), gboolean(sensitive))

proc gtk_cell_renderer_set_visible*(self: ptr CellRenderer00; visible: gboolean) {.
    importc: "gtk_cell_renderer_set_visible", libprag.}

proc setVisible*(self: CellRenderer; visible: bool) =
  gtk_cell_renderer_set_visible(cast[ptr CellRenderer00](self.impl), gboolean(visible))

proc `visible=`*(self: CellRenderer; visible: bool) =
  gtk_cell_renderer_set_visible(cast[ptr CellRenderer00](self.impl), gboolean(visible))

proc gtk_cell_renderer_stop_editing*(self: ptr CellRenderer00; canceled: gboolean) {.
    importc: "gtk_cell_renderer_stop_editing", libprag.}

proc stopEditing*(self: CellRenderer; canceled: bool) =
  gtk_cell_renderer_stop_editing(cast[ptr CellRenderer00](self.impl), gboolean(canceled))

type
  CellRendererState* {.size: sizeof(cint), pure.} = enum
    selected = 1
    prelit = 2
    insensitive = 4
    sorted = 8
    focused = 16
    expandable = 32
    expanded = 64

proc gtk_cell_renderer_activate*(self: ptr CellRenderer00; event: ptr gdk.Event00; 
    widget: ptr Widget00; path: cstring; backgroundArea: ptr gdk.Rectangle00; cellArea: ptr gdk.Rectangle00; 
    flags: CellRendererState): gboolean {.
    importc: "gtk_cell_renderer_activate", libprag.}

proc activate*(self: CellRenderer; event: gdk.Event; widget: Widget; 
    path: string; backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle; flags: CellRendererState): bool =
  toBool(gtk_cell_renderer_activate(cast[ptr CellRenderer00](self.impl), cast[ptr gdk.Event00](event.impl), cast[ptr Widget00](widget.impl), cstring(path), cast[ptr gdk.Rectangle00](backgroundArea.impl), cast[ptr gdk.Rectangle00](cellArea.impl), flags))

proc gtk_cell_renderer_get_aligned_area*(self: ptr CellRenderer00; widget: ptr Widget00; flags: CellRendererState; 
    cellArea: ptr gdk.Rectangle00; alignedArea: var gdk.Rectangle00) {.
    importc: "gtk_cell_renderer_get_aligned_area", libprag.}

proc getAlignedArea*(self: ptr CellRenderer00; widget: ptr Widget00; flags: CellRendererState; 
    cellArea: ptr gdk.Rectangle00; alignedArea: var gdk.Rectangle00) {.
    importc: "gtk_cell_renderer_get_aligned_area", libprag.}

proc alignedArea*(self: ptr CellRenderer00; widget: ptr Widget00; flags: CellRendererState; 
    cellArea: ptr gdk.Rectangle00; alignedArea: var gdk.Rectangle00) {.
    importc: "gtk_cell_renderer_get_aligned_area", libprag.}

proc gtk_cell_renderer_get_state*(self: ptr CellRenderer00; widget: ptr Widget00; cellState: CellRendererState): StateFlags {.
    importc: "gtk_cell_renderer_get_state", libprag.}

proc getState*(self: CellRenderer; widget: Widget; cellState: CellRendererState): StateFlags =
  gtk_cell_renderer_get_state(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), cellState)

proc state*(self: CellRenderer; widget: Widget; cellState: CellRendererState): StateFlags =
  gtk_cell_renderer_get_state(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), cellState)

proc gtk_cell_renderer_render*(self: ptr CellRenderer00; cr: ptr cairo.Context00; 
    widget: ptr Widget00; backgroundArea: ptr gdk.Rectangle00; cellArea: ptr gdk.Rectangle00; flags: CellRendererState) {.
    importc: "gtk_cell_renderer_render", libprag.}

proc render*(self: CellRenderer; cr: cairo.Context; widget: Widget; 
    backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle; flags: CellRendererState) =
  gtk_cell_renderer_render(cast[ptr CellRenderer00](self.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Rectangle00](backgroundArea.impl), cast[ptr gdk.Rectangle00](cellArea.impl), flags)

proc gtk_cell_renderer_start_editing*(self: ptr CellRenderer00; event: ptr gdk.Event00; 
    widget: ptr Widget00; path: cstring; backgroundArea: ptr gdk.Rectangle00; cellArea: ptr gdk.Rectangle00; 
    flags: CellRendererState): ptr CellEditable00 {.
    importc: "gtk_cell_renderer_start_editing", libprag.}

proc startEditing*(self: CellRenderer; event: gdk.Event; widget: Widget; 
    path: string; backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle; flags: CellRendererState): CellEditable =
  new(result)
  result.impl = gtk_cell_renderer_start_editing(cast[ptr CellRenderer00](self.impl), cast[ptr gdk.Event00](event.impl), cast[ptr Widget00](widget.impl), cstring(path), cast[ptr gdk.Rectangle00](backgroundArea.impl), cast[ptr gdk.Rectangle00](cellArea.impl), flags)

type
  TreeIter00* {.pure.} = object
    stamp*: int32
    userData*: pointer
    userData2*: pointer
    userData3*: pointer
  TreeIter* = ref object
    impl*: ptr TreeIter00

proc gtk_tree_iter_copy*(self: ptr TreeIter00): ptr TreeIter00 {.
    importc: "gtk_tree_iter_copy", libprag.}

proc copy*(self: TreeIter): TreeIter =
  new(result)
  result.impl = gtk_tree_iter_copy(cast[ptr TreeIter00](self.impl))

proc gtk_tree_iter_free*(self: ptr TreeIter00) {.
    importc: "gtk_tree_iter_free", libprag.}

proc free*(self: TreeIter) =
  gtk_tree_iter_free(cast[ptr TreeIter00](self.impl))

proc gtk_combo_box_get_active_iter*(self: ptr ComboBox00; iter: var TreeIter00): gboolean {.
    importc: "gtk_combo_box_get_active_iter", libprag.}

proc getActiveIter*(self: ptr ComboBox00; iter: var TreeIter00): gboolean {.
    importc: "gtk_combo_box_get_active_iter", libprag.}

proc activeIter*(self: ptr ComboBox00; iter: var TreeIter00): gboolean {.
    importc: "gtk_combo_box_get_active_iter", libprag.}

proc gtk_combo_box_set_active_iter*(self: ptr ComboBox00; iter: ptr TreeIter00) {.
    importc: "gtk_combo_box_set_active_iter", libprag.}

proc setActiveIter*(self: ComboBox; iter: TreeIter) =
  gtk_combo_box_set_active_iter(cast[ptr ComboBox00](self.impl), cast[ptr TreeIter00](iter.impl))

proc `activeIter=`*(self: ComboBox; iter: TreeIter) =
  gtk_combo_box_set_active_iter(cast[ptr ComboBox00](self.impl), cast[ptr TreeIter00](iter.impl))

type
  SensitivityType* {.size: sizeof(cint), pure.} = enum
    auto = 0
    on = 1
    off = 2

proc gtk_combo_box_get_button_sensitivity*(self: ptr ComboBox00): SensitivityType {.
    importc: "gtk_combo_box_get_button_sensitivity", libprag.}

proc getButtonSensitivity*(self: ComboBox): SensitivityType =
  gtk_combo_box_get_button_sensitivity(cast[ptr ComboBox00](self.impl))

proc buttonSensitivity*(self: ComboBox): SensitivityType =
  gtk_combo_box_get_button_sensitivity(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_set_button_sensitivity*(self: ptr ComboBox00; sensitivity: SensitivityType) {.
    importc: "gtk_combo_box_set_button_sensitivity", libprag.}

proc setButtonSensitivity*(self: ComboBox; sensitivity: SensitivityType) =
  gtk_combo_box_set_button_sensitivity(cast[ptr ComboBox00](self.impl), sensitivity)

proc `buttonSensitivity=`*(self: ComboBox; sensitivity: SensitivityType) =
  gtk_combo_box_set_button_sensitivity(cast[ptr ComboBox00](self.impl), sensitivity)

type
  TreeModel00* {.pure.} = object
  TreeModel* = ref object
    impl*: ptr TreeModel00

proc gtk_tree_model_get_column_type*(self: ptr TreeModel00; index: int32): GType {.
    importc: "gtk_tree_model_get_column_type", libprag.}

proc getColumnType*(self: TreeModel; index: int): GType =
  gtk_tree_model_get_column_type(cast[ptr TreeModel00](self.impl), int32(index))

proc columnType*(self: TreeModel; index: int): GType =
  gtk_tree_model_get_column_type(cast[ptr TreeModel00](self.impl), int32(index))

proc gtk_tree_model_get_iter_first*(self: ptr TreeModel00; iter: var TreeIter00): gboolean {.
    importc: "gtk_tree_model_get_iter_first", libprag.}

proc getIterFirst*(self: ptr TreeModel00; iter: var TreeIter00): gboolean {.
    importc: "gtk_tree_model_get_iter_first", libprag.}

proc iterFirst*(self: ptr TreeModel00; iter: var TreeIter00): gboolean {.
    importc: "gtk_tree_model_get_iter_first", libprag.}

proc gtk_tree_model_get_iter_from_string*(self: ptr TreeModel00; iter: var TreeIter00; pathString: cstring): gboolean {.
    importc: "gtk_tree_model_get_iter_from_string", libprag.}

proc getIterFromString*(self: ptr TreeModel00; iter: var TreeIter00; pathString: cstring): gboolean {.
    importc: "gtk_tree_model_get_iter_from_string", libprag.}

proc iterFromString*(self: ptr TreeModel00; iter: var TreeIter00; pathString: cstring): gboolean {.
    importc: "gtk_tree_model_get_iter_from_string", libprag.}

proc gtk_tree_model_get_n_columns*(self: ptr TreeModel00): int32 {.
    importc: "gtk_tree_model_get_n_columns", libprag.}

proc getNColumns*(self: TreeModel): int =
  int(gtk_tree_model_get_n_columns(cast[ptr TreeModel00](self.impl)))

proc nColumns*(self: TreeModel): int =
  int(gtk_tree_model_get_n_columns(cast[ptr TreeModel00](self.impl)))

proc gtk_tree_model_get_string_from_iter*(self: ptr TreeModel00; iter: ptr TreeIter00): cstring {.
    importc: "gtk_tree_model_get_string_from_iter", libprag.}

proc getStringFromIter*(self: TreeModel; iter: TreeIter): string =
  let resul0 = gtk_tree_model_get_string_from_iter(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl))
  result = $resul0
  cogfree(resul0)

proc stringFromIter*(self: TreeModel; iter: TreeIter): string =
  let resul0 = gtk_tree_model_get_string_from_iter(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_tree_model_get_value*(self: ptr TreeModel00; iter: ptr TreeIter00; column: int32; 
    value: var gobject.Value00) {.
    importc: "gtk_tree_model_get_value", libprag.}

proc getValue*(self: ptr TreeModel00; iter: ptr TreeIter00; column: int32; 
    value: var gobject.Value00) {.
    importc: "gtk_tree_model_get_value", libprag.}

proc value*(self: ptr TreeModel00; iter: ptr TreeIter00; column: int32; 
    value: var gobject.Value00) {.
    importc: "gtk_tree_model_get_value", libprag.}

proc gtk_tree_model_iter_children*(self: ptr TreeModel00; iter: var TreeIter00; parent: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_iter_children", libprag.}

proc iterChildren*(self: ptr TreeModel00; iter: var TreeIter00; parent: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_iter_children", libprag.}

proc gtk_tree_model_iter_has_child*(self: ptr TreeModel00; iter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_iter_has_child", libprag.}

proc iterHasChild*(self: TreeModel; iter: TreeIter): bool =
  toBool(gtk_tree_model_iter_has_child(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_tree_model_iter_n_children*(self: ptr TreeModel00; iter: ptr TreeIter00): int32 {.
    importc: "gtk_tree_model_iter_n_children", libprag.}

proc iterNChildren*(self: TreeModel; iter: TreeIter): int =
  int(gtk_tree_model_iter_n_children(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_tree_model_iter_next*(self: ptr TreeModel00; iter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_iter_next", libprag.}

proc iterNext*(self: TreeModel; iter: TreeIter): bool =
  toBool(gtk_tree_model_iter_next(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_tree_model_iter_nth_child*(self: ptr TreeModel00; iter: var TreeIter00; parent: ptr TreeIter00; 
    n: int32): gboolean {.
    importc: "gtk_tree_model_iter_nth_child", libprag.}

proc iterNthChild*(self: ptr TreeModel00; iter: var TreeIter00; parent: ptr TreeIter00; 
    n: int32): gboolean {.
    importc: "gtk_tree_model_iter_nth_child", libprag.}

proc gtk_tree_model_iter_parent*(self: ptr TreeModel00; iter: var TreeIter00; child: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_iter_parent", libprag.}

proc iterParent*(self: ptr TreeModel00; iter: var TreeIter00; child: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_iter_parent", libprag.}

proc gtk_tree_model_iter_previous*(self: ptr TreeModel00; iter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_iter_previous", libprag.}

proc iterPrevious*(self: TreeModel; iter: TreeIter): bool =
  toBool(gtk_tree_model_iter_previous(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_tree_model_ref_node*(self: ptr TreeModel00; iter: ptr TreeIter00) {.
    importc: "gtk_tree_model_ref_node", libprag.}

proc refNode*(self: TreeModel; iter: TreeIter) =
  gtk_tree_model_ref_node(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl))

proc gtk_tree_model_sort_new_with_model*(self: ptr TreeModel00): ptr TreeModel00 {.
    importc: "gtk_tree_model_sort_new_with_model", libprag.}

proc sortNewWithModel*(self: TreeModel): TreeModel =
  new(result)
  result.impl = gtk_tree_model_sort_new_with_model(cast[ptr TreeModel00](self.impl))

proc gtk_tree_model_unref_node*(self: ptr TreeModel00; iter: ptr TreeIter00) {.
    importc: "gtk_tree_model_unref_node", libprag.}

proc unrefNode*(self: TreeModel; iter: TreeIter) =
  gtk_tree_model_unref_node(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl))

type
  CellArea* = ref object of gobject.InitiallyUnowned
  CellArea00* = object of gobject.InitiallyUnowned00
    priv1: ptr CellAreaPrivate00

proc scAddEditable*(self: CellArea;  p: proc (self: ptr gobject.Object00; renderer: CellRenderer00; editable: CellEditable00; 
    cellArea: gdk.Rectangle00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "add-editable", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scApplyAttributes*(self: CellArea;  p: proc (self: ptr gobject.Object00; model: TreeModel00; iter: TreeIter00; isExpander: gboolean; 
    isExpanded: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "apply-attributes", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scFocusChanged*(self: CellArea;  p: proc (self: ptr gobject.Object00; renderer: CellRenderer00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "focus-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRemoveEditable*(self: CellArea;  p: proc (self: ptr gobject.Object00; renderer: CellRenderer00; editable: CellEditable00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "remove-editable", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_cell_area_activate_cell*(self: ptr CellArea00; widget: ptr Widget00; renderer: ptr CellRenderer00; 
    event: ptr gdk.Event00; cellArea: ptr gdk.Rectangle00; flags: CellRendererState): gboolean {.
    importc: "gtk_cell_area_activate_cell", libprag.}

proc activateCell*(self: CellArea; widget: Widget; renderer: CellRenderer; 
    event: gdk.Event; cellArea: gdk.Rectangle; flags: CellRendererState): bool =
  toBool(gtk_cell_area_activate_cell(cast[ptr CellArea00](self.impl), cast[ptr Widget00](widget.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr gdk.Event00](event.impl), cast[ptr gdk.Rectangle00](cellArea.impl), flags))

proc gtk_cell_area_add*(self: ptr CellArea00; renderer: ptr CellRenderer00) {.
    importc: "gtk_cell_area_add", libprag.}

proc add*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_add(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_add_focus_sibling*(self: ptr CellArea00; renderer: ptr CellRenderer00; 
    sibling: ptr CellRenderer00) {.
    importc: "gtk_cell_area_add_focus_sibling", libprag.}

proc addFocusSibling*(self: CellArea; renderer: CellRenderer; sibling: CellRenderer) =
  gtk_cell_area_add_focus_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr CellRenderer00](sibling.impl))

proc gtk_cell_area_apply_attributes*(self: ptr CellArea00; treeModel: ptr TreeModel00; 
    iter: ptr TreeIter00; isExpander: gboolean; isExpanded: gboolean) {.
    importc: "gtk_cell_area_apply_attributes", libprag.}

proc applyAttributes*(self: CellArea; treeModel: TreeModel; iter: TreeIter; 
    isExpander: bool; isExpanded: bool) =
  gtk_cell_area_apply_attributes(cast[ptr CellArea00](self.impl), cast[ptr TreeModel00](treeModel.impl), cast[ptr TreeIter00](iter.impl), gboolean(isExpander), gboolean(isExpanded))

proc gtk_cell_area_attribute_connect*(self: ptr CellArea00; renderer: ptr CellRenderer00; 
    attribute: cstring; column: int32) {.
    importc: "gtk_cell_area_attribute_connect", libprag.}

proc attributeConnect*(self: CellArea; renderer: CellRenderer; attribute: string; 
    column: int) =
  gtk_cell_area_attribute_connect(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cstring(attribute), int32(column))

proc gtk_cell_area_attribute_disconnect*(self: ptr CellArea00; renderer: ptr CellRenderer00; 
    attribute: cstring) {.
    importc: "gtk_cell_area_attribute_disconnect", libprag.}

proc attributeDisconnect*(self: CellArea; renderer: CellRenderer; attribute: string) =
  gtk_cell_area_attribute_disconnect(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cstring(attribute))

proc gtk_cell_area_attribute_get_column*(self: ptr CellArea00; renderer: ptr CellRenderer00; 
    attribute: cstring): int32 {.
    importc: "gtk_cell_area_attribute_get_column", libprag.}

proc attributeGetColumn*(self: CellArea; renderer: CellRenderer; attribute: string): int =
  int(gtk_cell_area_attribute_get_column(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cstring(attribute)))

proc gtk_cell_area_cell_get_property*(self: ptr CellArea00; renderer: ptr CellRenderer00; 
    propertyName: cstring; value: ptr gobject.Value00) {.
    importc: "gtk_cell_area_cell_get_property", libprag.}

proc cellGetProperty*(self: CellArea; renderer: CellRenderer; propertyName: string; 
    value: gobject.Value) =
  gtk_cell_area_cell_get_property(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cstring(propertyName), cast[ptr gobject.Value00](value.impl))

proc gtk_cell_area_cell_set_property*(self: ptr CellArea00; renderer: ptr CellRenderer00; 
    propertyName: cstring; value: ptr gobject.Value00) {.
    importc: "gtk_cell_area_cell_set_property", libprag.}

proc cellSetProperty*(self: CellArea; renderer: CellRenderer; propertyName: string; 
    value: gobject.Value) =
  gtk_cell_area_cell_set_property(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cstring(propertyName), cast[ptr gobject.Value00](value.impl))

proc gtk_cell_area_focus*(self: ptr CellArea00; direction: DirectionType): gboolean {.
    importc: "gtk_cell_area_focus", libprag.}

proc focus*(self: CellArea; direction: DirectionType): bool =
  toBool(gtk_cell_area_focus(cast[ptr CellArea00](self.impl), direction))

proc gtk_cell_area_get_current_path_string*(self: ptr CellArea00): cstring {.
    importc: "gtk_cell_area_get_current_path_string", libprag.}

proc getCurrentPathString*(self: CellArea): string =
  let resul0 = gtk_cell_area_get_current_path_string(cast[ptr CellArea00](self.impl))
  result = $resul0

proc currentPathString*(self: CellArea): string =
  let resul0 = gtk_cell_area_get_current_path_string(cast[ptr CellArea00](self.impl))
  result = $resul0

proc gtk_cell_area_get_edit_widget*(self: ptr CellArea00): ptr CellEditable00 {.
    importc: "gtk_cell_area_get_edit_widget", libprag.}

proc getEditWidget*(self: CellArea): CellEditable =
  new(result)
  result.impl = gtk_cell_area_get_edit_widget(cast[ptr CellArea00](self.impl))

proc editWidget*(self: CellArea): CellEditable =
  new(result)
  result.impl = gtk_cell_area_get_edit_widget(cast[ptr CellArea00](self.impl))

proc gtk_cell_area_get_edited_cell*(self: ptr CellArea00): ptr CellRenderer00 {.
    importc: "gtk_cell_area_get_edited_cell", libprag.}

proc getEditedCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_edited_cell(cast[ptr CellArea00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellRenderer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc editedCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_edited_cell(cast[ptr CellArea00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellRenderer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_focus_cell*(self: ptr CellArea00): ptr CellRenderer00 {.
    importc: "gtk_cell_area_get_focus_cell", libprag.}

proc getFocusCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_focus_cell(cast[ptr CellArea00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellRenderer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_focus_cell(cast[ptr CellArea00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellRenderer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_focus_from_sibling*(self: ptr CellArea00; renderer: ptr CellRenderer00): ptr CellRenderer00 {.
    importc: "gtk_cell_area_get_focus_from_sibling", libprag.}

proc getFocusFromSibling*(self: CellArea; renderer: CellRenderer): CellRenderer =
  let gobj = gtk_cell_area_get_focus_from_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellRenderer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusFromSibling*(self: CellArea; renderer: CellRenderer): CellRenderer =
  let gobj = gtk_cell_area_get_focus_from_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellRenderer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_focus_siblings*(self: ptr CellArea00; renderer: ptr CellRenderer00): ptr pointer {.
    importc: "gtk_cell_area_get_focus_siblings", libprag.}

proc getFocusSiblings*(self: CellArea; renderer: CellRenderer): ptr pointer =
  gtk_cell_area_get_focus_siblings(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc focusSiblings*(self: CellArea; renderer: CellRenderer): ptr pointer =
  gtk_cell_area_get_focus_siblings(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_get_request_mode*(self: ptr CellArea00): SizeRequestMode {.
    importc: "gtk_cell_area_get_request_mode", libprag.}

proc getRequestMode*(self: CellArea): SizeRequestMode =
  gtk_cell_area_get_request_mode(cast[ptr CellArea00](self.impl))

proc requestMode*(self: CellArea): SizeRequestMode =
  gtk_cell_area_get_request_mode(cast[ptr CellArea00](self.impl))

proc gtk_cell_area_has_renderer*(self: ptr CellArea00; renderer: ptr CellRenderer00): gboolean {.
    importc: "gtk_cell_area_has_renderer", libprag.}

proc hasRenderer*(self: CellArea; renderer: CellRenderer): bool =
  toBool(gtk_cell_area_has_renderer(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl)))

proc gtk_cell_area_inner_cell_area*(self: ptr CellArea00; widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; 
    innerArea: var gdk.Rectangle00) {.
    importc: "gtk_cell_area_inner_cell_area", libprag.}

proc innerCellArea*(self: ptr CellArea00; widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; 
    innerArea: var gdk.Rectangle00) {.
    importc: "gtk_cell_area_inner_cell_area", libprag.}

proc gtk_cell_area_is_activatable*(self: ptr CellArea00): gboolean {.
    importc: "gtk_cell_area_is_activatable", libprag.}

proc isActivatable*(self: CellArea): bool =
  toBool(gtk_cell_area_is_activatable(cast[ptr CellArea00](self.impl)))

proc gtk_cell_area_is_focus_sibling*(self: ptr CellArea00; renderer: ptr CellRenderer00; 
    sibling: ptr CellRenderer00): gboolean {.
    importc: "gtk_cell_area_is_focus_sibling", libprag.}

proc isFocusSibling*(self: CellArea; renderer: CellRenderer; sibling: CellRenderer): bool =
  toBool(gtk_cell_area_is_focus_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr CellRenderer00](sibling.impl)))

proc gtk_cell_area_remove*(self: ptr CellArea00; renderer: ptr CellRenderer00) {.
    importc: "gtk_cell_area_remove", libprag.}

proc remove*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_remove(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_remove_focus_sibling*(self: ptr CellArea00; renderer: ptr CellRenderer00; 
    sibling: ptr CellRenderer00) {.
    importc: "gtk_cell_area_remove_focus_sibling", libprag.}

proc removeFocusSibling*(self: CellArea; renderer: CellRenderer; sibling: CellRenderer) =
  gtk_cell_area_remove_focus_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr CellRenderer00](sibling.impl))

proc gtk_cell_area_request_renderer*(self: ptr CellArea00; renderer: ptr CellRenderer00; 
    orientation: Orientation; widget: ptr Widget00; forSize: int32; minimumSize: var int32; naturalSize: var int32) {.
    importc: "gtk_cell_area_request_renderer", libprag.}

proc requestRenderer*(self: CellArea; renderer: CellRenderer; orientation: Orientation; 
    widget: Widget; forSize: int; minimumSize: var int; naturalSize: var int) =
  var minimumSize_00 = int32(minimumSize)
  var naturalSize_00 = int32(naturalSize)
  gtk_cell_area_request_renderer(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), orientation, cast[ptr Widget00](widget.impl), int32(forSize), minimumSize_00, naturalSize_00)
  minimumSize = int(minimumSize_00)
  naturalSize = int(naturalSize_00)

proc gtk_cell_area_set_focus_cell*(self: ptr CellArea00; renderer: ptr CellRenderer00) {.
    importc: "gtk_cell_area_set_focus_cell", libprag.}

proc setFocusCell*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_set_focus_cell(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc `focusCell=`*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_set_focus_cell(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_stop_editing*(self: ptr CellArea00; canceled: gboolean) {.
    importc: "gtk_cell_area_stop_editing", libprag.}

proc stopEditing*(self: CellArea; canceled: bool) =
  gtk_cell_area_stop_editing(cast[ptr CellArea00](self.impl), gboolean(canceled))

proc gtk_combo_box_new_with_area*(area: ptr CellArea00): ptr ComboBox00 {.
    importc: "gtk_combo_box_new_with_area", libprag.}

proc newComboBoxWithArea*(area: CellArea): ComboBox =
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_area(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithArea*[T](result: var T; area: CellArea) =
  assert(result is ComboBox)
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_area(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_area_and_entry*(area: ptr CellArea00): ptr ComboBox00 {.
    importc: "gtk_combo_box_new_with_area_and_entry", libprag.}

proc newComboBoxWithAreaAndEntry*(area: CellArea): ComboBox =
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_area_and_entry(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithAreaAndEntry*[T](result: var T; area: CellArea) =
  assert(result is ComboBox)
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_area_and_entry(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_model*(model: ptr TreeModel00): ptr ComboBox00 {.
    importc: "gtk_combo_box_new_with_model", libprag.}

proc newComboBoxWithModel*(model: TreeModel): ComboBox =
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_model(cast[ptr TreeModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithModel*[T](result: var T; model: TreeModel) =
  assert(result is ComboBox)
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_model(cast[ptr TreeModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_model_and_entry*(model: ptr TreeModel00): ptr ComboBox00 {.
    importc: "gtk_combo_box_new_with_model_and_entry", libprag.}

proc newComboBoxWithModelAndEntry*(model: TreeModel): ComboBox =
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_model_and_entry(cast[ptr TreeModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithModelAndEntry*[T](result: var T; model: TreeModel) =
  assert(result is ComboBox)
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_new_with_model_and_entry(cast[ptr TreeModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_get_model*(self: ptr ComboBox00): ptr TreeModel00 {.
    importc: "gtk_combo_box_get_model", libprag.}

proc getModel*(self: ComboBox): TreeModel =
  new(result)
  result.impl = gtk_combo_box_get_model(cast[ptr ComboBox00](self.impl))

proc model*(self: ComboBox): TreeModel =
  new(result)
  result.impl = gtk_combo_box_get_model(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_set_model*(self: ptr ComboBox00; model: ptr TreeModel00) {.
    importc: "gtk_combo_box_set_model", libprag.}

proc setModel*(self: ComboBox; model: TreeModel) =
  gtk_combo_box_set_model(cast[ptr ComboBox00](self.impl), cast[ptr TreeModel00](model.impl))

proc `model=`*(self: ComboBox; model: TreeModel) =
  gtk_combo_box_set_model(cast[ptr ComboBox00](self.impl), cast[ptr TreeModel00](model.impl))

type
  TreeModelFlag* {.size: sizeof(cint), pure.} = enum
    itersPersist = 1
    listOnly = 2

  TreeModelFlags* {.size: sizeof(cint).} = set[TreeModelFlag]

proc gtk_tree_model_get_flags*(self: ptr TreeModel00): TreeModelFlags {.
    importc: "gtk_tree_model_get_flags", libprag.}

proc getFlags*(self: TreeModel): TreeModelFlags =
  gtk_tree_model_get_flags(cast[ptr TreeModel00](self.impl))

proc flags*(self: TreeModel): TreeModelFlags =
  gtk_tree_model_get_flags(cast[ptr TreeModel00](self.impl))

type
  TreePath00* {.pure.} = object
  TreePath* = ref object
    impl*: ptr TreePath00

proc gtk_tree_path_new*(): ptr TreePath00 {.
    importc: "gtk_tree_path_new", libprag.}

proc newTreePath*(): TreePath =
  new(result)
  result.impl = gtk_tree_path_new()

proc initTreePath*[T](result: var T) =
  assert(result is TreePath)
  new(result)
  result.impl = gtk_tree_path_new()

proc gtk_tree_path_new_first*(): ptr TreePath00 {.
    importc: "gtk_tree_path_new_first", libprag.}

proc newTreePathFirst*(): TreePath =
  new(result)
  result.impl = gtk_tree_path_new_first()

proc initTreePathFirst*[T](result: var T) =
  assert(result is TreePath)
  new(result)
  result.impl = gtk_tree_path_new_first()

proc gtk_tree_path_new_from_indicesv*(indices: int32Array; length: uint64): ptr TreePath00 {.
    importc: "gtk_tree_path_new_from_indicesv", libprag.}

proc newTreePathFromIndices*(indices: int32Array; length: uint64): TreePath =
  new(result)
  result.impl = gtk_tree_path_new_from_indicesv(indices, length)

proc initTreePathFromIndices*[T](result: var T; indices: int32Array; length: uint64) =
  assert(result is TreePath)
  new(result)
  result.impl = gtk_tree_path_new_from_indicesv(indices, length)

proc gtk_tree_path_new_from_string*(path: cstring): ptr TreePath00 {.
    importc: "gtk_tree_path_new_from_string", libprag.}

proc newTreePathFromString*(path: string): TreePath =
  new(result)
  result.impl = gtk_tree_path_new_from_string(cstring(path))

proc initTreePathFromString*[T](result: var T; path: string) =
  assert(result is TreePath)
  new(result)
  result.impl = gtk_tree_path_new_from_string(cstring(path))

proc gtk_tree_path_append_index*(self: ptr TreePath00; index: int32) {.
    importc: "gtk_tree_path_append_index", libprag.}

proc appendIndex*(self: TreePath; index: int) =
  gtk_tree_path_append_index(cast[ptr TreePath00](self.impl), int32(index))

proc gtk_tree_path_compare*(self: ptr TreePath00; b: ptr TreePath00): int32 {.
    importc: "gtk_tree_path_compare", libprag.}

proc compare*(self: TreePath; b: TreePath): int =
  int(gtk_tree_path_compare(cast[ptr TreePath00](self.impl), cast[ptr TreePath00](b.impl)))

proc gtk_tree_path_copy*(self: ptr TreePath00): ptr TreePath00 {.
    importc: "gtk_tree_path_copy", libprag.}

proc copy*(self: TreePath): TreePath =
  new(result)
  result.impl = gtk_tree_path_copy(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_down*(self: ptr TreePath00) {.
    importc: "gtk_tree_path_down", libprag.}

proc down*(self: TreePath) =
  gtk_tree_path_down(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_free*(self: ptr TreePath00) {.
    importc: "gtk_tree_path_free", libprag.}

proc free*(self: TreePath) =
  gtk_tree_path_free(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_get_depth*(self: ptr TreePath00): int32 {.
    importc: "gtk_tree_path_get_depth", libprag.}

proc getDepth*(self: TreePath): int =
  int(gtk_tree_path_get_depth(cast[ptr TreePath00](self.impl)))

proc depth*(self: TreePath): int =
  int(gtk_tree_path_get_depth(cast[ptr TreePath00](self.impl)))

proc gtk_tree_path_get_indices_with_depth*(self: ptr TreePath00; depth: var int32): int32Array {.
    importc: "gtk_tree_path_get_indices_with_depth", libprag.}

proc getIndices*(self: TreePath; depth: var int): int32Array =
  var depth_00 = int32(depth)
  result = gtk_tree_path_get_indices_with_depth(cast[ptr TreePath00](self.impl), depth_00)
  depth = int(depth_00)

proc indices*(self: TreePath; depth: var int): int32Array =
  var depth_00 = int32(depth)
  result = gtk_tree_path_get_indices_with_depth(cast[ptr TreePath00](self.impl), depth_00)
  depth = int(depth_00)

proc gtk_tree_path_is_ancestor*(self: ptr TreePath00; descendant: ptr TreePath00): gboolean {.
    importc: "gtk_tree_path_is_ancestor", libprag.}

proc isAncestor*(self: TreePath; descendant: TreePath): bool =
  toBool(gtk_tree_path_is_ancestor(cast[ptr TreePath00](self.impl), cast[ptr TreePath00](descendant.impl)))

proc gtk_tree_path_is_descendant*(self: ptr TreePath00; ancestor: ptr TreePath00): gboolean {.
    importc: "gtk_tree_path_is_descendant", libprag.}

proc isDescendant*(self: TreePath; ancestor: TreePath): bool =
  toBool(gtk_tree_path_is_descendant(cast[ptr TreePath00](self.impl), cast[ptr TreePath00](ancestor.impl)))

proc gtk_tree_path_next*(self: ptr TreePath00) {.
    importc: "gtk_tree_path_next", libprag.}

proc next*(self: TreePath) =
  gtk_tree_path_next(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_prepend_index*(self: ptr TreePath00; index: int32) {.
    importc: "gtk_tree_path_prepend_index", libprag.}

proc prependIndex*(self: TreePath; index: int) =
  gtk_tree_path_prepend_index(cast[ptr TreePath00](self.impl), int32(index))

proc gtk_tree_path_prev*(self: ptr TreePath00): gboolean {.
    importc: "gtk_tree_path_prev", libprag.}

proc prev*(self: TreePath): bool =
  toBool(gtk_tree_path_prev(cast[ptr TreePath00](self.impl)))

proc gtk_tree_path_to_string*(self: ptr TreePath00): cstring {.
    importc: "gtk_tree_path_to_string", libprag.}

proc toString*(self: TreePath): string =
  let resul0 = gtk_tree_path_to_string(cast[ptr TreePath00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_tree_path_up*(self: ptr TreePath00): gboolean {.
    importc: "gtk_tree_path_up", libprag.}

proc up*(self: TreePath): bool =
  toBool(gtk_tree_path_up(cast[ptr TreePath00](self.impl)))

proc gtk_tree_model_filter_new*(self: ptr TreeModel00; root: ptr TreePath00): ptr TreeModel00 {.
    importc: "gtk_tree_model_filter_new", libprag.}

proc filterNew*(self: TreeModel; root: TreePath): TreeModel =
  new(result)
  result.impl = gtk_tree_model_filter_new(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](root.impl))

proc gtk_tree_model_get_iter*(self: ptr TreeModel00; iter: var TreeIter00; path: ptr TreePath00): gboolean {.
    importc: "gtk_tree_model_get_iter", libprag.}

proc getIter*(self: ptr TreeModel00; iter: var TreeIter00; path: ptr TreePath00): gboolean {.
    importc: "gtk_tree_model_get_iter", libprag.}

proc iter*(self: ptr TreeModel00; iter: var TreeIter00; path: ptr TreePath00): gboolean {.
    importc: "gtk_tree_model_get_iter", libprag.}

proc gtk_tree_model_get_path*(self: ptr TreeModel00; iter: ptr TreeIter00): ptr TreePath00 {.
    importc: "gtk_tree_model_get_path", libprag.}

proc getPath*(self: TreeModel; iter: TreeIter): TreePath =
  new(result)
  result.impl = gtk_tree_model_get_path(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl))

proc path*(self: TreeModel; iter: TreeIter): TreePath =
  new(result)
  result.impl = gtk_tree_model_get_path(cast[ptr TreeModel00](self.impl), cast[ptr TreeIter00](iter.impl))

proc gtk_tree_model_row_changed*(self: ptr TreeModel00; path: ptr TreePath00; iter: ptr TreeIter00) {.
    importc: "gtk_tree_model_row_changed", libprag.}

proc rowChanged*(self: TreeModel; path: TreePath; iter: TreeIter) =
  gtk_tree_model_row_changed(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeIter00](iter.impl))

proc gtk_tree_model_row_deleted*(self: ptr TreeModel00; path: ptr TreePath00) {.
    importc: "gtk_tree_model_row_deleted", libprag.}

proc rowDeleted*(self: TreeModel; path: TreePath) =
  gtk_tree_model_row_deleted(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_model_row_has_child_toggled*(self: ptr TreeModel00; path: ptr TreePath00; iter: ptr TreeIter00) {.
    importc: "gtk_tree_model_row_has_child_toggled", libprag.}

proc rowHasChildToggled*(self: TreeModel; path: TreePath; iter: TreeIter) =
  gtk_tree_model_row_has_child_toggled(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeIter00](iter.impl))

proc gtk_tree_model_row_inserted*(self: ptr TreeModel00; path: ptr TreePath00; iter: ptr TreeIter00) {.
    importc: "gtk_tree_model_row_inserted", libprag.}

proc rowInserted*(self: TreeModel; path: TreePath; iter: TreeIter) =
  gtk_tree_model_row_inserted(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeIter00](iter.impl))

proc gtk_tree_model_rows_reordered_with_length*(self: ptr TreeModel00; path: ptr TreePath00; iter: ptr TreeIter00; 
    newOrder: int32Array; length: int32) {.
    importc: "gtk_tree_model_rows_reordered_with_length", libprag.}

proc rowsReordered*(self: TreeModel; path: TreePath; iter: TreeIter; newOrder: int32Array; 
    length: int) =
  gtk_tree_model_rows_reordered_with_length(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeIter00](iter.impl), newOrder, int32(length))

type
  CellAreaContextPrivate00* {.pure.} = object
  CellAreaContextPrivate* = ref object
    impl*: ptr CellAreaContextPrivate00

type
  CellAreaContext* = ref object of gobject.Object
  CellAreaContext00* = object of gobject.Object00
    priv1: ptr CellAreaContextPrivate00

proc gtk_cell_area_context_allocate*(self: ptr CellAreaContext00; width: int32; height: int32) {.
    importc: "gtk_cell_area_context_allocate", libprag.}

proc allocate*(self: CellAreaContext; width: int; height: int) =
  gtk_cell_area_context_allocate(cast[ptr CellAreaContext00](self.impl), int32(width), int32(height))

proc gtk_cell_area_context_get_allocation*(self: ptr CellAreaContext00; width: var int32; height: var int32) {.
    importc: "gtk_cell_area_context_get_allocation", libprag.}

proc getAllocation*(self: CellAreaContext; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_cell_area_context_get_allocation(cast[ptr CellAreaContext00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc allocation*(self: CellAreaContext; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  gtk_cell_area_context_get_allocation(cast[ptr CellAreaContext00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc gtk_cell_area_context_get_area*(self: ptr CellAreaContext00): ptr CellArea00 {.
    importc: "gtk_cell_area_context_get_area", libprag.}

proc getArea*(self: CellAreaContext): CellArea =
  let gobj = gtk_cell_area_context_get_area(cast[ptr CellAreaContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellArea](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc area*(self: CellAreaContext): CellArea =
  let gobj = gtk_cell_area_context_get_area(cast[ptr CellAreaContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellArea](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_context_get_preferred_height*(self: ptr CellAreaContext00; minimumHeight: var int32; 
    naturalHeight: var int32) {.
    importc: "gtk_cell_area_context_get_preferred_height", libprag.}

proc getPreferredHeight*(self: CellAreaContext; minimumHeight: var int; naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_area_context_get_preferred_height(cast[ptr CellAreaContext00](self.impl), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc preferredHeight*(self: CellAreaContext; minimumHeight: var int; naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_area_context_get_preferred_height(cast[ptr CellAreaContext00](self.impl), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_context_get_preferred_height_for_width*(self: ptr CellAreaContext00; width: int32; minimumHeight: var int32; 
    naturalHeight: var int32) {.
    importc: "gtk_cell_area_context_get_preferred_height_for_width", libprag.}

proc getPreferredHeightForWidth*(self: CellAreaContext; width: int; minimumHeight: var int; 
    naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_area_context_get_preferred_height_for_width(cast[ptr CellAreaContext00](self.impl), int32(width), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc preferredHeightForWidth*(self: CellAreaContext; width: int; minimumHeight: var int; 
    naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_area_context_get_preferred_height_for_width(cast[ptr CellAreaContext00](self.impl), int32(width), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_context_get_preferred_width*(self: ptr CellAreaContext00; minimumWidth: var int32; 
    naturalWidth: var int32) {.
    importc: "gtk_cell_area_context_get_preferred_width", libprag.}

proc getPreferredWidth*(self: CellAreaContext; minimumWidth: var int; naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_area_context_get_preferred_width(cast[ptr CellAreaContext00](self.impl), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc preferredWidth*(self: CellAreaContext; minimumWidth: var int; naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_area_context_get_preferred_width(cast[ptr CellAreaContext00](self.impl), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_context_get_preferred_width_for_height*(self: ptr CellAreaContext00; height: int32; minimumWidth: var int32; 
    naturalWidth: var int32) {.
    importc: "gtk_cell_area_context_get_preferred_width_for_height", libprag.}

proc getPreferredWidthForHeight*(self: CellAreaContext; height: int; minimumWidth: var int; 
    naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_area_context_get_preferred_width_for_height(cast[ptr CellAreaContext00](self.impl), int32(height), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc preferredWidthForHeight*(self: CellAreaContext; height: int; minimumWidth: var int; 
    naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_area_context_get_preferred_width_for_height(cast[ptr CellAreaContext00](self.impl), int32(height), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_context_push_preferred_height*(self: ptr CellAreaContext00; minimumHeight: int32; 
    naturalHeight: int32) {.
    importc: "gtk_cell_area_context_push_preferred_height", libprag.}

proc pushPreferredHeight*(self: CellAreaContext; minimumHeight: int; naturalHeight: int) =
  gtk_cell_area_context_push_preferred_height(cast[ptr CellAreaContext00](self.impl), int32(minimumHeight), int32(naturalHeight))

proc gtk_cell_area_context_push_preferred_width*(self: ptr CellAreaContext00; minimumWidth: int32; 
    naturalWidth: int32) {.
    importc: "gtk_cell_area_context_push_preferred_width", libprag.}

proc pushPreferredWidth*(self: CellAreaContext; minimumWidth: int; naturalWidth: int) =
  gtk_cell_area_context_push_preferred_width(cast[ptr CellAreaContext00](self.impl), int32(minimumWidth), int32(naturalWidth))

proc gtk_cell_area_context_reset*(self: ptr CellAreaContext00) {.
    importc: "gtk_cell_area_context_reset", libprag.}

proc reset*(self: CellAreaContext) =
  gtk_cell_area_context_reset(cast[ptr CellAreaContext00](self.impl))

proc gtk_cell_area_activate*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; flags: CellRendererState; editOnly: gboolean): gboolean {.
    importc: "gtk_cell_area_activate", libprag.}

proc activate*(self: CellArea; context: CellAreaContext; widget: Widget; 
    cellArea: gdk.Rectangle; flags: CellRendererState; editOnly: bool): bool =
  toBool(gtk_cell_area_activate(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Rectangle00](cellArea.impl), flags, gboolean(editOnly)))

proc gtk_cell_area_copy_context*(self: ptr CellArea00; context: ptr CellAreaContext00): ptr CellAreaContext00 {.
    importc: "gtk_cell_area_copy_context", libprag.}

proc copyContext*(self: CellArea; context: CellAreaContext): CellAreaContext =
  let gobj = gtk_cell_area_copy_context(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellAreaContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_create_context*(self: ptr CellArea00): ptr CellAreaContext00 {.
    importc: "gtk_cell_area_create_context", libprag.}

proc createContext*(self: CellArea): CellAreaContext =
  let gobj = gtk_cell_area_create_context(cast[ptr CellArea00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellAreaContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_event*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; event: ptr gdk.Event00; cellArea: ptr gdk.Rectangle00; flags: CellRendererState): int32 {.
    importc: "gtk_cell_area_event", libprag.}

proc event*(self: CellArea; context: CellAreaContext; widget: Widget; 
    event: gdk.Event; cellArea: gdk.Rectangle; flags: CellRendererState): int =
  int(gtk_cell_area_event(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Event00](event.impl), cast[ptr gdk.Rectangle00](cellArea.impl), flags))

proc gtk_cell_area_get_cell_allocation*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; renderer: ptr CellRenderer00; cellArea: ptr gdk.Rectangle00; allocation: var gdk.Rectangle00) {.
    importc: "gtk_cell_area_get_cell_allocation", libprag.}

proc getCellAllocation*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; renderer: ptr CellRenderer00; cellArea: ptr gdk.Rectangle00; allocation: var gdk.Rectangle00) {.
    importc: "gtk_cell_area_get_cell_allocation", libprag.}

proc cellAllocation*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; renderer: ptr CellRenderer00; cellArea: ptr gdk.Rectangle00; allocation: var gdk.Rectangle00) {.
    importc: "gtk_cell_area_get_cell_allocation", libprag.}

proc gtk_cell_area_get_cell_at_position*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; x: int32; y: int32; allocArea: var gdk.Rectangle00): ptr CellRenderer00 {.
    importc: "gtk_cell_area_get_cell_at_position", libprag.}

proc getCellAtPosition*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; x: int32; y: int32; allocArea: var gdk.Rectangle00): ptr CellRenderer00 {.
    importc: "gtk_cell_area_get_cell_at_position", libprag.}

proc cellAtPosition*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; x: int32; y: int32; allocArea: var gdk.Rectangle00): ptr CellRenderer00 {.
    importc: "gtk_cell_area_get_cell_at_position", libprag.}

proc gtk_cell_area_get_preferred_height*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; minimumHeight: var int32; naturalHeight: var int32) {.
    importc: "gtk_cell_area_get_preferred_height", libprag.}

proc getPreferredHeight*(self: CellArea; context: CellAreaContext; widget: Widget; 
    minimumHeight: var int; naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_area_get_preferred_height(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc preferredHeight*(self: CellArea; context: CellAreaContext; widget: Widget; 
    minimumHeight: var int; naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_area_get_preferred_height(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_get_preferred_height_for_width*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; width: int32; minimumHeight: var int32; naturalHeight: var int32) {.
    importc: "gtk_cell_area_get_preferred_height_for_width", libprag.}

proc getPreferredHeightForWidth*(self: CellArea; context: CellAreaContext; widget: Widget; 
    width: int; minimumHeight: var int; naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_area_get_preferred_height_for_width(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), int32(width), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc preferredHeightForWidth*(self: CellArea; context: CellAreaContext; widget: Widget; 
    width: int; minimumHeight: var int; naturalHeight: var int) =
  var naturalHeight_00 = int32(naturalHeight)
  var minimumHeight_00 = int32(minimumHeight)
  gtk_cell_area_get_preferred_height_for_width(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), int32(width), minimumHeight_00, naturalHeight_00)
  naturalHeight = int(naturalHeight_00)
  minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_get_preferred_width*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; minimumWidth: var int32; naturalWidth: var int32) {.
    importc: "gtk_cell_area_get_preferred_width", libprag.}

proc getPreferredWidth*(self: CellArea; context: CellAreaContext; widget: Widget; 
    minimumWidth: var int; naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_area_get_preferred_width(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc preferredWidth*(self: CellArea; context: CellAreaContext; widget: Widget; 
    minimumWidth: var int; naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_area_get_preferred_width(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_get_preferred_width_for_height*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; height: int32; minimumWidth: var int32; naturalWidth: var int32) {.
    importc: "gtk_cell_area_get_preferred_width_for_height", libprag.}

proc getPreferredWidthForHeight*(self: CellArea; context: CellAreaContext; widget: Widget; 
    height: int; minimumWidth: var int; naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_area_get_preferred_width_for_height(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), int32(height), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc preferredWidthForHeight*(self: CellArea; context: CellAreaContext; widget: Widget; 
    height: int; minimumWidth: var int; naturalWidth: var int) =
  var minimumWidth_00 = int32(minimumWidth)
  var naturalWidth_00 = int32(naturalWidth)
  gtk_cell_area_get_preferred_width_for_height(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), int32(height), minimumWidth_00, naturalWidth_00)
  minimumWidth = int(minimumWidth_00)
  naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_render*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; cr: ptr cairo.Context00; backgroundArea: ptr gdk.Rectangle00; cellArea: ptr gdk.Rectangle00; 
    flags: CellRendererState; paintFocus: gboolean) {.
    importc: "gtk_cell_area_render", libprag.}

proc render*(self: CellArea; context: CellAreaContext; widget: Widget; 
    cr: cairo.Context; backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle; flags: CellRendererState; 
    paintFocus: bool) =
  gtk_cell_area_render(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr gdk.Rectangle00](backgroundArea.impl), cast[ptr gdk.Rectangle00](cellArea.impl), flags, gboolean(paintFocus))

type
  AppChooserDialogPrivate00* {.pure.} = object
  AppChooserDialogPrivate* = ref object
    impl*: ptr AppChooserDialogPrivate00

type
  AppChooserDialog* = ref object of Dialog
  AppChooserDialog00* = object of Dialog00
    priv6: ptr AppChooserDialogPrivate00

proc gtk_app_chooser_dialog_get_heading*(self: ptr AppChooserDialog00): cstring {.
    importc: "gtk_app_chooser_dialog_get_heading", libprag.}

proc getHeading*(self: AppChooserDialog): string =
  let resul0 = gtk_app_chooser_dialog_get_heading(cast[ptr AppChooserDialog00](self.impl))
  result = $resul0

proc heading*(self: AppChooserDialog): string =
  let resul0 = gtk_app_chooser_dialog_get_heading(cast[ptr AppChooserDialog00](self.impl))
  result = $resul0

proc gtk_app_chooser_dialog_get_widget*(self: ptr AppChooserDialog00): ptr Widget00 {.
    importc: "gtk_app_chooser_dialog_get_widget", libprag.}

proc getWidget*(self: AppChooserDialog): Widget =
  let gobj = gtk_app_chooser_dialog_get_widget(cast[ptr AppChooserDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: AppChooserDialog): Widget =
  let gobj = gtk_app_chooser_dialog_get_widget(cast[ptr AppChooserDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_dialog_set_heading*(self: ptr AppChooserDialog00; heading: cstring) {.
    importc: "gtk_app_chooser_dialog_set_heading", libprag.}

proc setHeading*(self: AppChooserDialog; heading: string) =
  gtk_app_chooser_dialog_set_heading(cast[ptr AppChooserDialog00](self.impl), cstring(heading))

proc `heading=`*(self: AppChooserDialog; heading: string) =
  gtk_app_chooser_dialog_set_heading(cast[ptr AppChooserDialog00](self.impl), cstring(heading))

type
  DialogFlag* {.size: sizeof(cint), pure.} = enum
    modal = 1
    destroyWithParent = 2
    useHeaderBar = 3

  DialogFlags* {.size: sizeof(cint).} = set[DialogFlag]

proc gtk_app_chooser_dialog_new*(parent: ptr Window00; flags: DialogFlags; file: ptr gio.File00): ptr AppChooserDialog00 {.
    importc: "gtk_app_chooser_dialog_new", libprag.}

proc newAppChooserDialog*(parent: Window; flags: DialogFlags; file: gio.File): AppChooserDialog =
  new(result, finalizeGObject)
  result.impl = gtk_app_chooser_dialog_new(cast[ptr Window00](parent.impl), flags, cast[ptr gio.File00](file.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserDialog*[T](result: var T; parent: Window; flags: DialogFlags; file: gio.File) =
  assert(result is AppChooserDialog)
  new(result, finalizeGObject)
  result.impl = gtk_app_chooser_dialog_new(cast[ptr Window00](parent.impl), flags, cast[ptr gio.File00](file.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_dialog_new_for_content_type*(parent: ptr Window00; flags: DialogFlags; contentType: cstring): ptr AppChooserDialog00 {.
    importc: "gtk_app_chooser_dialog_new_for_content_type", libprag.}

proc newAppChooserDialogForContentType*(parent: Window; flags: DialogFlags; contentType: string): AppChooserDialog =
  new(result, finalizeGObject)
  result.impl = gtk_app_chooser_dialog_new_for_content_type(cast[ptr Window00](parent.impl), flags, cstring(contentType))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserDialogForContentType*[T](result: var T; parent: Window; flags: DialogFlags; contentType: string) =
  assert(result is AppChooserDialog)
  new(result, finalizeGObject)
  result.impl = gtk_app_chooser_dialog_new_for_content_type(cast[ptr Window00](parent.impl), flags, cstring(contentType))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  AppChooserWidgetPrivate00* {.pure.} = object
  AppChooserWidgetPrivate* = ref object
    impl*: ptr AppChooserWidgetPrivate00

type
  AppChooserWidget* = ref object of Box
  AppChooserWidget00* = object of Box00
    priv4: ptr AppChooserWidgetPrivate00

proc scApplicationActivated*(self: AppChooserWidget;  p: proc (self: ptr gobject.Object00; application: gio.AppInfo00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "application-activated", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scApplicationSelected*(self: AppChooserWidget;  p: proc (self: ptr gobject.Object00; application: gio.AppInfo00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "application-selected", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopulatePopup*(self: AppChooserWidget;  p: proc (self: ptr gobject.Object00; menu: Menu00; application: gio.AppInfo00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_app_chooser_widget_new*(contentType: cstring): ptr AppChooserWidget00 {.
    importc: "gtk_app_chooser_widget_new", libprag.}

proc newAppChooserWidget*(contentType: string): AppChooserWidget =
  new(result, finalizeGObject)
  result.impl = gtk_app_chooser_widget_new(cstring(contentType))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserWidget*[T](result: var T; contentType: string) =
  assert(result is AppChooserWidget)
  new(result, finalizeGObject)
  result.impl = gtk_app_chooser_widget_new(cstring(contentType))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_widget_get_default_text*(self: ptr AppChooserWidget00): cstring {.
    importc: "gtk_app_chooser_widget_get_default_text", libprag.}

proc getDefaultText*(self: AppChooserWidget): string =
  let resul0 = gtk_app_chooser_widget_get_default_text(cast[ptr AppChooserWidget00](self.impl))
  result = $resul0

proc defaultText*(self: AppChooserWidget): string =
  let resul0 = gtk_app_chooser_widget_get_default_text(cast[ptr AppChooserWidget00](self.impl))
  result = $resul0

proc gtk_app_chooser_widget_get_show_all*(self: ptr AppChooserWidget00): gboolean {.
    importc: "gtk_app_chooser_widget_get_show_all", libprag.}

proc getShowAll*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_all(cast[ptr AppChooserWidget00](self.impl)))

proc showAll*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_all(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_default*(self: ptr AppChooserWidget00): gboolean {.
    importc: "gtk_app_chooser_widget_get_show_default", libprag.}

proc getShowDefault*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_default(cast[ptr AppChooserWidget00](self.impl)))

proc showDefault*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_default(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_fallback*(self: ptr AppChooserWidget00): gboolean {.
    importc: "gtk_app_chooser_widget_get_show_fallback", libprag.}

proc getShowFallback*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_fallback(cast[ptr AppChooserWidget00](self.impl)))

proc showFallback*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_fallback(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_other*(self: ptr AppChooserWidget00): gboolean {.
    importc: "gtk_app_chooser_widget_get_show_other", libprag.}

proc getShowOther*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_other(cast[ptr AppChooserWidget00](self.impl)))

proc showOther*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_other(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_recommended*(self: ptr AppChooserWidget00): gboolean {.
    importc: "gtk_app_chooser_widget_get_show_recommended", libprag.}

proc getShowRecommended*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_recommended(cast[ptr AppChooserWidget00](self.impl)))

proc showRecommended*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_recommended(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_set_default_text*(self: ptr AppChooserWidget00; text: cstring) {.
    importc: "gtk_app_chooser_widget_set_default_text", libprag.}

proc setDefaultText*(self: AppChooserWidget; text: string) =
  gtk_app_chooser_widget_set_default_text(cast[ptr AppChooserWidget00](self.impl), cstring(text))

proc `defaultText=`*(self: AppChooserWidget; text: string) =
  gtk_app_chooser_widget_set_default_text(cast[ptr AppChooserWidget00](self.impl), cstring(text))

proc gtk_app_chooser_widget_set_show_all*(self: ptr AppChooserWidget00; setting: gboolean) {.
    importc: "gtk_app_chooser_widget_set_show_all", libprag.}

proc setShowAll*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_all(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showAll=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_all(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_default*(self: ptr AppChooserWidget00; setting: gboolean) {.
    importc: "gtk_app_chooser_widget_set_show_default", libprag.}

proc setShowDefault*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_default(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showDefault=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_default(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_fallback*(self: ptr AppChooserWidget00; setting: gboolean) {.
    importc: "gtk_app_chooser_widget_set_show_fallback", libprag.}

proc setShowFallback*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_fallback(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showFallback=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_fallback(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_other*(self: ptr AppChooserWidget00; setting: gboolean) {.
    importc: "gtk_app_chooser_widget_set_show_other", libprag.}

proc setShowOther*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_other(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showOther=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_other(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_recommended*(self: ptr AppChooserWidget00; setting: gboolean) {.
    importc: "gtk_app_chooser_widget_set_show_recommended", libprag.}

proc setShowRecommended*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_recommended(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showRecommended=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_recommended(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

type
  ApplicationClass00* {.pure.} = object
    parentClass*: gio.ApplicationClass00
    windowAdded*: proc(application: ptr Application00; window: ptr Window00) {.cdecl.}
    windowRemoved*: proc(application: ptr Application00; window: ptr Window00) {.cdecl.}
    padding*: array[12, pointer]
  ApplicationClass* = ref object
    impl*: ptr ApplicationClass00

type
  ApplicationWindowPrivate00* {.pure.} = object
  ApplicationWindowPrivate* = ref object
    impl*: ptr ApplicationWindowPrivate00

type
  ApplicationWindow* = ref object of Window
  ApplicationWindow00* = object of Window00
    priv5: ptr ApplicationWindowPrivate00

proc gtk_application_window_new*(application: ptr Application00): ptr ApplicationWindow00 {.
    importc: "gtk_application_window_new", libprag.}

proc newApplicationWindow*(application: Application): ApplicationWindow =
  new(result, finalizeGObject)
  result.impl = gtk_application_window_new(cast[ptr Application00](application.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initApplicationWindow*[T](result: var T; application: Application) =
  assert(result is ApplicationWindow)
  new(result, finalizeGObject)
  result.impl = gtk_application_window_new(cast[ptr Application00](application.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_window_get_id*(self: ptr ApplicationWindow00): uint32 {.
    importc: "gtk_application_window_get_id", libprag.}

proc getId*(self: ApplicationWindow): int =
  int(gtk_application_window_get_id(cast[ptr ApplicationWindow00](self.impl)))

proc id*(self: ApplicationWindow): int =
  int(gtk_application_window_get_id(cast[ptr ApplicationWindow00](self.impl)))

proc gtk_application_window_get_show_menubar*(self: ptr ApplicationWindow00): gboolean {.
    importc: "gtk_application_window_get_show_menubar", libprag.}

proc getShowMenubar*(self: ApplicationWindow): bool =
  toBool(gtk_application_window_get_show_menubar(cast[ptr ApplicationWindow00](self.impl)))

proc showMenubar*(self: ApplicationWindow): bool =
  toBool(gtk_application_window_get_show_menubar(cast[ptr ApplicationWindow00](self.impl)))

proc gtk_application_window_set_show_menubar*(self: ptr ApplicationWindow00; showMenubar: gboolean) {.
    importc: "gtk_application_window_set_show_menubar", libprag.}

proc setShowMenubar*(self: ApplicationWindow; showMenubar: bool) =
  gtk_application_window_set_show_menubar(cast[ptr ApplicationWindow00](self.impl), gboolean(showMenubar))

proc `showMenubar=`*(self: ApplicationWindow; showMenubar: bool) =
  gtk_application_window_set_show_menubar(cast[ptr ApplicationWindow00](self.impl), gboolean(showMenubar))

type
  ShortcutsWindow* = ref object of Window
  ShortcutsWindow00* = object of Window00

proc scClose*(self: ShortcutsWindow;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSearch*(self: ShortcutsWindow;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "search", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_application_window_get_help_overlay*(self: ptr ApplicationWindow00): ptr ShortcutsWindow00 {.
    importc: "gtk_application_window_get_help_overlay", libprag.}

proc getHelpOverlay*(self: ApplicationWindow): ShortcutsWindow =
  let gobj = gtk_application_window_get_help_overlay(cast[ptr ApplicationWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ShortcutsWindow](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc helpOverlay*(self: ApplicationWindow): ShortcutsWindow =
  let gobj = gtk_application_window_get_help_overlay(cast[ptr ApplicationWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ShortcutsWindow](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_window_set_help_overlay*(self: ptr ApplicationWindow00; helpOverlay: ptr ShortcutsWindow00) {.
    importc: "gtk_application_window_set_help_overlay", libprag.}

proc setHelpOverlay*(self: ApplicationWindow; helpOverlay: ShortcutsWindow) =
  gtk_application_window_set_help_overlay(cast[ptr ApplicationWindow00](self.impl), cast[ptr ShortcutsWindow00](helpOverlay.impl))

proc `helpOverlay=`*(self: ApplicationWindow; helpOverlay: ShortcutsWindow) =
  gtk_application_window_set_help_overlay(cast[ptr ApplicationWindow00](self.impl), cast[ptr ShortcutsWindow00](helpOverlay.impl))

type
  ArrowPrivate00* {.pure.} = object
  ArrowPrivate* = ref object
    impl*: ptr ArrowPrivate00

type
  Arrow* = ref object of Misc
  Arrow00* = object of Misc00
    priv3: ptr ArrowPrivate00

type
  ArrowType* {.size: sizeof(cint), pure.} = enum
    up = 0
    down = 1
    left = 2
    right = 3
    none = 4

type
  ShadowType* {.size: sizeof(cint), pure.} = enum
    none = 0
    `in` = 1
    `out` = 2
    etchedIn = 3
    etchedOut = 4

proc gtk_arrow_new*(arrowType: ArrowType; shadowType: ShadowType): ptr Arrow00 {.
    importc: "gtk_arrow_new", libprag.}

proc newArrow*(arrowType: ArrowType; shadowType: ShadowType): Arrow =
  new(result, finalizeGObject)
  result.impl = gtk_arrow_new(arrowType, shadowType)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initArrow*[T](result: var T; arrowType: ArrowType; shadowType: ShadowType) =
  assert(result is Arrow)
  new(result, finalizeGObject)
  result.impl = gtk_arrow_new(arrowType, shadowType)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_arrow_set*(self: ptr Arrow00; arrowType: ArrowType; shadowType: ShadowType) {.
    importc: "gtk_arrow_set", libprag.}

proc set*(self: Arrow; arrowType: ArrowType; shadowType: ShadowType) =
  gtk_arrow_set(cast[ptr Arrow00](self.impl), arrowType, shadowType)

type
  WidgetAccessiblePrivate00* {.pure.} = object
  WidgetAccessiblePrivate* = ref object
    impl*: ptr WidgetAccessiblePrivate00

type
  WidgetAccessible* = ref object of Accessible
  WidgetAccessible00* = object of Accessible00
    priv2: ptr WidgetAccessiblePrivate00

type
  ArrowAccessiblePrivate00* {.pure.} = object
  ArrowAccessiblePrivate* = ref object
    impl*: ptr ArrowAccessiblePrivate00

type
  ArrowAccessible* = ref object of WidgetAccessible
  ArrowAccessible00* = object of WidgetAccessible00
    priv3: ptr ArrowAccessiblePrivate00

type
  WidgetAccessibleClass00* {.pure.} = object
    parentClass*: AccessibleClass00
    notifyGtk*: proc(`object`: ptr gobject.Object00; pspec: ptr gobject.ParamSpec00) {.cdecl.}
  WidgetAccessibleClass* = ref object
    impl*: ptr WidgetAccessibleClass00

type
  ArrowAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
  ArrowAccessibleClass* = ref object
    impl*: ptr ArrowAccessibleClass00

type
  ArrowClass00* {.pure.} = object
    parentClass*: MiscClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ArrowClass* = ref object
    impl*: ptr ArrowClass00

type
  ArrowPlacement* {.size: sizeof(cint), pure.} = enum
    both = 0
    start = 1
    `end` = 2

type
  FramePrivate00* {.pure.} = object
  FramePrivate* = ref object
    impl*: ptr FramePrivate00

type
  Frame* = ref object of Bin
  Frame00* = object of Bin00
    priv4: ptr FramePrivate00

proc gtk_frame_new*(label: cstring): ptr Frame00 {.
    importc: "gtk_frame_new", libprag.}

proc newFrame*(label: string): Frame =
  new(result, finalizeGObject)
  result.impl = gtk_frame_new(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFrame*[T](result: var T; label: string) =
  assert(result is Frame)
  new(result, finalizeGObject)
  result.impl = gtk_frame_new(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_frame_get_label*(self: ptr Frame00): cstring {.
    importc: "gtk_frame_get_label", libprag.}

proc getLabel*(self: Frame): string =
  let resul0 = gtk_frame_get_label(cast[ptr Frame00](self.impl))
  result = $resul0

proc label*(self: Frame): string =
  let resul0 = gtk_frame_get_label(cast[ptr Frame00](self.impl))
  result = $resul0

proc gtk_frame_get_label_align*(self: ptr Frame00; xalign: var cfloat; yalign: var cfloat) {.
    importc: "gtk_frame_get_label_align", libprag.}

proc getLabelAlign*(self: Frame; xalign: var cfloat; yalign: var cfloat) =
  gtk_frame_get_label_align(cast[ptr Frame00](self.impl), xalign, yalign)

proc labelAlign*(self: Frame; xalign: var cfloat; yalign: var cfloat) =
  gtk_frame_get_label_align(cast[ptr Frame00](self.impl), xalign, yalign)

proc gtk_frame_get_label_widget*(self: ptr Frame00): ptr Widget00 {.
    importc: "gtk_frame_get_label_widget", libprag.}

proc getLabelWidget*(self: Frame): Widget =
  let gobj = gtk_frame_get_label_widget(cast[ptr Frame00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: Frame): Widget =
  let gobj = gtk_frame_get_label_widget(cast[ptr Frame00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_frame_get_shadow_type*(self: ptr Frame00): ShadowType {.
    importc: "gtk_frame_get_shadow_type", libprag.}

proc getShadowType*(self: Frame): ShadowType =
  gtk_frame_get_shadow_type(cast[ptr Frame00](self.impl))

proc shadowType*(self: Frame): ShadowType =
  gtk_frame_get_shadow_type(cast[ptr Frame00](self.impl))

proc gtk_frame_set_label*(self: ptr Frame00; label: cstring) {.
    importc: "gtk_frame_set_label", libprag.}

proc setLabel*(self: Frame; label: string) =
  gtk_frame_set_label(cast[ptr Frame00](self.impl), cstring(label))

proc `label=`*(self: Frame; label: string) =
  gtk_frame_set_label(cast[ptr Frame00](self.impl), cstring(label))

proc gtk_frame_set_label_align*(self: ptr Frame00; xalign: cfloat; yalign: cfloat) {.
    importc: "gtk_frame_set_label_align", libprag.}

proc setLabelAlign*(self: Frame; xalign: cfloat; yalign: cfloat) =
  gtk_frame_set_label_align(cast[ptr Frame00](self.impl), xalign, yalign)

proc gtk_frame_set_label_widget*(self: ptr Frame00; labelWidget: ptr Widget00) {.
    importc: "gtk_frame_set_label_widget", libprag.}

proc setLabelWidget*(self: Frame; labelWidget: Widget) =
  gtk_frame_set_label_widget(cast[ptr Frame00](self.impl), cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: Frame; labelWidget: Widget) =
  gtk_frame_set_label_widget(cast[ptr Frame00](self.impl), cast[ptr Widget00](labelWidget.impl))

proc gtk_frame_set_shadow_type*(self: ptr Frame00; `type`: ShadowType) {.
    importc: "gtk_frame_set_shadow_type", libprag.}

proc setShadowType*(self: Frame; `type`: ShadowType) =
  gtk_frame_set_shadow_type(cast[ptr Frame00](self.impl), `type`)

proc `shadowType=`*(self: Frame; `type`: ShadowType) =
  gtk_frame_set_shadow_type(cast[ptr Frame00](self.impl), `type`)

type
  AspectFramePrivate00* {.pure.} = object
  AspectFramePrivate* = ref object
    impl*: ptr AspectFramePrivate00

type
  AspectFrame* = ref object of Frame
  AspectFrame00* = object of Frame00
    priv5: ptr AspectFramePrivate00

proc gtk_aspect_frame_new*(label: cstring; xalign: cfloat; yalign: cfloat; ratio: cfloat; 
    obeyChild: gboolean): ptr AspectFrame00 {.
    importc: "gtk_aspect_frame_new", libprag.}

proc newAspectFrame*(label: string; xalign: cfloat; yalign: cfloat; ratio: cfloat; 
    obeyChild: bool): AspectFrame =
  new(result, finalizeGObject)
  result.impl = gtk_aspect_frame_new(cstring(label), xalign, yalign, ratio, gboolean(obeyChild))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAspectFrame*[T](result: var T; label: string; xalign: cfloat; yalign: cfloat; ratio: cfloat; 
    obeyChild: bool) =
  assert(result is AspectFrame)
  new(result, finalizeGObject)
  result.impl = gtk_aspect_frame_new(cstring(label), xalign, yalign, ratio, gboolean(obeyChild))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_aspect_frame_set*(self: ptr AspectFrame00; xalign: cfloat; yalign: cfloat; 
    ratio: cfloat; obeyChild: gboolean) {.
    importc: "gtk_aspect_frame_set", libprag.}

proc set*(self: AspectFrame; xalign: cfloat; yalign: cfloat; 
    ratio: cfloat; obeyChild: bool) =
  gtk_aspect_frame_set(cast[ptr AspectFrame00](self.impl), xalign, yalign, ratio, gboolean(obeyChild))

type
  AssistantPrivate00* {.pure.} = object
  AssistantPrivate* = ref object
    impl*: ptr AssistantPrivate00

type
  Assistant* = ref object of Window
  Assistant00* = object of Window00
    priv5: ptr AssistantPrivate00

proc scApply*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "apply", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCancel*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cancel", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scClose*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEscape*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "escape", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPrepare*(self: Assistant;  p: proc (self: ptr gobject.Object00; page: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "prepare", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_assistant_new*(): ptr Assistant00 {.
    importc: "gtk_assistant_new", libprag.}

proc newAssistant*(): Assistant =
  new(result, finalizeGObject)
  result.impl = gtk_assistant_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAssistant*[T](result: var T) =
  assert(result is Assistant)
  new(result, finalizeGObject)
  result.impl = gtk_assistant_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_add_action_widget*(self: ptr Assistant00; child: ptr Widget00) {.
    importc: "gtk_assistant_add_action_widget", libprag.}

proc addActionWidget*(self: Assistant; child: Widget) =
  gtk_assistant_add_action_widget(cast[ptr Assistant00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_assistant_append_page*(self: ptr Assistant00; page: ptr Widget00): int32 {.
    importc: "gtk_assistant_append_page", libprag.}

proc appendPage*(self: Assistant; page: Widget): int =
  int(gtk_assistant_append_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_commit*(self: ptr Assistant00) {.
    importc: "gtk_assistant_commit", libprag.}

proc commit*(self: Assistant) =
  gtk_assistant_commit(cast[ptr Assistant00](self.impl))

proc gtk_assistant_get_current_page*(self: ptr Assistant00): int32 {.
    importc: "gtk_assistant_get_current_page", libprag.}

proc getCurrentPage*(self: Assistant): int =
  int(gtk_assistant_get_current_page(cast[ptr Assistant00](self.impl)))

proc currentPage*(self: Assistant): int =
  int(gtk_assistant_get_current_page(cast[ptr Assistant00](self.impl)))

proc gtk_assistant_get_n_pages*(self: ptr Assistant00): int32 {.
    importc: "gtk_assistant_get_n_pages", libprag.}

proc getNPages*(self: Assistant): int =
  int(gtk_assistant_get_n_pages(cast[ptr Assistant00](self.impl)))

proc nPages*(self: Assistant): int =
  int(gtk_assistant_get_n_pages(cast[ptr Assistant00](self.impl)))

proc gtk_assistant_get_nth_page*(self: ptr Assistant00; pageNum: int32): ptr Widget00 {.
    importc: "gtk_assistant_get_nth_page", libprag.}

proc getNthPage*(self: Assistant; pageNum: int): Widget =
  let gobj = gtk_assistant_get_nth_page(cast[ptr Assistant00](self.impl), int32(pageNum))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc nthPage*(self: Assistant; pageNum: int): Widget =
  let gobj = gtk_assistant_get_nth_page(cast[ptr Assistant00](self.impl), int32(pageNum))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_get_page_complete*(self: ptr Assistant00; page: ptr Widget00): gboolean {.
    importc: "gtk_assistant_get_page_complete", libprag.}

proc getPageComplete*(self: Assistant; page: Widget): bool =
  toBool(gtk_assistant_get_page_complete(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc pageComplete*(self: Assistant; page: Widget): bool =
  toBool(gtk_assistant_get_page_complete(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_get_page_has_padding*(self: ptr Assistant00; page: ptr Widget00): gboolean {.
    importc: "gtk_assistant_get_page_has_padding", libprag.}

proc getPageHasPadding*(self: Assistant; page: Widget): bool =
  toBool(gtk_assistant_get_page_has_padding(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc pageHasPadding*(self: Assistant; page: Widget): bool =
  toBool(gtk_assistant_get_page_has_padding(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_get_page_header_image*(self: ptr Assistant00; page: ptr Widget00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_assistant_get_page_header_image", libprag.}

proc getPageHeaderImage*(self: Assistant; page: Widget): gdkpixbuf.Pixbuf =
  let gobj = gtk_assistant_get_page_header_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pageHeaderImage*(self: Assistant; page: Widget): gdkpixbuf.Pixbuf =
  let gobj = gtk_assistant_get_page_header_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_get_page_side_image*(self: ptr Assistant00; page: ptr Widget00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_assistant_get_page_side_image", libprag.}

proc getPageSideImage*(self: Assistant; page: Widget): gdkpixbuf.Pixbuf =
  let gobj = gtk_assistant_get_page_side_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pageSideImage*(self: Assistant; page: Widget): gdkpixbuf.Pixbuf =
  let gobj = gtk_assistant_get_page_side_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_get_page_title*(self: ptr Assistant00; page: ptr Widget00): cstring {.
    importc: "gtk_assistant_get_page_title", libprag.}

proc getPageTitle*(self: Assistant; page: Widget): string =
  let resul0 = gtk_assistant_get_page_title(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))
  result = $resul0

proc pageTitle*(self: Assistant; page: Widget): string =
  let resul0 = gtk_assistant_get_page_title(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))
  result = $resul0

proc gtk_assistant_insert_page*(self: ptr Assistant00; page: ptr Widget00; position: int32): int32 {.
    importc: "gtk_assistant_insert_page", libprag.}

proc insertPage*(self: Assistant; page: Widget; position: int): int =
  int(gtk_assistant_insert_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), int32(position)))

proc gtk_assistant_next_page*(self: ptr Assistant00) {.
    importc: "gtk_assistant_next_page", libprag.}

proc nextPage*(self: Assistant) =
  gtk_assistant_next_page(cast[ptr Assistant00](self.impl))

proc gtk_assistant_prepend_page*(self: ptr Assistant00; page: ptr Widget00): int32 {.
    importc: "gtk_assistant_prepend_page", libprag.}

proc prependPage*(self: Assistant; page: Widget): int =
  int(gtk_assistant_prepend_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_previous_page*(self: ptr Assistant00) {.
    importc: "gtk_assistant_previous_page", libprag.}

proc previousPage*(self: Assistant) =
  gtk_assistant_previous_page(cast[ptr Assistant00](self.impl))

proc gtk_assistant_remove_action_widget*(self: ptr Assistant00; child: ptr Widget00) {.
    importc: "gtk_assistant_remove_action_widget", libprag.}

proc removeActionWidget*(self: Assistant; child: Widget) =
  gtk_assistant_remove_action_widget(cast[ptr Assistant00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_assistant_remove_page*(self: ptr Assistant00; pageNum: int32) {.
    importc: "gtk_assistant_remove_page", libprag.}

proc removePage*(self: Assistant; pageNum: int) =
  gtk_assistant_remove_page(cast[ptr Assistant00](self.impl), int32(pageNum))

proc gtk_assistant_set_current_page*(self: ptr Assistant00; pageNum: int32) {.
    importc: "gtk_assistant_set_current_page", libprag.}

proc setCurrentPage*(self: Assistant; pageNum: int) =
  gtk_assistant_set_current_page(cast[ptr Assistant00](self.impl), int32(pageNum))

proc `currentPage=`*(self: Assistant; pageNum: int) =
  gtk_assistant_set_current_page(cast[ptr Assistant00](self.impl), int32(pageNum))

proc gtk_assistant_set_page_complete*(self: ptr Assistant00; page: ptr Widget00; complete: gboolean) {.
    importc: "gtk_assistant_set_page_complete", libprag.}

proc setPageComplete*(self: Assistant; page: Widget; complete: bool) =
  gtk_assistant_set_page_complete(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), gboolean(complete))

proc gtk_assistant_set_page_has_padding*(self: ptr Assistant00; page: ptr Widget00; hasPadding: gboolean) {.
    importc: "gtk_assistant_set_page_has_padding", libprag.}

proc setPageHasPadding*(self: Assistant; page: Widget; hasPadding: bool) =
  gtk_assistant_set_page_has_padding(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), gboolean(hasPadding))

proc gtk_assistant_set_page_header_image*(self: ptr Assistant00; page: ptr Widget00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_assistant_set_page_header_image", libprag.}

proc setPageHeaderImage*(self: Assistant; page: Widget; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_assistant_set_page_header_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_assistant_set_page_side_image*(self: ptr Assistant00; page: ptr Widget00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_assistant_set_page_side_image", libprag.}

proc setPageSideImage*(self: Assistant; page: Widget; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_assistant_set_page_side_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_assistant_set_page_title*(self: ptr Assistant00; page: ptr Widget00; title: cstring) {.
    importc: "gtk_assistant_set_page_title", libprag.}

proc setPageTitle*(self: Assistant; page: Widget; title: string) =
  gtk_assistant_set_page_title(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), cstring(title))

proc gtk_assistant_update_buttons_state*(self: ptr Assistant00) {.
    importc: "gtk_assistant_update_buttons_state", libprag.}

proc updateButtonsState*(self: Assistant) =
  gtk_assistant_update_buttons_state(cast[ptr Assistant00](self.impl))

type
  AssistantPageType* {.size: sizeof(cint), pure.} = enum
    content = 0
    intro = 1
    confirm = 2
    summary = 3
    progress = 4
    custom = 5

proc gtk_assistant_get_page_type*(self: ptr Assistant00; page: ptr Widget00): AssistantPageType {.
    importc: "gtk_assistant_get_page_type", libprag.}

proc getPageType*(self: Assistant; page: Widget): AssistantPageType =
  gtk_assistant_get_page_type(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))

proc pageType*(self: Assistant; page: Widget): AssistantPageType =
  gtk_assistant_get_page_type(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))

proc gtk_assistant_set_page_type*(self: ptr Assistant00; page: ptr Widget00; `type`: AssistantPageType) {.
    importc: "gtk_assistant_set_page_type", libprag.}

proc setPageType*(self: Assistant; page: Widget; `type`: AssistantPageType) =
  gtk_assistant_set_page_type(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), `type`)

type
  AssistantPageFunc* = proc (currentPage: int32; data: pointer): int32 {.cdecl.}

proc gtk_assistant_set_forward_page_func*(self: ptr Assistant00; pageFunc: AssistantPageFunc; 
    data: pointer; destroy: DestroyNotify) {.
    importc: "gtk_assistant_set_forward_page_func", libprag.}

proc setForwardPageFunc*(self: Assistant; pageFunc: AssistantPageFunc; data: pointer; 
    destroy: DestroyNotify) =
  gtk_assistant_set_forward_page_func(cast[ptr Assistant00](self.impl), pageFunc, data, destroy)

type
  AttachOptions* {.size: sizeof(cint), pure.} = enum
    expand = 1
    shrink = 2
    fill = 4

const BINARY_AGE* = 2215'i32

type
  BindingArg00* {.pure.} = object
    argType*: GType
  BindingArg* = ref object
    impl*: ptr BindingArg00

type
  PathType* {.size: sizeof(cint), pure.} = enum
    widget = 0
    widgetClass = 1
    class = 2

type
  PathPriorityType* {.size: sizeof(cint), pure.} = enum
    lowest = 0
    gtk = 4
    application = 8
    theme = 10
    rc = 12
    highest = 15

type
  BindingSignal00* {.pure.} = object
    next*: ptr BindingSignal00
    signalName*: cstring
    nArgs*: uint32
    args*: BindingArg00Array
  BindingSignal* = ref object
    impl*: ptr BindingSignal00
type

  BindingSet00* {.pure.} = object
    setName*: cstring
    priority*: int32
    widgetPathPspecs*: ptr pointer
    widgetClassPspecs*: ptr pointer
    classBranchPspecs*: ptr pointer
    entries*: ptr BindingEntry00
    current*: ptr BindingEntry00
    parsed*: uint32
  BindingSet* = ref object
    impl*: ptr BindingSet00

  BindingEntry00* {.pure.} = object
    keyval*: uint32
    modifiers*: gdk.ModifierType
    bindingSet*: ptr BindingSet00
    destroyed*: uint32
    inEmission*: uint32
    marksUnbound*: uint32
    setNext*: ptr BindingEntry00
    hashNext*: ptr BindingEntry00
    signals*: ptr BindingSignal00
  BindingEntry* = ref object
    impl*: ptr BindingEntry00

proc gtk_binding_entry_add_signal_from_string*(bindingSet: ptr BindingSet00; signalDesc: cstring): glib.TokenType {.
    importc: "gtk_binding_entry_add_signal_from_string", libprag.}

proc addSignalFromString*(bindingSet: BindingSet; signalDesc: string): glib.TokenType =
  gtk_binding_entry_add_signal_from_string(cast[ptr BindingSet00](bindingSet.impl), cstring(signalDesc))

proc gtk_binding_entry_add_signall*(bindingSet: ptr BindingSet00; keyval: uint32; modifiers: gdk.ModifierType; 
    signalName: cstring; bindingArgs: ptr pointer) {.
    importc: "gtk_binding_entry_add_signall", libprag.}

proc addSignall*(bindingSet: BindingSet; keyval: int; modifiers: gdk.ModifierType; 
    signalName: string; bindingArgs: ptr pointer) =
  gtk_binding_entry_add_signall(cast[ptr BindingSet00](bindingSet.impl), uint32(keyval), modifiers, cstring(signalName), bindingArgs)

proc gtk_binding_entry_remove*(bindingSet: ptr BindingSet00; keyval: uint32; modifiers: gdk.ModifierType) {.
    importc: "gtk_binding_entry_remove", libprag.}

proc remove*(bindingSet: BindingSet; keyval: int; modifiers: gdk.ModifierType) =
  gtk_binding_entry_remove(cast[ptr BindingSet00](bindingSet.impl), uint32(keyval), modifiers)

proc gtk_binding_entry_skip*(bindingSet: ptr BindingSet00; keyval: uint32; modifiers: gdk.ModifierType) {.
    importc: "gtk_binding_entry_skip", libprag.}

proc skip*(bindingSet: BindingSet; keyval: int; modifiers: gdk.ModifierType) =
  gtk_binding_entry_skip(cast[ptr BindingSet00](bindingSet.impl), uint32(keyval), modifiers)

type
  CellAccessiblePrivate00* {.pure.} = object
  CellAccessiblePrivate* = ref object
    impl*: ptr CellAccessiblePrivate00

type
  CellAccessible* = ref object of Accessible
  CellAccessible00* = object of Accessible00
    priv2: ptr CellAccessiblePrivate00

type
  RendererCellAccessiblePrivate00* {.pure.} = object
  RendererCellAccessiblePrivate* = ref object
    impl*: ptr RendererCellAccessiblePrivate00

type
  RendererCellAccessible* = ref object of CellAccessible
  RendererCellAccessible00* = object of CellAccessible00
    priv3: ptr RendererCellAccessiblePrivate00

proc gtk_renderer_cell_accessible_new*(renderer: ptr CellRenderer00): ptr RendererCellAccessible00 {.
    importc: "gtk_renderer_cell_accessible_new", libprag.}

proc newRendererCellAccessible*(renderer: CellRenderer): RendererCellAccessible =
  new(result, finalizeGObject)
  result.impl = gtk_renderer_cell_accessible_new(cast[ptr CellRenderer00](renderer.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRendererCellAccessible*[T](result: var T; renderer: CellRenderer) =
  assert(result is RendererCellAccessible)
  new(result, finalizeGObject)
  result.impl = gtk_renderer_cell_accessible_new(cast[ptr CellRenderer00](renderer.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  BooleanCellAccessiblePrivate00* {.pure.} = object
  BooleanCellAccessiblePrivate* = ref object
    impl*: ptr BooleanCellAccessiblePrivate00

type
  BooleanCellAccessible* = ref object of RendererCellAccessible
  BooleanCellAccessible00* = object of RendererCellAccessible00
    priv4: ptr BooleanCellAccessiblePrivate00

type
  CellAccessibleClass00* {.pure.} = object
    parentClass*: AccessibleClass00
    updateCache*: proc(cell: ptr CellAccessible00; emitSignal: gboolean) {.cdecl.}
  CellAccessibleClass* = ref object
    impl*: ptr CellAccessibleClass00

type
  RendererCellAccessibleClass00* {.pure.} = object
    parentClass*: CellAccessibleClass00
  RendererCellAccessibleClass* = ref object
    impl*: ptr RendererCellAccessibleClass00

type
  BooleanCellAccessibleClass00* {.pure.} = object
    parentClass*: RendererCellAccessibleClass00
  BooleanCellAccessibleClass* = ref object
    impl*: ptr BooleanCellAccessibleClass00

type
  BorderStyle* {.size: sizeof(cint), pure.} = enum
    none = 0
    solid = 1
    inset = 2
    outset = 3
    hidden = 4
    dotted = 5
    dashed = 6
    double = 7
    groove = 8
    ridge = 9

type
  Buildable00* {.pure.} = object
  Buildable* = ref object
    impl*: ptr Buildable00

proc gtk_buildable_get_name*(self: ptr Buildable00): cstring {.
    importc: "gtk_buildable_get_name", libprag.}

proc getName*(self: Buildable): string =
  let resul0 = gtk_buildable_get_name(cast[ptr Buildable00](self.impl))
  result = $resul0

proc name*(self: Buildable): string =
  let resul0 = gtk_buildable_get_name(cast[ptr Buildable00](self.impl))
  result = $resul0

proc gtk_buildable_set_name*(self: ptr Buildable00; name: cstring) {.
    importc: "gtk_buildable_set_name", libprag.}

proc setName*(self: Buildable; name: string) =
  gtk_buildable_set_name(cast[ptr Buildable00](self.impl), cstring(name))

proc `name=`*(self: Buildable; name: string) =
  gtk_buildable_set_name(cast[ptr Buildable00](self.impl), cstring(name))

type
  BuilderPrivate00* {.pure.} = object
  BuilderPrivate* = ref object
    impl*: ptr BuilderPrivate00

type
  Builder* = ref object of gobject.Object
  Builder00* = object of gobject.Object00
    priv1: ptr BuilderPrivate00

proc gtk_builder_new*(): ptr Builder00 {.
    importc: "gtk_builder_new", libprag.}

proc newBuilder*(): Builder =
  new(result, finalizeGObject)
  result.impl = gtk_builder_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilder*[T](result: var T) =
  assert(result is Builder)
  new(result, finalizeGObject)
  result.impl = gtk_builder_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_new_from_file*(filename: cstring): ptr Builder00 {.
    importc: "gtk_builder_new_from_file", libprag.}

proc newBuilderFromFile*(filename: string): Builder =
  new(result, finalizeGObject)
  result.impl = gtk_builder_new_from_file(cstring(filename))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderFromFile*[T](result: var T; filename: string) =
  assert(result is Builder)
  new(result, finalizeGObject)
  result.impl = gtk_builder_new_from_file(cstring(filename))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_new_from_resource*(resourcePath: cstring): ptr Builder00 {.
    importc: "gtk_builder_new_from_resource", libprag.}

proc newBuilderFromResource*(resourcePath: string): Builder =
  new(result, finalizeGObject)
  result.impl = gtk_builder_new_from_resource(cstring(resourcePath))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderFromResource*[T](result: var T; resourcePath: string) =
  assert(result is Builder)
  new(result, finalizeGObject)
  result.impl = gtk_builder_new_from_resource(cstring(resourcePath))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_new_from_string*(string: cstring; length: int64): ptr Builder00 {.
    importc: "gtk_builder_new_from_string", libprag.}

proc newBuilderFromString*(string: string; length: int64): Builder =
  new(result, finalizeGObject)
  result.impl = gtk_builder_new_from_string(cstring(string), length)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderFromString*[T](result: var T; string: string; length: int64) =
  assert(result is Builder)
  new(result, finalizeGObject)
  result.impl = gtk_builder_new_from_string(cstring(string), length)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_add_from_file*(self: ptr Builder00; filename: cstring): uint32 {.
    importc: "gtk_builder_add_from_file", libprag.}

proc addFromFile*(self: Builder; filename: string): int =
  int(gtk_builder_add_from_file(cast[ptr Builder00](self.impl), cstring(filename)))

proc gtk_builder_add_from_resource*(self: ptr Builder00; resourcePath: cstring): uint32 {.
    importc: "gtk_builder_add_from_resource", libprag.}

proc addFromResource*(self: Builder; resourcePath: string): int =
  int(gtk_builder_add_from_resource(cast[ptr Builder00](self.impl), cstring(resourcePath)))

proc gtk_builder_add_from_string*(self: ptr Builder00; buffer: cstring; length: uint64): uint32 {.
    importc: "gtk_builder_add_from_string", libprag.}

proc addFromString*(self: Builder; buffer: string; length: uint64): int =
  int(gtk_builder_add_from_string(cast[ptr Builder00](self.impl), cstring(buffer), length))

proc gtk_builder_add_objects_from_file*(self: ptr Builder00; filename: cstring; objectIds: cstringArray): uint32 {.
    importc: "gtk_builder_add_objects_from_file", libprag.}

proc addObjectsFromFile*(self: Builder; filename: string; objectIds: cstringArray): int =
  int(gtk_builder_add_objects_from_file(cast[ptr Builder00](self.impl), cstring(filename), objectIds))

proc gtk_builder_add_objects_from_resource*(self: ptr Builder00; resourcePath: cstring; objectIds: cstringArray): uint32 {.
    importc: "gtk_builder_add_objects_from_resource", libprag.}

proc addObjectsFromResource*(self: Builder; resourcePath: string; objectIds: cstringArray): int =
  int(gtk_builder_add_objects_from_resource(cast[ptr Builder00](self.impl), cstring(resourcePath), objectIds))

proc gtk_builder_add_objects_from_string*(self: ptr Builder00; buffer: cstring; length: uint64; 
    objectIds: cstringArray): uint32 {.
    importc: "gtk_builder_add_objects_from_string", libprag.}

proc addObjectsFromString*(self: Builder; buffer: string; length: uint64; objectIds: cstringArray): int =
  int(gtk_builder_add_objects_from_string(cast[ptr Builder00](self.impl), cstring(buffer), length, objectIds))

proc gtk_builder_connect_signals*(self: ptr Builder00; userData: pointer) {.
    importc: "gtk_builder_connect_signals", libprag.}

proc connectSignals*(self: Builder; userData: pointer) =
  gtk_builder_connect_signals(cast[ptr Builder00](self.impl), userData)

proc gtk_builder_expose_object*(self: ptr Builder00; name: cstring; `object`: ptr gobject.Object00) {.
    importc: "gtk_builder_expose_object", libprag.}

proc exposeObject*(self: Builder; name: string; `object`: gobject.Object) =
  gtk_builder_expose_object(cast[ptr Builder00](self.impl), cstring(name), cast[ptr gobject.Object00](`object`.impl))

proc gtk_builder_extend_with_template*(self: ptr Builder00; widget: ptr Widget00; templateType: GType; 
    buffer: cstring; length: uint64): uint32 {.
    importc: "gtk_builder_extend_with_template", libprag.}

proc extendWithTemplate*(self: Builder; widget: Widget; templateType: GType; 
    buffer: string; length: uint64): int =
  int(gtk_builder_extend_with_template(cast[ptr Builder00](self.impl), cast[ptr Widget00](widget.impl), templateType, cstring(buffer), length))

proc gtk_builder_get_application*(self: ptr Builder00): ptr Application00 {.
    importc: "gtk_builder_get_application", libprag.}

proc getApplication*(self: Builder): Application =
  let gobj = gtk_builder_get_application(cast[ptr Builder00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Application](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc application*(self: Builder): Application =
  let gobj = gtk_builder_get_application(cast[ptr Builder00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Application](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_get_object*(self: ptr Builder00; name: cstring): ptr gobject.Object00 {.
    importc: "gtk_builder_get_object", libprag.}

proc getObject*(self: Builder; name: string): gobject.Object =
  let gobj = gtk_builder_get_object(cast[ptr Builder00](self.impl), cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gobject.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_get_objects*(self: ptr Builder00): ptr pointer {.
    importc: "gtk_builder_get_objects", libprag.}

proc getObjects*(self: Builder): ptr pointer =
  gtk_builder_get_objects(cast[ptr Builder00](self.impl))

proc objects*(self: Builder): ptr pointer =
  gtk_builder_get_objects(cast[ptr Builder00](self.impl))

proc gtk_builder_get_translation_domain*(self: ptr Builder00): cstring {.
    importc: "gtk_builder_get_translation_domain", libprag.}

proc getTranslationDomain*(self: Builder): string =
  let resul0 = gtk_builder_get_translation_domain(cast[ptr Builder00](self.impl))
  result = $resul0

proc translationDomain*(self: Builder): string =
  let resul0 = gtk_builder_get_translation_domain(cast[ptr Builder00](self.impl))
  result = $resul0

proc gtk_builder_get_type_from_name*(self: ptr Builder00; typeName: cstring): GType {.
    importc: "gtk_builder_get_type_from_name", libprag.}

proc getTypeFromName*(self: Builder; typeName: string): GType =
  gtk_builder_get_type_from_name(cast[ptr Builder00](self.impl), cstring(typeName))

proc typeFromName*(self: Builder; typeName: string): GType =
  gtk_builder_get_type_from_name(cast[ptr Builder00](self.impl), cstring(typeName))

proc gtk_builder_set_application*(self: ptr Builder00; application: ptr Application00) {.
    importc: "gtk_builder_set_application", libprag.}

proc setApplication*(self: Builder; application: Application) =
  gtk_builder_set_application(cast[ptr Builder00](self.impl), cast[ptr Application00](application.impl))

proc `application=`*(self: Builder; application: Application) =
  gtk_builder_set_application(cast[ptr Builder00](self.impl), cast[ptr Application00](application.impl))

proc gtk_builder_set_translation_domain*(self: ptr Builder00; domain: cstring) {.
    importc: "gtk_builder_set_translation_domain", libprag.}

proc setTranslationDomain*(self: Builder; domain: string) =
  gtk_builder_set_translation_domain(cast[ptr Builder00](self.impl), cstring(domain))

proc `translationDomain=`*(self: Builder; domain: string) =
  gtk_builder_set_translation_domain(cast[ptr Builder00](self.impl), cstring(domain))

proc gtk_builder_value_from_string*(self: ptr Builder00; pspec: ptr gobject.ParamSpec00; 
    string: cstring; value: var gobject.Value00): gboolean {.
    importc: "gtk_builder_value_from_string", libprag.}

proc valueFromString*(self: ptr Builder00; pspec: ptr gobject.ParamSpec00; 
    string: cstring; value: var gobject.Value00): gboolean {.
    importc: "gtk_builder_value_from_string", libprag.}

proc gtk_builder_value_from_string_type*(self: ptr Builder00; `type`: GType; string: cstring; 
    value: var gobject.Value00): gboolean {.
    importc: "gtk_builder_value_from_string_type", libprag.}

proc valueFromStringType*(self: ptr Builder00; `type`: GType; string: cstring; 
    value: var gobject.Value00): gboolean {.
    importc: "gtk_builder_value_from_string_type", libprag.}

proc gtk_buildable_add_child*(self: ptr Buildable00; builder: ptr Builder00; child: ptr gobject.Object00; 
    `type`: cstring) {.
    importc: "gtk_buildable_add_child", libprag.}

proc addChild*(self: Buildable; builder: Builder; child: gobject.Object; 
    `type`: string) =
  gtk_buildable_add_child(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), cast[ptr gobject.Object00](child.impl), cstring(`type`))

proc gtk_buildable_construct_child*(self: ptr Buildable00; builder: ptr Builder00; name: cstring): ptr gobject.Object00 {.
    importc: "gtk_buildable_construct_child", libprag.}

proc constructChild*(self: Buildable; builder: Builder; name: string): gobject.Object =
  let gobj = gtk_buildable_construct_child(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gobject.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_buildable_custom_finished*(self: ptr Buildable00; builder: ptr Builder00; child: ptr gobject.Object00; 
    tagname: cstring; data: pointer) {.
    importc: "gtk_buildable_custom_finished", libprag.}

proc customFinished*(self: Buildable; builder: Builder; child: gobject.Object; 
    tagname: string; data: pointer) =
  gtk_buildable_custom_finished(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), cast[ptr gobject.Object00](child.impl), cstring(tagname), data)

proc gtk_buildable_custom_tag_end*(self: ptr Buildable00; builder: ptr Builder00; child: ptr gobject.Object00; 
    tagname: cstring; data: pointer) {.
    importc: "gtk_buildable_custom_tag_end", libprag.}

proc customTagEnd*(self: Buildable; builder: Builder; child: gobject.Object; 
    tagname: string; data: pointer) =
  gtk_buildable_custom_tag_end(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), cast[ptr gobject.Object00](child.impl), cstring(tagname), data)

proc gtk_buildable_custom_tag_start*(self: ptr Buildable00; builder: ptr Builder00; child: ptr gobject.Object00; 
    tagname: cstring; parser: var glib.MarkupParser00; data: var pointer): gboolean {.
    importc: "gtk_buildable_custom_tag_start", libprag.}

proc customTagStart*(self: ptr Buildable00; builder: ptr Builder00; child: ptr gobject.Object00; 
    tagname: cstring; parser: var glib.MarkupParser00; data: var pointer): gboolean {.
    importc: "gtk_buildable_custom_tag_start", libprag.}

proc gtk_buildable_get_internal_child*(self: ptr Buildable00; builder: ptr Builder00; childname: cstring): ptr gobject.Object00 {.
    importc: "gtk_buildable_get_internal_child", libprag.}

proc getInternalChild*(self: Buildable; builder: Builder; childname: string): gobject.Object =
  let gobj = gtk_buildable_get_internal_child(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), cstring(childname))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gobject.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc internalChild*(self: Buildable; builder: Builder; childname: string): gobject.Object =
  let gobj = gtk_buildable_get_internal_child(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), cstring(childname))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gobject.Object](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_buildable_parser_finished*(self: ptr Buildable00; builder: ptr Builder00) {.
    importc: "gtk_buildable_parser_finished", libprag.}

proc parserFinished*(self: Buildable; builder: Builder) =
  gtk_buildable_parser_finished(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl))

proc gtk_buildable_set_buildable_property*(self: ptr Buildable00; builder: ptr Builder00; name: cstring; 
    value: ptr gobject.Value00) {.
    importc: "gtk_buildable_set_buildable_property", libprag.}

proc setBuildableProperty*(self: Buildable; builder: Builder; name: string; value: gobject.Value) =
  gtk_buildable_set_buildable_property(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), cstring(name), cast[ptr gobject.Value00](value.impl))

type
  BuildableIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    setName*: proc(buildable: ptr Buildable00; name: cstring) {.cdecl.}
    getName*: proc(buildable: ptr Buildable00): cstring {.cdecl.}
    addChild*: proc(buildable: ptr Buildable00; builder: ptr Builder00; 
    child: ptr gobject.Object00; `type`: cstring) {.cdecl.}
    setBuildableProperty*: proc(buildable: ptr Buildable00; builder: ptr Builder00; 
    name: cstring; value: ptr gobject.Value00) {.cdecl.}
    constructChild*: proc(buildable: ptr Buildable00; builder: ptr Builder00; 
    name: cstring): ptr gobject.Object00 {.cdecl.}
    customTagStart*: proc(buildable: ptr Buildable00; builder: ptr Builder00; 
    child: ptr gobject.Object00; tagname: cstring; parser: var glib.MarkupParser00; data: var pointer): gboolean {.cdecl.}
    customTagEnd*: proc(buildable: ptr Buildable00; builder: ptr Builder00; 
    child: ptr gobject.Object00; tagname: cstring; data: pointer) {.cdecl.}
    customFinished*: proc(buildable: ptr Buildable00; builder: ptr Builder00; 
    child: ptr gobject.Object00; tagname: cstring; data: pointer) {.cdecl.}
    parserFinished*: proc(buildable: ptr Buildable00; builder: ptr Builder00) {.cdecl.}
    getInternalChild*: proc(buildable: ptr Buildable00; builder: ptr Builder00; 
    childname: cstring): ptr gobject.Object00 {.cdecl.}
  BuildableIface* = ref object
    impl*: ptr BuildableIface00

type
  BuilderClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    getTypeFromName*: proc(builder: ptr Builder00; typeName: cstring): GType {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  BuilderClass* = ref object
    impl*: ptr BuilderClass00

type
  BuilderConnectFunc* = proc (builder: ptr Builder00; `object`: ptr gobject.Object00; 
    signalName: cstring; handlerName: cstring; connectObject: ptr gobject.Object00; flags: gobject.ConnectFlags; 
    userData: pointer) {.cdecl.}

proc gtk_widget_class_set_connect_func*(self: ptr WidgetClass00; connectFunc: BuilderConnectFunc; 
    connectData: pointer; connectDataDestroy: DestroyNotify) {.
    importc: "gtk_widget_class_set_connect_func", libprag.}

proc setConnectFunc*(self: WidgetClass; connectFunc: BuilderConnectFunc; 
    connectData: pointer; connectDataDestroy: DestroyNotify) =
  gtk_widget_class_set_connect_func(cast[ptr WidgetClass00](self.impl), connectFunc, connectData, connectDataDestroy)

proc gtk_builder_connect_signals_full*(self: ptr Builder00; `func`: BuilderConnectFunc; userData: pointer) {.
    importc: "gtk_builder_connect_signals_full", libprag.}

proc connectSignalsFull*(self: Builder; `func`: BuilderConnectFunc; userData: pointer) =
  gtk_builder_connect_signals_full(cast[ptr Builder00](self.impl), `func`, userData)

type
  BuilderError* {.size: sizeof(cint), pure.} = enum
    invalidTypeFunction = 0
    unhandledTag = 1
    missingAttribute = 2
    invalidAttribute = 3
    invalidTag = 4
    missingPropertyValue = 5
    invalidValue = 6
    versionMismatch = 7
    duplicateId = 8
    objectTypeRefused = 9
    templateMismatch = 10
    invalidProperty = 11
    invalidSignal = 12
    invalidId = 13

proc gtk_builder_error_quark*(): uint32 {.
    importc: "gtk_builder_error_quark", libprag.}

type
  ButtonPrivate00* {.pure.} = object
  ButtonPrivate* = ref object
    impl*: ptr ButtonPrivate00

type
  Button* = ref object of Bin
  Button00* = object of Bin00
    priv4: ptr ButtonPrivate00

proc scActivate*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scClicked*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "clicked", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEnter*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "enter", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scLeave*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "leave", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPressed*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "pressed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scReleased*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "released", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_button_new*(): ptr Button00 {.
    importc: "gtk_button_new", libprag.}

proc newButton*(): Button =
  new(result, finalizeGObject)
  result.impl = gtk_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButton*[T](result: var T) =
  assert(result is Button)
  new(result, finalizeGObject)
  result.impl = gtk_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_from_icon_name*(iconName: cstring; size: int32): ptr Button00 {.
    importc: "gtk_button_new_from_icon_name", libprag.}

proc newButtonFromIconName*(iconName: string; size: int): Button =
  new(result, finalizeGObject)
  result.impl = gtk_button_new_from_icon_name(cstring(iconName), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonFromIconName*[T](result: var T; iconName: string; size: int) =
  assert(result is Button)
  new(result, finalizeGObject)
  result.impl = gtk_button_new_from_icon_name(cstring(iconName), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_from_stock*(stockId: cstring): ptr Button00 {.
    importc: "gtk_button_new_from_stock", libprag.}

proc newButtonFromStock*(stockId: string): Button =
  new(result, finalizeGObject)
  result.impl = gtk_button_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonFromStock*[T](result: var T; stockId: string) =
  assert(result is Button)
  new(result, finalizeGObject)
  result.impl = gtk_button_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_with_label*(label: cstring): ptr Button00 {.
    importc: "gtk_button_new_with_label", libprag.}

proc newButton*(label: string): Button =
  new(result, finalizeGObject)
  result.impl = gtk_button_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButton*[T](result: var T; label: string) =
  assert(result is Button)
  new(result, finalizeGObject)
  result.impl = gtk_button_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_with_mnemonic*(label: cstring): ptr Button00 {.
    importc: "gtk_button_new_with_mnemonic", libprag.}

proc newButtonWithMnemonic*(label: string): Button =
  new(result, finalizeGObject)
  result.impl = gtk_button_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonWithMnemonic*[T](result: var T; label: string) =
  assert(result is Button)
  new(result, finalizeGObject)
  result.impl = gtk_button_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_clicked*(self: ptr Button00) {.
    importc: "gtk_button_clicked", libprag.}

proc clicked*(self: Button) =
  gtk_button_clicked(cast[ptr Button00](self.impl))

proc gtk_button_enter*(self: ptr Button00) {.
    importc: "gtk_button_enter", libprag.}

proc enter*(self: Button) =
  gtk_button_enter(cast[ptr Button00](self.impl))

proc gtk_button_get_alignment*(self: ptr Button00; xalign: var cfloat; yalign: var cfloat) {.
    importc: "gtk_button_get_alignment", libprag.}

proc getAlignment*(self: Button; xalign: var cfloat; yalign: var cfloat) =
  gtk_button_get_alignment(cast[ptr Button00](self.impl), xalign, yalign)

proc alignment*(self: Button; xalign: var cfloat; yalign: var cfloat) =
  gtk_button_get_alignment(cast[ptr Button00](self.impl), xalign, yalign)

proc gtk_button_get_always_show_image*(self: ptr Button00): gboolean {.
    importc: "gtk_button_get_always_show_image", libprag.}

proc getAlwaysShowImage*(self: Button): bool =
  toBool(gtk_button_get_always_show_image(cast[ptr Button00](self.impl)))

proc alwaysShowImage*(self: Button): bool =
  toBool(gtk_button_get_always_show_image(cast[ptr Button00](self.impl)))

proc gtk_button_get_event_window*(self: ptr Button00): ptr gdk.Window00 {.
    importc: "gtk_button_get_event_window", libprag.}

proc getEventWindow*(self: Button): gdk.Window =
  let gobj = gtk_button_get_event_window(cast[ptr Button00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc eventWindow*(self: Button): gdk.Window =
  let gobj = gtk_button_get_event_window(cast[ptr Button00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_get_focus_on_click*(self: ptr Button00): gboolean {.
    importc: "gtk_button_get_focus_on_click", libprag.}

proc getFocusOnClick*(self: Button): bool =
  toBool(gtk_button_get_focus_on_click(cast[ptr Button00](self.impl)))

proc focusOnClick*(self: Button): bool =
  toBool(gtk_button_get_focus_on_click(cast[ptr Button00](self.impl)))

proc gtk_button_get_image*(self: ptr Button00): ptr Widget00 {.
    importc: "gtk_button_get_image", libprag.}

proc getImage*(self: Button): Widget =
  let gobj = gtk_button_get_image(cast[ptr Button00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc image*(self: Button): Widget =
  let gobj = gtk_button_get_image(cast[ptr Button00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_get_label*(self: ptr Button00): cstring {.
    importc: "gtk_button_get_label", libprag.}

proc getLabel*(self: Button): string =
  let resul0 = gtk_button_get_label(cast[ptr Button00](self.impl))
  result = $resul0

proc label*(self: Button): string =
  let resul0 = gtk_button_get_label(cast[ptr Button00](self.impl))
  result = $resul0

proc gtk_button_get_use_stock*(self: ptr Button00): gboolean {.
    importc: "gtk_button_get_use_stock", libprag.}

proc getUseStock*(self: Button): bool =
  toBool(gtk_button_get_use_stock(cast[ptr Button00](self.impl)))

proc useStock*(self: Button): bool =
  toBool(gtk_button_get_use_stock(cast[ptr Button00](self.impl)))

proc gtk_button_get_use_underline*(self: ptr Button00): gboolean {.
    importc: "gtk_button_get_use_underline", libprag.}

proc getUseUnderline*(self: Button): bool =
  toBool(gtk_button_get_use_underline(cast[ptr Button00](self.impl)))

proc useUnderline*(self: Button): bool =
  toBool(gtk_button_get_use_underline(cast[ptr Button00](self.impl)))

proc gtk_button_leave*(self: ptr Button00) {.
    importc: "gtk_button_leave", libprag.}

proc leave*(self: Button) =
  gtk_button_leave(cast[ptr Button00](self.impl))

proc gtk_button_pressed*(self: ptr Button00) {.
    importc: "gtk_button_pressed", libprag.}

proc pressed*(self: Button) =
  gtk_button_pressed(cast[ptr Button00](self.impl))

proc gtk_button_released*(self: ptr Button00) {.
    importc: "gtk_button_released", libprag.}

proc released*(self: Button) =
  gtk_button_released(cast[ptr Button00](self.impl))

proc gtk_button_set_alignment*(self: ptr Button00; xalign: cfloat; yalign: cfloat) {.
    importc: "gtk_button_set_alignment", libprag.}

proc setAlignment*(self: Button; xalign: cfloat; yalign: cfloat) =
  gtk_button_set_alignment(cast[ptr Button00](self.impl), xalign, yalign)

proc gtk_button_set_always_show_image*(self: ptr Button00; alwaysShow: gboolean) {.
    importc: "gtk_button_set_always_show_image", libprag.}

proc setAlwaysShowImage*(self: Button; alwaysShow: bool) =
  gtk_button_set_always_show_image(cast[ptr Button00](self.impl), gboolean(alwaysShow))

proc `alwaysShowImage=`*(self: Button; alwaysShow: bool) =
  gtk_button_set_always_show_image(cast[ptr Button00](self.impl), gboolean(alwaysShow))

proc gtk_button_set_focus_on_click*(self: ptr Button00; focusOnClick: gboolean) {.
    importc: "gtk_button_set_focus_on_click", libprag.}

proc setFocusOnClick*(self: Button; focusOnClick: bool) =
  gtk_button_set_focus_on_click(cast[ptr Button00](self.impl), gboolean(focusOnClick))

proc `focusOnClick=`*(self: Button; focusOnClick: bool) =
  gtk_button_set_focus_on_click(cast[ptr Button00](self.impl), gboolean(focusOnClick))

proc gtk_button_set_image*(self: ptr Button00; image: ptr Widget00) {.
    importc: "gtk_button_set_image", libprag.}

proc setImage*(self: Button; image: Widget) =
  gtk_button_set_image(cast[ptr Button00](self.impl), cast[ptr Widget00](image.impl))

proc `image=`*(self: Button; image: Widget) =
  gtk_button_set_image(cast[ptr Button00](self.impl), cast[ptr Widget00](image.impl))

proc gtk_button_set_label*(self: ptr Button00; label: cstring) {.
    importc: "gtk_button_set_label", libprag.}

proc setLabel*(self: Button; label: string) =
  gtk_button_set_label(cast[ptr Button00](self.impl), cstring(label))

proc `label=`*(self: Button; label: string) =
  gtk_button_set_label(cast[ptr Button00](self.impl), cstring(label))

proc gtk_button_set_use_stock*(self: ptr Button00; useStock: gboolean) {.
    importc: "gtk_button_set_use_stock", libprag.}

proc setUseStock*(self: Button; useStock: bool) =
  gtk_button_set_use_stock(cast[ptr Button00](self.impl), gboolean(useStock))

proc `useStock=`*(self: Button; useStock: bool) =
  gtk_button_set_use_stock(cast[ptr Button00](self.impl), gboolean(useStock))

proc gtk_button_set_use_underline*(self: ptr Button00; useUnderline: gboolean) {.
    importc: "gtk_button_set_use_underline", libprag.}

proc setUseUnderline*(self: Button; useUnderline: bool) =
  gtk_button_set_use_underline(cast[ptr Button00](self.impl), gboolean(useUnderline))

proc `useUnderline=`*(self: Button; useUnderline: bool) =
  gtk_button_set_use_underline(cast[ptr Button00](self.impl), gboolean(useUnderline))

type
  PositionType* {.size: sizeof(cint), pure.} = enum
    left = 0
    right = 1
    top = 2
    bottom = 3

proc gtk_button_get_image_position*(self: ptr Button00): PositionType {.
    importc: "gtk_button_get_image_position", libprag.}

proc getImagePosition*(self: Button): PositionType =
  gtk_button_get_image_position(cast[ptr Button00](self.impl))

proc imagePosition*(self: Button): PositionType =
  gtk_button_get_image_position(cast[ptr Button00](self.impl))

proc gtk_button_set_image_position*(self: ptr Button00; position: PositionType) {.
    importc: "gtk_button_set_image_position", libprag.}

proc setImagePosition*(self: Button; position: PositionType) =
  gtk_button_set_image_position(cast[ptr Button00](self.impl), position)

proc `imagePosition=`*(self: Button; position: PositionType) =
  gtk_button_set_image_position(cast[ptr Button00](self.impl), position)

type
  ReliefStyle* {.size: sizeof(cint), pure.} = enum
    normal = 0
    half = 1
    none = 2

proc gtk_button_get_relief*(self: ptr Button00): ReliefStyle {.
    importc: "gtk_button_get_relief", libprag.}

proc getRelief*(self: Button): ReliefStyle =
  gtk_button_get_relief(cast[ptr Button00](self.impl))

proc relief*(self: Button): ReliefStyle =
  gtk_button_get_relief(cast[ptr Button00](self.impl))

proc gtk_button_set_relief*(self: ptr Button00; relief: ReliefStyle) {.
    importc: "gtk_button_set_relief", libprag.}

proc setRelief*(self: Button; relief: ReliefStyle) =
  gtk_button_set_relief(cast[ptr Button00](self.impl), relief)

proc `relief=`*(self: Button; relief: ReliefStyle) =
  gtk_button_set_relief(cast[ptr Button00](self.impl), relief)

type
  ContainerAccessiblePrivate00* {.pure.} = object
  ContainerAccessiblePrivate* = ref object
    impl*: ptr ContainerAccessiblePrivate00

type
  ContainerAccessible* = ref object of WidgetAccessible
  ContainerAccessible00* = object of WidgetAccessible00
    priv3: ptr ContainerAccessiblePrivate00

type
  ButtonAccessiblePrivate00* {.pure.} = object
  ButtonAccessiblePrivate* = ref object
    impl*: ptr ButtonAccessiblePrivate00

type
  ButtonAccessible* = ref object of ContainerAccessible
  ButtonAccessible00* = object of ContainerAccessible00
    priv4: ptr ButtonAccessiblePrivate00

type
  ContainerAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
    addGtk*: proc(container: ptr Container00; widget: ptr Widget00; 
    data: pointer): int32 {.cdecl.}
    removeGtk*: proc(container: ptr Container00; widget: ptr Widget00; 
    data: pointer): int32 {.cdecl.}
  ContainerAccessibleClass* = ref object
    impl*: ptr ContainerAccessibleClass00

type
  ButtonAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  ButtonAccessibleClass* = ref object
    impl*: ptr ButtonAccessibleClass00

type
  ButtonBoxPrivate00* {.pure.} = object
  ButtonBoxPrivate* = ref object
    impl*: ptr ButtonBoxPrivate00

type
  ButtonBox* = ref object of Box
  ButtonBox00* = object of Box00
    priv4: ptr ButtonBoxPrivate00

proc gtk_button_box_new*(orientation: Orientation): ptr ButtonBox00 {.
    importc: "gtk_button_box_new", libprag.}

proc newButtonBox*(orientation: Orientation): ButtonBox =
  new(result, finalizeGObject)
  result.impl = gtk_button_box_new(orientation)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonBox*[T](result: var T; orientation: Orientation) =
  assert(result is ButtonBox)
  new(result, finalizeGObject)
  result.impl = gtk_button_box_new(orientation)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_box_get_child_non_homogeneous*(self: ptr ButtonBox00; child: ptr Widget00): gboolean {.
    importc: "gtk_button_box_get_child_non_homogeneous", libprag.}

proc getChildNonHomogeneous*(self: ButtonBox; child: Widget): bool =
  toBool(gtk_button_box_get_child_non_homogeneous(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl)))

proc childNonHomogeneous*(self: ButtonBox; child: Widget): bool =
  toBool(gtk_button_box_get_child_non_homogeneous(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_button_box_get_child_secondary*(self: ptr ButtonBox00; child: ptr Widget00): gboolean {.
    importc: "gtk_button_box_get_child_secondary", libprag.}

proc getChildSecondary*(self: ButtonBox; child: Widget): bool =
  toBool(gtk_button_box_get_child_secondary(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl)))

proc childSecondary*(self: ButtonBox; child: Widget): bool =
  toBool(gtk_button_box_get_child_secondary(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_button_box_set_child_non_homogeneous*(self: ptr ButtonBox00; child: ptr Widget00; nonHomogeneous: gboolean) {.
    importc: "gtk_button_box_set_child_non_homogeneous", libprag.}

proc setChildNonHomogeneous*(self: ButtonBox; child: Widget; nonHomogeneous: bool) =
  gtk_button_box_set_child_non_homogeneous(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl), gboolean(nonHomogeneous))

proc gtk_button_box_set_child_secondary*(self: ptr ButtonBox00; child: ptr Widget00; isSecondary: gboolean) {.
    importc: "gtk_button_box_set_child_secondary", libprag.}

proc setChildSecondary*(self: ButtonBox; child: Widget; isSecondary: bool) =
  gtk_button_box_set_child_secondary(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl), gboolean(isSecondary))

type
  ButtonBoxStyle* {.size: sizeof(cint), pure.} = enum
    spread = 1
    edge = 2
    start = 3
    `end` = 4
    center = 5
    expand = 6

proc gtk_button_box_get_layout*(self: ptr ButtonBox00): ButtonBoxStyle {.
    importc: "gtk_button_box_get_layout", libprag.}

proc getLayout*(self: ButtonBox): ButtonBoxStyle =
  gtk_button_box_get_layout(cast[ptr ButtonBox00](self.impl))

proc layout*(self: ButtonBox): ButtonBoxStyle =
  gtk_button_box_get_layout(cast[ptr ButtonBox00](self.impl))

proc gtk_button_box_set_layout*(self: ptr ButtonBox00; layoutStyle: ButtonBoxStyle) {.
    importc: "gtk_button_box_set_layout", libprag.}

proc setLayout*(self: ButtonBox; layoutStyle: ButtonBoxStyle) =
  gtk_button_box_set_layout(cast[ptr ButtonBox00](self.impl), layoutStyle)

proc `layout=`*(self: ButtonBox; layoutStyle: ButtonBoxStyle) =
  gtk_button_box_set_layout(cast[ptr ButtonBox00](self.impl), layoutStyle)

type
  ButtonRole* {.size: sizeof(cint), pure.} = enum
    normal = 0
    check = 1
    radio = 2

type
  ButtonsType* {.size: sizeof(cint), pure.} = enum
    none = 0
    ok = 1
    close = 2
    cancel = 3
    yesNo = 4
    okCancel = 5

type
  CalendarPrivate00* {.pure.} = object
  CalendarPrivate* = ref object
    impl*: ptr CalendarPrivate00

type
  Calendar* = ref object of Widget
  Calendar00* = object of Widget00
    priv2: ptr CalendarPrivate00

proc scDaySelected*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "day-selected", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDaySelectedDoubleClick*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "day-selected-double-click", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMonthChanged*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "month-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scNextMonth*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "next-month", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scNextYear*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "next-year", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPrevMonth*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "prev-month", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPrevYear*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "prev-year", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_calendar_new*(): ptr Calendar00 {.
    importc: "gtk_calendar_new", libprag.}

proc newCalendar*(): Calendar =
  new(result, finalizeGObject)
  result.impl = gtk_calendar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCalendar*[T](result: var T) =
  assert(result is Calendar)
  new(result, finalizeGObject)
  result.impl = gtk_calendar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_calendar_clear_marks*(self: ptr Calendar00) {.
    importc: "gtk_calendar_clear_marks", libprag.}

proc clearMarks*(self: Calendar) =
  gtk_calendar_clear_marks(cast[ptr Calendar00](self.impl))

proc gtk_calendar_get_date*(self: ptr Calendar00; year: var uint32; month: var uint32; 
    day: var uint32) {.
    importc: "gtk_calendar_get_date", libprag.}

proc getDate*(self: Calendar; year: var int; month: var int; day: var int) =
  var day_00 = uint32(day)
  var month_00 = uint32(month)
  var year_00 = uint32(year)
  gtk_calendar_get_date(cast[ptr Calendar00](self.impl), year_00, month_00, day_00)
  day = int(day_00)
  month = int(month_00)
  year = int(year_00)

proc date*(self: Calendar; year: var int; month: var int; day: var int) =
  var day_00 = uint32(day)
  var month_00 = uint32(month)
  var year_00 = uint32(year)
  gtk_calendar_get_date(cast[ptr Calendar00](self.impl), year_00, month_00, day_00)
  day = int(day_00)
  month = int(month_00)
  year = int(year_00)

proc gtk_calendar_get_day_is_marked*(self: ptr Calendar00; day: uint32): gboolean {.
    importc: "gtk_calendar_get_day_is_marked", libprag.}

proc getDayIsMarked*(self: Calendar; day: int): bool =
  toBool(gtk_calendar_get_day_is_marked(cast[ptr Calendar00](self.impl), uint32(day)))

proc dayIsMarked*(self: Calendar; day: int): bool =
  toBool(gtk_calendar_get_day_is_marked(cast[ptr Calendar00](self.impl), uint32(day)))

proc gtk_calendar_get_detail_height_rows*(self: ptr Calendar00): int32 {.
    importc: "gtk_calendar_get_detail_height_rows", libprag.}

proc getDetailHeightRows*(self: Calendar): int =
  int(gtk_calendar_get_detail_height_rows(cast[ptr Calendar00](self.impl)))

proc detailHeightRows*(self: Calendar): int =
  int(gtk_calendar_get_detail_height_rows(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_get_detail_width_chars*(self: ptr Calendar00): int32 {.
    importc: "gtk_calendar_get_detail_width_chars", libprag.}

proc getDetailWidthChars*(self: Calendar): int =
  int(gtk_calendar_get_detail_width_chars(cast[ptr Calendar00](self.impl)))

proc detailWidthChars*(self: Calendar): int =
  int(gtk_calendar_get_detail_width_chars(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_mark_day*(self: ptr Calendar00; day: uint32) {.
    importc: "gtk_calendar_mark_day", libprag.}

proc markDay*(self: Calendar; day: int) =
  gtk_calendar_mark_day(cast[ptr Calendar00](self.impl), uint32(day))

proc gtk_calendar_select_day*(self: ptr Calendar00; day: uint32) {.
    importc: "gtk_calendar_select_day", libprag.}

proc selectDay*(self: Calendar; day: int) =
  gtk_calendar_select_day(cast[ptr Calendar00](self.impl), uint32(day))

proc gtk_calendar_select_month*(self: ptr Calendar00; month: uint32; year: uint32) {.
    importc: "gtk_calendar_select_month", libprag.}

proc selectMonth*(self: Calendar; month: int; year: int) =
  gtk_calendar_select_month(cast[ptr Calendar00](self.impl), uint32(month), uint32(year))

proc gtk_calendar_set_detail_height_rows*(self: ptr Calendar00; rows: int32) {.
    importc: "gtk_calendar_set_detail_height_rows", libprag.}

proc setDetailHeightRows*(self: Calendar; rows: int) =
  gtk_calendar_set_detail_height_rows(cast[ptr Calendar00](self.impl), int32(rows))

proc `detailHeightRows=`*(self: Calendar; rows: int) =
  gtk_calendar_set_detail_height_rows(cast[ptr Calendar00](self.impl), int32(rows))

proc gtk_calendar_set_detail_width_chars*(self: ptr Calendar00; chars: int32) {.
    importc: "gtk_calendar_set_detail_width_chars", libprag.}

proc setDetailWidthChars*(self: Calendar; chars: int) =
  gtk_calendar_set_detail_width_chars(cast[ptr Calendar00](self.impl), int32(chars))

proc `detailWidthChars=`*(self: Calendar; chars: int) =
  gtk_calendar_set_detail_width_chars(cast[ptr Calendar00](self.impl), int32(chars))

proc gtk_calendar_unmark_day*(self: ptr Calendar00; day: uint32) {.
    importc: "gtk_calendar_unmark_day", libprag.}

proc unmarkDay*(self: Calendar; day: int) =
  gtk_calendar_unmark_day(cast[ptr Calendar00](self.impl), uint32(day))

type
  CalendarDisplayOptions* {.size: sizeof(cint), pure.} = enum
    showHeading = 1
    showDayNames = 2
    noMonthChange = 4
    showWeekNumbers = 8
    showDetails = 32

proc gtk_calendar_get_display_options*(self: ptr Calendar00): CalendarDisplayOptions {.
    importc: "gtk_calendar_get_display_options", libprag.}

proc getDisplayOptions*(self: Calendar): CalendarDisplayOptions =
  gtk_calendar_get_display_options(cast[ptr Calendar00](self.impl))

proc displayOptions*(self: Calendar): CalendarDisplayOptions =
  gtk_calendar_get_display_options(cast[ptr Calendar00](self.impl))

proc gtk_calendar_set_display_options*(self: ptr Calendar00; flags: CalendarDisplayOptions) {.
    importc: "gtk_calendar_set_display_options", libprag.}

proc setDisplayOptions*(self: Calendar; flags: CalendarDisplayOptions) =
  gtk_calendar_set_display_options(cast[ptr Calendar00](self.impl), flags)

proc `displayOptions=`*(self: Calendar; flags: CalendarDisplayOptions) =
  gtk_calendar_set_display_options(cast[ptr Calendar00](self.impl), flags)

type
  CalendarClass00* {.pure.} = object
    parentClass*: WidgetClass00
    monthChanged*: proc(calendar: ptr Calendar00) {.cdecl.}
    daySelected*: proc(calendar: ptr Calendar00) {.cdecl.}
    daySelectedDoubleClick*: proc(calendar: ptr Calendar00) {.cdecl.}
    prevMonth*: proc(calendar: ptr Calendar00) {.cdecl.}
    nextMonth*: proc(calendar: ptr Calendar00) {.cdecl.}
    prevYear*: proc(calendar: ptr Calendar00) {.cdecl.}
    nextYear*: proc(calendar: ptr Calendar00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CalendarClass* = ref object
    impl*: ptr CalendarClass00

type
  CalendarDetailFunc* = proc (calendar: ptr Calendar00; year: uint32; month: uint32; 
    day: uint32; userData: pointer): cstring {.cdecl.}

proc gtk_calendar_set_detail_func*(self: ptr Calendar00; `func`: CalendarDetailFunc; 
    data: pointer; destroy: DestroyNotify) {.
    importc: "gtk_calendar_set_detail_func", libprag.}

proc setDetailFunc*(self: Calendar; `func`: CalendarDetailFunc; data: pointer; 
    destroy: DestroyNotify) =
  gtk_calendar_set_detail_func(cast[ptr Calendar00](self.impl), `func`, data, destroy)

type
  Callback* = proc (widget: ptr Widget00; data: pointer) {.cdecl.}

type
  ActionEntry00* {.pure.} = object
    name*: cstring
    stockId*: cstring
    label*: cstring
    accelerator*: cstring
    tooltip*: cstring
    callback*: Callback
  ActionEntry* = ref object
    impl*: ptr ActionEntry00

type
  ContainerClass00* {.pure.} = object
    parentClass*: WidgetClass00
    add*: proc(container: ptr Container00; widget: ptr Widget00) {.cdecl.}
    remove*: proc(container: ptr Container00; widget: ptr Widget00) {.cdecl.}
    checkResize*: proc(container: ptr Container00) {.cdecl.}
    forall*: proc(container: ptr Container00; includeInternals: gboolean; 
    callback: Callback; callbackData: pointer) {.cdecl.}
    setFocusChild*: proc(container: ptr Container00; child: ptr Widget00) {.cdecl.}
    childType*: proc(container: ptr Container00): GType {.cdecl.}
    compositeName*: proc(container: ptr Container00; child: ptr Widget00): cstring {.cdecl.}
    setChildProperty*: proc(container: ptr Container00; child: ptr Widget00; propertyId: uint32; 
    value: ptr gobject.Value00; pspec: ptr gobject.ParamSpec00) {.cdecl.}
    getChildProperty*: proc(container: ptr Container00; child: ptr Widget00; propertyId: uint32; 
    value: ptr gobject.Value00; pspec: ptr gobject.ParamSpec00) {.cdecl.}
    getPathForChild*: proc(container: ptr Container00; child: ptr Widget00): ptr WidgetPath00 {.cdecl.}
    handleBorderWidth*: uint32
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  ContainerClass* = ref object
    impl*: ptr ContainerClass00

proc gtk_container_class_find_child_property*(self: ptr ContainerClass00; propertyName: cstring): ptr gobject.ParamSpec00 {.
    importc: "gtk_container_class_find_child_property", libprag.}

proc gtk_container_class_handle_border_width*(self: ptr ContainerClass00) {.
    importc: "gtk_container_class_handle_border_width", libprag.}

proc handleBorderWidth*(self: ContainerClass) =
  gtk_container_class_handle_border_width(cast[ptr ContainerClass00](self.impl))

proc gtk_container_class_install_child_properties*(self: ptr ContainerClass00; nPspecs: uint32; pspecs: ptr gobject.ParamSpec00Array) {.
    importc: "gtk_container_class_install_child_properties", libprag.}

proc installChildProperties*(self: ContainerClass; nPspecs: int; pspecs: ptr gobject.ParamSpec00Array) =
  gtk_container_class_install_child_properties(cast[ptr ContainerClass00](self.impl), uint32(nPspecs), pspecs)

proc gtk_container_class_install_child_property*(self: ptr ContainerClass00; propertyId: uint32; pspec: ptr gobject.ParamSpec00) {.
    importc: "gtk_container_class_install_child_property", libprag.}

proc installChildProperty*(self: ContainerClass; propertyId: int; pspec: gobject.ParamSpec) =
  gtk_container_class_install_child_property(cast[ptr ContainerClass00](self.impl), uint32(propertyId), cast[ptr gobject.ParamSpec00](pspec.impl))

proc gtk_container_class_list_child_properties*(self: ptr ContainerClass00; nProperties: var uint32): ptr gobject.ParamSpec00Array {.
    importc: "gtk_container_class_list_child_properties", libprag.}

proc listChildProperties*(self: ContainerClass; nProperties: var int): ptr gobject.ParamSpec00Array =
  var nProperties_00 = uint32(nProperties)
  result = gtk_container_class_list_child_properties(cast[ptr ContainerClass00](self.impl), nProperties_00)
  nProperties = int(nProperties_00)

type
  BinClass00* {.pure.} = object
    parentClass*: ContainerClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  BinClass* = ref object
    impl*: ptr BinClass00

type
  WindowClass00* {.pure.} = object
    parentClass*: BinClass00
    setFocus*: proc(window: ptr Window00; focus: ptr Widget00) {.cdecl.}
    activateFocus*: proc(window: ptr Window00) {.cdecl.}
    activateDefault*: proc(window: ptr Window00) {.cdecl.}
    keysChanged*: proc(window: ptr Window00) {.cdecl.}
    enableDebugging*: proc(window: ptr Window00; toggle: gboolean): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
  WindowClass* = ref object
    impl*: ptr WindowClass00

type
  DialogClass00* {.pure.} = object
    parentClass*: WindowClass00
    response*: proc(dialog: ptr Dialog00; responseId: int32) {.cdecl.}
    close*: proc(dialog: ptr Dialog00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  DialogClass* = ref object
    impl*: ptr DialogClass00

type
  AboutDialogClass00* {.pure.} = object
    parentClass*: DialogClass00
    activateLink*: proc(dialog: ptr AboutDialog00; uri: cstring): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  AboutDialogClass* = ref object
    impl*: ptr AboutDialogClass00
type

  ButtonClass00* {.pure.} = object
    parentClass*: BinClass00
    pressed*: proc(button: ptr Button00) {.cdecl.}
    released*: proc(button: ptr Button00) {.cdecl.}
    clicked*: proc(button: ptr Button00) {.cdecl.}
    enter*: proc(button: ptr Button00) {.cdecl.}
    leave*: proc(button: ptr Button00) {.cdecl.}
    activate*: proc(button: ptr Button00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ButtonClass* = ref object
    impl*: ptr ButtonClass00

  AssistantClass00* {.pure.} = object
    parentClass*: WindowClass00
    prepare*: proc(assistant: ptr Assistant00; page: ptr Widget00) {.cdecl.}
    apply*: proc(assistant: ptr Assistant00) {.cdecl.}
    close*: proc(assistant: ptr Assistant00) {.cdecl.}
    cancel*: proc(assistant: ptr Assistant00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
  AssistantClass* = ref object
    impl*: ptr AssistantClass00

proc gtk_container_forall*(self: ptr Container00; callback: Callback; callbackData: pointer) {.
    importc: "gtk_container_forall", libprag.}

proc forall*(self: Container; callback: Callback; callbackData: pointer) =
  gtk_container_forall(cast[ptr Container00](self.impl), callback, callbackData)

proc gtk_container_foreach*(self: ptr Container00; callback: Callback; callbackData: pointer) {.
    importc: "gtk_container_foreach", libprag.}

proc foreach*(self: Container; callback: Callback; callbackData: pointer) =
  gtk_container_foreach(cast[ptr Container00](self.impl), callback, callbackData)

proc gtk_widget_class_bind_template_callback_full*(self: ptr WidgetClass00; callbackName: cstring; callbackSymbol: Callback) {.
    importc: "gtk_widget_class_bind_template_callback_full", libprag.}

proc bindTemplateCallbackFull*(self: WidgetClass; callbackName: string; callbackSymbol: Callback) =
  gtk_widget_class_bind_template_callback_full(cast[ptr WidgetClass00](self.impl), cstring(callbackName), callbackSymbol)

proc gtk_builder_add_callback_symbol*(self: ptr Builder00; callbackName: cstring; callbackSymbol: Callback) {.
    importc: "gtk_builder_add_callback_symbol", libprag.}

proc addCallbackSymbol*(self: Builder; callbackName: string; callbackSymbol: Callback) =
  gtk_builder_add_callback_symbol(cast[ptr Builder00](self.impl), cstring(callbackName), callbackSymbol)

type
  CellAccessibleParent00* {.pure.} = object
  CellAccessibleParent* = ref object
    impl*: ptr CellAccessibleParent00

proc gtk_cell_accessible_parent_activate*(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00) {.
    importc: "gtk_cell_accessible_parent_activate", libprag.}

proc activate*(self: CellAccessibleParent; cell: CellAccessible) =
  gtk_cell_accessible_parent_activate(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_edit*(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00) {.
    importc: "gtk_cell_accessible_parent_edit", libprag.}

proc edit*(self: CellAccessibleParent; cell: CellAccessible) =
  gtk_cell_accessible_parent_edit(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_expand_collapse*(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00) {.
    importc: "gtk_cell_accessible_parent_expand_collapse", libprag.}

proc expandCollapse*(self: CellAccessibleParent; cell: CellAccessible) =
  gtk_cell_accessible_parent_expand_collapse(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_get_cell_area*(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00; 
    cellRect: ptr gdk.Rectangle00) {.
    importc: "gtk_cell_accessible_parent_get_cell_area", libprag.}

proc getCellArea*(self: CellAccessibleParent; cell: CellAccessible; 
    cellRect: gdk.Rectangle) =
  gtk_cell_accessible_parent_get_cell_area(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl), cast[ptr gdk.Rectangle00](cellRect.impl))

proc cellArea*(self: CellAccessibleParent; cell: CellAccessible; 
    cellRect: gdk.Rectangle) =
  gtk_cell_accessible_parent_get_cell_area(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl), cast[ptr gdk.Rectangle00](cellRect.impl))

proc gtk_cell_accessible_parent_get_cell_extents*(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00; 
    x: ptr int32; y: ptr int32; width: ptr int32; height: ptr int32; coordType: atk.CoordType) {.
    importc: "gtk_cell_accessible_parent_get_cell_extents", libprag.}

proc getCellExtents*(self: CellAccessibleParent; cell: CellAccessible; 
    x: ptr int32; y: ptr int32; width: ptr int32; height: ptr int32; coordType: atk.CoordType) =
  gtk_cell_accessible_parent_get_cell_extents(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl), x, y, width, height, coordType)

proc cellExtents*(self: CellAccessibleParent; cell: CellAccessible; 
    x: ptr int32; y: ptr int32; width: ptr int32; height: ptr int32; coordType: atk.CoordType) =
  gtk_cell_accessible_parent_get_cell_extents(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl), x, y, width, height, coordType)

proc gtk_cell_accessible_parent_get_child_index*(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00): int32 {.
    importc: "gtk_cell_accessible_parent_get_child_index", libprag.}

proc getChildIndex*(self: CellAccessibleParent; cell: CellAccessible): int =
  int(gtk_cell_accessible_parent_get_child_index(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl)))

proc childIndex*(self: CellAccessibleParent; cell: CellAccessible): int =
  int(gtk_cell_accessible_parent_get_child_index(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl)))

proc gtk_cell_accessible_parent_get_renderer_state*(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00): CellRendererState {.
    importc: "gtk_cell_accessible_parent_get_renderer_state", libprag.}

proc getRendererState*(self: CellAccessibleParent; cell: CellAccessible): CellRendererState =
  gtk_cell_accessible_parent_get_renderer_state(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc rendererState*(self: CellAccessibleParent; cell: CellAccessible): CellRendererState =
  gtk_cell_accessible_parent_get_renderer_state(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_grab_focus*(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00): gboolean {.
    importc: "gtk_cell_accessible_parent_grab_focus", libprag.}

proc grabFocus*(self: CellAccessibleParent; cell: CellAccessible): bool =
  toBool(gtk_cell_accessible_parent_grab_focus(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl)))

proc gtk_cell_accessible_parent_update_relationset*(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00; 
    relationset: ptr atk.RelationSet00) {.
    importc: "gtk_cell_accessible_parent_update_relationset", libprag.}

proc updateRelationset*(self: CellAccessibleParent; cell: CellAccessible; 
    relationset: atk.RelationSet) =
  gtk_cell_accessible_parent_update_relationset(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl), cast[ptr atk.RelationSet00](relationset.impl))

type
  FrameClass00* {.pure.} = object
    parentClass*: BinClass00
    computeChildAllocation*: proc(frame: ptr Frame00; allocation: ptr gdk.Rectangle00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  FrameClass* = ref object
    impl*: ptr FrameClass00

type
  AspectFrameClass00* {.pure.} = object
    parentClass*: FrameClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  AspectFrameClass* = ref object
    impl*: ptr AspectFrameClass00

type
  ApplicationWindowClass00* {.pure.} = object
    parentClass*: WindowClass00
    padding*: array[14, pointer]
  ApplicationWindowClass* = ref object
    impl*: ptr ApplicationWindowClass00

type
  BoxClass00* {.pure.} = object
    parentClass*: ContainerClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  BoxClass* = ref object
    impl*: ptr BoxClass00

type
  AppChooserWidgetClass00* {.pure.} = object
    parentClass*: BoxClass00
    applicationSelected*: proc(self: ptr AppChooserWidget00; appInfo: ptr gio.AppInfo00) {.cdecl.}
    applicationActivated*: proc(self: ptr AppChooserWidget00; appInfo: ptr gio.AppInfo00) {.cdecl.}
    populatePopup*: proc(self: ptr AppChooserWidget00; menu: ptr Menu00; appInfo: ptr gio.AppInfo00) {.cdecl.}
    padding*: array[16, pointer]
  AppChooserWidgetClass* = ref object
    impl*: ptr AppChooserWidgetClass00

type
  AppChooserDialogClass00* {.pure.} = object
    parentClass*: DialogClass00
    padding*: array[16, pointer]
  AppChooserDialogClass* = ref object
    impl*: ptr AppChooserDialogClass00

type
  ComboBoxClass00* {.pure.} = object
    parentClass*: BinClass00
    changed*: proc(comboBox: ptr ComboBox00) {.cdecl.}
    formatEntryText*: proc(comboBox: ptr ComboBox00; path: cstring): cstring {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
  ComboBoxClass* = ref object
    impl*: ptr ComboBoxClass00

type
  AppChooserButtonClass00* {.pure.} = object
    parentClass*: ComboBoxClass00
    customItemActivated*: proc(self: ptr AppChooserButton00; itemName: cstring) {.cdecl.}
    padding*: array[16, pointer]
  AppChooserButtonClass* = ref object
    impl*: ptr AppChooserButtonClass00

type
  AlignmentClass00* {.pure.} = object
    parentClass*: BinClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  AlignmentClass* = ref object
    impl*: ptr AlignmentClass00

type
  ActionBarClass00* {.pure.} = object
    parentClass*: BinClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ActionBarClass* = ref object
    impl*: ptr ActionBarClass00

type
  CellAccessibleParentIface00* {.pure.} = object
    parent*: gobject.TypeInterface00
    getCellExtents*: proc(parent: ptr CellAccessibleParent00; cell: ptr CellAccessible00; 
    x: ptr int32; y: ptr int32; width: ptr int32; height: ptr int32; coordType: atk.CoordType) {.cdecl.}
    getCellArea*: proc(parent: ptr CellAccessibleParent00; cell: ptr CellAccessible00; 
    cellRect: ptr gdk.Rectangle00) {.cdecl.}
    grabFocus*: proc(parent: ptr CellAccessibleParent00; cell: ptr CellAccessible00): gboolean {.cdecl.}
    getChildIndex*: proc(parent: ptr CellAccessibleParent00; cell: ptr CellAccessible00): int32 {.cdecl.}
    getRendererState*: proc(parent: ptr CellAccessibleParent00; cell: ptr CellAccessible00): CellRendererState {.cdecl.}
    expandCollapse*: proc(parent: ptr CellAccessibleParent00; cell: ptr CellAccessible00) {.cdecl.}
    activate*: proc(parent: ptr CellAccessibleParent00; cell: ptr CellAccessible00) {.cdecl.}
    edit*: proc(parent: ptr CellAccessibleParent00; cell: ptr CellAccessible00) {.cdecl.}
    updateRelationset*: proc(parent: ptr CellAccessibleParent00; cell: ptr CellAccessible00; 
    relationset: ptr atk.RelationSet00) {.cdecl.}
  CellAccessibleParentIface* = ref object
    impl*: ptr CellAccessibleParentIface00

type
  ButtonBoxClass00* {.pure.} = object
    parentClass*: BoxClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ButtonBoxClass* = ref object
    impl*: ptr ButtonBoxClass00

type
  CellAllocCallback* = proc (renderer: ptr CellRenderer00; cellArea: ptr gdk.Rectangle00; 
    cellBackground: ptr gdk.Rectangle00; data: pointer): gboolean {.cdecl.}

proc gtk_cell_area_foreach_alloc*(self: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; backgroundArea: ptr gdk.Rectangle00; callback: CellAllocCallback; 
    callbackData: pointer) {.
    importc: "gtk_cell_area_foreach_alloc", libprag.}

proc foreachAlloc*(self: CellArea; context: CellAreaContext; widget: Widget; 
    cellArea: gdk.Rectangle; backgroundArea: gdk.Rectangle; callback: CellAllocCallback; callbackData: pointer) =
  gtk_cell_area_foreach_alloc(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Rectangle00](cellArea.impl), cast[ptr gdk.Rectangle00](backgroundArea.impl), callback, callbackData)

type
  CellAreaBoxPrivate00* {.pure.} = object
  CellAreaBoxPrivate* = ref object
    impl*: ptr CellAreaBoxPrivate00

type
  CellAreaBox* = ref object of CellArea
  CellAreaBox00* = object of CellArea00
    priv2: ptr CellAreaBoxPrivate00

proc gtk_cell_area_box_new*(): ptr CellAreaBox00 {.
    importc: "gtk_cell_area_box_new", libprag.}

proc newCellAreaBox*(): CellAreaBox =
  new(result, finalizeGObject)
  result.impl = gtk_cell_area_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellAreaBox*[T](result: var T) =
  assert(result is CellAreaBox)
  new(result, finalizeGObject)
  result.impl = gtk_cell_area_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_box_get_spacing*(self: ptr CellAreaBox00): int32 {.
    importc: "gtk_cell_area_box_get_spacing", libprag.}

proc getSpacing*(self: CellAreaBox): int =
  int(gtk_cell_area_box_get_spacing(cast[ptr CellAreaBox00](self.impl)))

proc spacing*(self: CellAreaBox): int =
  int(gtk_cell_area_box_get_spacing(cast[ptr CellAreaBox00](self.impl)))

proc gtk_cell_area_box_pack_end*(self: ptr CellAreaBox00; renderer: ptr CellRenderer00; 
    expand: gboolean; align: gboolean; fixed: gboolean) {.
    importc: "gtk_cell_area_box_pack_end", libprag.}

proc packEnd*(self: CellAreaBox; renderer: CellRenderer; expand: bool; 
    align: bool; fixed: bool) =
  gtk_cell_area_box_pack_end(cast[ptr CellAreaBox00](self.impl), cast[ptr CellRenderer00](renderer.impl), gboolean(expand), gboolean(align), gboolean(fixed))

proc gtk_cell_area_box_pack_start*(self: ptr CellAreaBox00; renderer: ptr CellRenderer00; 
    expand: gboolean; align: gboolean; fixed: gboolean) {.
    importc: "gtk_cell_area_box_pack_start", libprag.}

proc packStart*(self: CellAreaBox; renderer: CellRenderer; expand: bool; 
    align: bool; fixed: bool) =
  gtk_cell_area_box_pack_start(cast[ptr CellAreaBox00](self.impl), cast[ptr CellRenderer00](renderer.impl), gboolean(expand), gboolean(align), gboolean(fixed))

proc gtk_cell_area_box_set_spacing*(self: ptr CellAreaBox00; spacing: int32) {.
    importc: "gtk_cell_area_box_set_spacing", libprag.}

proc setSpacing*(self: CellAreaBox; spacing: int) =
  gtk_cell_area_box_set_spacing(cast[ptr CellAreaBox00](self.impl), int32(spacing))

proc `spacing=`*(self: CellAreaBox; spacing: int) =
  gtk_cell_area_box_set_spacing(cast[ptr CellAreaBox00](self.impl), int32(spacing))

type
  CellAreaContextClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    allocate*: proc(context: ptr CellAreaContext00; width: int32; height: int32) {.cdecl.}
    reset*: proc(context: ptr CellAreaContext00) {.cdecl.}
    getPreferredHeightForWidth*: proc(context: ptr CellAreaContext00; width: int32; minimumHeight: var int32; 
    naturalHeight: var int32) {.cdecl.}
    getPreferredWidthForHeight*: proc(context: ptr CellAreaContext00; height: int32; minimumWidth: var int32; 
    naturalWidth: var int32) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
  CellAreaContextClass* = ref object
    impl*: ptr CellAreaContextClass00

type
  CellCallback* = proc (renderer: ptr CellRenderer00; data: pointer): gboolean {.cdecl.}

type
  CellAreaClass00* {.pure.} = object
    parentClass*: gobject.InitiallyUnownedClass00
    add*: proc(area: ptr CellArea00; renderer: ptr CellRenderer00) {.cdecl.}
    remove*: proc(area: ptr CellArea00; renderer: ptr CellRenderer00) {.cdecl.}
    foreach*: proc(area: ptr CellArea00; callback: CellCallback; callbackData: pointer) {.cdecl.}
    foreachAlloc*: proc(area: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; backgroundArea: ptr gdk.Rectangle00; callback: CellAllocCallback; 
    callbackData: pointer) {.cdecl.}
    event*: proc(area: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; event: ptr gdk.Event00; cellArea: ptr gdk.Rectangle00; flags: CellRendererState): int32 {.cdecl.}
    render*: proc(area: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; cr: ptr cairo.Context00; backgroundArea: ptr gdk.Rectangle00; cellArea: ptr gdk.Rectangle00; 
    flags: CellRendererState; paintFocus: gboolean) {.cdecl.}
    applyAttributes*: proc(area: ptr CellArea00; treeModel: ptr TreeModel00; 
    iter: ptr TreeIter00; isExpander: gboolean; isExpanded: gboolean) {.cdecl.}
    createContext*: proc(area: ptr CellArea00): ptr CellAreaContext00 {.cdecl.}
    copyContext*: proc(area: ptr CellArea00; context: ptr CellAreaContext00): ptr CellAreaContext00 {.cdecl.}
    getRequestMode*: proc(area: ptr CellArea00): SizeRequestMode {.cdecl.}
    getPreferredWidth*: proc(area: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; minimumWidth: var int32; naturalWidth: var int32) {.cdecl.}
    getPreferredHeightForWidth*: proc(area: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; width: int32; minimumHeight: var int32; naturalHeight: var int32) {.cdecl.}
    getPreferredHeight*: proc(area: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; minimumHeight: var int32; naturalHeight: var int32) {.cdecl.}
    getPreferredWidthForHeight*: proc(area: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; height: int32; minimumWidth: var int32; naturalWidth: var int32) {.cdecl.}
    setCellProperty*: proc(area: ptr CellArea00; renderer: ptr CellRenderer00; 
    propertyId: uint32; value: ptr gobject.Value00; pspec: ptr gobject.ParamSpec00) {.cdecl.}
    getCellProperty*: proc(area: ptr CellArea00; renderer: ptr CellRenderer00; 
    propertyId: uint32; value: ptr gobject.Value00; pspec: ptr gobject.ParamSpec00) {.cdecl.}
    focus*: proc(area: ptr CellArea00; direction: DirectionType): gboolean {.cdecl.}
    isActivatable*: proc(area: ptr CellArea00): gboolean {.cdecl.}
    activate*: proc(area: ptr CellArea00; context: ptr CellAreaContext00; 
    widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; flags: CellRendererState; editOnly: gboolean): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  CellAreaClass* = ref object
    impl*: ptr CellAreaClass00

proc gtk_cell_area_class_find_cell_property*(self: ptr CellAreaClass00; propertyName: cstring): ptr gobject.ParamSpec00 {.
    importc: "gtk_cell_area_class_find_cell_property", libprag.}

proc gtk_cell_area_class_install_cell_property*(self: ptr CellAreaClass00; propertyId: uint32; pspec: ptr gobject.ParamSpec00) {.
    importc: "gtk_cell_area_class_install_cell_property", libprag.}

proc installCellProperty*(self: CellAreaClass; propertyId: int; pspec: gobject.ParamSpec) =
  gtk_cell_area_class_install_cell_property(cast[ptr CellAreaClass00](self.impl), uint32(propertyId), cast[ptr gobject.ParamSpec00](pspec.impl))

proc gtk_cell_area_class_list_cell_properties*(self: ptr CellAreaClass00; nProperties: var uint32): ptr gobject.ParamSpec00Array {.
    importc: "gtk_cell_area_class_list_cell_properties", libprag.}

proc listCellProperties*(self: CellAreaClass; nProperties: var int): ptr gobject.ParamSpec00Array =
  var nProperties_00 = uint32(nProperties)
  result = gtk_cell_area_class_list_cell_properties(cast[ptr CellAreaClass00](self.impl), nProperties_00)
  nProperties = int(nProperties_00)

type
  CellAreaBoxClass00* {.pure.} = object
    parentClass*: CellAreaClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellAreaBoxClass* = ref object
    impl*: ptr CellAreaBoxClass00

proc gtk_cell_area_foreach*(self: ptr CellArea00; callback: CellCallback; callbackData: pointer) {.
    importc: "gtk_cell_area_foreach", libprag.}

proc foreach*(self: CellArea; callback: CellCallback; callbackData: pointer) =
  gtk_cell_area_foreach(cast[ptr CellArea00](self.impl), callback, callbackData)

type
  CellEditableIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    editingDone*: proc(cellEditable: ptr CellEditable00) {.cdecl.}
    removeWidget*: proc(cellEditable: ptr CellEditable00) {.cdecl.}
    startEditing*: proc(cellEditable: ptr CellEditable00; event: ptr gdk.Event00) {.cdecl.}
  CellEditableIface* = ref object
    impl*: ptr CellEditableIface00

type
  CellLayout00* {.pure.} = object
  CellLayout* = ref object
    impl*: ptr CellLayout00

proc gtk_cell_layout_add_attribute*(self: ptr CellLayout00; cell: ptr CellRenderer00; 
    attribute: cstring; column: int32) {.
    importc: "gtk_cell_layout_add_attribute", libprag.}

proc addAttribute*(self: CellLayout; cell: CellRenderer; attribute: string; 
    column: int) =
  gtk_cell_layout_add_attribute(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), cstring(attribute), int32(column))

proc gtk_cell_layout_clear*(self: ptr CellLayout00) {.
    importc: "gtk_cell_layout_clear", libprag.}

proc clear*(self: CellLayout) =
  gtk_cell_layout_clear(cast[ptr CellLayout00](self.impl))

proc gtk_cell_layout_clear_attributes*(self: ptr CellLayout00; cell: ptr CellRenderer00) {.
    importc: "gtk_cell_layout_clear_attributes", libprag.}

proc clearAttributes*(self: CellLayout; cell: CellRenderer) =
  gtk_cell_layout_clear_attributes(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl))

proc gtk_cell_layout_get_area*(self: ptr CellLayout00): ptr CellArea00 {.
    importc: "gtk_cell_layout_get_area", libprag.}

proc getArea*(self: CellLayout): CellArea =
  let gobj = gtk_cell_layout_get_area(cast[ptr CellLayout00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellArea](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc area*(self: CellLayout): CellArea =
  let gobj = gtk_cell_layout_get_area(cast[ptr CellLayout00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CellArea](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_layout_get_cells*(self: ptr CellLayout00): ptr pointer {.
    importc: "gtk_cell_layout_get_cells", libprag.}

proc getCells*(self: CellLayout): ptr pointer =
  gtk_cell_layout_get_cells(cast[ptr CellLayout00](self.impl))

proc cells*(self: CellLayout): ptr pointer =
  gtk_cell_layout_get_cells(cast[ptr CellLayout00](self.impl))

proc gtk_cell_layout_pack_end*(self: ptr CellLayout00; cell: ptr CellRenderer00; 
    expand: gboolean) {.
    importc: "gtk_cell_layout_pack_end", libprag.}

proc packEnd*(self: CellLayout; cell: CellRenderer; expand: bool) =
  gtk_cell_layout_pack_end(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_cell_layout_pack_start*(self: ptr CellLayout00; cell: ptr CellRenderer00; 
    expand: gboolean) {.
    importc: "gtk_cell_layout_pack_start", libprag.}

proc packStart*(self: CellLayout; cell: CellRenderer; expand: bool) =
  gtk_cell_layout_pack_start(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_cell_layout_reorder*(self: ptr CellLayout00; cell: ptr CellRenderer00; 
    position: int32) {.
    importc: "gtk_cell_layout_reorder", libprag.}

proc reorder*(self: CellLayout; cell: CellRenderer; position: int) =
  gtk_cell_layout_reorder(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), int32(position))

type
  CellLayoutDataFunc* = proc (cellLayout: ptr CellLayout00; cell: ptr CellRenderer00; 
    treeModel: ptr TreeModel00; iter: ptr TreeIter00; data: pointer) {.cdecl.}

proc gtk_cell_layout_set_cell_data_func*(self: ptr CellLayout00; cell: ptr CellRenderer00; 
    `func`: CellLayoutDataFunc; funcData: pointer; destroy: DestroyNotify) {.
    importc: "gtk_cell_layout_set_cell_data_func", libprag.}

proc setCellDataFunc*(self: CellLayout; cell: CellRenderer; `func`: CellLayoutDataFunc; 
    funcData: pointer; destroy: DestroyNotify) =
  gtk_cell_layout_set_cell_data_func(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), `func`, funcData, destroy)

type
  CellLayoutIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    packStart*: proc(cellLayout: ptr CellLayout00; cell: ptr CellRenderer00; 
    expand: gboolean) {.cdecl.}
    packEnd*: proc(cellLayout: ptr CellLayout00; cell: ptr CellRenderer00; 
    expand: gboolean) {.cdecl.}
    clear*: proc(cellLayout: ptr CellLayout00) {.cdecl.}
    addAttribute*: proc(cellLayout: ptr CellLayout00; cell: ptr CellRenderer00; 
    attribute: cstring; column: int32) {.cdecl.}
    setCellDataFunc*: proc(cellLayout: ptr CellLayout00; cell: ptr CellRenderer00; 
    `func`: CellLayoutDataFunc; funcData: pointer; destroy: DestroyNotify) {.cdecl.}
    clearAttributes*: proc(cellLayout: ptr CellLayout00; cell: ptr CellRenderer00) {.cdecl.}
    reorder*: proc(cellLayout: ptr CellLayout00; cell: ptr CellRenderer00; 
    position: int32) {.cdecl.}
    getCells*: proc(cellLayout: ptr CellLayout00): ptr pointer {.cdecl.}
    getArea*: proc(cellLayout: ptr CellLayout00): ptr CellArea00 {.cdecl.}
  CellLayoutIface* = ref object
    impl*: ptr CellLayoutIface00

type
  CellRendererTextPrivate00* {.pure.} = object
  CellRendererTextPrivate* = ref object
    impl*: ptr CellRendererTextPrivate00

type
  CellRendererText* = ref object of CellRenderer
  CellRendererText00* = object of CellRenderer00
    priv2: ptr CellRendererTextPrivate00

proc scEdited*(self: CellRendererText;  p: proc (self: ptr gobject.Object00; path: cstring; newText: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "edited", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_cell_renderer_text_new*(): ptr CellRendererText00 {.
    importc: "gtk_cell_renderer_text_new", libprag.}

proc newCellRendererText*(): CellRendererText =
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_text_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererText*[T](result: var T) =
  assert(result is CellRendererText)
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_text_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_renderer_text_set_fixed_height_from_font*(self: ptr CellRendererText00; numberOfRows: int32) {.
    importc: "gtk_cell_renderer_text_set_fixed_height_from_font", libprag.}

proc setFixedHeightFromFont*(self: CellRendererText; numberOfRows: int) =
  gtk_cell_renderer_text_set_fixed_height_from_font(cast[ptr CellRendererText00](self.impl), int32(numberOfRows))

proc `fixedHeightFromFont=`*(self: CellRendererText; numberOfRows: int) =
  gtk_cell_renderer_text_set_fixed_height_from_font(cast[ptr CellRendererText00](self.impl), int32(numberOfRows))

type
  CellRendererAccelPrivate00* {.pure.} = object
  CellRendererAccelPrivate* = ref object
    impl*: ptr CellRendererAccelPrivate00

type
  CellRendererAccel* = ref object of CellRendererText
  CellRendererAccel00* = object of CellRendererText00
    priv3: ptr CellRendererAccelPrivate00

proc scAccelCleared*(self: CellRendererAccel;  p: proc (self: ptr gobject.Object00; pathString: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "accel-cleared", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scAccelEdited*(self: CellRendererAccel;  p: proc (self: ptr gobject.Object00; pathString: cstring; accelKey: uint32; accelMods: gdk.ModifierType; 
    hardwareKeycode: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "accel-edited", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_cell_renderer_accel_new*(): ptr CellRendererAccel00 {.
    importc: "gtk_cell_renderer_accel_new", libprag.}

proc newCellRendererAccel*(): CellRendererAccel =
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_accel_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererAccel*[T](result: var T) =
  assert(result is CellRendererAccel)
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_accel_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererClassPrivate00* {.pure.} = object
  CellRendererClassPrivate* = ref object
    impl*: ptr CellRendererClassPrivate00

type
  CellRendererClass00* {.pure.} = object
    parentClass*: gobject.InitiallyUnownedClass00
    getRequestMode*: proc(cell: ptr CellRenderer00): SizeRequestMode {.cdecl.}
    getPreferredWidth*: proc(cell: ptr CellRenderer00; widget: ptr Widget00; minimumSize: var int32; 
    naturalSize: var int32) {.cdecl.}
    getPreferredHeightForWidth*: proc(cell: ptr CellRenderer00; widget: ptr Widget00; width: int32; 
    minimumHeight: var int32; naturalHeight: var int32) {.cdecl.}
    getPreferredHeight*: proc(cell: ptr CellRenderer00; widget: ptr Widget00; minimumSize: var int32; 
    naturalSize: var int32) {.cdecl.}
    getPreferredWidthForHeight*: proc(cell: ptr CellRenderer00; widget: ptr Widget00; height: int32; 
    minimumWidth: var int32; naturalWidth: var int32) {.cdecl.}
    getAlignedArea*: proc(cell: ptr CellRenderer00; widget: ptr Widget00; flags: CellRendererState; 
    cellArea: ptr gdk.Rectangle00; alignedArea: var gdk.Rectangle00) {.cdecl.}
    getSize*: proc(cell: ptr CellRenderer00; widget: ptr Widget00; cellArea: ptr gdk.Rectangle00; 
    xOffset: var int32; yOffset: var int32; width: var int32; height: var int32) {.cdecl.}
    render*: proc(cell: ptr CellRenderer00; cr: ptr cairo.Context00; 
    widget: ptr Widget00; backgroundArea: ptr gdk.Rectangle00; cellArea: ptr gdk.Rectangle00; flags: CellRendererState) {.cdecl.}
    activate*: proc(cell: ptr CellRenderer00; event: ptr gdk.Event00; 
    widget: ptr Widget00; path: cstring; backgroundArea: ptr gdk.Rectangle00; cellArea: ptr gdk.Rectangle00; 
    flags: CellRendererState): gboolean {.cdecl.}
    startEditing*: proc(cell: ptr CellRenderer00; event: ptr gdk.Event00; 
    widget: ptr Widget00; path: cstring; backgroundArea: ptr gdk.Rectangle00; cellArea: ptr gdk.Rectangle00; 
    flags: CellRendererState): ptr CellEditable00 {.cdecl.}
    editingCanceled*: proc(cell: ptr CellRenderer00) {.cdecl.}
    editingStarted*: proc(cell: ptr CellRenderer00; editable: ptr CellEditable00; 
    path: cstring) {.cdecl.}
    priv*: ptr CellRendererClassPrivate00
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellRendererClass* = ref object
    impl*: ptr CellRendererClass00

proc gtk_cell_renderer_class_set_accessible_type*(self: ptr CellRendererClass00; `type`: GType) {.
    importc: "gtk_cell_renderer_class_set_accessible_type", libprag.}

proc setAccessibleType*(self: CellRendererClass; `type`: GType) =
  gtk_cell_renderer_class_set_accessible_type(cast[ptr CellRendererClass00](self.impl), `type`)

proc `accessibleType=`*(self: CellRendererClass; `type`: GType) =
  gtk_cell_renderer_class_set_accessible_type(cast[ptr CellRendererClass00](self.impl), `type`)

type
  CellRendererTextClass00* {.pure.} = object
    parentClass*: CellRendererClass00
    edited*: proc(cellRendererText: ptr CellRendererText00; path: cstring; 
    newText: cstring) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellRendererTextClass* = ref object
    impl*: ptr CellRendererTextClass00

type
  CellRendererAccelClass00* {.pure.} = object
    parentClass*: CellRendererTextClass00
    accelEdited*: proc(accel: ptr CellRendererAccel00; pathString: cstring; 
    accelKey: uint32; accelMods: gdk.ModifierType; hardwareKeycode: uint32) {.cdecl.}
    accelCleared*: proc(accel: ptr CellRendererAccel00; pathString: cstring) {.cdecl.}
    gtkReserved0*: pointer
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellRendererAccelClass* = ref object
    impl*: ptr CellRendererAccelClass00

type
  CellRendererAccelMode* {.size: sizeof(cint), pure.} = enum
    gtk = 0
    other = 1

type
  CellRendererComboPrivate00* {.pure.} = object
  CellRendererComboPrivate* = ref object
    impl*: ptr CellRendererComboPrivate00

type
  CellRendererCombo* = ref object of CellRendererText
  CellRendererCombo00* = object of CellRendererText00
    priv3: ptr CellRendererComboPrivate00

proc scChanged*(self: CellRendererCombo;  p: proc (self: ptr gobject.Object00; pathString: cstring; newIter: TreeIter00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_cell_renderer_combo_new*(): ptr CellRendererCombo00 {.
    importc: "gtk_cell_renderer_combo_new", libprag.}

proc newCellRendererCombo*(): CellRendererCombo =
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_combo_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererCombo*[T](result: var T) =
  assert(result is CellRendererCombo)
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_combo_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererComboClass00* {.pure.} = object
    parent*: CellRendererTextClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellRendererComboClass* = ref object
    impl*: ptr CellRendererComboClass00

type
  CellRendererMode* {.size: sizeof(cint), pure.} = enum
    inert = 0
    activatable = 1
    editable = 2

type
  CellRendererPixbufPrivate00* {.pure.} = object
  CellRendererPixbufPrivate* = ref object
    impl*: ptr CellRendererPixbufPrivate00

type
  CellRendererPixbuf* = ref object of CellRenderer
  CellRendererPixbuf00* = object of CellRenderer00
    priv2: ptr CellRendererPixbufPrivate00

proc gtk_cell_renderer_pixbuf_new*(): ptr CellRendererPixbuf00 {.
    importc: "gtk_cell_renderer_pixbuf_new", libprag.}

proc newCellRendererPixbuf*(): CellRendererPixbuf =
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_pixbuf_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererPixbuf*[T](result: var T) =
  assert(result is CellRendererPixbuf)
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_pixbuf_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererPixbufClass00* {.pure.} = object
    parentClass*: CellRendererClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellRendererPixbufClass* = ref object
    impl*: ptr CellRendererPixbufClass00

type
  CellRendererProgressPrivate00* {.pure.} = object
  CellRendererProgressPrivate* = ref object
    impl*: ptr CellRendererProgressPrivate00

type
  CellRendererProgress* = ref object of CellRenderer
  CellRendererProgress00* = object of CellRenderer00
    priv2: ptr CellRendererProgressPrivate00

proc gtk_cell_renderer_progress_new*(): ptr CellRendererProgress00 {.
    importc: "gtk_cell_renderer_progress_new", libprag.}

proc newCellRendererProgress*(): CellRendererProgress =
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_progress_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererProgress*[T](result: var T) =
  assert(result is CellRendererProgress)
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_progress_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererProgressClass00* {.pure.} = object
    parentClass*: CellRendererClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellRendererProgressClass* = ref object
    impl*: ptr CellRendererProgressClass00

type
  CellRendererSpinPrivate00* {.pure.} = object
  CellRendererSpinPrivate* = ref object
    impl*: ptr CellRendererSpinPrivate00

type
  CellRendererSpin* = ref object of CellRendererText
  CellRendererSpin00* = object of CellRendererText00
    priv3: ptr CellRendererSpinPrivate00

proc gtk_cell_renderer_spin_new*(): ptr CellRendererSpin00 {.
    importc: "gtk_cell_renderer_spin_new", libprag.}

proc newCellRendererSpin*(): CellRendererSpin =
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_spin_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererSpin*[T](result: var T) =
  assert(result is CellRendererSpin)
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_spin_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererSpinClass00* {.pure.} = object
    parent*: CellRendererTextClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellRendererSpinClass* = ref object
    impl*: ptr CellRendererSpinClass00

type
  CellRendererSpinnerPrivate00* {.pure.} = object
  CellRendererSpinnerPrivate* = ref object
    impl*: ptr CellRendererSpinnerPrivate00

type
  CellRendererSpinner* = ref object of CellRenderer
  CellRendererSpinner00* = object of CellRenderer00
    priv2: ptr CellRendererSpinnerPrivate00

proc gtk_cell_renderer_spinner_new*(): ptr CellRendererSpinner00 {.
    importc: "gtk_cell_renderer_spinner_new", libprag.}

proc newCellRendererSpinner*(): CellRendererSpinner =
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_spinner_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererSpinner*[T](result: var T) =
  assert(result is CellRendererSpinner)
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_spinner_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererSpinnerClass00* {.pure.} = object
    parentClass*: CellRendererClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellRendererSpinnerClass* = ref object
    impl*: ptr CellRendererSpinnerClass00

type
  CellRendererTogglePrivate00* {.pure.} = object
  CellRendererTogglePrivate* = ref object
    impl*: ptr CellRendererTogglePrivate00

type
  CellRendererToggle* = ref object of CellRenderer
  CellRendererToggle00* = object of CellRenderer00
    priv2: ptr CellRendererTogglePrivate00

proc scToggled*(self: CellRendererToggle;  p: proc (self: ptr gobject.Object00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_cell_renderer_toggle_new*(): ptr CellRendererToggle00 {.
    importc: "gtk_cell_renderer_toggle_new", libprag.}

proc newCellRendererToggle*(): CellRendererToggle =
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_toggle_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererToggle*[T](result: var T) =
  assert(result is CellRendererToggle)
  new(result, finalizeGObject)
  result.impl = gtk_cell_renderer_toggle_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_renderer_toggle_get_activatable*(self: ptr CellRendererToggle00): gboolean {.
    importc: "gtk_cell_renderer_toggle_get_activatable", libprag.}

proc getActivatable*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_activatable(cast[ptr CellRendererToggle00](self.impl)))

proc activatable*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_activatable(cast[ptr CellRendererToggle00](self.impl)))

proc gtk_cell_renderer_toggle_get_active*(self: ptr CellRendererToggle00): gboolean {.
    importc: "gtk_cell_renderer_toggle_get_active", libprag.}

proc getActive*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_active(cast[ptr CellRendererToggle00](self.impl)))

proc active*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_active(cast[ptr CellRendererToggle00](self.impl)))

proc gtk_cell_renderer_toggle_get_radio*(self: ptr CellRendererToggle00): gboolean {.
    importc: "gtk_cell_renderer_toggle_get_radio", libprag.}

proc getRadio*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_radio(cast[ptr CellRendererToggle00](self.impl)))

proc radio*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_radio(cast[ptr CellRendererToggle00](self.impl)))

proc gtk_cell_renderer_toggle_set_activatable*(self: ptr CellRendererToggle00; setting: gboolean) {.
    importc: "gtk_cell_renderer_toggle_set_activatable", libprag.}

proc setActivatable*(self: CellRendererToggle; setting: bool) =
  gtk_cell_renderer_toggle_set_activatable(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc `activatable=`*(self: CellRendererToggle; setting: bool) =
  gtk_cell_renderer_toggle_set_activatable(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc gtk_cell_renderer_toggle_set_active*(self: ptr CellRendererToggle00; setting: gboolean) {.
    importc: "gtk_cell_renderer_toggle_set_active", libprag.}

proc setActive*(self: CellRendererToggle; setting: bool) =
  gtk_cell_renderer_toggle_set_active(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc `active=`*(self: CellRendererToggle; setting: bool) =
  gtk_cell_renderer_toggle_set_active(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc gtk_cell_renderer_toggle_set_radio*(self: ptr CellRendererToggle00; radio: gboolean) {.
    importc: "gtk_cell_renderer_toggle_set_radio", libprag.}

proc setRadio*(self: CellRendererToggle; radio: bool) =
  gtk_cell_renderer_toggle_set_radio(cast[ptr CellRendererToggle00](self.impl), gboolean(radio))

proc `radio=`*(self: CellRendererToggle; radio: bool) =
  gtk_cell_renderer_toggle_set_radio(cast[ptr CellRendererToggle00](self.impl), gboolean(radio))

type
  CellRendererToggleClass00* {.pure.} = object
    parentClass*: CellRendererClass00
    toggled*: proc(cellRendererToggle: ptr CellRendererToggle00; path: cstring) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellRendererToggleClass* = ref object
    impl*: ptr CellRendererToggleClass00

type
  CellViewPrivate00* {.pure.} = object
  CellViewPrivate* = ref object
    impl*: ptr CellViewPrivate00

type
  CellView* = ref object of Widget
  CellView00* = object of Widget00
    priv2: ptr CellViewPrivate00

proc gtk_cell_view_new*(): ptr CellView00 {.
    importc: "gtk_cell_view_new", libprag.}

proc newCellView*(): CellView =
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellView*[T](result: var T) =
  assert(result is CellView)
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_context*(area: ptr CellArea00; context: ptr CellAreaContext00): ptr CellView00 {.
    importc: "gtk_cell_view_new_with_context", libprag.}

proc newCellViewWithContext*(area: CellArea; context: CellAreaContext): CellView =
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new_with_context(cast[ptr CellArea00](area.impl), cast[ptr CellAreaContext00](context.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithContext*[T](result: var T; area: CellArea; context: CellAreaContext) =
  assert(result is CellView)
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new_with_context(cast[ptr CellArea00](area.impl), cast[ptr CellAreaContext00](context.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_markup*(markup: cstring): ptr CellView00 {.
    importc: "gtk_cell_view_new_with_markup", libprag.}

proc newCellViewWithMarkup*(markup: string): CellView =
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new_with_markup(cstring(markup))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithMarkup*[T](result: var T; markup: string) =
  assert(result is CellView)
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new_with_markup(cstring(markup))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_pixbuf*(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr CellView00 {.
    importc: "gtk_cell_view_new_with_pixbuf", libprag.}

proc newCellViewWithPixbuf*(pixbuf: gdkpixbuf.Pixbuf): CellView =
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new_with_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf) =
  assert(result is CellView)
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new_with_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_text*(text: cstring): ptr CellView00 {.
    importc: "gtk_cell_view_new_with_text", libprag.}

proc newCellViewWithText*(text: string): CellView =
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new_with_text(cstring(text))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithText*[T](result: var T; text: string) =
  assert(result is CellView)
  new(result, finalizeGObject)
  result.impl = gtk_cell_view_new_with_text(cstring(text))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_get_displayed_row*(self: ptr CellView00): ptr TreePath00 {.
    importc: "gtk_cell_view_get_displayed_row", libprag.}

proc getDisplayedRow*(self: CellView): TreePath =
  new(result)
  result.impl = gtk_cell_view_get_displayed_row(cast[ptr CellView00](self.impl))

proc displayedRow*(self: CellView): TreePath =
  new(result)
  result.impl = gtk_cell_view_get_displayed_row(cast[ptr CellView00](self.impl))

proc gtk_cell_view_get_draw_sensitive*(self: ptr CellView00): gboolean {.
    importc: "gtk_cell_view_get_draw_sensitive", libprag.}

proc getDrawSensitive*(self: CellView): bool =
  toBool(gtk_cell_view_get_draw_sensitive(cast[ptr CellView00](self.impl)))

proc drawSensitive*(self: CellView): bool =
  toBool(gtk_cell_view_get_draw_sensitive(cast[ptr CellView00](self.impl)))

proc gtk_cell_view_get_fit_model*(self: ptr CellView00): gboolean {.
    importc: "gtk_cell_view_get_fit_model", libprag.}

proc getFitModel*(self: CellView): bool =
  toBool(gtk_cell_view_get_fit_model(cast[ptr CellView00](self.impl)))

proc fitModel*(self: CellView): bool =
  toBool(gtk_cell_view_get_fit_model(cast[ptr CellView00](self.impl)))

proc gtk_cell_view_get_model*(self: ptr CellView00): ptr TreeModel00 {.
    importc: "gtk_cell_view_get_model", libprag.}

proc getModel*(self: CellView): TreeModel =
  new(result)
  result.impl = gtk_cell_view_get_model(cast[ptr CellView00](self.impl))

proc model*(self: CellView): TreeModel =
  new(result)
  result.impl = gtk_cell_view_get_model(cast[ptr CellView00](self.impl))

proc gtk_cell_view_get_size_of_row*(self: ptr CellView00; path: ptr TreePath00; requisition: var Requisition00): gboolean {.
    importc: "gtk_cell_view_get_size_of_row", libprag.}

proc getSizeOfRow*(self: ptr CellView00; path: ptr TreePath00; requisition: var Requisition00): gboolean {.
    importc: "gtk_cell_view_get_size_of_row", libprag.}

proc sizeOfRow*(self: ptr CellView00; path: ptr TreePath00; requisition: var Requisition00): gboolean {.
    importc: "gtk_cell_view_get_size_of_row", libprag.}

proc gtk_cell_view_set_background_color*(self: ptr CellView00; color: ptr gdk.Color00) {.
    importc: "gtk_cell_view_set_background_color", libprag.}

proc setBackgroundColor*(self: CellView; color: gdk.Color) =
  gtk_cell_view_set_background_color(cast[ptr CellView00](self.impl), cast[ptr gdk.Color00](color.impl))

proc `backgroundColor=`*(self: CellView; color: gdk.Color) =
  gtk_cell_view_set_background_color(cast[ptr CellView00](self.impl), cast[ptr gdk.Color00](color.impl))

proc gtk_cell_view_set_background_rgba*(self: ptr CellView00; rgba: ptr gdk.RGBA00) {.
    importc: "gtk_cell_view_set_background_rgba", libprag.}

proc setBackgroundRgba*(self: CellView; rgba: gdk.RGBA) =
  gtk_cell_view_set_background_rgba(cast[ptr CellView00](self.impl), cast[ptr gdk.RGBA00](rgba.impl))

proc `backgroundRgba=`*(self: CellView; rgba: gdk.RGBA) =
  gtk_cell_view_set_background_rgba(cast[ptr CellView00](self.impl), cast[ptr gdk.RGBA00](rgba.impl))

proc gtk_cell_view_set_displayed_row*(self: ptr CellView00; path: ptr TreePath00) {.
    importc: "gtk_cell_view_set_displayed_row", libprag.}

proc setDisplayedRow*(self: CellView; path: TreePath) =
  gtk_cell_view_set_displayed_row(cast[ptr CellView00](self.impl), cast[ptr TreePath00](path.impl))

proc `displayedRow=`*(self: CellView; path: TreePath) =
  gtk_cell_view_set_displayed_row(cast[ptr CellView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_cell_view_set_draw_sensitive*(self: ptr CellView00; drawSensitive: gboolean) {.
    importc: "gtk_cell_view_set_draw_sensitive", libprag.}

proc setDrawSensitive*(self: CellView; drawSensitive: bool) =
  gtk_cell_view_set_draw_sensitive(cast[ptr CellView00](self.impl), gboolean(drawSensitive))

proc `drawSensitive=`*(self: CellView; drawSensitive: bool) =
  gtk_cell_view_set_draw_sensitive(cast[ptr CellView00](self.impl), gboolean(drawSensitive))

proc gtk_cell_view_set_fit_model*(self: ptr CellView00; fitModel: gboolean) {.
    importc: "gtk_cell_view_set_fit_model", libprag.}

proc setFitModel*(self: CellView; fitModel: bool) =
  gtk_cell_view_set_fit_model(cast[ptr CellView00](self.impl), gboolean(fitModel))

proc `fitModel=`*(self: CellView; fitModel: bool) =
  gtk_cell_view_set_fit_model(cast[ptr CellView00](self.impl), gboolean(fitModel))

proc gtk_cell_view_set_model*(self: ptr CellView00; model: ptr TreeModel00) {.
    importc: "gtk_cell_view_set_model", libprag.}

proc setModel*(self: CellView; model: TreeModel) =
  gtk_cell_view_set_model(cast[ptr CellView00](self.impl), cast[ptr TreeModel00](model.impl))

proc `model=`*(self: CellView; model: TreeModel) =
  gtk_cell_view_set_model(cast[ptr CellView00](self.impl), cast[ptr TreeModel00](model.impl))

type
  CellViewClass00* {.pure.} = object
    parentClass*: WidgetClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CellViewClass* = ref object
    impl*: ptr CellViewClass00

type
  ToggleButtonPrivate00* {.pure.} = object
  ToggleButtonPrivate* = ref object
    impl*: ptr ToggleButtonPrivate00

type
  ToggleButton* = ref object of Button
  ToggleButton00* = object of Button00
    priv5: ptr ToggleButtonPrivate00

proc scToggled*(self: ToggleButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_toggle_button_new*(): ptr ToggleButton00 {.
    importc: "gtk_toggle_button_new", libprag.}

proc newToggleButton*(): ToggleButton =
  new(result, finalizeGObject)
  result.impl = gtk_toggle_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleButton*[T](result: var T) =
  assert(result is ToggleButton)
  new(result, finalizeGObject)
  result.impl = gtk_toggle_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_button_new_with_label*(label: cstring): ptr ToggleButton00 {.
    importc: "gtk_toggle_button_new_with_label", libprag.}

proc newToggleButtonWithLabel*(label: string): ToggleButton =
  new(result, finalizeGObject)
  result.impl = gtk_toggle_button_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleButtonWithLabel*[T](result: var T; label: string) =
  assert(result is ToggleButton)
  new(result, finalizeGObject)
  result.impl = gtk_toggle_button_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_button_new_with_mnemonic*(label: cstring): ptr ToggleButton00 {.
    importc: "gtk_toggle_button_new_with_mnemonic", libprag.}

proc newToggleButtonWithMnemonic*(label: string): ToggleButton =
  new(result, finalizeGObject)
  result.impl = gtk_toggle_button_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleButtonWithMnemonic*[T](result: var T; label: string) =
  assert(result is ToggleButton)
  new(result, finalizeGObject)
  result.impl = gtk_toggle_button_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_button_get_active*(self: ptr ToggleButton00): gboolean {.
    importc: "gtk_toggle_button_get_active", libprag.}

proc getActive*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_active(cast[ptr ToggleButton00](self.impl)))

proc active*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_active(cast[ptr ToggleButton00](self.impl)))

proc gtk_toggle_button_get_inconsistent*(self: ptr ToggleButton00): gboolean {.
    importc: "gtk_toggle_button_get_inconsistent", libprag.}

proc getInconsistent*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_inconsistent(cast[ptr ToggleButton00](self.impl)))

proc inconsistent*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_inconsistent(cast[ptr ToggleButton00](self.impl)))

proc gtk_toggle_button_get_mode*(self: ptr ToggleButton00): gboolean {.
    importc: "gtk_toggle_button_get_mode", libprag.}

proc getMode*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_mode(cast[ptr ToggleButton00](self.impl)))

proc mode*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_mode(cast[ptr ToggleButton00](self.impl)))

proc gtk_toggle_button_set_active*(self: ptr ToggleButton00; isActive: gboolean) {.
    importc: "gtk_toggle_button_set_active", libprag.}

proc setActive*(self: ToggleButton; isActive: bool) =
  gtk_toggle_button_set_active(cast[ptr ToggleButton00](self.impl), gboolean(isActive))

proc `active=`*(self: ToggleButton; isActive: bool) =
  gtk_toggle_button_set_active(cast[ptr ToggleButton00](self.impl), gboolean(isActive))

proc gtk_toggle_button_set_inconsistent*(self: ptr ToggleButton00; setting: gboolean) {.
    importc: "gtk_toggle_button_set_inconsistent", libprag.}

proc setInconsistent*(self: ToggleButton; setting: bool) =
  gtk_toggle_button_set_inconsistent(cast[ptr ToggleButton00](self.impl), gboolean(setting))

proc `inconsistent=`*(self: ToggleButton; setting: bool) =
  gtk_toggle_button_set_inconsistent(cast[ptr ToggleButton00](self.impl), gboolean(setting))

proc gtk_toggle_button_set_mode*(self: ptr ToggleButton00; drawIndicator: gboolean) {.
    importc: "gtk_toggle_button_set_mode", libprag.}

proc setMode*(self: ToggleButton; drawIndicator: bool) =
  gtk_toggle_button_set_mode(cast[ptr ToggleButton00](self.impl), gboolean(drawIndicator))

proc `mode=`*(self: ToggleButton; drawIndicator: bool) =
  gtk_toggle_button_set_mode(cast[ptr ToggleButton00](self.impl), gboolean(drawIndicator))

proc gtk_toggle_button_toggled*(self: ptr ToggleButton00) {.
    importc: "gtk_toggle_button_toggled", libprag.}

proc toggled*(self: ToggleButton) =
  gtk_toggle_button_toggled(cast[ptr ToggleButton00](self.impl))

type
  CheckButton* = ref object of ToggleButton
  CheckButton00* = object of ToggleButton00

proc gtk_check_button_new*(): ptr CheckButton00 {.
    importc: "gtk_check_button_new", libprag.}

proc newCheckButton*(): CheckButton =
  new(result, finalizeGObject)
  result.impl = gtk_check_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckButton*[T](result: var T) =
  assert(result is CheckButton)
  new(result, finalizeGObject)
  result.impl = gtk_check_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_button_new_with_label*(label: cstring): ptr CheckButton00 {.
    importc: "gtk_check_button_new_with_label", libprag.}

proc newCheckButtonWithLabel*(label: string): CheckButton =
  new(result, finalizeGObject)
  result.impl = gtk_check_button_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckButtonWithLabel*[T](result: var T; label: string) =
  assert(result is CheckButton)
  new(result, finalizeGObject)
  result.impl = gtk_check_button_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_button_new_with_mnemonic*(label: cstring): ptr CheckButton00 {.
    importc: "gtk_check_button_new_with_mnemonic", libprag.}

proc newCheckButtonWithMnemonic*(label: string): CheckButton =
  new(result, finalizeGObject)
  result.impl = gtk_check_button_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckButtonWithMnemonic*[T](result: var T; label: string) =
  assert(result is CheckButton)
  new(result, finalizeGObject)
  result.impl = gtk_check_button_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ToggleButtonClass00* {.pure.} = object
    parentClass*: ButtonClass00
    toggled*: proc(toggleButton: ptr ToggleButton00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ToggleButtonClass* = ref object
    impl*: ptr ToggleButtonClass00

type
  CheckButtonClass00* {.pure.} = object
    parentClass*: ToggleButtonClass00
    drawIndicator*: proc(checkButton: ptr CheckButton00; cr: ptr cairo.Context00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CheckButtonClass* = ref object
    impl*: ptr CheckButtonClass00

type
  CheckMenuItemPrivate00* {.pure.} = object
  CheckMenuItemPrivate* = ref object
    impl*: ptr CheckMenuItemPrivate00

type
  CheckMenuItem* = ref object of MenuItem
  CheckMenuItem00* = object of MenuItem00
    priv5: ptr CheckMenuItemPrivate00

proc scToggled*(self: CheckMenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_check_menu_item_new*(): ptr CheckMenuItem00 {.
    importc: "gtk_check_menu_item_new", libprag.}

proc newCheckMenuItem*(): CheckMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_check_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckMenuItem*[T](result: var T) =
  assert(result is CheckMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_check_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_menu_item_new_with_label*(label: cstring): ptr CheckMenuItem00 {.
    importc: "gtk_check_menu_item_new_with_label", libprag.}

proc newCheckMenuItemWithLabel*(label: string): CheckMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_check_menu_item_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckMenuItemWithLabel*[T](result: var T; label: string) =
  assert(result is CheckMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_check_menu_item_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_menu_item_new_with_mnemonic*(label: cstring): ptr CheckMenuItem00 {.
    importc: "gtk_check_menu_item_new_with_mnemonic", libprag.}

proc newCheckMenuItemWithMnemonic*(label: string): CheckMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_check_menu_item_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckMenuItemWithMnemonic*[T](result: var T; label: string) =
  assert(result is CheckMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_check_menu_item_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_menu_item_get_active*(self: ptr CheckMenuItem00): gboolean {.
    importc: "gtk_check_menu_item_get_active", libprag.}

proc getActive*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_active(cast[ptr CheckMenuItem00](self.impl)))

proc active*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_active(cast[ptr CheckMenuItem00](self.impl)))

proc gtk_check_menu_item_get_draw_as_radio*(self: ptr CheckMenuItem00): gboolean {.
    importc: "gtk_check_menu_item_get_draw_as_radio", libprag.}

proc getDrawAsRadio*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_draw_as_radio(cast[ptr CheckMenuItem00](self.impl)))

proc drawAsRadio*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_draw_as_radio(cast[ptr CheckMenuItem00](self.impl)))

proc gtk_check_menu_item_get_inconsistent*(self: ptr CheckMenuItem00): gboolean {.
    importc: "gtk_check_menu_item_get_inconsistent", libprag.}

proc getInconsistent*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_inconsistent(cast[ptr CheckMenuItem00](self.impl)))

proc inconsistent*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_inconsistent(cast[ptr CheckMenuItem00](self.impl)))

proc gtk_check_menu_item_set_active*(self: ptr CheckMenuItem00; isActive: gboolean) {.
    importc: "gtk_check_menu_item_set_active", libprag.}

proc setActive*(self: CheckMenuItem; isActive: bool) =
  gtk_check_menu_item_set_active(cast[ptr CheckMenuItem00](self.impl), gboolean(isActive))

proc `active=`*(self: CheckMenuItem; isActive: bool) =
  gtk_check_menu_item_set_active(cast[ptr CheckMenuItem00](self.impl), gboolean(isActive))

proc gtk_check_menu_item_set_draw_as_radio*(self: ptr CheckMenuItem00; drawAsRadio: gboolean) {.
    importc: "gtk_check_menu_item_set_draw_as_radio", libprag.}

proc setDrawAsRadio*(self: CheckMenuItem; drawAsRadio: bool) =
  gtk_check_menu_item_set_draw_as_radio(cast[ptr CheckMenuItem00](self.impl), gboolean(drawAsRadio))

proc `drawAsRadio=`*(self: CheckMenuItem; drawAsRadio: bool) =
  gtk_check_menu_item_set_draw_as_radio(cast[ptr CheckMenuItem00](self.impl), gboolean(drawAsRadio))

proc gtk_check_menu_item_set_inconsistent*(self: ptr CheckMenuItem00; setting: gboolean) {.
    importc: "gtk_check_menu_item_set_inconsistent", libprag.}

proc setInconsistent*(self: CheckMenuItem; setting: bool) =
  gtk_check_menu_item_set_inconsistent(cast[ptr CheckMenuItem00](self.impl), gboolean(setting))

proc `inconsistent=`*(self: CheckMenuItem; setting: bool) =
  gtk_check_menu_item_set_inconsistent(cast[ptr CheckMenuItem00](self.impl), gboolean(setting))

proc gtk_check_menu_item_toggled*(self: ptr CheckMenuItem00) {.
    importc: "gtk_check_menu_item_toggled", libprag.}

proc toggled*(self: CheckMenuItem) =
  gtk_check_menu_item_toggled(cast[ptr CheckMenuItem00](self.impl))

type
  MenuItemAccessiblePrivate00* {.pure.} = object
  MenuItemAccessiblePrivate* = ref object
    impl*: ptr MenuItemAccessiblePrivate00

type
  MenuItemAccessible* = ref object of ContainerAccessible
  MenuItemAccessible00* = object of ContainerAccessible00
    priv4: ptr MenuItemAccessiblePrivate00

type
  CheckMenuItemAccessiblePrivate00* {.pure.} = object
  CheckMenuItemAccessiblePrivate* = ref object
    impl*: ptr CheckMenuItemAccessiblePrivate00

type
  CheckMenuItemAccessible* = ref object of MenuItemAccessible
  CheckMenuItemAccessible00* = object of MenuItemAccessible00
    priv5: ptr CheckMenuItemAccessiblePrivate00

type
  MenuItemAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  MenuItemAccessibleClass* = ref object
    impl*: ptr MenuItemAccessibleClass00

type
  CheckMenuItemAccessibleClass00* {.pure.} = object
    parentClass*: MenuItemAccessibleClass00
  CheckMenuItemAccessibleClass* = ref object
    impl*: ptr CheckMenuItemAccessibleClass00

type
  MenuItemClass00* {.pure.} = object
    parentClass*: BinClass00
    hideOnActivate*: uint32
    activate*: proc(menuItem: ptr MenuItem00) {.cdecl.}
    activateItem*: proc(menuItem: ptr MenuItem00) {.cdecl.}
    toggleSizeRequest*: proc(menuItem: ptr MenuItem00; requisition: int32) {.cdecl.}
    toggleSizeAllocate*: proc(menuItem: ptr MenuItem00; allocation: int32) {.cdecl.}
    setLabel*: proc(menuItem: ptr MenuItem00; label: cstring) {.cdecl.}
    getLabel*: proc(menuItem: ptr MenuItem00): cstring {.cdecl.}
    select*: proc(menuItem: ptr MenuItem00) {.cdecl.}
    deselect*: proc(menuItem: ptr MenuItem00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  MenuItemClass* = ref object
    impl*: ptr MenuItemClass00

type
  CheckMenuItemClass00* {.pure.} = object
    parentClass*: MenuItemClass00
    toggled*: proc(checkMenuItem: ptr CheckMenuItem00) {.cdecl.}
    drawIndicator*: proc(checkMenuItem: ptr CheckMenuItem00; cr: ptr cairo.Context00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CheckMenuItemClass* = ref object
    impl*: ptr CheckMenuItemClass00

type
  ClipboardClearFunc* = proc (clipboard: ptr Clipboard00; userDataOrOwner: pointer) {.cdecl.}

type
  ClipboardGetFunc* = proc (clipboard: ptr Clipboard00; selectionData: ptr SelectionData00; 
    info: uint32; userDataOrOwner: pointer) {.cdecl.}

type
  ClipboardImageReceivedFunc* = proc (clipboard: ptr Clipboard00; pixbuf: ptr gdkpixbuf.Pixbuf00; 
    data: pointer) {.cdecl.}

proc gtk_clipboard_request_image*(self: ptr Clipboard00; callback: ClipboardImageReceivedFunc; 
    userData: pointer) {.
    importc: "gtk_clipboard_request_image", libprag.}

proc requestImage*(self: Clipboard; callback: ClipboardImageReceivedFunc; 
    userData: pointer) =
  gtk_clipboard_request_image(cast[ptr Clipboard00](self.impl), callback, userData)

type
  ClipboardReceivedFunc* = proc (clipboard: ptr Clipboard00; selectionData: ptr SelectionData00; 
    data: pointer) {.cdecl.}

proc gtk_clipboard_request_contents*(self: ptr Clipboard00; target: ptr gdk.Atom00; callback: ClipboardReceivedFunc; 
    userData: pointer) {.
    importc: "gtk_clipboard_request_contents", libprag.}

proc requestContents*(self: Clipboard; target: gdk.Atom; callback: ClipboardReceivedFunc; 
    userData: pointer) =
  gtk_clipboard_request_contents(cast[ptr Clipboard00](self.impl), cast[ptr gdk.Atom00](target.impl), callback, userData)

type
  ClipboardRichTextReceivedFunc* = proc (clipboard: ptr Clipboard00; format: ptr gdk.Atom00; 
    text: cstring; length: uint64; data: pointer) {.cdecl.}

proc gtk_clipboard_request_rich_text*(self: ptr Clipboard00; buffer: ptr TextBuffer00; callback: ClipboardRichTextReceivedFunc; 
    userData: pointer) {.
    importc: "gtk_clipboard_request_rich_text", libprag.}

proc requestRichText*(self: Clipboard; buffer: TextBuffer; callback: ClipboardRichTextReceivedFunc; 
    userData: pointer) =
  gtk_clipboard_request_rich_text(cast[ptr Clipboard00](self.impl), cast[ptr TextBuffer00](buffer.impl), callback, userData)

type
  ClipboardTargetsReceivedFunc* = proc (clipboard: ptr Clipboard00; atoms: ptr gdk.Atom00Array; 
    nAtoms: int32; data: pointer) {.cdecl.}

proc gtk_clipboard_request_targets*(self: ptr Clipboard00; callback: ClipboardTargetsReceivedFunc; 
    userData: pointer) {.
    importc: "gtk_clipboard_request_targets", libprag.}

proc requestTargets*(self: Clipboard; callback: ClipboardTargetsReceivedFunc; 
    userData: pointer) =
  gtk_clipboard_request_targets(cast[ptr Clipboard00](self.impl), callback, userData)

type
  ClipboardTextReceivedFunc* = proc (clipboard: ptr Clipboard00; text: cstring; data: pointer) {.cdecl.}

proc gtk_clipboard_request_text*(self: ptr Clipboard00; callback: ClipboardTextReceivedFunc; 
    userData: pointer) {.
    importc: "gtk_clipboard_request_text", libprag.}

proc requestText*(self: Clipboard; callback: ClipboardTextReceivedFunc; 
    userData: pointer) =
  gtk_clipboard_request_text(cast[ptr Clipboard00](self.impl), callback, userData)

type
  ClipboardURIReceivedFunc* = proc (clipboard: ptr Clipboard00; uris: cstringArray; data: pointer) {.cdecl.}

proc gtk_clipboard_request_uris*(self: ptr Clipboard00; callback: ClipboardURIReceivedFunc; 
    userData: pointer) {.
    importc: "gtk_clipboard_request_uris", libprag.}

proc requestUris*(self: Clipboard; callback: ClipboardURIReceivedFunc; 
    userData: pointer) =
  gtk_clipboard_request_uris(cast[ptr Clipboard00](self.impl), callback, userData)

type
  ColorButtonPrivate00* {.pure.} = object
  ColorButtonPrivate* = ref object
    impl*: ptr ColorButtonPrivate00

type
  ColorButton* = ref object of Button
  ColorButton00* = object of Button00
    priv5: ptr ColorButtonPrivate00

proc scColorSet*(self: ColorButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "color-set", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_color_button_new*(): ptr ColorButton00 {.
    importc: "gtk_color_button_new", libprag.}

proc newColorButton*(): ColorButton =
  new(result, finalizeGObject)
  result.impl = gtk_color_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorButton*[T](result: var T) =
  assert(result is ColorButton)
  new(result, finalizeGObject)
  result.impl = gtk_color_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_button_new_with_color*(color: ptr gdk.Color00): ptr ColorButton00 {.
    importc: "gtk_color_button_new_with_color", libprag.}

proc newColorButtonWithColor*(color: gdk.Color): ColorButton =
  new(result, finalizeGObject)
  result.impl = gtk_color_button_new_with_color(cast[ptr gdk.Color00](color.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorButtonWithColor*[T](result: var T; color: gdk.Color) =
  assert(result is ColorButton)
  new(result, finalizeGObject)
  result.impl = gtk_color_button_new_with_color(cast[ptr gdk.Color00](color.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_button_new_with_rgba*(rgba: ptr gdk.RGBA00): ptr ColorButton00 {.
    importc: "gtk_color_button_new_with_rgba", libprag.}

proc newColorButtonWithRgba*(rgba: gdk.RGBA): ColorButton =
  new(result, finalizeGObject)
  result.impl = gtk_color_button_new_with_rgba(cast[ptr gdk.RGBA00](rgba.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorButtonWithRgba*[T](result: var T; rgba: gdk.RGBA) =
  assert(result is ColorButton)
  new(result, finalizeGObject)
  result.impl = gtk_color_button_new_with_rgba(cast[ptr gdk.RGBA00](rgba.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_button_get_alpha*(self: ptr ColorButton00): uint16 {.
    importc: "gtk_color_button_get_alpha", libprag.}

proc getAlpha*(self: ColorButton): uint16 =
  gtk_color_button_get_alpha(cast[ptr ColorButton00](self.impl))

proc alpha*(self: ColorButton): uint16 =
  gtk_color_button_get_alpha(cast[ptr ColorButton00](self.impl))

proc gtk_color_button_get_color*(self: ptr ColorButton00; color: var gdk.Color00) {.
    importc: "gtk_color_button_get_color", libprag.}

proc getColor*(self: ptr ColorButton00; color: var gdk.Color00) {.
    importc: "gtk_color_button_get_color", libprag.}

proc color*(self: ptr ColorButton00; color: var gdk.Color00) {.
    importc: "gtk_color_button_get_color", libprag.}

proc gtk_color_button_get_title*(self: ptr ColorButton00): cstring {.
    importc: "gtk_color_button_get_title", libprag.}

proc getTitle*(self: ColorButton): string =
  let resul0 = gtk_color_button_get_title(cast[ptr ColorButton00](self.impl))
  result = $resul0

proc title*(self: ColorButton): string =
  let resul0 = gtk_color_button_get_title(cast[ptr ColorButton00](self.impl))
  result = $resul0

proc gtk_color_button_get_use_alpha*(self: ptr ColorButton00): gboolean {.
    importc: "gtk_color_button_get_use_alpha", libprag.}

proc getUseAlpha*(self: ColorButton): bool =
  toBool(gtk_color_button_get_use_alpha(cast[ptr ColorButton00](self.impl)))

proc useAlpha*(self: ColorButton): bool =
  toBool(gtk_color_button_get_use_alpha(cast[ptr ColorButton00](self.impl)))

proc gtk_color_button_set_alpha*(self: ptr ColorButton00; alpha: uint16) {.
    importc: "gtk_color_button_set_alpha", libprag.}

proc setAlpha*(self: ColorButton; alpha: uint16) =
  gtk_color_button_set_alpha(cast[ptr ColorButton00](self.impl), alpha)

proc `alpha=`*(self: ColorButton; alpha: uint16) =
  gtk_color_button_set_alpha(cast[ptr ColorButton00](self.impl), alpha)

proc gtk_color_button_set_color*(self: ptr ColorButton00; color: ptr gdk.Color00) {.
    importc: "gtk_color_button_set_color", libprag.}

proc setColor*(self: ColorButton; color: gdk.Color) =
  gtk_color_button_set_color(cast[ptr ColorButton00](self.impl), cast[ptr gdk.Color00](color.impl))

proc `color=`*(self: ColorButton; color: gdk.Color) =
  gtk_color_button_set_color(cast[ptr ColorButton00](self.impl), cast[ptr gdk.Color00](color.impl))

proc gtk_color_button_set_title*(self: ptr ColorButton00; title: cstring) {.
    importc: "gtk_color_button_set_title", libprag.}

proc setTitle*(self: ColorButton; title: string) =
  gtk_color_button_set_title(cast[ptr ColorButton00](self.impl), cstring(title))

proc `title=`*(self: ColorButton; title: string) =
  gtk_color_button_set_title(cast[ptr ColorButton00](self.impl), cstring(title))

proc gtk_color_button_set_use_alpha*(self: ptr ColorButton00; useAlpha: gboolean) {.
    importc: "gtk_color_button_set_use_alpha", libprag.}

proc setUseAlpha*(self: ColorButton; useAlpha: bool) =
  gtk_color_button_set_use_alpha(cast[ptr ColorButton00](self.impl), gboolean(useAlpha))

proc `useAlpha=`*(self: ColorButton; useAlpha: bool) =
  gtk_color_button_set_use_alpha(cast[ptr ColorButton00](self.impl), gboolean(useAlpha))

type
  ColorButtonClass00* {.pure.} = object
    parentClass*: ButtonClass00
    colorSet*: proc(cp: ptr ColorButton00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ColorButtonClass* = ref object
    impl*: ptr ColorButtonClass00

type
  ColorChooser00* {.pure.} = object
  ColorChooser* = ref object
    impl*: ptr ColorChooser00

proc gtk_color_chooser_add_palette*(self: ptr ColorChooser00; orientation: Orientation; 
    colorsPerLine: int32; nColors: int32; colors: gdk.RGBA00Array) {.
    importc: "gtk_color_chooser_add_palette", libprag.}

proc addPalette*(self: ColorChooser; orientation: Orientation; colorsPerLine: int; 
    nColors: int; colors: gdk.RGBA00Array) =
  gtk_color_chooser_add_palette(cast[ptr ColorChooser00](self.impl), orientation, int32(colorsPerLine), int32(nColors), colors)

proc gtk_color_chooser_get_rgba*(self: ptr ColorChooser00; color: var gdk.RGBA00) {.
    importc: "gtk_color_chooser_get_rgba", libprag.}

proc getRgba*(self: ptr ColorChooser00; color: var gdk.RGBA00) {.
    importc: "gtk_color_chooser_get_rgba", libprag.}

proc rgba*(self: ptr ColorChooser00; color: var gdk.RGBA00) {.
    importc: "gtk_color_chooser_get_rgba", libprag.}

proc gtk_color_chooser_get_use_alpha*(self: ptr ColorChooser00): gboolean {.
    importc: "gtk_color_chooser_get_use_alpha", libprag.}

proc getUseAlpha*(self: ColorChooser): bool =
  toBool(gtk_color_chooser_get_use_alpha(cast[ptr ColorChooser00](self.impl)))

proc useAlpha*(self: ColorChooser): bool =
  toBool(gtk_color_chooser_get_use_alpha(cast[ptr ColorChooser00](self.impl)))

proc gtk_color_chooser_set_rgba*(self: ptr ColorChooser00; color: ptr gdk.RGBA00) {.
    importc: "gtk_color_chooser_set_rgba", libprag.}

proc setRgba*(self: ColorChooser; color: gdk.RGBA) =
  gtk_color_chooser_set_rgba(cast[ptr ColorChooser00](self.impl), cast[ptr gdk.RGBA00](color.impl))

proc `rgba=`*(self: ColorChooser; color: gdk.RGBA) =
  gtk_color_chooser_set_rgba(cast[ptr ColorChooser00](self.impl), cast[ptr gdk.RGBA00](color.impl))

proc gtk_color_chooser_set_use_alpha*(self: ptr ColorChooser00; useAlpha: gboolean) {.
    importc: "gtk_color_chooser_set_use_alpha", libprag.}

proc setUseAlpha*(self: ColorChooser; useAlpha: bool) =
  gtk_color_chooser_set_use_alpha(cast[ptr ColorChooser00](self.impl), gboolean(useAlpha))

proc `useAlpha=`*(self: ColorChooser; useAlpha: bool) =
  gtk_color_chooser_set_use_alpha(cast[ptr ColorChooser00](self.impl), gboolean(useAlpha))

type
  ColorChooserDialogPrivate00* {.pure.} = object
  ColorChooserDialogPrivate* = ref object
    impl*: ptr ColorChooserDialogPrivate00

type
  ColorChooserDialog* = ref object of Dialog
  ColorChooserDialog00* = object of Dialog00
    priv6: ptr ColorChooserDialogPrivate00

proc gtk_color_chooser_dialog_new*(title: cstring; parent: ptr Window00): ptr ColorChooserDialog00 {.
    importc: "gtk_color_chooser_dialog_new", libprag.}

proc newColorChooserDialog*(title: string; parent: Window): ColorChooserDialog =
  new(result, finalizeGObject)
  result.impl = gtk_color_chooser_dialog_new(cstring(title), cast[ptr Window00](parent.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorChooserDialog*[T](result: var T; title: string; parent: Window) =
  assert(result is ColorChooserDialog)
  new(result, finalizeGObject)
  result.impl = gtk_color_chooser_dialog_new(cstring(title), cast[ptr Window00](parent.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ColorChooserDialogClass00* {.pure.} = object
    parentClass*: DialogClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ColorChooserDialogClass* = ref object
    impl*: ptr ColorChooserDialogClass00

type
  ColorChooserInterface00* {.pure.} = object
    baseInterface*: gobject.TypeInterface00
    getRgba*: proc(chooser: ptr ColorChooser00; color: var gdk.RGBA00) {.cdecl.}
    setRgba*: proc(chooser: ptr ColorChooser00; color: ptr gdk.RGBA00) {.cdecl.}
    addPalette*: proc(chooser: ptr ColorChooser00; orientation: Orientation; 
    colorsPerLine: int32; nColors: int32; colors: gdk.RGBA00Array) {.cdecl.}
    colorActivated*: proc(chooser: ptr ColorChooser00; color: ptr gdk.RGBA00) {.cdecl.}
    padding*: array[12, pointer]
  ColorChooserInterface* = ref object
    impl*: ptr ColorChooserInterface00

type
  ColorChooserWidgetPrivate00* {.pure.} = object
  ColorChooserWidgetPrivate* = ref object
    impl*: ptr ColorChooserWidgetPrivate00

type
  ColorChooserWidget* = ref object of Box
  ColorChooserWidget00* = object of Box00
    priv4: ptr ColorChooserWidgetPrivate00

proc gtk_color_chooser_widget_new*(): ptr ColorChooserWidget00 {.
    importc: "gtk_color_chooser_widget_new", libprag.}

proc newColorChooserWidget*(): ColorChooserWidget =
  new(result, finalizeGObject)
  result.impl = gtk_color_chooser_widget_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorChooserWidget*[T](result: var T) =
  assert(result is ColorChooserWidget)
  new(result, finalizeGObject)
  result.impl = gtk_color_chooser_widget_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ColorChooserWidgetClass00* {.pure.} = object
    parentClass*: BoxClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  ColorChooserWidgetClass* = ref object
    impl*: ptr ColorChooserWidgetClass00

type
  ColorSelectionPrivate00* {.pure.} = object
  ColorSelectionPrivate* = ref object
    impl*: ptr ColorSelectionPrivate00

type
  ColorSelection* = ref object of Box
  ColorSelection00* = object of Box00
    privateData4: ptr ColorSelectionPrivate00

proc scColorChanged*(self: ColorSelection;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "color-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_color_selection_new*(): ptr ColorSelection00 {.
    importc: "gtk_color_selection_new", libprag.}

proc newColorSelection*(): ColorSelection =
  new(result, finalizeGObject)
  result.impl = gtk_color_selection_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorSelection*[T](result: var T) =
  assert(result is ColorSelection)
  new(result, finalizeGObject)
  result.impl = gtk_color_selection_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_selection_palette_from_string*(str: cstring; colors: var gdk.Color00Array; nColors: var int32): gboolean {.
    importc: "gtk_color_selection_palette_from_string", libprag.}

proc paletteFromString*(str: cstring; colors: var gdk.Color00Array; nColors: var int32): gboolean {.
    importc: "gtk_color_selection_palette_from_string", libprag.}

proc gtk_color_selection_palette_to_string*(colors: gdk.Color00Array; nColors: int32): cstring {.
    importc: "gtk_color_selection_palette_to_string", libprag.}

proc paletteToString*(colors: gdk.Color00Array; nColors: int): string =
  let resul0 = gtk_color_selection_palette_to_string(colors, int32(nColors))
  result = $resul0
  cogfree(resul0)

proc gtk_color_selection_get_current_alpha*(self: ptr ColorSelection00): uint16 {.
    importc: "gtk_color_selection_get_current_alpha", libprag.}

proc getCurrentAlpha*(self: ColorSelection): uint16 =
  gtk_color_selection_get_current_alpha(cast[ptr ColorSelection00](self.impl))

proc currentAlpha*(self: ColorSelection): uint16 =
  gtk_color_selection_get_current_alpha(cast[ptr ColorSelection00](self.impl))

proc gtk_color_selection_get_current_color*(self: ptr ColorSelection00; color: var gdk.Color00) {.
    importc: "gtk_color_selection_get_current_color", libprag.}

proc getCurrentColor*(self: ptr ColorSelection00; color: var gdk.Color00) {.
    importc: "gtk_color_selection_get_current_color", libprag.}

proc currentColor*(self: ptr ColorSelection00; color: var gdk.Color00) {.
    importc: "gtk_color_selection_get_current_color", libprag.}

proc gtk_color_selection_get_current_rgba*(self: ptr ColorSelection00; rgba: var gdk.RGBA00) {.
    importc: "gtk_color_selection_get_current_rgba", libprag.}

proc getCurrentRgba*(self: ptr ColorSelection00; rgba: var gdk.RGBA00) {.
    importc: "gtk_color_selection_get_current_rgba", libprag.}

proc currentRgba*(self: ptr ColorSelection00; rgba: var gdk.RGBA00) {.
    importc: "gtk_color_selection_get_current_rgba", libprag.}

proc gtk_color_selection_get_has_opacity_control*(self: ptr ColorSelection00): gboolean {.
    importc: "gtk_color_selection_get_has_opacity_control", libprag.}

proc getHasOpacityControl*(self: ColorSelection): bool =
  toBool(gtk_color_selection_get_has_opacity_control(cast[ptr ColorSelection00](self.impl)))

proc hasOpacityControl*(self: ColorSelection): bool =
  toBool(gtk_color_selection_get_has_opacity_control(cast[ptr ColorSelection00](self.impl)))

proc gtk_color_selection_get_has_palette*(self: ptr ColorSelection00): gboolean {.
    importc: "gtk_color_selection_get_has_palette", libprag.}

proc getHasPalette*(self: ColorSelection): bool =
  toBool(gtk_color_selection_get_has_palette(cast[ptr ColorSelection00](self.impl)))

proc hasPalette*(self: ColorSelection): bool =
  toBool(gtk_color_selection_get_has_palette(cast[ptr ColorSelection00](self.impl)))

proc gtk_color_selection_get_previous_alpha*(self: ptr ColorSelection00): uint16 {.
    importc: "gtk_color_selection_get_previous_alpha", libprag.}

proc getPreviousAlpha*(self: ColorSelection): uint16 =
  gtk_color_selection_get_previous_alpha(cast[ptr ColorSelection00](self.impl))

proc previousAlpha*(self: ColorSelection): uint16 =
  gtk_color_selection_get_previous_alpha(cast[ptr ColorSelection00](self.impl))

proc gtk_color_selection_get_previous_color*(self: ptr ColorSelection00; color: var gdk.Color00) {.
    importc: "gtk_color_selection_get_previous_color", libprag.}

proc getPreviousColor*(self: ptr ColorSelection00; color: var gdk.Color00) {.
    importc: "gtk_color_selection_get_previous_color", libprag.}

proc previousColor*(self: ptr ColorSelection00; color: var gdk.Color00) {.
    importc: "gtk_color_selection_get_previous_color", libprag.}

proc gtk_color_selection_get_previous_rgba*(self: ptr ColorSelection00; rgba: var gdk.RGBA00) {.
    importc: "gtk_color_selection_get_previous_rgba", libprag.}

proc getPreviousRgba*(self: ptr ColorSelection00; rgba: var gdk.RGBA00) {.
    importc: "gtk_color_selection_get_previous_rgba", libprag.}

proc previousRgba*(self: ptr ColorSelection00; rgba: var gdk.RGBA00) {.
    importc: "gtk_color_selection_get_previous_rgba", libprag.}

proc gtk_color_selection_is_adjusting*(self: ptr ColorSelection00): gboolean {.
    importc: "gtk_color_selection_is_adjusting", libprag.}

proc isAdjusting*(self: ColorSelection): bool =
  toBool(gtk_color_selection_is_adjusting(cast[ptr ColorSelection00](self.impl)))

proc gtk_color_selection_set_current_alpha*(self: ptr ColorSelection00; alpha: uint16) {.
    importc: "gtk_color_selection_set_current_alpha", libprag.}

proc setCurrentAlpha*(self: ColorSelection; alpha: uint16) =
  gtk_color_selection_set_current_alpha(cast[ptr ColorSelection00](self.impl), alpha)

proc `currentAlpha=`*(self: ColorSelection; alpha: uint16) =
  gtk_color_selection_set_current_alpha(cast[ptr ColorSelection00](self.impl), alpha)

proc gtk_color_selection_set_current_color*(self: ptr ColorSelection00; color: ptr gdk.Color00) {.
    importc: "gtk_color_selection_set_current_color", libprag.}

proc setCurrentColor*(self: ColorSelection; color: gdk.Color) =
  gtk_color_selection_set_current_color(cast[ptr ColorSelection00](self.impl), cast[ptr gdk.Color00](color.impl))

proc `currentColor=`*(self: ColorSelection; color: gdk.Color) =
  gtk_color_selection_set_current_color(cast[ptr ColorSelection00](self.impl), cast[ptr gdk.Color00](color.impl))

proc gtk_color_selection_set_current_rgba*(self: ptr ColorSelection00; rgba: ptr gdk.RGBA00) {.
    importc: "gtk_color_selection_set_current_rgba", libprag.}

proc setCurrentRgba*(self: ColorSelection; rgba: gdk.RGBA) =
  gtk_color_selection_set_current_rgba(cast[ptr ColorSelection00](self.impl), cast[ptr gdk.RGBA00](rgba.impl))

proc `currentRgba=`*(self: ColorSelection; rgba: gdk.RGBA) =
  gtk_color_selection_set_current_rgba(cast[ptr ColorSelection00](self.impl), cast[ptr gdk.RGBA00](rgba.impl))

proc gtk_color_selection_set_has_opacity_control*(self: ptr ColorSelection00; hasOpacity: gboolean) {.
    importc: "gtk_color_selection_set_has_opacity_control", libprag.}

proc setHasOpacityControl*(self: ColorSelection; hasOpacity: bool) =
  gtk_color_selection_set_has_opacity_control(cast[ptr ColorSelection00](self.impl), gboolean(hasOpacity))

proc `hasOpacityControl=`*(self: ColorSelection; hasOpacity: bool) =
  gtk_color_selection_set_has_opacity_control(cast[ptr ColorSelection00](self.impl), gboolean(hasOpacity))

proc gtk_color_selection_set_has_palette*(self: ptr ColorSelection00; hasPalette: gboolean) {.
    importc: "gtk_color_selection_set_has_palette", libprag.}

proc setHasPalette*(self: ColorSelection; hasPalette: bool) =
  gtk_color_selection_set_has_palette(cast[ptr ColorSelection00](self.impl), gboolean(hasPalette))

proc `hasPalette=`*(self: ColorSelection; hasPalette: bool) =
  gtk_color_selection_set_has_palette(cast[ptr ColorSelection00](self.impl), gboolean(hasPalette))

proc gtk_color_selection_set_previous_alpha*(self: ptr ColorSelection00; alpha: uint16) {.
    importc: "gtk_color_selection_set_previous_alpha", libprag.}

proc setPreviousAlpha*(self: ColorSelection; alpha: uint16) =
  gtk_color_selection_set_previous_alpha(cast[ptr ColorSelection00](self.impl), alpha)

proc `previousAlpha=`*(self: ColorSelection; alpha: uint16) =
  gtk_color_selection_set_previous_alpha(cast[ptr ColorSelection00](self.impl), alpha)

proc gtk_color_selection_set_previous_color*(self: ptr ColorSelection00; color: ptr gdk.Color00) {.
    importc: "gtk_color_selection_set_previous_color", libprag.}

proc setPreviousColor*(self: ColorSelection; color: gdk.Color) =
  gtk_color_selection_set_previous_color(cast[ptr ColorSelection00](self.impl), cast[ptr gdk.Color00](color.impl))

proc `previousColor=`*(self: ColorSelection; color: gdk.Color) =
  gtk_color_selection_set_previous_color(cast[ptr ColorSelection00](self.impl), cast[ptr gdk.Color00](color.impl))

proc gtk_color_selection_set_previous_rgba*(self: ptr ColorSelection00; rgba: ptr gdk.RGBA00) {.
    importc: "gtk_color_selection_set_previous_rgba", libprag.}

proc setPreviousRgba*(self: ColorSelection; rgba: gdk.RGBA) =
  gtk_color_selection_set_previous_rgba(cast[ptr ColorSelection00](self.impl), cast[ptr gdk.RGBA00](rgba.impl))

proc `previousRgba=`*(self: ColorSelection; rgba: gdk.RGBA) =
  gtk_color_selection_set_previous_rgba(cast[ptr ColorSelection00](self.impl), cast[ptr gdk.RGBA00](rgba.impl))

type
  ColorSelectionChangePaletteFunc* = proc (colors: gdk.Color00Array; nColors: int32) {.cdecl.}

type
  ColorSelectionChangePaletteWithScreenFunc* = proc (screen: ptr gdk.Screen00; colors: gdk.Color00Array; 
    nColors: int32) {.cdecl.}

type
  ColorSelectionClass00* {.pure.} = object
    parentClass*: BoxClass00
    colorChanged*: proc(colorSelection: ptr ColorSelection00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ColorSelectionClass* = ref object
    impl*: ptr ColorSelectionClass00

type
  ColorSelectionDialogPrivate00* {.pure.} = object
  ColorSelectionDialogPrivate* = ref object
    impl*: ptr ColorSelectionDialogPrivate00

type
  ColorSelectionDialog* = ref object of Dialog
  ColorSelectionDialog00* = object of Dialog00
    priv6: ptr ColorSelectionDialogPrivate00

proc gtk_color_selection_dialog_new*(title: cstring): ptr ColorSelectionDialog00 {.
    importc: "gtk_color_selection_dialog_new", libprag.}

proc newColorSelectionDialog*(title: string): ColorSelectionDialog =
  new(result, finalizeGObject)
  result.impl = gtk_color_selection_dialog_new(cstring(title))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorSelectionDialog*[T](result: var T; title: string) =
  assert(result is ColorSelectionDialog)
  new(result, finalizeGObject)
  result.impl = gtk_color_selection_dialog_new(cstring(title))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_selection_dialog_get_color_selection*(self: ptr ColorSelectionDialog00): ptr Widget00 {.
    importc: "gtk_color_selection_dialog_get_color_selection", libprag.}

proc getColorSelection*(self: ColorSelectionDialog): Widget =
  let gobj = gtk_color_selection_dialog_get_color_selection(cast[ptr ColorSelectionDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc colorSelection*(self: ColorSelectionDialog): Widget =
  let gobj = gtk_color_selection_dialog_get_color_selection(cast[ptr ColorSelectionDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ColorSelectionDialogClass00* {.pure.} = object
    parentClass*: DialogClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ColorSelectionDialogClass* = ref object
    impl*: ptr ColorSelectionDialogClass00

type
  ComboBoxAccessiblePrivate00* {.pure.} = object
  ComboBoxAccessiblePrivate* = ref object
    impl*: ptr ComboBoxAccessiblePrivate00

type
  ComboBoxAccessible* = ref object of ContainerAccessible
  ComboBoxAccessible00* = object of ContainerAccessible00
    priv4: ptr ComboBoxAccessiblePrivate00

type
  ComboBoxAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  ComboBoxAccessibleClass* = ref object
    impl*: ptr ComboBoxAccessibleClass00

type
  ComboBoxTextPrivate00* {.pure.} = object
  ComboBoxTextPrivate* = ref object
    impl*: ptr ComboBoxTextPrivate00

type
  ComboBoxText* = ref object of ComboBox
  ComboBoxText00* = object of ComboBox00
    priv5: ptr ComboBoxTextPrivate00

proc gtk_combo_box_text_new*(): ptr ComboBoxText00 {.
    importc: "gtk_combo_box_text_new", libprag.}

proc newComboBoxText*(): ComboBoxText =
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_text_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxText*[T](result: var T) =
  assert(result is ComboBoxText)
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_text_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_text_new_with_entry*(): ptr ComboBoxText00 {.
    importc: "gtk_combo_box_text_new_with_entry", libprag.}

proc newComboBoxTextWithEntry*(): ComboBoxText =
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_text_new_with_entry()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxTextWithEntry*[T](result: var T) =
  assert(result is ComboBoxText)
  new(result, finalizeGObject)
  result.impl = gtk_combo_box_text_new_with_entry()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_text_append*(self: ptr ComboBoxText00; id: cstring; text: cstring) {.
    importc: "gtk_combo_box_text_append", libprag.}

proc append*(self: ComboBoxText; id: string; text: string) =
  gtk_combo_box_text_append(cast[ptr ComboBoxText00](self.impl), cstring(id), cstring(text))

proc gtk_combo_box_text_append_text*(self: ptr ComboBoxText00; text: cstring) {.
    importc: "gtk_combo_box_text_append_text", libprag.}

proc appendText*(self: ComboBoxText; text: string) =
  gtk_combo_box_text_append_text(cast[ptr ComboBoxText00](self.impl), cstring(text))

proc gtk_combo_box_text_get_active_text*(self: ptr ComboBoxText00): cstring {.
    importc: "gtk_combo_box_text_get_active_text", libprag.}

proc getActiveText*(self: ComboBoxText): string =
  let resul0 = gtk_combo_box_text_get_active_text(cast[ptr ComboBoxText00](self.impl))
  result = $resul0
  cogfree(resul0)

proc activeText*(self: ComboBoxText): string =
  let resul0 = gtk_combo_box_text_get_active_text(cast[ptr ComboBoxText00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_combo_box_text_insert*(self: ptr ComboBoxText00; position: int32; id: cstring; 
    text: cstring) {.
    importc: "gtk_combo_box_text_insert", libprag.}

proc insert*(self: ComboBoxText; position: int; id: string; text: string) =
  gtk_combo_box_text_insert(cast[ptr ComboBoxText00](self.impl), int32(position), cstring(id), cstring(text))

proc gtk_combo_box_text_insert_text*(self: ptr ComboBoxText00; position: int32; text: cstring) {.
    importc: "gtk_combo_box_text_insert_text", libprag.}

proc insertText*(self: ComboBoxText; position: int; text: string) =
  gtk_combo_box_text_insert_text(cast[ptr ComboBoxText00](self.impl), int32(position), cstring(text))

proc gtk_combo_box_text_prepend*(self: ptr ComboBoxText00; id: cstring; text: cstring) {.
    importc: "gtk_combo_box_text_prepend", libprag.}

proc prepend*(self: ComboBoxText; id: string; text: string) =
  gtk_combo_box_text_prepend(cast[ptr ComboBoxText00](self.impl), cstring(id), cstring(text))

proc gtk_combo_box_text_prepend_text*(self: ptr ComboBoxText00; text: cstring) {.
    importc: "gtk_combo_box_text_prepend_text", libprag.}

proc prependText*(self: ComboBoxText; text: string) =
  gtk_combo_box_text_prepend_text(cast[ptr ComboBoxText00](self.impl), cstring(text))

proc gtk_combo_box_text_remove*(self: ptr ComboBoxText00; position: int32) {.
    importc: "gtk_combo_box_text_remove", libprag.}

proc remove*(self: ComboBoxText; position: int) =
  gtk_combo_box_text_remove(cast[ptr ComboBoxText00](self.impl), int32(position))

proc gtk_combo_box_text_remove_all*(self: ptr ComboBoxText00) {.
    importc: "gtk_combo_box_text_remove_all", libprag.}

proc removeAll*(self: ComboBoxText) =
  gtk_combo_box_text_remove_all(cast[ptr ComboBoxText00](self.impl))

type
  ComboBoxTextClass00* {.pure.} = object
    parentClass*: ComboBoxClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ComboBoxTextClass* = ref object
    impl*: ptr ComboBoxTextClass00

type
  ContainerCellAccessiblePrivate00* {.pure.} = object
  ContainerCellAccessiblePrivate* = ref object
    impl*: ptr ContainerCellAccessiblePrivate00

type
  ContainerCellAccessible* = ref object of CellAccessible
  ContainerCellAccessible00* = object of CellAccessible00
    priv3: ptr ContainerCellAccessiblePrivate00

proc gtk_container_cell_accessible_new*(): ptr ContainerCellAccessible00 {.
    importc: "gtk_container_cell_accessible_new", libprag.}

proc newContainerCellAccessible*(): ContainerCellAccessible =
  new(result, finalizeGObject)
  result.impl = gtk_container_cell_accessible_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initContainerCellAccessible*[T](result: var T) =
  assert(result is ContainerCellAccessible)
  new(result, finalizeGObject)
  result.impl = gtk_container_cell_accessible_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_container_cell_accessible_add_child*(self: ptr ContainerCellAccessible00; child: ptr CellAccessible00) {.
    importc: "gtk_container_cell_accessible_add_child", libprag.}

proc addChild*(self: ContainerCellAccessible; child: CellAccessible) =
  gtk_container_cell_accessible_add_child(cast[ptr ContainerCellAccessible00](self.impl), cast[ptr CellAccessible00](child.impl))

proc gtk_container_cell_accessible_get_children*(self: ptr ContainerCellAccessible00): ptr pointer {.
    importc: "gtk_container_cell_accessible_get_children", libprag.}

proc getChildren*(self: ContainerCellAccessible): ptr pointer =
  gtk_container_cell_accessible_get_children(cast[ptr ContainerCellAccessible00](self.impl))

proc children*(self: ContainerCellAccessible): ptr pointer =
  gtk_container_cell_accessible_get_children(cast[ptr ContainerCellAccessible00](self.impl))

proc gtk_container_cell_accessible_remove_child*(self: ptr ContainerCellAccessible00; child: ptr CellAccessible00) {.
    importc: "gtk_container_cell_accessible_remove_child", libprag.}

proc removeChild*(self: ContainerCellAccessible; child: CellAccessible) =
  gtk_container_cell_accessible_remove_child(cast[ptr ContainerCellAccessible00](self.impl), cast[ptr CellAccessible00](child.impl))

type
  ContainerCellAccessibleClass00* {.pure.} = object
    parentClass*: CellAccessibleClass00
  ContainerCellAccessibleClass* = ref object
    impl*: ptr ContainerCellAccessibleClass00

type
  CornerType* {.size: sizeof(cint), pure.} = enum
    topLeft = 0
    bottomLeft = 1
    topRight = 2
    bottomRight = 3

type
  CssProviderPrivate00* {.pure.} = object
  CssProviderPrivate* = ref object
    impl*: ptr CssProviderPrivate00

type
  CssProvider* = ref object of gobject.Object
  CssProvider00* = object of gobject.Object00
    priv1: ptr CssProviderPrivate00

proc scParsingError*(self: CssProvider;  p: proc (self: ptr gobject.Object00; section: CssSection00; error: ptr Error00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "parsing-error", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_css_provider_new*(): ptr CssProvider00 {.
    importc: "gtk_css_provider_new", libprag.}

proc newCssProvider*(): CssProvider =
  new(result, finalizeGObject)
  result.impl = gtk_css_provider_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCssProvider*[T](result: var T) =
  assert(result is CssProvider)
  new(result, finalizeGObject)
  result.impl = gtk_css_provider_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_css_provider_get_default*(): ptr CssProvider00 {.
    importc: "gtk_css_provider_get_default", libprag.}

proc getDefault*(): CssProvider =
  let gobj = gtk_css_provider_get_default()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CssProvider](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc default*(): CssProvider =
  let gobj = gtk_css_provider_get_default()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CssProvider](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_css_provider_get_named*(name: cstring; variant: cstring): ptr CssProvider00 {.
    importc: "gtk_css_provider_get_named", libprag.}

proc getNamed*(name: string; variant: string): CssProvider =
  let gobj = gtk_css_provider_get_named(cstring(name), cstring(variant))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CssProvider](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc named*(name: string; variant: string): CssProvider =
  let gobj = gtk_css_provider_get_named(cstring(name), cstring(variant))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[CssProvider](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_css_provider_load_from_data*(self: ptr CssProvider00; data: uint8Array; length: int64): gboolean {.
    importc: "gtk_css_provider_load_from_data", libprag.}

proc loadFromData*(self: CssProvider; data: uint8Array; length: int64): bool =
  toBool(gtk_css_provider_load_from_data(cast[ptr CssProvider00](self.impl), data, length))

proc gtk_css_provider_load_from_file*(self: ptr CssProvider00; file: ptr gio.File00): gboolean {.
    importc: "gtk_css_provider_load_from_file", libprag.}

proc loadFromFile*(self: CssProvider; file: gio.File): bool =
  toBool(gtk_css_provider_load_from_file(cast[ptr CssProvider00](self.impl), cast[ptr gio.File00](file.impl)))

proc gtk_css_provider_load_from_path*(self: ptr CssProvider00; path: cstring): gboolean {.
    importc: "gtk_css_provider_load_from_path", libprag.}

proc loadFromPath*(self: CssProvider; path: string): bool =
  toBool(gtk_css_provider_load_from_path(cast[ptr CssProvider00](self.impl), cstring(path)))

proc gtk_css_provider_load_from_resource*(self: ptr CssProvider00; resourcePath: cstring) {.
    importc: "gtk_css_provider_load_from_resource", libprag.}

proc loadFromResource*(self: CssProvider; resourcePath: string) =
  gtk_css_provider_load_from_resource(cast[ptr CssProvider00](self.impl), cstring(resourcePath))

proc gtk_css_provider_to_string*(self: ptr CssProvider00): cstring {.
    importc: "gtk_css_provider_to_string", libprag.}

proc toString*(self: CssProvider): string =
  let resul0 = gtk_css_provider_to_string(cast[ptr CssProvider00](self.impl))
  result = $resul0
  cogfree(resul0)

type
  CssProviderClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    parsingError*: proc(provider: ptr CssProvider00; section: ptr CssSection00; 
    error: ptr Error00) {.cdecl.}
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  CssProviderClass* = ref object
    impl*: ptr CssProviderClass00

type
  CssProviderError* {.size: sizeof(cint), pure.} = enum
    failed = 0
    syntax = 1
    `import` = 2
    name = 3
    deprecated = 4
    unknownValue = 5

proc gtk_css_provider_error_quark*(): uint32 {.
    importc: "gtk_css_provider_error_quark", libprag.}

type
  DebugFlag* {.size: sizeof(cint), pure.} = enum
    misc = 1
    plugsocket = 2
    text = 4
    tree = 8
    updates = 16
    keybindings = 32
    multihead = 64
    modules = 128
    geometry = 256
    icontheme = 512
    printing = 1024
    builder = 2048
    sizeRequest = 4096
    noCssCache = 8192
    baselines = 16384
    pixelCache = 32768
    noPixelCache = 65536
    interactive = 131072
    touchscreen = 262144
    actions = 524288
    resize = 1048576
    layout = 2097152

type
  DeleteType* {.size: sizeof(cint), pure.} = enum
    chars = 0
    wordEnds = 1
    words = 2
    displayLines = 3
    displayLineEnds = 4
    paragraphEnds = 5
    paragraphs = 6
    whitespace = 7

type
  DrawingArea* = ref object of Widget
  DrawingArea00* = object of Widget00
    dummy*: pointer

proc gtk_drawing_area_new*(): ptr DrawingArea00 {.
    importc: "gtk_drawing_area_new", libprag.}

proc newDrawingArea*(): DrawingArea =
  new(result, finalizeGObject)
  result.impl = gtk_drawing_area_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDrawingArea*[T](result: var T) =
  assert(result is DrawingArea)
  new(result, finalizeGObject)
  result.impl = gtk_drawing_area_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  DrawingAreaClass00* {.pure.} = object
    parentClass*: WidgetClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  DrawingAreaClass* = ref object
    impl*: ptr DrawingAreaClass00

type
  Editable00* {.pure.} = object
  Editable* = ref object
    impl*: ptr Editable00

proc gtk_editable_copy_clipboard*(self: ptr Editable00) {.
    importc: "gtk_editable_copy_clipboard", libprag.}

proc copyClipboard*(self: Editable) =
  gtk_editable_copy_clipboard(cast[ptr Editable00](self.impl))

proc gtk_editable_cut_clipboard*(self: ptr Editable00) {.
    importc: "gtk_editable_cut_clipboard", libprag.}

proc cutClipboard*(self: Editable) =
  gtk_editable_cut_clipboard(cast[ptr Editable00](self.impl))

proc gtk_editable_delete_selection*(self: ptr Editable00) {.
    importc: "gtk_editable_delete_selection", libprag.}

proc deleteSelection*(self: Editable) =
  gtk_editable_delete_selection(cast[ptr Editable00](self.impl))

proc gtk_editable_delete_text*(self: ptr Editable00; startPos: int32; endPos: int32) {.
    importc: "gtk_editable_delete_text", libprag.}

proc deleteText*(self: Editable; startPos: int; endPos: int) =
  gtk_editable_delete_text(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))

proc gtk_editable_get_chars*(self: ptr Editable00; startPos: int32; endPos: int32): cstring {.
    importc: "gtk_editable_get_chars", libprag.}

proc getChars*(self: Editable; startPos: int; endPos: int): string =
  let resul0 = gtk_editable_get_chars(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))
  result = $resul0
  cogfree(resul0)

proc chars*(self: Editable; startPos: int; endPos: int): string =
  let resul0 = gtk_editable_get_chars(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))
  result = $resul0
  cogfree(resul0)

proc gtk_editable_get_editable*(self: ptr Editable00): gboolean {.
    importc: "gtk_editable_get_editable", libprag.}

proc getEditable*(self: Editable): bool =
  toBool(gtk_editable_get_editable(cast[ptr Editable00](self.impl)))

proc editable*(self: Editable): bool =
  toBool(gtk_editable_get_editable(cast[ptr Editable00](self.impl)))

proc gtk_editable_get_position*(self: ptr Editable00): int32 {.
    importc: "gtk_editable_get_position", libprag.}

proc getPosition*(self: Editable): int =
  int(gtk_editable_get_position(cast[ptr Editable00](self.impl)))

proc position*(self: Editable): int =
  int(gtk_editable_get_position(cast[ptr Editable00](self.impl)))

proc gtk_editable_get_selection_bounds*(self: ptr Editable00; startPos: var int32; endPos: var int32): gboolean {.
    importc: "gtk_editable_get_selection_bounds", libprag.}

proc getSelectionBounds*(self: Editable; startPos: var int; endPos: var int): bool =
  var startPos_00 = int32(startPos)
  var endPos_00 = int32(endPos)
  result = toBool(gtk_editable_get_selection_bounds(cast[ptr Editable00](self.impl), startPos_00, endPos_00))
  startPos = int(startPos_00)
  endPos = int(endPos_00)

proc selectionBounds*(self: Editable; startPos: var int; endPos: var int): bool =
  var startPos_00 = int32(startPos)
  var endPos_00 = int32(endPos)
  result = toBool(gtk_editable_get_selection_bounds(cast[ptr Editable00](self.impl), startPos_00, endPos_00))
  startPos = int(startPos_00)
  endPos = int(endPos_00)

proc gtk_editable_insert_text*(self: ptr Editable00; newText: cstring; newTextLength: int32; 
    position: int32) {.
    importc: "gtk_editable_insert_text", libprag.}

proc insertText*(self: Editable; newText: string; newTextLength: int; 
    position: int) =
  gtk_editable_insert_text(cast[ptr Editable00](self.impl), cstring(newText), int32(newTextLength), int32(position))

proc gtk_editable_paste_clipboard*(self: ptr Editable00) {.
    importc: "gtk_editable_paste_clipboard", libprag.}

proc pasteClipboard*(self: Editable) =
  gtk_editable_paste_clipboard(cast[ptr Editable00](self.impl))

proc gtk_editable_select_region*(self: ptr Editable00; startPos: int32; endPos: int32) {.
    importc: "gtk_editable_select_region", libprag.}

proc selectRegion*(self: Editable; startPos: int; endPos: int) =
  gtk_editable_select_region(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))

proc gtk_editable_set_editable*(self: ptr Editable00; isEditable: gboolean) {.
    importc: "gtk_editable_set_editable", libprag.}

proc setEditable*(self: Editable; isEditable: bool) =
  gtk_editable_set_editable(cast[ptr Editable00](self.impl), gboolean(isEditable))

proc `editable=`*(self: Editable; isEditable: bool) =
  gtk_editable_set_editable(cast[ptr Editable00](self.impl), gboolean(isEditable))

proc gtk_editable_set_position*(self: ptr Editable00; position: int32) {.
    importc: "gtk_editable_set_position", libprag.}

proc setPosition*(self: Editable; position: int) =
  gtk_editable_set_position(cast[ptr Editable00](self.impl), int32(position))

proc `position=`*(self: Editable; position: int) =
  gtk_editable_set_position(cast[ptr Editable00](self.impl), int32(position))

type
  EditableInterface00* {.pure.} = object
    baseIface*: gobject.TypeInterface00
    insertText*: proc(editable: ptr Editable00; newText: cstring; newTextLength: int32; 
    position: int32) {.cdecl.}
    deleteText*: proc(editable: ptr Editable00; startPos: int32; endPos: int32) {.cdecl.}
    changed*: proc(editable: ptr Editable00) {.cdecl.}
    doInsertText*: proc(editable: ptr Editable00; newText: cstring; newTextLength: int32; 
    position: int32) {.cdecl.}
    doDeleteText*: proc(editable: ptr Editable00; startPos: int32; endPos: int32) {.cdecl.}
    getChars*: proc(editable: ptr Editable00; startPos: int32; endPos: int32): cstring {.cdecl.}
    setSelectionBounds*: proc(editable: ptr Editable00; startPos: int32; endPos: int32) {.cdecl.}
    getSelectionBounds*: proc(editable: ptr Editable00; startPos: var int32; endPos: var int32): gboolean {.cdecl.}
    setPosition*: proc(editable: ptr Editable00; position: int32) {.cdecl.}
    getPosition*: proc(editable: ptr Editable00): int32 {.cdecl.}
  EditableInterface* = ref object
    impl*: ptr EditableInterface00

type
  EntryPrivate00* {.pure.} = object
  EntryPrivate* = ref object
    impl*: ptr EntryPrivate00

type
  EntryIconPosition* {.size: sizeof(cint), pure.} = enum
    primary = 0
    secondary = 1

type
  Entry* = ref object of Widget
  Entry00* = object of Widget00
    priv2: ptr EntryPrivate00

proc scActivate*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scBackspace*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "backspace", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCopyClipboard*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "copy-clipboard", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCutClipboard*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cut-clipboard", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDeleteFromCursor*(self: Entry;  p: proc (self: ptr gobject.Object00; `type`: DeleteType; count: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "delete-from-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scIconPress*(self: Entry;  p: proc (self: ptr gobject.Object00; iconPos: EntryIconPosition; event: gdk.EventButton00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "icon-press", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scIconRelease*(self: Entry;  p: proc (self: ptr gobject.Object00; iconPos: EntryIconPosition; event: gdk.EventButton00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "icon-release", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scInsertAtCursor*(self: Entry;  p: proc (self: ptr gobject.Object00; string: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "insert-at-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveCursor*(self: Entry;  p: proc (self: ptr gobject.Object00; step: MovementStep; count: int32; extendSelection: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPasteClipboard*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "paste-clipboard", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopulatePopup*(self: Entry;  p: proc (self: ptr gobject.Object00; widget: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPreeditChanged*(self: Entry;  p: proc (self: ptr gobject.Object00; preedit: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "preedit-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleOverwrite*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-overwrite", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_entry_new*(): ptr Entry00 {.
    importc: "gtk_entry_new", libprag.}

proc newEntry*(): Entry =
  new(result, finalizeGObject)
  result.impl = gtk_entry_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntry*[T](result: var T) =
  assert(result is Entry)
  new(result, finalizeGObject)
  result.impl = gtk_entry_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_activates_default*(self: ptr Entry00): gboolean {.
    importc: "gtk_entry_get_activates_default", libprag.}

proc getActivatesDefault*(self: Entry): bool =
  toBool(gtk_entry_get_activates_default(cast[ptr Entry00](self.impl)))

proc activatesDefault*(self: Entry): bool =
  toBool(gtk_entry_get_activates_default(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_alignment*(self: ptr Entry00): cfloat {.
    importc: "gtk_entry_get_alignment", libprag.}

proc getAlignment*(self: Entry): cfloat =
  gtk_entry_get_alignment(cast[ptr Entry00](self.impl))

proc alignment*(self: Entry): cfloat =
  gtk_entry_get_alignment(cast[ptr Entry00](self.impl))

proc gtk_entry_get_attributes*(self: ptr Entry00): ptr pango.AttrList00 {.
    importc: "gtk_entry_get_attributes", libprag.}

proc getAttributes*(self: Entry): pango.AttrList =
  new(result)
  result.impl = gtk_entry_get_attributes(cast[ptr Entry00](self.impl))

proc attributes*(self: Entry): pango.AttrList =
  new(result)
  result.impl = gtk_entry_get_attributes(cast[ptr Entry00](self.impl))

proc gtk_entry_get_current_icon_drag_source*(self: ptr Entry00): int32 {.
    importc: "gtk_entry_get_current_icon_drag_source", libprag.}

proc getCurrentIconDragSource*(self: Entry): int =
  int(gtk_entry_get_current_icon_drag_source(cast[ptr Entry00](self.impl)))

proc currentIconDragSource*(self: Entry): int =
  int(gtk_entry_get_current_icon_drag_source(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_cursor_hadjustment*(self: ptr Entry00): ptr Adjustment00 {.
    importc: "gtk_entry_get_cursor_hadjustment", libprag.}

proc getCursorHadjustment*(self: Entry): Adjustment =
  let gobj = gtk_entry_get_cursor_hadjustment(cast[ptr Entry00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc cursorHadjustment*(self: Entry): Adjustment =
  let gobj = gtk_entry_get_cursor_hadjustment(cast[ptr Entry00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_has_frame*(self: ptr Entry00): gboolean {.
    importc: "gtk_entry_get_has_frame", libprag.}

proc getHasFrame*(self: Entry): bool =
  toBool(gtk_entry_get_has_frame(cast[ptr Entry00](self.impl)))

proc hasFrame*(self: Entry): bool =
  toBool(gtk_entry_get_has_frame(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_icon_activatable*(self: ptr Entry00; iconPos: EntryIconPosition): gboolean {.
    importc: "gtk_entry_get_icon_activatable", libprag.}

proc getIconActivatable*(self: Entry; iconPos: EntryIconPosition): bool =
  toBool(gtk_entry_get_icon_activatable(cast[ptr Entry00](self.impl), iconPos))

proc iconActivatable*(self: Entry; iconPos: EntryIconPosition): bool =
  toBool(gtk_entry_get_icon_activatable(cast[ptr Entry00](self.impl), iconPos))

proc gtk_entry_get_icon_area*(self: ptr Entry00; iconPos: EntryIconPosition; iconArea: var gdk.Rectangle00) {.
    importc: "gtk_entry_get_icon_area", libprag.}

proc getIconArea*(self: ptr Entry00; iconPos: EntryIconPosition; iconArea: var gdk.Rectangle00) {.
    importc: "gtk_entry_get_icon_area", libprag.}

proc iconArea*(self: ptr Entry00; iconPos: EntryIconPosition; iconArea: var gdk.Rectangle00) {.
    importc: "gtk_entry_get_icon_area", libprag.}

proc gtk_entry_get_icon_at_pos*(self: ptr Entry00; x: int32; y: int32): int32 {.
    importc: "gtk_entry_get_icon_at_pos", libprag.}

proc getIconAtPos*(self: Entry; x: int; y: int): int =
  int(gtk_entry_get_icon_at_pos(cast[ptr Entry00](self.impl), int32(x), int32(y)))

proc iconAtPos*(self: Entry; x: int; y: int): int =
  int(gtk_entry_get_icon_at_pos(cast[ptr Entry00](self.impl), int32(x), int32(y)))

proc gtk_entry_get_icon_gicon*(self: ptr Entry00; iconPos: EntryIconPosition): ptr gio.Icon00 {.
    importc: "gtk_entry_get_icon_gicon", libprag.}

proc getIconGicon*(self: Entry; iconPos: EntryIconPosition): gio.Icon =
  new(result)
  result.impl = gtk_entry_get_icon_gicon(cast[ptr Entry00](self.impl), iconPos)

proc iconGicon*(self: Entry; iconPos: EntryIconPosition): gio.Icon =
  new(result)
  result.impl = gtk_entry_get_icon_gicon(cast[ptr Entry00](self.impl), iconPos)

proc gtk_entry_get_icon_name*(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc: "gtk_entry_get_icon_name", libprag.}

proc getIconName*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_name(cast[ptr Entry00](self.impl), iconPos)
  result = $resul0

proc iconName*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_name(cast[ptr Entry00](self.impl), iconPos)
  result = $resul0

proc gtk_entry_get_icon_pixbuf*(self: ptr Entry00; iconPos: EntryIconPosition): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_entry_get_icon_pixbuf", libprag.}

proc getIconPixbuf*(self: Entry; iconPos: EntryIconPosition): gdkpixbuf.Pixbuf =
  let gobj = gtk_entry_get_icon_pixbuf(cast[ptr Entry00](self.impl), iconPos)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc iconPixbuf*(self: Entry; iconPos: EntryIconPosition): gdkpixbuf.Pixbuf =
  let gobj = gtk_entry_get_icon_pixbuf(cast[ptr Entry00](self.impl), iconPos)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_icon_sensitive*(self: ptr Entry00; iconPos: EntryIconPosition): gboolean {.
    importc: "gtk_entry_get_icon_sensitive", libprag.}

proc getIconSensitive*(self: Entry; iconPos: EntryIconPosition): bool =
  toBool(gtk_entry_get_icon_sensitive(cast[ptr Entry00](self.impl), iconPos))

proc iconSensitive*(self: Entry; iconPos: EntryIconPosition): bool =
  toBool(gtk_entry_get_icon_sensitive(cast[ptr Entry00](self.impl), iconPos))

proc gtk_entry_get_icon_stock*(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc: "gtk_entry_get_icon_stock", libprag.}

proc getIconStock*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_stock(cast[ptr Entry00](self.impl), iconPos)
  result = $resul0

proc iconStock*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_stock(cast[ptr Entry00](self.impl), iconPos)
  result = $resul0

proc gtk_entry_get_icon_tooltip_markup*(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc: "gtk_entry_get_icon_tooltip_markup", libprag.}

proc getIconTooltipMarkup*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_tooltip_markup(cast[ptr Entry00](self.impl), iconPos)
  result = $resul0
  cogfree(resul0)

proc iconTooltipMarkup*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_tooltip_markup(cast[ptr Entry00](self.impl), iconPos)
  result = $resul0
  cogfree(resul0)

proc gtk_entry_get_icon_tooltip_text*(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc: "gtk_entry_get_icon_tooltip_text", libprag.}

proc getIconTooltipText*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_tooltip_text(cast[ptr Entry00](self.impl), iconPos)
  result = $resul0
  cogfree(resul0)

proc iconTooltipText*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_tooltip_text(cast[ptr Entry00](self.impl), iconPos)
  result = $resul0
  cogfree(resul0)

proc gtk_entry_get_inner_border*(self: ptr Entry00): ptr Border00 {.
    importc: "gtk_entry_get_inner_border", libprag.}

proc getInnerBorder*(self: Entry): Border =
  new(result)
  result.impl = gtk_entry_get_inner_border(cast[ptr Entry00](self.impl))

proc innerBorder*(self: Entry): Border =
  new(result)
  result.impl = gtk_entry_get_inner_border(cast[ptr Entry00](self.impl))

proc gtk_entry_get_invisible_char*(self: ptr Entry00): gunichar {.
    importc: "gtk_entry_get_invisible_char", libprag.}

proc getInvisibleChar*(self: Entry): gunichar =
  gtk_entry_get_invisible_char(cast[ptr Entry00](self.impl))

proc invisibleChar*(self: Entry): gunichar =
  gtk_entry_get_invisible_char(cast[ptr Entry00](self.impl))

proc gtk_entry_get_layout*(self: ptr Entry00): ptr pango.Layout00 {.
    importc: "gtk_entry_get_layout", libprag.}

proc getLayout*(self: Entry): pango.Layout =
  let gobj = gtk_entry_get_layout(cast[ptr Entry00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Layout](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layout*(self: Entry): pango.Layout =
  let gobj = gtk_entry_get_layout(cast[ptr Entry00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Layout](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_layout_offsets*(self: ptr Entry00; x: var int32; y: var int32) {.
    importc: "gtk_entry_get_layout_offsets", libprag.}

proc getLayoutOffsets*(self: Entry; x: var int; y: var int) =
  var y_00 = int32(y)
  var x_00 = int32(x)
  gtk_entry_get_layout_offsets(cast[ptr Entry00](self.impl), x_00, y_00)
  y = int(y_00)
  x = int(x_00)

proc layoutOffsets*(self: Entry; x: var int; y: var int) =
  var y_00 = int32(y)
  var x_00 = int32(x)
  gtk_entry_get_layout_offsets(cast[ptr Entry00](self.impl), x_00, y_00)
  y = int(y_00)
  x = int(x_00)

proc gtk_entry_get_max_length*(self: ptr Entry00): int32 {.
    importc: "gtk_entry_get_max_length", libprag.}

proc getMaxLength*(self: Entry): int =
  int(gtk_entry_get_max_length(cast[ptr Entry00](self.impl)))

proc maxLength*(self: Entry): int =
  int(gtk_entry_get_max_length(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_max_width_chars*(self: ptr Entry00): int32 {.
    importc: "gtk_entry_get_max_width_chars", libprag.}

proc getMaxWidthChars*(self: Entry): int =
  int(gtk_entry_get_max_width_chars(cast[ptr Entry00](self.impl)))

proc maxWidthChars*(self: Entry): int =
  int(gtk_entry_get_max_width_chars(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_overwrite_mode*(self: ptr Entry00): gboolean {.
    importc: "gtk_entry_get_overwrite_mode", libprag.}

proc getOverwriteMode*(self: Entry): bool =
  toBool(gtk_entry_get_overwrite_mode(cast[ptr Entry00](self.impl)))

proc overwriteMode*(self: Entry): bool =
  toBool(gtk_entry_get_overwrite_mode(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_placeholder_text*(self: ptr Entry00): cstring {.
    importc: "gtk_entry_get_placeholder_text", libprag.}

proc getPlaceholderText*(self: Entry): string =
  let resul0 = gtk_entry_get_placeholder_text(cast[ptr Entry00](self.impl))
  result = $resul0

proc placeholderText*(self: Entry): string =
  let resul0 = gtk_entry_get_placeholder_text(cast[ptr Entry00](self.impl))
  result = $resul0

proc gtk_entry_get_progress_fraction*(self: ptr Entry00): cdouble {.
    importc: "gtk_entry_get_progress_fraction", libprag.}

proc getProgressFraction*(self: Entry): cdouble =
  gtk_entry_get_progress_fraction(cast[ptr Entry00](self.impl))

proc progressFraction*(self: Entry): cdouble =
  gtk_entry_get_progress_fraction(cast[ptr Entry00](self.impl))

proc gtk_entry_get_progress_pulse_step*(self: ptr Entry00): cdouble {.
    importc: "gtk_entry_get_progress_pulse_step", libprag.}

proc getProgressPulseStep*(self: Entry): cdouble =
  gtk_entry_get_progress_pulse_step(cast[ptr Entry00](self.impl))

proc progressPulseStep*(self: Entry): cdouble =
  gtk_entry_get_progress_pulse_step(cast[ptr Entry00](self.impl))

proc gtk_entry_get_tabs*(self: ptr Entry00): ptr pango.TabArray00 {.
    importc: "gtk_entry_get_tabs", libprag.}

proc getTabs*(self: Entry): pango.TabArray =
  new(result)
  result.impl = gtk_entry_get_tabs(cast[ptr Entry00](self.impl))

proc tabs*(self: Entry): pango.TabArray =
  new(result)
  result.impl = gtk_entry_get_tabs(cast[ptr Entry00](self.impl))

proc gtk_entry_get_text*(self: ptr Entry00): cstring {.
    importc: "gtk_entry_get_text", libprag.}

proc getText*(self: Entry): string =
  let resul0 = gtk_entry_get_text(cast[ptr Entry00](self.impl))
  result = $resul0

proc text*(self: Entry): string =
  let resul0 = gtk_entry_get_text(cast[ptr Entry00](self.impl))
  result = $resul0

proc gtk_entry_get_text_area*(self: ptr Entry00; textArea: var gdk.Rectangle00) {.
    importc: "gtk_entry_get_text_area", libprag.}

proc getTextArea*(self: ptr Entry00; textArea: var gdk.Rectangle00) {.
    importc: "gtk_entry_get_text_area", libprag.}

proc textArea*(self: ptr Entry00; textArea: var gdk.Rectangle00) {.
    importc: "gtk_entry_get_text_area", libprag.}

proc gtk_entry_get_text_length*(self: ptr Entry00): uint16 {.
    importc: "gtk_entry_get_text_length", libprag.}

proc getTextLength*(self: Entry): uint16 =
  gtk_entry_get_text_length(cast[ptr Entry00](self.impl))

proc textLength*(self: Entry): uint16 =
  gtk_entry_get_text_length(cast[ptr Entry00](self.impl))

proc gtk_entry_get_visibility*(self: ptr Entry00): gboolean {.
    importc: "gtk_entry_get_visibility", libprag.}

proc getVisibility*(self: Entry): bool =
  toBool(gtk_entry_get_visibility(cast[ptr Entry00](self.impl)))

proc visibility*(self: Entry): bool =
  toBool(gtk_entry_get_visibility(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_width_chars*(self: ptr Entry00): int32 {.
    importc: "gtk_entry_get_width_chars", libprag.}

proc getWidthChars*(self: Entry): int =
  int(gtk_entry_get_width_chars(cast[ptr Entry00](self.impl)))

proc widthChars*(self: Entry): int =
  int(gtk_entry_get_width_chars(cast[ptr Entry00](self.impl)))

proc gtk_entry_grab_focus_without_selecting*(self: ptr Entry00) {.
    importc: "gtk_entry_grab_focus_without_selecting", libprag.}

proc grabFocusWithoutSelecting*(self: Entry) =
  gtk_entry_grab_focus_without_selecting(cast[ptr Entry00](self.impl))

proc gtk_entry_im_context_filter_keypress*(self: ptr Entry00; event: ptr gdk.EventKey00): gboolean {.
    importc: "gtk_entry_im_context_filter_keypress", libprag.}

proc imContextFilterKeypress*(self: Entry; event: gdk.EventKey): bool =
  toBool(gtk_entry_im_context_filter_keypress(cast[ptr Entry00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_entry_layout_index_to_text_index*(self: ptr Entry00; layoutIndex: int32): int32 {.
    importc: "gtk_entry_layout_index_to_text_index", libprag.}

proc layoutIndexToTextIndex*(self: Entry; layoutIndex: int): int =
  int(gtk_entry_layout_index_to_text_index(cast[ptr Entry00](self.impl), int32(layoutIndex)))

proc gtk_entry_progress_pulse*(self: ptr Entry00) {.
    importc: "gtk_entry_progress_pulse", libprag.}

proc progressPulse*(self: Entry) =
  gtk_entry_progress_pulse(cast[ptr Entry00](self.impl))

proc gtk_entry_reset_im_context*(self: ptr Entry00) {.
    importc: "gtk_entry_reset_im_context", libprag.}

proc resetImContext*(self: Entry) =
  gtk_entry_reset_im_context(cast[ptr Entry00](self.impl))

proc gtk_entry_set_activates_default*(self: ptr Entry00; setting: gboolean) {.
    importc: "gtk_entry_set_activates_default", libprag.}

proc setActivatesDefault*(self: Entry; setting: bool) =
  gtk_entry_set_activates_default(cast[ptr Entry00](self.impl), gboolean(setting))

proc `activatesDefault=`*(self: Entry; setting: bool) =
  gtk_entry_set_activates_default(cast[ptr Entry00](self.impl), gboolean(setting))

proc gtk_entry_set_alignment*(self: ptr Entry00; xalign: cfloat) {.
    importc: "gtk_entry_set_alignment", libprag.}

proc setAlignment*(self: Entry; xalign: cfloat) =
  gtk_entry_set_alignment(cast[ptr Entry00](self.impl), xalign)

proc `alignment=`*(self: Entry; xalign: cfloat) =
  gtk_entry_set_alignment(cast[ptr Entry00](self.impl), xalign)

proc gtk_entry_set_attributes*(self: ptr Entry00; attrs: ptr pango.AttrList00) {.
    importc: "gtk_entry_set_attributes", libprag.}

proc setAttributes*(self: Entry; attrs: pango.AttrList) =
  gtk_entry_set_attributes(cast[ptr Entry00](self.impl), cast[ptr pango.AttrList00](attrs.impl))

proc `attributes=`*(self: Entry; attrs: pango.AttrList) =
  gtk_entry_set_attributes(cast[ptr Entry00](self.impl), cast[ptr pango.AttrList00](attrs.impl))

proc gtk_entry_set_cursor_hadjustment*(self: ptr Entry00; adjustment: ptr Adjustment00) {.
    importc: "gtk_entry_set_cursor_hadjustment", libprag.}

proc setCursorHadjustment*(self: Entry; adjustment: Adjustment) =
  gtk_entry_set_cursor_hadjustment(cast[ptr Entry00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `cursorHadjustment=`*(self: Entry; adjustment: Adjustment) =
  gtk_entry_set_cursor_hadjustment(cast[ptr Entry00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_entry_set_has_frame*(self: ptr Entry00; setting: gboolean) {.
    importc: "gtk_entry_set_has_frame", libprag.}

proc setHasFrame*(self: Entry; setting: bool) =
  gtk_entry_set_has_frame(cast[ptr Entry00](self.impl), gboolean(setting))

proc `hasFrame=`*(self: Entry; setting: bool) =
  gtk_entry_set_has_frame(cast[ptr Entry00](self.impl), gboolean(setting))

proc gtk_entry_set_icon_activatable*(self: ptr Entry00; iconPos: EntryIconPosition; activatable: gboolean) {.
    importc: "gtk_entry_set_icon_activatable", libprag.}

proc setIconActivatable*(self: Entry; iconPos: EntryIconPosition; activatable: bool) =
  gtk_entry_set_icon_activatable(cast[ptr Entry00](self.impl), iconPos, gboolean(activatable))

proc gtk_entry_set_icon_drag_source*(self: ptr Entry00; iconPos: EntryIconPosition; targetList: ptr TargetList00; 
    actions: gdk.DragAction) {.
    importc: "gtk_entry_set_icon_drag_source", libprag.}

proc setIconDragSource*(self: Entry; iconPos: EntryIconPosition; targetList: TargetList; 
    actions: gdk.DragAction) =
  gtk_entry_set_icon_drag_source(cast[ptr Entry00](self.impl), iconPos, cast[ptr TargetList00](targetList.impl), actions)

proc gtk_entry_set_icon_from_gicon*(self: ptr Entry00; iconPos: EntryIconPosition; icon: ptr gio.Icon00) {.
    importc: "gtk_entry_set_icon_from_gicon", libprag.}

proc setIconFromGicon*(self: Entry; iconPos: EntryIconPosition; icon: gio.Icon) =
  gtk_entry_set_icon_from_gicon(cast[ptr Entry00](self.impl), iconPos, cast[ptr gio.Icon00](icon.impl))

proc gtk_entry_set_icon_from_icon_name*(self: ptr Entry00; iconPos: EntryIconPosition; iconName: cstring) {.
    importc: "gtk_entry_set_icon_from_icon_name", libprag.}

proc setIconFromIconName*(self: Entry; iconPos: EntryIconPosition; iconName: string) =
  gtk_entry_set_icon_from_icon_name(cast[ptr Entry00](self.impl), iconPos, cstring(iconName))

proc gtk_entry_set_icon_from_pixbuf*(self: ptr Entry00; iconPos: EntryIconPosition; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_entry_set_icon_from_pixbuf", libprag.}

proc setIconFromPixbuf*(self: Entry; iconPos: EntryIconPosition; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_entry_set_icon_from_pixbuf(cast[ptr Entry00](self.impl), iconPos, cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_entry_set_icon_from_stock*(self: ptr Entry00; iconPos: EntryIconPosition; stockId: cstring) {.
    importc: "gtk_entry_set_icon_from_stock", libprag.}

proc setIconFromStock*(self: Entry; iconPos: EntryIconPosition; stockId: string) =
  gtk_entry_set_icon_from_stock(cast[ptr Entry00](self.impl), iconPos, cstring(stockId))

proc gtk_entry_set_icon_sensitive*(self: ptr Entry00; iconPos: EntryIconPosition; sensitive: gboolean) {.
    importc: "gtk_entry_set_icon_sensitive", libprag.}

proc setIconSensitive*(self: Entry; iconPos: EntryIconPosition; sensitive: bool) =
  gtk_entry_set_icon_sensitive(cast[ptr Entry00](self.impl), iconPos, gboolean(sensitive))

proc gtk_entry_set_icon_tooltip_markup*(self: ptr Entry00; iconPos: EntryIconPosition; tooltip: cstring) {.
    importc: "gtk_entry_set_icon_tooltip_markup", libprag.}

proc setIconTooltipMarkup*(self: Entry; iconPos: EntryIconPosition; tooltip: string) =
  gtk_entry_set_icon_tooltip_markup(cast[ptr Entry00](self.impl), iconPos, cstring(tooltip))

proc gtk_entry_set_icon_tooltip_text*(self: ptr Entry00; iconPos: EntryIconPosition; tooltip: cstring) {.
    importc: "gtk_entry_set_icon_tooltip_text", libprag.}

proc setIconTooltipText*(self: Entry; iconPos: EntryIconPosition; tooltip: string) =
  gtk_entry_set_icon_tooltip_text(cast[ptr Entry00](self.impl), iconPos, cstring(tooltip))

proc gtk_entry_set_inner_border*(self: ptr Entry00; border: ptr Border00) {.
    importc: "gtk_entry_set_inner_border", libprag.}

proc setInnerBorder*(self: Entry; border: Border) =
  gtk_entry_set_inner_border(cast[ptr Entry00](self.impl), cast[ptr Border00](border.impl))

proc `innerBorder=`*(self: Entry; border: Border) =
  gtk_entry_set_inner_border(cast[ptr Entry00](self.impl), cast[ptr Border00](border.impl))

proc gtk_entry_set_invisible_char*(self: ptr Entry00; ch: gunichar) {.
    importc: "gtk_entry_set_invisible_char", libprag.}

proc setInvisibleChar*(self: Entry; ch: gunichar) =
  gtk_entry_set_invisible_char(cast[ptr Entry00](self.impl), ch)

proc `invisibleChar=`*(self: Entry; ch: gunichar) =
  gtk_entry_set_invisible_char(cast[ptr Entry00](self.impl), ch)

proc gtk_entry_set_max_length*(self: ptr Entry00; max: int32) {.
    importc: "gtk_entry_set_max_length", libprag.}

proc setMaxLength*(self: Entry; max: int) =
  gtk_entry_set_max_length(cast[ptr Entry00](self.impl), int32(max))

proc `maxLength=`*(self: Entry; max: int) =
  gtk_entry_set_max_length(cast[ptr Entry00](self.impl), int32(max))

proc gtk_entry_set_max_width_chars*(self: ptr Entry00; nChars: int32) {.
    importc: "gtk_entry_set_max_width_chars", libprag.}

proc setMaxWidthChars*(self: Entry; nChars: int) =
  gtk_entry_set_max_width_chars(cast[ptr Entry00](self.impl), int32(nChars))

proc `maxWidthChars=`*(self: Entry; nChars: int) =
  gtk_entry_set_max_width_chars(cast[ptr Entry00](self.impl), int32(nChars))

proc gtk_entry_set_overwrite_mode*(self: ptr Entry00; overwrite: gboolean) {.
    importc: "gtk_entry_set_overwrite_mode", libprag.}

proc setOverwriteMode*(self: Entry; overwrite: bool) =
  gtk_entry_set_overwrite_mode(cast[ptr Entry00](self.impl), gboolean(overwrite))

proc `overwriteMode=`*(self: Entry; overwrite: bool) =
  gtk_entry_set_overwrite_mode(cast[ptr Entry00](self.impl), gboolean(overwrite))

proc gtk_entry_set_placeholder_text*(self: ptr Entry00; text: cstring) {.
    importc: "gtk_entry_set_placeholder_text", libprag.}

proc setPlaceholderText*(self: Entry; text: string) =
  gtk_entry_set_placeholder_text(cast[ptr Entry00](self.impl), cstring(text))

proc `placeholderText=`*(self: Entry; text: string) =
  gtk_entry_set_placeholder_text(cast[ptr Entry00](self.impl), cstring(text))

proc gtk_entry_set_progress_fraction*(self: ptr Entry00; fraction: cdouble) {.
    importc: "gtk_entry_set_progress_fraction", libprag.}

proc setProgressFraction*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_fraction(cast[ptr Entry00](self.impl), fraction)

proc `progressFraction=`*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_fraction(cast[ptr Entry00](self.impl), fraction)

proc gtk_entry_set_progress_pulse_step*(self: ptr Entry00; fraction: cdouble) {.
    importc: "gtk_entry_set_progress_pulse_step", libprag.}

proc setProgressPulseStep*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_pulse_step(cast[ptr Entry00](self.impl), fraction)

proc `progressPulseStep=`*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_pulse_step(cast[ptr Entry00](self.impl), fraction)

proc gtk_entry_set_tabs*(self: ptr Entry00; tabs: ptr pango.TabArray00) {.
    importc: "gtk_entry_set_tabs", libprag.}

proc setTabs*(self: Entry; tabs: pango.TabArray) =
  gtk_entry_set_tabs(cast[ptr Entry00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc `tabs=`*(self: Entry; tabs: pango.TabArray) =
  gtk_entry_set_tabs(cast[ptr Entry00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc gtk_entry_set_text*(self: ptr Entry00; text: cstring) {.
    importc: "gtk_entry_set_text", libprag.}

proc setText*(self: Entry; text: string) =
  gtk_entry_set_text(cast[ptr Entry00](self.impl), cstring(text))

proc `text=`*(self: Entry; text: string) =
  gtk_entry_set_text(cast[ptr Entry00](self.impl), cstring(text))

proc gtk_entry_set_visibility*(self: ptr Entry00; visible: gboolean) {.
    importc: "gtk_entry_set_visibility", libprag.}

proc setVisibility*(self: Entry; visible: bool) =
  gtk_entry_set_visibility(cast[ptr Entry00](self.impl), gboolean(visible))

proc `visibility=`*(self: Entry; visible: bool) =
  gtk_entry_set_visibility(cast[ptr Entry00](self.impl), gboolean(visible))

proc gtk_entry_set_width_chars*(self: ptr Entry00; nChars: int32) {.
    importc: "gtk_entry_set_width_chars", libprag.}

proc setWidthChars*(self: Entry; nChars: int) =
  gtk_entry_set_width_chars(cast[ptr Entry00](self.impl), int32(nChars))

proc `widthChars=`*(self: Entry; nChars: int) =
  gtk_entry_set_width_chars(cast[ptr Entry00](self.impl), int32(nChars))

proc gtk_entry_text_index_to_layout_index*(self: ptr Entry00; textIndex: int32): int32 {.
    importc: "gtk_entry_text_index_to_layout_index", libprag.}

proc textIndexToLayoutIndex*(self: Entry; textIndex: int): int =
  int(gtk_entry_text_index_to_layout_index(cast[ptr Entry00](self.impl), int32(textIndex)))

proc gtk_entry_unset_invisible_char*(self: ptr Entry00) {.
    importc: "gtk_entry_unset_invisible_char", libprag.}

proc unsetInvisibleChar*(self: Entry) =
  gtk_entry_unset_invisible_char(cast[ptr Entry00](self.impl))

type
  ImageType* {.size: sizeof(cint), pure.} = enum
    empty = 0
    pixbuf = 1
    stock = 2
    iconSet = 3
    animation = 4
    iconName = 5
    gicon = 6
    surface = 7

proc gtk_entry_get_icon_storage_type*(self: ptr Entry00; iconPos: EntryIconPosition): ImageType {.
    importc: "gtk_entry_get_icon_storage_type", libprag.}

proc getIconStorageType*(self: Entry; iconPos: EntryIconPosition): ImageType =
  gtk_entry_get_icon_storage_type(cast[ptr Entry00](self.impl), iconPos)

proc iconStorageType*(self: Entry; iconPos: EntryIconPosition): ImageType =
  gtk_entry_get_icon_storage_type(cast[ptr Entry00](self.impl), iconPos)

type
  EntryBufferPrivate00* {.pure.} = object
  EntryBufferPrivate* = ref object
    impl*: ptr EntryBufferPrivate00

type
  EntryBuffer* = ref object of gobject.Object
  EntryBuffer00* = object of gobject.Object00
    priv1: ptr EntryBufferPrivate00

proc scDeletedText*(self: EntryBuffer;  p: proc (self: ptr gobject.Object00; position: uint32; nChars: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "deleted-text", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scInsertedText*(self: EntryBuffer;  p: proc (self: ptr gobject.Object00; position: uint32; chars: cstring; nChars: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "inserted-text", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_entry_buffer_new*(initialChars: cstring; nInitialChars: int32): ptr EntryBuffer00 {.
    importc: "gtk_entry_buffer_new", libprag.}

proc newEntryBuffer*(initialChars: string; nInitialChars: int): EntryBuffer =
  new(result, finalizeGObject)
  result.impl = gtk_entry_buffer_new(cstring(initialChars), int32(nInitialChars))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryBuffer*[T](result: var T; initialChars: string; nInitialChars: int) =
  assert(result is EntryBuffer)
  new(result, finalizeGObject)
  result.impl = gtk_entry_buffer_new(cstring(initialChars), int32(nInitialChars))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_buffer_delete_text*(self: ptr EntryBuffer00; position: uint32; nChars: int32): uint32 {.
    importc: "gtk_entry_buffer_delete_text", libprag.}

proc deleteText*(self: EntryBuffer; position: int; nChars: int): int =
  int(gtk_entry_buffer_delete_text(cast[ptr EntryBuffer00](self.impl), uint32(position), int32(nChars)))

proc gtk_entry_buffer_emit_deleted_text*(self: ptr EntryBuffer00; position: uint32; nChars: uint32) {.
    importc: "gtk_entry_buffer_emit_deleted_text", libprag.}

proc emitDeletedText*(self: EntryBuffer; position: int; nChars: int) =
  gtk_entry_buffer_emit_deleted_text(cast[ptr EntryBuffer00](self.impl), uint32(position), uint32(nChars))

proc gtk_entry_buffer_emit_inserted_text*(self: ptr EntryBuffer00; position: uint32; chars: cstring; 
    nChars: uint32) {.
    importc: "gtk_entry_buffer_emit_inserted_text", libprag.}

proc emitInsertedText*(self: EntryBuffer; position: int; chars: string; nChars: int) =
  gtk_entry_buffer_emit_inserted_text(cast[ptr EntryBuffer00](self.impl), uint32(position), cstring(chars), uint32(nChars))

proc gtk_entry_buffer_get_bytes*(self: ptr EntryBuffer00): uint64 {.
    importc: "gtk_entry_buffer_get_bytes", libprag.}

proc getBytes*(self: EntryBuffer): uint64 =
  gtk_entry_buffer_get_bytes(cast[ptr EntryBuffer00](self.impl))

proc bytes*(self: EntryBuffer): uint64 =
  gtk_entry_buffer_get_bytes(cast[ptr EntryBuffer00](self.impl))

proc gtk_entry_buffer_get_length*(self: ptr EntryBuffer00): uint32 {.
    importc: "gtk_entry_buffer_get_length", libprag.}

proc getLength*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_length(cast[ptr EntryBuffer00](self.impl)))

proc length*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_length(cast[ptr EntryBuffer00](self.impl)))

proc gtk_entry_buffer_get_max_length*(self: ptr EntryBuffer00): int32 {.
    importc: "gtk_entry_buffer_get_max_length", libprag.}

proc getMaxLength*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_max_length(cast[ptr EntryBuffer00](self.impl)))

proc maxLength*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_max_length(cast[ptr EntryBuffer00](self.impl)))

proc gtk_entry_buffer_get_text*(self: ptr EntryBuffer00): cstring {.
    importc: "gtk_entry_buffer_get_text", libprag.}

proc getText*(self: EntryBuffer): string =
  let resul0 = gtk_entry_buffer_get_text(cast[ptr EntryBuffer00](self.impl))
  result = $resul0

proc text*(self: EntryBuffer): string =
  let resul0 = gtk_entry_buffer_get_text(cast[ptr EntryBuffer00](self.impl))
  result = $resul0

proc gtk_entry_buffer_insert_text*(self: ptr EntryBuffer00; position: uint32; chars: cstring; 
    nChars: int32): uint32 {.
    importc: "gtk_entry_buffer_insert_text", libprag.}

proc insertText*(self: EntryBuffer; position: int; chars: string; nChars: int): int =
  int(gtk_entry_buffer_insert_text(cast[ptr EntryBuffer00](self.impl), uint32(position), cstring(chars), int32(nChars)))

proc gtk_entry_buffer_set_max_length*(self: ptr EntryBuffer00; maxLength: int32) {.
    importc: "gtk_entry_buffer_set_max_length", libprag.}

proc setMaxLength*(self: EntryBuffer; maxLength: int) =
  gtk_entry_buffer_set_max_length(cast[ptr EntryBuffer00](self.impl), int32(maxLength))

proc `maxLength=`*(self: EntryBuffer; maxLength: int) =
  gtk_entry_buffer_set_max_length(cast[ptr EntryBuffer00](self.impl), int32(maxLength))

proc gtk_entry_buffer_set_text*(self: ptr EntryBuffer00; chars: cstring; nChars: int32) {.
    importc: "gtk_entry_buffer_set_text", libprag.}

proc setText*(self: EntryBuffer; chars: string; nChars: int) =
  gtk_entry_buffer_set_text(cast[ptr EntryBuffer00](self.impl), cstring(chars), int32(nChars))

proc gtk_entry_new_with_buffer*(buffer: ptr EntryBuffer00): ptr Entry00 {.
    importc: "gtk_entry_new_with_buffer", libprag.}

proc newEntryWithBuffer*(buffer: EntryBuffer): Entry =
  new(result, finalizeGObject)
  result.impl = gtk_entry_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryWithBuffer*[T](result: var T; buffer: EntryBuffer) =
  assert(result is Entry)
  new(result, finalizeGObject)
  result.impl = gtk_entry_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_buffer*(self: ptr Entry00): ptr EntryBuffer00 {.
    importc: "gtk_entry_get_buffer", libprag.}

proc getBuffer*(self: Entry): EntryBuffer =
  let gobj = gtk_entry_get_buffer(cast[ptr Entry00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[EntryBuffer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: Entry): EntryBuffer =
  let gobj = gtk_entry_get_buffer(cast[ptr Entry00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[EntryBuffer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_set_buffer*(self: ptr Entry00; buffer: ptr EntryBuffer00) {.
    importc: "gtk_entry_set_buffer", libprag.}

proc setBuffer*(self: Entry; buffer: EntryBuffer) =
  gtk_entry_set_buffer(cast[ptr Entry00](self.impl), cast[ptr EntryBuffer00](buffer.impl))

proc `buffer=`*(self: Entry; buffer: EntryBuffer) =
  gtk_entry_set_buffer(cast[ptr Entry00](self.impl), cast[ptr EntryBuffer00](buffer.impl))

type
  EntryCompletionPrivate00* {.pure.} = object
  EntryCompletionPrivate* = ref object
    impl*: ptr EntryCompletionPrivate00

type
  EntryCompletion* = ref object of gobject.Object
  EntryCompletion00* = object of gobject.Object00
    priv1: ptr EntryCompletionPrivate00

proc scActionActivated*(self: EntryCompletion;  p: proc (self: ptr gobject.Object00; index: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "action-activated", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCursorOnMatch*(self: EntryCompletion;  p: proc (self: ptr gobject.Object00; model: TreeModel00; iter: TreeIter00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cursor-on-match", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scInsertPrefix*(self: EntryCompletion;  p: proc (self: ptr gobject.Object00; prefix: cstring; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "insert-prefix", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMatchSelected*(self: EntryCompletion;  p: proc (self: ptr gobject.Object00; model: TreeModel00; iter: TreeIter00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "match-selected", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scNoMatches*(self: EntryCompletion;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "no-matches", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_entry_completion_new*(): ptr EntryCompletion00 {.
    importc: "gtk_entry_completion_new", libprag.}

proc newEntryCompletion*(): EntryCompletion =
  new(result, finalizeGObject)
  result.impl = gtk_entry_completion_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryCompletion*[T](result: var T) =
  assert(result is EntryCompletion)
  new(result, finalizeGObject)
  result.impl = gtk_entry_completion_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_new_with_area*(area: ptr CellArea00): ptr EntryCompletion00 {.
    importc: "gtk_entry_completion_new_with_area", libprag.}

proc newEntryCompletionWithArea*(area: CellArea): EntryCompletion =
  new(result, finalizeGObject)
  result.impl = gtk_entry_completion_new_with_area(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryCompletionWithArea*[T](result: var T; area: CellArea) =
  assert(result is EntryCompletion)
  new(result, finalizeGObject)
  result.impl = gtk_entry_completion_new_with_area(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_complete*(self: ptr EntryCompletion00) {.
    importc: "gtk_entry_completion_complete", libprag.}

proc complete*(self: EntryCompletion) =
  gtk_entry_completion_complete(cast[ptr EntryCompletion00](self.impl))

proc gtk_entry_completion_compute_prefix*(self: ptr EntryCompletion00; key: cstring): cstring {.
    importc: "gtk_entry_completion_compute_prefix", libprag.}

proc computePrefix*(self: EntryCompletion; key: string): string =
  let resul0 = gtk_entry_completion_compute_prefix(cast[ptr EntryCompletion00](self.impl), cstring(key))
  result = $resul0
  cogfree(resul0)

proc gtk_entry_completion_delete_action*(self: ptr EntryCompletion00; index: int32) {.
    importc: "gtk_entry_completion_delete_action", libprag.}

proc deleteAction*(self: EntryCompletion; index: int) =
  gtk_entry_completion_delete_action(cast[ptr EntryCompletion00](self.impl), int32(index))

proc gtk_entry_completion_get_completion_prefix*(self: ptr EntryCompletion00): cstring {.
    importc: "gtk_entry_completion_get_completion_prefix", libprag.}

proc getCompletionPrefix*(self: EntryCompletion): string =
  let resul0 = gtk_entry_completion_get_completion_prefix(cast[ptr EntryCompletion00](self.impl))
  result = $resul0

proc completionPrefix*(self: EntryCompletion): string =
  let resul0 = gtk_entry_completion_get_completion_prefix(cast[ptr EntryCompletion00](self.impl))
  result = $resul0

proc gtk_entry_completion_get_entry*(self: ptr EntryCompletion00): ptr Widget00 {.
    importc: "gtk_entry_completion_get_entry", libprag.}

proc getEntry*(self: EntryCompletion): Widget =
  let gobj = gtk_entry_completion_get_entry(cast[ptr EntryCompletion00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc entry*(self: EntryCompletion): Widget =
  let gobj = gtk_entry_completion_get_entry(cast[ptr EntryCompletion00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_get_inline_completion*(self: ptr EntryCompletion00): gboolean {.
    importc: "gtk_entry_completion_get_inline_completion", libprag.}

proc getInlineCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_completion(cast[ptr EntryCompletion00](self.impl)))

proc inlineCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_completion(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_inline_selection*(self: ptr EntryCompletion00): gboolean {.
    importc: "gtk_entry_completion_get_inline_selection", libprag.}

proc getInlineSelection*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_selection(cast[ptr EntryCompletion00](self.impl)))

proc inlineSelection*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_selection(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_minimum_key_length*(self: ptr EntryCompletion00): int32 {.
    importc: "gtk_entry_completion_get_minimum_key_length", libprag.}

proc getMinimumKeyLength*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_minimum_key_length(cast[ptr EntryCompletion00](self.impl)))

proc minimumKeyLength*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_minimum_key_length(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_model*(self: ptr EntryCompletion00): ptr TreeModel00 {.
    importc: "gtk_entry_completion_get_model", libprag.}

proc getModel*(self: EntryCompletion): TreeModel =
  new(result)
  result.impl = gtk_entry_completion_get_model(cast[ptr EntryCompletion00](self.impl))

proc model*(self: EntryCompletion): TreeModel =
  new(result)
  result.impl = gtk_entry_completion_get_model(cast[ptr EntryCompletion00](self.impl))

proc gtk_entry_completion_get_popup_completion*(self: ptr EntryCompletion00): gboolean {.
    importc: "gtk_entry_completion_get_popup_completion", libprag.}

proc getPopupCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_completion(cast[ptr EntryCompletion00](self.impl)))

proc popupCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_completion(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_popup_set_width*(self: ptr EntryCompletion00): gboolean {.
    importc: "gtk_entry_completion_get_popup_set_width", libprag.}

proc getPopupSetWidth*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_set_width(cast[ptr EntryCompletion00](self.impl)))

proc popupSetWidth*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_set_width(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_popup_single_match*(self: ptr EntryCompletion00): gboolean {.
    importc: "gtk_entry_completion_get_popup_single_match", libprag.}

proc getPopupSingleMatch*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_single_match(cast[ptr EntryCompletion00](self.impl)))

proc popupSingleMatch*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_single_match(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_text_column*(self: ptr EntryCompletion00): int32 {.
    importc: "gtk_entry_completion_get_text_column", libprag.}

proc getTextColumn*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_text_column(cast[ptr EntryCompletion00](self.impl)))

proc textColumn*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_text_column(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_insert_action_markup*(self: ptr EntryCompletion00; index: int32; markup: cstring) {.
    importc: "gtk_entry_completion_insert_action_markup", libprag.}

proc insertActionMarkup*(self: EntryCompletion; index: int; markup: string) =
  gtk_entry_completion_insert_action_markup(cast[ptr EntryCompletion00](self.impl), int32(index), cstring(markup))

proc gtk_entry_completion_insert_action_text*(self: ptr EntryCompletion00; index: int32; text: cstring) {.
    importc: "gtk_entry_completion_insert_action_text", libprag.}

proc insertActionText*(self: EntryCompletion; index: int; text: string) =
  gtk_entry_completion_insert_action_text(cast[ptr EntryCompletion00](self.impl), int32(index), cstring(text))

proc gtk_entry_completion_insert_prefix*(self: ptr EntryCompletion00) {.
    importc: "gtk_entry_completion_insert_prefix", libprag.}

proc insertPrefix*(self: EntryCompletion) =
  gtk_entry_completion_insert_prefix(cast[ptr EntryCompletion00](self.impl))

proc gtk_entry_completion_set_inline_completion*(self: ptr EntryCompletion00; inlineCompletion: gboolean) {.
    importc: "gtk_entry_completion_set_inline_completion", libprag.}

proc setInlineCompletion*(self: EntryCompletion; inlineCompletion: bool) =
  gtk_entry_completion_set_inline_completion(cast[ptr EntryCompletion00](self.impl), gboolean(inlineCompletion))

proc `inlineCompletion=`*(self: EntryCompletion; inlineCompletion: bool) =
  gtk_entry_completion_set_inline_completion(cast[ptr EntryCompletion00](self.impl), gboolean(inlineCompletion))

proc gtk_entry_completion_set_inline_selection*(self: ptr EntryCompletion00; inlineSelection: gboolean) {.
    importc: "gtk_entry_completion_set_inline_selection", libprag.}

proc setInlineSelection*(self: EntryCompletion; inlineSelection: bool) =
  gtk_entry_completion_set_inline_selection(cast[ptr EntryCompletion00](self.impl), gboolean(inlineSelection))

proc `inlineSelection=`*(self: EntryCompletion; inlineSelection: bool) =
  gtk_entry_completion_set_inline_selection(cast[ptr EntryCompletion00](self.impl), gboolean(inlineSelection))

proc gtk_entry_completion_set_minimum_key_length*(self: ptr EntryCompletion00; length: int32) {.
    importc: "gtk_entry_completion_set_minimum_key_length", libprag.}

proc setMinimumKeyLength*(self: EntryCompletion; length: int) =
  gtk_entry_completion_set_minimum_key_length(cast[ptr EntryCompletion00](self.impl), int32(length))

proc `minimumKeyLength=`*(self: EntryCompletion; length: int) =
  gtk_entry_completion_set_minimum_key_length(cast[ptr EntryCompletion00](self.impl), int32(length))

proc gtk_entry_completion_set_model*(self: ptr EntryCompletion00; model: ptr TreeModel00) {.
    importc: "gtk_entry_completion_set_model", libprag.}

proc setModel*(self: EntryCompletion; model: TreeModel) =
  gtk_entry_completion_set_model(cast[ptr EntryCompletion00](self.impl), cast[ptr TreeModel00](model.impl))

proc `model=`*(self: EntryCompletion; model: TreeModel) =
  gtk_entry_completion_set_model(cast[ptr EntryCompletion00](self.impl), cast[ptr TreeModel00](model.impl))

proc gtk_entry_completion_set_popup_completion*(self: ptr EntryCompletion00; popupCompletion: gboolean) {.
    importc: "gtk_entry_completion_set_popup_completion", libprag.}

proc setPopupCompletion*(self: EntryCompletion; popupCompletion: bool) =
  gtk_entry_completion_set_popup_completion(cast[ptr EntryCompletion00](self.impl), gboolean(popupCompletion))

proc `popupCompletion=`*(self: EntryCompletion; popupCompletion: bool) =
  gtk_entry_completion_set_popup_completion(cast[ptr EntryCompletion00](self.impl), gboolean(popupCompletion))

proc gtk_entry_completion_set_popup_set_width*(self: ptr EntryCompletion00; popupSetWidth: gboolean) {.
    importc: "gtk_entry_completion_set_popup_set_width", libprag.}

proc setPopupSetWidth*(self: EntryCompletion; popupSetWidth: bool) =
  gtk_entry_completion_set_popup_set_width(cast[ptr EntryCompletion00](self.impl), gboolean(popupSetWidth))

proc `popupSetWidth=`*(self: EntryCompletion; popupSetWidth: bool) =
  gtk_entry_completion_set_popup_set_width(cast[ptr EntryCompletion00](self.impl), gboolean(popupSetWidth))

proc gtk_entry_completion_set_popup_single_match*(self: ptr EntryCompletion00; popupSingleMatch: gboolean) {.
    importc: "gtk_entry_completion_set_popup_single_match", libprag.}

proc setPopupSingleMatch*(self: EntryCompletion; popupSingleMatch: bool) =
  gtk_entry_completion_set_popup_single_match(cast[ptr EntryCompletion00](self.impl), gboolean(popupSingleMatch))

proc `popupSingleMatch=`*(self: EntryCompletion; popupSingleMatch: bool) =
  gtk_entry_completion_set_popup_single_match(cast[ptr EntryCompletion00](self.impl), gboolean(popupSingleMatch))

proc gtk_entry_completion_set_text_column*(self: ptr EntryCompletion00; column: int32) {.
    importc: "gtk_entry_completion_set_text_column", libprag.}

proc setTextColumn*(self: EntryCompletion; column: int) =
  gtk_entry_completion_set_text_column(cast[ptr EntryCompletion00](self.impl), int32(column))

proc `textColumn=`*(self: EntryCompletion; column: int) =
  gtk_entry_completion_set_text_column(cast[ptr EntryCompletion00](self.impl), int32(column))

proc gtk_entry_get_completion*(self: ptr Entry00): ptr EntryCompletion00 {.
    importc: "gtk_entry_get_completion", libprag.}

proc getCompletion*(self: Entry): EntryCompletion =
  let gobj = gtk_entry_get_completion(cast[ptr Entry00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[EntryCompletion](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc completion*(self: Entry): EntryCompletion =
  let gobj = gtk_entry_get_completion(cast[ptr Entry00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[EntryCompletion](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_set_completion*(self: ptr Entry00; completion: ptr EntryCompletion00) {.
    importc: "gtk_entry_set_completion", libprag.}

proc setCompletion*(self: Entry; completion: EntryCompletion) =
  gtk_entry_set_completion(cast[ptr Entry00](self.impl), cast[ptr EntryCompletion00](completion.impl))

proc `completion=`*(self: Entry; completion: EntryCompletion) =
  gtk_entry_set_completion(cast[ptr Entry00](self.impl), cast[ptr EntryCompletion00](completion.impl))

type
  InputHints* {.size: sizeof(cint), pure.} = enum
    none = 0
    spellcheck = 1
    noSpellcheck = 2
    wordCompletion = 4
    lowercase = 8
    uppercaseChars = 16
    uppercaseWords = 32
    uppercaseSentences = 64
    inhibitOsk = 128
    verticalWriting = 256

proc gtk_entry_get_input_hints*(self: ptr Entry00): InputHints {.
    importc: "gtk_entry_get_input_hints", libprag.}

proc getInputHints*(self: Entry): InputHints =
  gtk_entry_get_input_hints(cast[ptr Entry00](self.impl))

proc inputHints*(self: Entry): InputHints =
  gtk_entry_get_input_hints(cast[ptr Entry00](self.impl))

proc gtk_entry_set_input_hints*(self: ptr Entry00; hints: InputHints) {.
    importc: "gtk_entry_set_input_hints", libprag.}

proc setInputHints*(self: Entry; hints: InputHints) =
  gtk_entry_set_input_hints(cast[ptr Entry00](self.impl), hints)

proc `inputHints=`*(self: Entry; hints: InputHints) =
  gtk_entry_set_input_hints(cast[ptr Entry00](self.impl), hints)

type
  InputPurpose* {.size: sizeof(cint), pure.} = enum
    freeForm = 0
    alpha = 1
    digits = 2
    number = 3
    phone = 4
    url = 5
    email = 6
    name = 7
    password = 8
    pin = 9

proc gtk_entry_get_input_purpose*(self: ptr Entry00): InputPurpose {.
    importc: "gtk_entry_get_input_purpose", libprag.}

proc getInputPurpose*(self: Entry): InputPurpose =
  gtk_entry_get_input_purpose(cast[ptr Entry00](self.impl))

proc inputPurpose*(self: Entry): InputPurpose =
  gtk_entry_get_input_purpose(cast[ptr Entry00](self.impl))

proc gtk_entry_set_input_purpose*(self: ptr Entry00; purpose: InputPurpose) {.
    importc: "gtk_entry_set_input_purpose", libprag.}

proc setInputPurpose*(self: Entry; purpose: InputPurpose) =
  gtk_entry_set_input_purpose(cast[ptr Entry00](self.impl), purpose)

proc `inputPurpose=`*(self: Entry; purpose: InputPurpose) =
  gtk_entry_set_input_purpose(cast[ptr Entry00](self.impl), purpose)

type
  EntryAccessiblePrivate00* {.pure.} = object
  EntryAccessiblePrivate* = ref object
    impl*: ptr EntryAccessiblePrivate00

type
  EntryAccessible* = ref object of WidgetAccessible
  EntryAccessible00* = object of WidgetAccessible00
    priv3: ptr EntryAccessiblePrivate00

type
  EntryAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
  EntryAccessibleClass* = ref object
    impl*: ptr EntryAccessibleClass00

type
  EntryBufferClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    insertedText*: proc(buffer: ptr EntryBuffer00; position: uint32; chars: cstring; 
    nChars: uint32) {.cdecl.}
    deletedText*: proc(buffer: ptr EntryBuffer00; position: uint32; nChars: uint32) {.cdecl.}
    getText*: proc(buffer: ptr EntryBuffer00; nBytes: ptr uint64): cstring {.cdecl.}
    getLength*: proc(buffer: ptr EntryBuffer00): uint32 {.cdecl.}
    insertText*: proc(buffer: ptr EntryBuffer00; position: uint32; chars: cstring; 
    nChars: uint32): uint32 {.cdecl.}
    deleteText*: proc(buffer: ptr EntryBuffer00; position: uint32; nChars: uint32): uint32 {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  EntryBufferClass* = ref object
    impl*: ptr EntryBufferClass00

type
  EntryClass00* {.pure.} = object
    parentClass*: WidgetClass00
    populatePopup*: proc(entry: ptr Entry00; popup: ptr Widget00) {.cdecl.}
    activate*: proc(entry: ptr Entry00) {.cdecl.}
    moveCursor*: proc(entry: ptr Entry00; step: MovementStep; count: int32; 
    extendSelection: gboolean) {.cdecl.}
    insertAtCursor*: proc(entry: ptr Entry00; str: cstring) {.cdecl.}
    deleteFromCursor*: proc(entry: ptr Entry00; `type`: DeleteType; count: int32) {.cdecl.}
    backspace*: proc(entry: ptr Entry00) {.cdecl.}
    cutClipboard*: proc(entry: ptr Entry00) {.cdecl.}
    copyClipboard*: proc(entry: ptr Entry00) {.cdecl.}
    pasteClipboard*: proc(entry: ptr Entry00) {.cdecl.}
    toggleOverwrite*: proc(entry: ptr Entry00) {.cdecl.}
    getTextAreaSize*: proc(entry: ptr Entry00; x: ptr int32; y: ptr int32; width: ptr int32; 
    height: ptr int32) {.cdecl.}
    getFrameSize*: proc(entry: ptr Entry00; x: ptr int32; y: ptr int32; width: ptr int32; 
    height: ptr int32) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
  EntryClass* = ref object
    impl*: ptr EntryClass00

type
  EntryCompletionClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    matchSelected*: proc(completion: ptr EntryCompletion00; model: ptr TreeModel00; 
    iter: ptr TreeIter00): gboolean {.cdecl.}
    actionActivated*: proc(completion: ptr EntryCompletion00; index: int32) {.cdecl.}
    insertPrefix*: proc(completion: ptr EntryCompletion00; prefix: cstring): gboolean {.cdecl.}
    cursorOnMatch*: proc(completion: ptr EntryCompletion00; model: ptr TreeModel00; 
    iter: ptr TreeIter00): gboolean {.cdecl.}
    noMatches*: proc(completion: ptr EntryCompletion00) {.cdecl.}
    gtkReserved0*: pointer
    gtkReserved1*: pointer
    gtkReserved2*: pointer
  EntryCompletionClass* = ref object
    impl*: ptr EntryCompletionClass00

type
  EntryCompletionMatchFunc* = proc (completion: ptr EntryCompletion00; key: cstring; iter: ptr TreeIter00; 
    userData: pointer): gboolean {.cdecl.}

proc gtk_entry_completion_set_match_func*(self: ptr EntryCompletion00; `func`: EntryCompletionMatchFunc; 
    funcData: pointer; funcNotify: DestroyNotify) {.
    importc: "gtk_entry_completion_set_match_func", libprag.}

proc setMatchFunc*(self: EntryCompletion; `func`: EntryCompletionMatchFunc; 
    funcData: pointer; funcNotify: DestroyNotify) =
  gtk_entry_completion_set_match_func(cast[ptr EntryCompletion00](self.impl), `func`, funcData, funcNotify)

type
  EntryIconAccessible* = ref object of atk.Object
  EntryIconAccessible00* = object of atk.Object00

type
  EventBoxPrivate00* {.pure.} = object
  EventBoxPrivate* = ref object
    impl*: ptr EventBoxPrivate00

type
  EventBox* = ref object of Bin
  EventBox00* = object of Bin00
    priv4: ptr EventBoxPrivate00

proc gtk_event_box_new*(): ptr EventBox00 {.
    importc: "gtk_event_box_new", libprag.}

proc newEventBox*(): EventBox =
  new(result, finalizeGObject)
  result.impl = gtk_event_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventBox*[T](result: var T) =
  assert(result is EventBox)
  new(result, finalizeGObject)
  result.impl = gtk_event_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_box_get_above_child*(self: ptr EventBox00): gboolean {.
    importc: "gtk_event_box_get_above_child", libprag.}

proc getAboveChild*(self: EventBox): bool =
  toBool(gtk_event_box_get_above_child(cast[ptr EventBox00](self.impl)))

proc aboveChild*(self: EventBox): bool =
  toBool(gtk_event_box_get_above_child(cast[ptr EventBox00](self.impl)))

proc gtk_event_box_get_visible_window*(self: ptr EventBox00): gboolean {.
    importc: "gtk_event_box_get_visible_window", libprag.}

proc getVisibleWindow*(self: EventBox): bool =
  toBool(gtk_event_box_get_visible_window(cast[ptr EventBox00](self.impl)))

proc visibleWindow*(self: EventBox): bool =
  toBool(gtk_event_box_get_visible_window(cast[ptr EventBox00](self.impl)))

proc gtk_event_box_set_above_child*(self: ptr EventBox00; aboveChild: gboolean) {.
    importc: "gtk_event_box_set_above_child", libprag.}

proc setAboveChild*(self: EventBox; aboveChild: bool) =
  gtk_event_box_set_above_child(cast[ptr EventBox00](self.impl), gboolean(aboveChild))

proc `aboveChild=`*(self: EventBox; aboveChild: bool) =
  gtk_event_box_set_above_child(cast[ptr EventBox00](self.impl), gboolean(aboveChild))

proc gtk_event_box_set_visible_window*(self: ptr EventBox00; visibleWindow: gboolean) {.
    importc: "gtk_event_box_set_visible_window", libprag.}

proc setVisibleWindow*(self: EventBox; visibleWindow: bool) =
  gtk_event_box_set_visible_window(cast[ptr EventBox00](self.impl), gboolean(visibleWindow))

proc `visibleWindow=`*(self: EventBox; visibleWindow: bool) =
  gtk_event_box_set_visible_window(cast[ptr EventBox00](self.impl), gboolean(visibleWindow))

type
  EventBoxClass00* {.pure.} = object
    parentClass*: BinClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  EventBoxClass* = ref object
    impl*: ptr EventBoxClass00

type
  EventController* = ref object of gobject.Object
  EventController00* = object of gobject.Object00

proc gtk_event_controller_get_widget*(self: ptr EventController00): ptr Widget00 {.
    importc: "gtk_event_controller_get_widget", libprag.}

proc getWidget*(self: EventController): Widget =
  let gobj = gtk_event_controller_get_widget(cast[ptr EventController00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: EventController): Widget =
  let gobj = gtk_event_controller_get_widget(cast[ptr EventController00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_handle_event*(self: ptr EventController00; event: ptr gdk.Event00): gboolean {.
    importc: "gtk_event_controller_handle_event", libprag.}

proc handleEvent*(self: EventController; event: gdk.Event): bool =
  toBool(gtk_event_controller_handle_event(cast[ptr EventController00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_event_controller_reset*(self: ptr EventController00) {.
    importc: "gtk_event_controller_reset", libprag.}

proc reset*(self: EventController) =
  gtk_event_controller_reset(cast[ptr EventController00](self.impl))

type
  PropagationPhase* {.size: sizeof(cint), pure.} = enum
    none = 0
    capture = 1
    bubble = 2
    target = 3

proc gtk_event_controller_get_propagation_phase*(self: ptr EventController00): PropagationPhase {.
    importc: "gtk_event_controller_get_propagation_phase", libprag.}

proc getPropagationPhase*(self: EventController): PropagationPhase =
  gtk_event_controller_get_propagation_phase(cast[ptr EventController00](self.impl))

proc propagationPhase*(self: EventController): PropagationPhase =
  gtk_event_controller_get_propagation_phase(cast[ptr EventController00](self.impl))

proc gtk_event_controller_set_propagation_phase*(self: ptr EventController00; phase: PropagationPhase) {.
    importc: "gtk_event_controller_set_propagation_phase", libprag.}

proc setPropagationPhase*(self: EventController; phase: PropagationPhase) =
  gtk_event_controller_set_propagation_phase(cast[ptr EventController00](self.impl), phase)

proc `propagationPhase=`*(self: EventController; phase: PropagationPhase) =
  gtk_event_controller_set_propagation_phase(cast[ptr EventController00](self.impl), phase)

type
  EventControllerClass00* {.pure.} = object
  EventControllerClass* = ref object
    impl*: ptr EventControllerClass00

type
  EventSequenceState* {.size: sizeof(cint), pure.} = enum
    none = 0
    claimed = 1
    denied = 2

type
  ExpanderPrivate00* {.pure.} = object
  ExpanderPrivate* = ref object
    impl*: ptr ExpanderPrivate00

type
  Expander* = ref object of Bin
  Expander00* = object of Bin00
    priv4: ptr ExpanderPrivate00

proc scActivate*(self: Expander;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_expander_new*(label: cstring): ptr Expander00 {.
    importc: "gtk_expander_new", libprag.}

proc newExpander*(label: string): Expander =
  new(result, finalizeGObject)
  result.impl = gtk_expander_new(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initExpander*[T](result: var T; label: string) =
  assert(result is Expander)
  new(result, finalizeGObject)
  result.impl = gtk_expander_new(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_new_with_mnemonic*(label: cstring): ptr Expander00 {.
    importc: "gtk_expander_new_with_mnemonic", libprag.}

proc newExpanderWithMnemonic*(label: string): Expander =
  new(result, finalizeGObject)
  result.impl = gtk_expander_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initExpanderWithMnemonic*[T](result: var T; label: string) =
  assert(result is Expander)
  new(result, finalizeGObject)
  result.impl = gtk_expander_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_get_expanded*(self: ptr Expander00): gboolean {.
    importc: "gtk_expander_get_expanded", libprag.}

proc getExpanded*(self: Expander): bool =
  toBool(gtk_expander_get_expanded(cast[ptr Expander00](self.impl)))

proc expanded*(self: Expander): bool =
  toBool(gtk_expander_get_expanded(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_label*(self: ptr Expander00): cstring {.
    importc: "gtk_expander_get_label", libprag.}

proc getLabel*(self: Expander): string =
  let resul0 = gtk_expander_get_label(cast[ptr Expander00](self.impl))
  result = $resul0

proc label*(self: Expander): string =
  let resul0 = gtk_expander_get_label(cast[ptr Expander00](self.impl))
  result = $resul0

proc gtk_expander_get_label_fill*(self: ptr Expander00): gboolean {.
    importc: "gtk_expander_get_label_fill", libprag.}

proc getLabelFill*(self: Expander): bool =
  toBool(gtk_expander_get_label_fill(cast[ptr Expander00](self.impl)))

proc labelFill*(self: Expander): bool =
  toBool(gtk_expander_get_label_fill(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_label_widget*(self: ptr Expander00): ptr Widget00 {.
    importc: "gtk_expander_get_label_widget", libprag.}

proc getLabelWidget*(self: Expander): Widget =
  let gobj = gtk_expander_get_label_widget(cast[ptr Expander00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: Expander): Widget =
  let gobj = gtk_expander_get_label_widget(cast[ptr Expander00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_get_resize_toplevel*(self: ptr Expander00): gboolean {.
    importc: "gtk_expander_get_resize_toplevel", libprag.}

proc getResizeToplevel*(self: Expander): bool =
  toBool(gtk_expander_get_resize_toplevel(cast[ptr Expander00](self.impl)))

proc resizeToplevel*(self: Expander): bool =
  toBool(gtk_expander_get_resize_toplevel(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_spacing*(self: ptr Expander00): int32 {.
    importc: "gtk_expander_get_spacing", libprag.}

proc getSpacing*(self: Expander): int =
  int(gtk_expander_get_spacing(cast[ptr Expander00](self.impl)))

proc spacing*(self: Expander): int =
  int(gtk_expander_get_spacing(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_use_markup*(self: ptr Expander00): gboolean {.
    importc: "gtk_expander_get_use_markup", libprag.}

proc getUseMarkup*(self: Expander): bool =
  toBool(gtk_expander_get_use_markup(cast[ptr Expander00](self.impl)))

proc useMarkup*(self: Expander): bool =
  toBool(gtk_expander_get_use_markup(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_use_underline*(self: ptr Expander00): gboolean {.
    importc: "gtk_expander_get_use_underline", libprag.}

proc getUseUnderline*(self: Expander): bool =
  toBool(gtk_expander_get_use_underline(cast[ptr Expander00](self.impl)))

proc useUnderline*(self: Expander): bool =
  toBool(gtk_expander_get_use_underline(cast[ptr Expander00](self.impl)))

proc gtk_expander_set_expanded*(self: ptr Expander00; expanded: gboolean) {.
    importc: "gtk_expander_set_expanded", libprag.}

proc setExpanded*(self: Expander; expanded: bool) =
  gtk_expander_set_expanded(cast[ptr Expander00](self.impl), gboolean(expanded))

proc `expanded=`*(self: Expander; expanded: bool) =
  gtk_expander_set_expanded(cast[ptr Expander00](self.impl), gboolean(expanded))

proc gtk_expander_set_label*(self: ptr Expander00; label: cstring) {.
    importc: "gtk_expander_set_label", libprag.}

proc setLabel*(self: Expander; label: string) =
  gtk_expander_set_label(cast[ptr Expander00](self.impl), cstring(label))

proc `label=`*(self: Expander; label: string) =
  gtk_expander_set_label(cast[ptr Expander00](self.impl), cstring(label))

proc gtk_expander_set_label_fill*(self: ptr Expander00; labelFill: gboolean) {.
    importc: "gtk_expander_set_label_fill", libprag.}

proc setLabelFill*(self: Expander; labelFill: bool) =
  gtk_expander_set_label_fill(cast[ptr Expander00](self.impl), gboolean(labelFill))

proc `labelFill=`*(self: Expander; labelFill: bool) =
  gtk_expander_set_label_fill(cast[ptr Expander00](self.impl), gboolean(labelFill))

proc gtk_expander_set_label_widget*(self: ptr Expander00; labelWidget: ptr Widget00) {.
    importc: "gtk_expander_set_label_widget", libprag.}

proc setLabelWidget*(self: Expander; labelWidget: Widget) =
  gtk_expander_set_label_widget(cast[ptr Expander00](self.impl), cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: Expander; labelWidget: Widget) =
  gtk_expander_set_label_widget(cast[ptr Expander00](self.impl), cast[ptr Widget00](labelWidget.impl))

proc gtk_expander_set_resize_toplevel*(self: ptr Expander00; resizeToplevel: gboolean) {.
    importc: "gtk_expander_set_resize_toplevel", libprag.}

proc setResizeToplevel*(self: Expander; resizeToplevel: bool) =
  gtk_expander_set_resize_toplevel(cast[ptr Expander00](self.impl), gboolean(resizeToplevel))

proc `resizeToplevel=`*(self: Expander; resizeToplevel: bool) =
  gtk_expander_set_resize_toplevel(cast[ptr Expander00](self.impl), gboolean(resizeToplevel))

proc gtk_expander_set_spacing*(self: ptr Expander00; spacing: int32) {.
    importc: "gtk_expander_set_spacing", libprag.}

proc setSpacing*(self: Expander; spacing: int) =
  gtk_expander_set_spacing(cast[ptr Expander00](self.impl), int32(spacing))

proc `spacing=`*(self: Expander; spacing: int) =
  gtk_expander_set_spacing(cast[ptr Expander00](self.impl), int32(spacing))

proc gtk_expander_set_use_markup*(self: ptr Expander00; useMarkup: gboolean) {.
    importc: "gtk_expander_set_use_markup", libprag.}

proc setUseMarkup*(self: Expander; useMarkup: bool) =
  gtk_expander_set_use_markup(cast[ptr Expander00](self.impl), gboolean(useMarkup))

proc `useMarkup=`*(self: Expander; useMarkup: bool) =
  gtk_expander_set_use_markup(cast[ptr Expander00](self.impl), gboolean(useMarkup))

proc gtk_expander_set_use_underline*(self: ptr Expander00; useUnderline: gboolean) {.
    importc: "gtk_expander_set_use_underline", libprag.}

proc setUseUnderline*(self: Expander; useUnderline: bool) =
  gtk_expander_set_use_underline(cast[ptr Expander00](self.impl), gboolean(useUnderline))

proc `useUnderline=`*(self: Expander; useUnderline: bool) =
  gtk_expander_set_use_underline(cast[ptr Expander00](self.impl), gboolean(useUnderline))

type
  ExpanderAccessiblePrivate00* {.pure.} = object
  ExpanderAccessiblePrivate* = ref object
    impl*: ptr ExpanderAccessiblePrivate00

type
  ExpanderAccessible* = ref object of ContainerAccessible
  ExpanderAccessible00* = object of ContainerAccessible00
    priv4: ptr ExpanderAccessiblePrivate00

type
  ExpanderAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  ExpanderAccessibleClass* = ref object
    impl*: ptr ExpanderAccessibleClass00

type
  ExpanderClass00* {.pure.} = object
    parentClass*: BinClass00
    activate*: proc(expander: ptr Expander00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ExpanderClass* = ref object
    impl*: ptr ExpanderClass00

type
  ExpanderStyle* {.size: sizeof(cint), pure.} = enum
    collapsed = 0
    semiCollapsed = 1
    semiExpanded = 2
    expanded = 3


type
  FileChooserAction* {.size: sizeof(cint), pure.} = enum
    open = 0
    save = 1
    selectFolder = 2
    createFolder = 3

type
  FileChooserButtonPrivate00* {.pure.} = object
  FileChooserButtonPrivate* = ref object
    impl*: ptr FileChooserButtonPrivate00

type
  FileChooserButton* = ref object of Box
  FileChooserButton00* = object of Box00
    priv4: ptr FileChooserButtonPrivate00

proc scFileSet*(self: FileChooserButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "file-set", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_file_chooser_button_new*(title: cstring; action: FileChooserAction): ptr FileChooserButton00 {.
    importc: "gtk_file_chooser_button_new", libprag.}

proc newFileChooserButton*(title: string; action: FileChooserAction): FileChooserButton =
  new(result, finalizeGObject)
  result.impl = gtk_file_chooser_button_new(cstring(title), action)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserButton*[T](result: var T; title: string; action: FileChooserAction) =
  assert(result is FileChooserButton)
  new(result, finalizeGObject)
  result.impl = gtk_file_chooser_button_new(cstring(title), action)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_button_new_with_dialog*(dialog: ptr Dialog00): ptr FileChooserButton00 {.
    importc: "gtk_file_chooser_button_new_with_dialog", libprag.}

proc newFileChooserButtonWithDialog*(dialog: Dialog): FileChooserButton =
  new(result, finalizeGObject)
  result.impl = gtk_file_chooser_button_new_with_dialog(cast[ptr Dialog00](dialog.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserButtonWithDialog*[T](result: var T; dialog: Dialog) =
  assert(result is FileChooserButton)
  new(result, finalizeGObject)
  result.impl = gtk_file_chooser_button_new_with_dialog(cast[ptr Dialog00](dialog.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_button_get_focus_on_click*(self: ptr FileChooserButton00): gboolean {.
    importc: "gtk_file_chooser_button_get_focus_on_click", libprag.}

proc getFocusOnClick*(self: FileChooserButton): bool =
  toBool(gtk_file_chooser_button_get_focus_on_click(cast[ptr FileChooserButton00](self.impl)))

proc focusOnClick*(self: FileChooserButton): bool =
  toBool(gtk_file_chooser_button_get_focus_on_click(cast[ptr FileChooserButton00](self.impl)))

proc gtk_file_chooser_button_get_title*(self: ptr FileChooserButton00): cstring {.
    importc: "gtk_file_chooser_button_get_title", libprag.}

proc getTitle*(self: FileChooserButton): string =
  let resul0 = gtk_file_chooser_button_get_title(cast[ptr FileChooserButton00](self.impl))
  result = $resul0

proc title*(self: FileChooserButton): string =
  let resul0 = gtk_file_chooser_button_get_title(cast[ptr FileChooserButton00](self.impl))
  result = $resul0

proc gtk_file_chooser_button_get_width_chars*(self: ptr FileChooserButton00): int32 {.
    importc: "gtk_file_chooser_button_get_width_chars", libprag.}

proc getWidthChars*(self: FileChooserButton): int =
  int(gtk_file_chooser_button_get_width_chars(cast[ptr FileChooserButton00](self.impl)))

proc widthChars*(self: FileChooserButton): int =
  int(gtk_file_chooser_button_get_width_chars(cast[ptr FileChooserButton00](self.impl)))

proc gtk_file_chooser_button_set_focus_on_click*(self: ptr FileChooserButton00; focusOnClick: gboolean) {.
    importc: "gtk_file_chooser_button_set_focus_on_click", libprag.}

proc setFocusOnClick*(self: FileChooserButton; focusOnClick: bool) =
  gtk_file_chooser_button_set_focus_on_click(cast[ptr FileChooserButton00](self.impl), gboolean(focusOnClick))

proc `focusOnClick=`*(self: FileChooserButton; focusOnClick: bool) =
  gtk_file_chooser_button_set_focus_on_click(cast[ptr FileChooserButton00](self.impl), gboolean(focusOnClick))

proc gtk_file_chooser_button_set_title*(self: ptr FileChooserButton00; title: cstring) {.
    importc: "gtk_file_chooser_button_set_title", libprag.}

proc setTitle*(self: FileChooserButton; title: string) =
  gtk_file_chooser_button_set_title(cast[ptr FileChooserButton00](self.impl), cstring(title))

proc `title=`*(self: FileChooserButton; title: string) =
  gtk_file_chooser_button_set_title(cast[ptr FileChooserButton00](self.impl), cstring(title))

proc gtk_file_chooser_button_set_width_chars*(self: ptr FileChooserButton00; nChars: int32) {.
    importc: "gtk_file_chooser_button_set_width_chars", libprag.}

proc setWidthChars*(self: FileChooserButton; nChars: int) =
  gtk_file_chooser_button_set_width_chars(cast[ptr FileChooserButton00](self.impl), int32(nChars))

proc `widthChars=`*(self: FileChooserButton; nChars: int) =
  gtk_file_chooser_button_set_width_chars(cast[ptr FileChooserButton00](self.impl), int32(nChars))

type
  FileChooserButtonClass00* {.pure.} = object
    parentClass*: BoxClass00
    fileSet*: proc(fc: ptr FileChooserButton00) {.cdecl.}
    GtkReserved1*: pointer
    GtkReserved2*: pointer
    GtkReserved3*: pointer
    GtkReserved4*: pointer
  FileChooserButtonClass* = ref object
    impl*: ptr FileChooserButtonClass00

type
  FileChooserConfirmation* {.size: sizeof(cint), pure.} = enum
    confirm = 0
    acceptFilename = 1
    selectAgain = 2

type
  FileChooserDialogPrivate00* {.pure.} = object
  FileChooserDialogPrivate* = ref object
    impl*: ptr FileChooserDialogPrivate00

type
  FileChooserDialog* = ref object of Dialog
  FileChooserDialog00* = object of Dialog00
    priv6: ptr FileChooserDialogPrivate00

type
  FileChooserDialogClass00* {.pure.} = object
    parentClass*: DialogClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  FileChooserDialogClass* = ref object
    impl*: ptr FileChooserDialogClass00

type
  FileChooserError* {.size: sizeof(cint), pure.} = enum
    nonexistent = 0
    badFilename = 1
    alreadyExists = 2
    incompleteHostname = 3

proc gtk_file_chooser_error_quark*(): uint32 {.
    importc: "gtk_file_chooser_error_quark", libprag.}

type
  NativeDialog* = ref object of gobject.Object
  NativeDialog00* = object of gobject.Object00

proc scResponse*(self: NativeDialog;  p: proc (self: ptr gobject.Object00; responseId: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "response", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_native_dialog_destroy*(self: ptr NativeDialog00) {.
    importc: "gtk_native_dialog_destroy", libprag.}

proc destroy*(self: NativeDialog) =
  gtk_native_dialog_destroy(cast[ptr NativeDialog00](self.impl))

proc gtk_native_dialog_get_modal*(self: ptr NativeDialog00): gboolean {.
    importc: "gtk_native_dialog_get_modal", libprag.}

proc getModal*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_modal(cast[ptr NativeDialog00](self.impl)))

proc modal*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_modal(cast[ptr NativeDialog00](self.impl)))

proc gtk_native_dialog_get_title*(self: ptr NativeDialog00): cstring {.
    importc: "gtk_native_dialog_get_title", libprag.}

proc getTitle*(self: NativeDialog): string =
  let resul0 = gtk_native_dialog_get_title(cast[ptr NativeDialog00](self.impl))
  result = $resul0

proc title*(self: NativeDialog): string =
  let resul0 = gtk_native_dialog_get_title(cast[ptr NativeDialog00](self.impl))
  result = $resul0

proc gtk_native_dialog_get_transient_for*(self: ptr NativeDialog00): ptr Window00 {.
    importc: "gtk_native_dialog_get_transient_for", libprag.}

proc getTransientFor*(self: NativeDialog): Window =
  let gobj = gtk_native_dialog_get_transient_for(cast[ptr NativeDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc transientFor*(self: NativeDialog): Window =
  let gobj = gtk_native_dialog_get_transient_for(cast[ptr NativeDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_native_dialog_get_visible*(self: ptr NativeDialog00): gboolean {.
    importc: "gtk_native_dialog_get_visible", libprag.}

proc getVisible*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_visible(cast[ptr NativeDialog00](self.impl)))

proc visible*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_visible(cast[ptr NativeDialog00](self.impl)))

proc gtk_native_dialog_hide*(self: ptr NativeDialog00) {.
    importc: "gtk_native_dialog_hide", libprag.}

proc hide*(self: NativeDialog) =
  gtk_native_dialog_hide(cast[ptr NativeDialog00](self.impl))

proc gtk_native_dialog_run*(self: ptr NativeDialog00): int32 {.
    importc: "gtk_native_dialog_run", libprag.}

proc run*(self: NativeDialog): int =
  int(gtk_native_dialog_run(cast[ptr NativeDialog00](self.impl)))

proc gtk_native_dialog_set_modal*(self: ptr NativeDialog00; modal: gboolean) {.
    importc: "gtk_native_dialog_set_modal", libprag.}

proc setModal*(self: NativeDialog; modal: bool) =
  gtk_native_dialog_set_modal(cast[ptr NativeDialog00](self.impl), gboolean(modal))

proc `modal=`*(self: NativeDialog; modal: bool) =
  gtk_native_dialog_set_modal(cast[ptr NativeDialog00](self.impl), gboolean(modal))

proc gtk_native_dialog_set_title*(self: ptr NativeDialog00; title: cstring) {.
    importc: "gtk_native_dialog_set_title", libprag.}

proc setTitle*(self: NativeDialog; title: string) =
  gtk_native_dialog_set_title(cast[ptr NativeDialog00](self.impl), cstring(title))

proc `title=`*(self: NativeDialog; title: string) =
  gtk_native_dialog_set_title(cast[ptr NativeDialog00](self.impl), cstring(title))

proc gtk_native_dialog_set_transient_for*(self: ptr NativeDialog00; parent: ptr Window00) {.
    importc: "gtk_native_dialog_set_transient_for", libprag.}

proc setTransientFor*(self: NativeDialog; parent: Window) =
  gtk_native_dialog_set_transient_for(cast[ptr NativeDialog00](self.impl), cast[ptr Window00](parent.impl))

proc `transientFor=`*(self: NativeDialog; parent: Window) =
  gtk_native_dialog_set_transient_for(cast[ptr NativeDialog00](self.impl), cast[ptr Window00](parent.impl))

proc gtk_native_dialog_show*(self: ptr NativeDialog00) {.
    importc: "gtk_native_dialog_show", libprag.}

proc show*(self: NativeDialog) =
  gtk_native_dialog_show(cast[ptr NativeDialog00](self.impl))

type
  FileChooserNative* = ref object of NativeDialog
  FileChooserNative00* = object of NativeDialog00

proc gtk_file_chooser_native_new*(title: cstring; parent: ptr Window00; action: FileChooserAction; 
    acceptLabel: cstring; cancelLabel: cstring): ptr FileChooserNative00 {.
    importc: "gtk_file_chooser_native_new", libprag.}

proc newFileChooserNative*(title: string; parent: Window; action: FileChooserAction; 
    acceptLabel: string; cancelLabel: string): FileChooserNative =
  new(result, finalizeGObject)
  result.impl = gtk_file_chooser_native_new(cstring(title), cast[ptr Window00](parent.impl), action, cstring(acceptLabel), cstring(cancelLabel))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserNative*[T](result: var T; title: string; parent: Window; action: FileChooserAction; 
    acceptLabel: string; cancelLabel: string) =
  assert(result is FileChooserNative)
  new(result, finalizeGObject)
  result.impl = gtk_file_chooser_native_new(cstring(title), cast[ptr Window00](parent.impl), action, cstring(acceptLabel), cstring(cancelLabel))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_native_get_accept_label*(self: ptr FileChooserNative00): cstring {.
    importc: "gtk_file_chooser_native_get_accept_label", libprag.}

proc getAcceptLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_accept_label(cast[ptr FileChooserNative00](self.impl))
  result = $resul0

proc acceptLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_accept_label(cast[ptr FileChooserNative00](self.impl))
  result = $resul0

proc gtk_file_chooser_native_get_cancel_label*(self: ptr FileChooserNative00): cstring {.
    importc: "gtk_file_chooser_native_get_cancel_label", libprag.}

proc getCancelLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_cancel_label(cast[ptr FileChooserNative00](self.impl))
  result = $resul0

proc cancelLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_cancel_label(cast[ptr FileChooserNative00](self.impl))
  result = $resul0

proc gtk_file_chooser_native_set_accept_label*(self: ptr FileChooserNative00; acceptLabel: cstring) {.
    importc: "gtk_file_chooser_native_set_accept_label", libprag.}

proc setAcceptLabel*(self: FileChooserNative; acceptLabel: string) =
  gtk_file_chooser_native_set_accept_label(cast[ptr FileChooserNative00](self.impl), cstring(acceptLabel))

proc `acceptLabel=`*(self: FileChooserNative; acceptLabel: string) =
  gtk_file_chooser_native_set_accept_label(cast[ptr FileChooserNative00](self.impl), cstring(acceptLabel))

proc gtk_file_chooser_native_set_cancel_label*(self: ptr FileChooserNative00; cancelLabel: cstring) {.
    importc: "gtk_file_chooser_native_set_cancel_label", libprag.}

proc setCancelLabel*(self: FileChooserNative; cancelLabel: string) =
  gtk_file_chooser_native_set_cancel_label(cast[ptr FileChooserNative00](self.impl), cstring(cancelLabel))

proc `cancelLabel=`*(self: FileChooserNative; cancelLabel: string) =
  gtk_file_chooser_native_set_cancel_label(cast[ptr FileChooserNative00](self.impl), cstring(cancelLabel))

type
  NativeDialogClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    response*: proc(self: ptr NativeDialog00; responseId: int32) {.cdecl.}
    show*: proc(self: ptr NativeDialog00) {.cdecl.}
    hide*: proc(self: ptr NativeDialog00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  NativeDialogClass* = ref object
    impl*: ptr NativeDialogClass00

type
  FileChooserNativeClass00* {.pure.} = object
    parentClass*: NativeDialogClass00
  FileChooserNativeClass* = ref object
    impl*: ptr FileChooserNativeClass00

type
  FileChooserWidgetPrivate00* {.pure.} = object
  FileChooserWidgetPrivate* = ref object
    impl*: ptr FileChooserWidgetPrivate00

type
  FileChooserWidget* = ref object of Box
  FileChooserWidget00* = object of Box00
    priv4: ptr FileChooserWidgetPrivate00

proc scDesktopFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "desktop-folder", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDownFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "down-folder", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scHomeFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "home-folder", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scLocationPopup*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "location-popup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scLocationPopupOnPaste*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "location-popup-on-paste", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scLocationTogglePopup*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "location-toggle-popup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPlacesShortcut*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "places-shortcut", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scQuickBookmark*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; bookmarkIndex: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "quick-bookmark", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRecentShortcut*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "recent-shortcut", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSearchShortcut*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "search-shortcut", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scShowHidden*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "show-hidden", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUpFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "up-folder", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_file_chooser_widget_new*(action: FileChooserAction): ptr FileChooserWidget00 {.
    importc: "gtk_file_chooser_widget_new", libprag.}

proc newFileChooserWidget*(action: FileChooserAction): FileChooserWidget =
  new(result, finalizeGObject)
  result.impl = gtk_file_chooser_widget_new(action)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserWidget*[T](result: var T; action: FileChooserAction) =
  assert(result is FileChooserWidget)
  new(result, finalizeGObject)
  result.impl = gtk_file_chooser_widget_new(action)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  FileChooserWidgetClass00* {.pure.} = object
    parentClass*: BoxClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  FileChooserWidgetClass* = ref object
    impl*: ptr FileChooserWidgetClass00

type
  FileFilter* = ref object of gobject.InitiallyUnowned
  FileFilter00* = object of gobject.InitiallyUnowned00

proc gtk_file_filter_new*(): ptr FileFilter00 {.
    importc: "gtk_file_filter_new", libprag.}

proc newFileFilter*(): FileFilter =
  new(result, finalizeGObject)
  result.impl = gtk_file_filter_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileFilter*[T](result: var T) =
  assert(result is FileFilter)
  new(result, finalizeGObject)
  result.impl = gtk_file_filter_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_filter_new_from_gvariant*(variant: ptr glib.Variant00): ptr FileFilter00 {.
    importc: "gtk_file_filter_new_from_gvariant", libprag.}

proc newFileFilterFromGvariant*(variant: glib.Variant): FileFilter =
  new(result, finalizeGObject)
  result.impl = gtk_file_filter_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileFilterFromGvariant*[T](result: var T; variant: glib.Variant) =
  assert(result is FileFilter)
  new(result, finalizeGObject)
  result.impl = gtk_file_filter_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_filter_add_mime_type*(self: ptr FileFilter00; mimeType: cstring) {.
    importc: "gtk_file_filter_add_mime_type", libprag.}

proc addMimeType*(self: FileFilter; mimeType: string) =
  gtk_file_filter_add_mime_type(cast[ptr FileFilter00](self.impl), cstring(mimeType))

proc gtk_file_filter_add_pattern*(self: ptr FileFilter00; pattern: cstring) {.
    importc: "gtk_file_filter_add_pattern", libprag.}

proc addPattern*(self: FileFilter; pattern: string) =
  gtk_file_filter_add_pattern(cast[ptr FileFilter00](self.impl), cstring(pattern))

proc gtk_file_filter_add_pixbuf_formats*(self: ptr FileFilter00) {.
    importc: "gtk_file_filter_add_pixbuf_formats", libprag.}

proc addPixbufFormats*(self: FileFilter) =
  gtk_file_filter_add_pixbuf_formats(cast[ptr FileFilter00](self.impl))

proc gtk_file_filter_get_name*(self: ptr FileFilter00): cstring {.
    importc: "gtk_file_filter_get_name", libprag.}

proc getName*(self: FileFilter): string =
  let resul0 = gtk_file_filter_get_name(cast[ptr FileFilter00](self.impl))
  result = $resul0

proc name*(self: FileFilter): string =
  let resul0 = gtk_file_filter_get_name(cast[ptr FileFilter00](self.impl))
  result = $resul0

proc gtk_file_filter_set_name*(self: ptr FileFilter00; name: cstring) {.
    importc: "gtk_file_filter_set_name", libprag.}

proc setName*(self: FileFilter; name: string) =
  gtk_file_filter_set_name(cast[ptr FileFilter00](self.impl), cstring(name))

proc `name=`*(self: FileFilter; name: string) =
  gtk_file_filter_set_name(cast[ptr FileFilter00](self.impl), cstring(name))

proc gtk_file_filter_to_gvariant*(self: ptr FileFilter00): ptr glib.Variant00 {.
    importc: "gtk_file_filter_to_gvariant", libprag.}

proc toGvariant*(self: FileFilter): glib.Variant =
  new(result)
  result.impl = gtk_file_filter_to_gvariant(cast[ptr FileFilter00](self.impl))

type
  FileFilterFlag* {.size: sizeof(cint), pure.} = enum
    filename = 1
    uri = 2
    displayName = 3
    mimeType = 4

  FileFilterFlags* {.size: sizeof(cint).} = set[FileFilterFlag]

type
  FileFilterInfo00* {.pure.} = object
    contains*: FileFilterFlags
    filename*: cstring
    uri*: cstring
    displayName*: cstring
    mimeType*: cstring
  FileFilterInfo* = ref object
    impl*: ptr FileFilterInfo00

proc gtk_file_filter_filter*(self: ptr FileFilter00; filterInfo: ptr FileFilterInfo00): gboolean {.
    importc: "gtk_file_filter_filter", libprag.}

proc filter*(self: FileFilter; filterInfo: FileFilterInfo): bool =
  toBool(gtk_file_filter_filter(cast[ptr FileFilter00](self.impl), cast[ptr FileFilterInfo00](filterInfo.impl)))

proc gtk_file_filter_get_needed*(self: ptr FileFilter00): FileFilterFlags {.
    importc: "gtk_file_filter_get_needed", libprag.}

proc getNeeded*(self: FileFilter): FileFilterFlags =
  gtk_file_filter_get_needed(cast[ptr FileFilter00](self.impl))

proc needed*(self: FileFilter): FileFilterFlags =
  gtk_file_filter_get_needed(cast[ptr FileFilter00](self.impl))

type
  FileFilterFunc* = proc (filterInfo: ptr FileFilterInfo00; data: pointer): gboolean {.cdecl.}

proc gtk_file_filter_add_custom*(self: ptr FileFilter00; needed: FileFilterFlags; `func`: FileFilterFunc; 
    data: pointer; notify: DestroyNotify) {.
    importc: "gtk_file_filter_add_custom", libprag.}

proc addCustom*(self: FileFilter; needed: FileFilterFlags; `func`: FileFilterFunc; 
    data: pointer; notify: DestroyNotify) =
  gtk_file_filter_add_custom(cast[ptr FileFilter00](self.impl), needed, `func`, data, notify)

type
  FixedPrivate00* {.pure.} = object
  FixedPrivate* = ref object
    impl*: ptr FixedPrivate00

type
  Fixed* = ref object of Container
  Fixed00* = object of Container00
    priv3: ptr FixedPrivate00

proc gtk_fixed_new*(): ptr Fixed00 {.
    importc: "gtk_fixed_new", libprag.}

proc newFixed*(): Fixed =
  new(result, finalizeGObject)
  result.impl = gtk_fixed_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFixed*[T](result: var T) =
  assert(result is Fixed)
  new(result, finalizeGObject)
  result.impl = gtk_fixed_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_fixed_move*(self: ptr Fixed00; widget: ptr Widget00; x: int32; 
    y: int32) {.
    importc: "gtk_fixed_move", libprag.}

proc move*(self: Fixed; widget: Widget; x: int; y: int) =
  gtk_fixed_move(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl), int32(x), int32(y))

proc gtk_fixed_put*(self: ptr Fixed00; widget: ptr Widget00; x: int32; 
    y: int32) {.
    importc: "gtk_fixed_put", libprag.}

proc put*(self: Fixed; widget: Widget; x: int; y: int) =
  gtk_fixed_put(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl), int32(x), int32(y))

type
  FixedChild00* {.pure.} = object
    widget*: ptr Widget00
    x*: int32
    y*: int32
  FixedChild* = ref object
    impl*: ptr FixedChild00

type
  FixedClass00* {.pure.} = object
    parentClass*: ContainerClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  FixedClass* = ref object
    impl*: ptr FixedClass00

type
  FlowBoxChild* = ref object of Bin
  FlowBoxChild00* = object of Bin00

proc scActivate*(self: FlowBoxChild;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_flow_box_child_new*(): ptr FlowBoxChild00 {.
    importc: "gtk_flow_box_child_new", libprag.}

proc newFlowBoxChild*(): FlowBoxChild =
  new(result, finalizeGObject)
  result.impl = gtk_flow_box_child_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFlowBoxChild*[T](result: var T) =
  assert(result is FlowBoxChild)
  new(result, finalizeGObject)
  result.impl = gtk_flow_box_child_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_child_changed*(self: ptr FlowBoxChild00) {.
    importc: "gtk_flow_box_child_changed", libprag.}

proc changed*(self: FlowBoxChild) =
  gtk_flow_box_child_changed(cast[ptr FlowBoxChild00](self.impl))

proc gtk_flow_box_child_get_index*(self: ptr FlowBoxChild00): int32 {.
    importc: "gtk_flow_box_child_get_index", libprag.}

proc getIndex*(self: FlowBoxChild): int =
  int(gtk_flow_box_child_get_index(cast[ptr FlowBoxChild00](self.impl)))

proc index*(self: FlowBoxChild): int =
  int(gtk_flow_box_child_get_index(cast[ptr FlowBoxChild00](self.impl)))

proc gtk_flow_box_child_is_selected*(self: ptr FlowBoxChild00): gboolean {.
    importc: "gtk_flow_box_child_is_selected", libprag.}

proc isSelected*(self: FlowBoxChild): bool =
  toBool(gtk_flow_box_child_is_selected(cast[ptr FlowBoxChild00](self.impl)))

type
  FlowBox* = ref object of Container
  FlowBox00* = object of Container00

proc scActivateCursorChild*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-cursor-child", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scChildActivated*(self: FlowBox;  p: proc (self: ptr gobject.Object00; child: FlowBoxChild00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "child-activated", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveCursor*(self: FlowBox;  p: proc (self: ptr gobject.Object00; step: MovementStep; count: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectAll*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectedChildrenChanged*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "selected-children-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleCursorChild*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-cursor-child", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUnselectAll*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_flow_box_new*(): ptr FlowBox00 {.
    importc: "gtk_flow_box_new", libprag.}

proc newFlowBox*(): FlowBox =
  new(result, finalizeGObject)
  result.impl = gtk_flow_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFlowBox*[T](result: var T) =
  assert(result is FlowBox)
  new(result, finalizeGObject)
  result.impl = gtk_flow_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_get_activate_on_single_click*(self: ptr FlowBox00): gboolean {.
    importc: "gtk_flow_box_get_activate_on_single_click", libprag.}

proc getActivateOnSingleClick*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_activate_on_single_click(cast[ptr FlowBox00](self.impl)))

proc activateOnSingleClick*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_activate_on_single_click(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_child_at_index*(self: ptr FlowBox00; idx: int32): ptr FlowBoxChild00 {.
    importc: "gtk_flow_box_get_child_at_index", libprag.}

proc getChildAtIndex*(self: FlowBox; idx: int): FlowBoxChild =
  let gobj = gtk_flow_box_get_child_at_index(cast[ptr FlowBox00](self.impl), int32(idx))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[FlowBoxChild](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc childAtIndex*(self: FlowBox; idx: int): FlowBoxChild =
  let gobj = gtk_flow_box_get_child_at_index(cast[ptr FlowBox00](self.impl), int32(idx))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[FlowBoxChild](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_get_child_at_pos*(self: ptr FlowBox00; x: int32; y: int32): ptr FlowBoxChild00 {.
    importc: "gtk_flow_box_get_child_at_pos", libprag.}

proc getChildAtPos*(self: FlowBox; x: int; y: int): FlowBoxChild =
  let gobj = gtk_flow_box_get_child_at_pos(cast[ptr FlowBox00](self.impl), int32(x), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[FlowBoxChild](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc childAtPos*(self: FlowBox; x: int; y: int): FlowBoxChild =
  let gobj = gtk_flow_box_get_child_at_pos(cast[ptr FlowBox00](self.impl), int32(x), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[FlowBoxChild](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_get_column_spacing*(self: ptr FlowBox00): uint32 {.
    importc: "gtk_flow_box_get_column_spacing", libprag.}

proc getColumnSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_column_spacing(cast[ptr FlowBox00](self.impl)))

proc columnSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_column_spacing(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_homogeneous*(self: ptr FlowBox00): gboolean {.
    importc: "gtk_flow_box_get_homogeneous", libprag.}

proc getHomogeneous*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_homogeneous(cast[ptr FlowBox00](self.impl)))

proc homogeneous*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_homogeneous(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_max_children_per_line*(self: ptr FlowBox00): uint32 {.
    importc: "gtk_flow_box_get_max_children_per_line", libprag.}

proc getMaxChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_max_children_per_line(cast[ptr FlowBox00](self.impl)))

proc maxChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_max_children_per_line(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_min_children_per_line*(self: ptr FlowBox00): uint32 {.
    importc: "gtk_flow_box_get_min_children_per_line", libprag.}

proc getMinChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_min_children_per_line(cast[ptr FlowBox00](self.impl)))

proc minChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_min_children_per_line(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_row_spacing*(self: ptr FlowBox00): uint32 {.
    importc: "gtk_flow_box_get_row_spacing", libprag.}

proc getRowSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_row_spacing(cast[ptr FlowBox00](self.impl)))

proc rowSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_row_spacing(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_selected_children*(self: ptr FlowBox00): ptr pointer {.
    importc: "gtk_flow_box_get_selected_children", libprag.}

proc getSelectedChildren*(self: FlowBox): ptr pointer =
  gtk_flow_box_get_selected_children(cast[ptr FlowBox00](self.impl))

proc selectedChildren*(self: FlowBox): ptr pointer =
  gtk_flow_box_get_selected_children(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_insert*(self: ptr FlowBox00; widget: ptr Widget00; position: int32) {.
    importc: "gtk_flow_box_insert", libprag.}

proc insert*(self: FlowBox; widget: Widget; position: int) =
  gtk_flow_box_insert(cast[ptr FlowBox00](self.impl), cast[ptr Widget00](widget.impl), int32(position))

proc gtk_flow_box_invalidate_filter*(self: ptr FlowBox00) {.
    importc: "gtk_flow_box_invalidate_filter", libprag.}

proc invalidateFilter*(self: FlowBox) =
  gtk_flow_box_invalidate_filter(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_invalidate_sort*(self: ptr FlowBox00) {.
    importc: "gtk_flow_box_invalidate_sort", libprag.}

proc invalidateSort*(self: FlowBox) =
  gtk_flow_box_invalidate_sort(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_select_all*(self: ptr FlowBox00) {.
    importc: "gtk_flow_box_select_all", libprag.}

proc selectAll*(self: FlowBox) =
  gtk_flow_box_select_all(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_select_child*(self: ptr FlowBox00; child: ptr FlowBoxChild00) {.
    importc: "gtk_flow_box_select_child", libprag.}

proc selectChild*(self: FlowBox; child: FlowBoxChild) =
  gtk_flow_box_select_child(cast[ptr FlowBox00](self.impl), cast[ptr FlowBoxChild00](child.impl))

proc gtk_flow_box_set_activate_on_single_click*(self: ptr FlowBox00; single: gboolean) {.
    importc: "gtk_flow_box_set_activate_on_single_click", libprag.}

proc setActivateOnSingleClick*(self: FlowBox; single: bool) =
  gtk_flow_box_set_activate_on_single_click(cast[ptr FlowBox00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: FlowBox; single: bool) =
  gtk_flow_box_set_activate_on_single_click(cast[ptr FlowBox00](self.impl), gboolean(single))

proc gtk_flow_box_set_column_spacing*(self: ptr FlowBox00; spacing: uint32) {.
    importc: "gtk_flow_box_set_column_spacing", libprag.}

proc setColumnSpacing*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_column_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc `columnSpacing=`*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_column_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc gtk_flow_box_set_hadjustment*(self: ptr FlowBox00; adjustment: ptr Adjustment00) {.
    importc: "gtk_flow_box_set_hadjustment", libprag.}

proc setHadjustment*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_hadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `hadjustment=`*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_hadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_flow_box_set_homogeneous*(self: ptr FlowBox00; homogeneous: gboolean) {.
    importc: "gtk_flow_box_set_homogeneous", libprag.}

proc setHomogeneous*(self: FlowBox; homogeneous: bool) =
  gtk_flow_box_set_homogeneous(cast[ptr FlowBox00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: FlowBox; homogeneous: bool) =
  gtk_flow_box_set_homogeneous(cast[ptr FlowBox00](self.impl), gboolean(homogeneous))

proc gtk_flow_box_set_max_children_per_line*(self: ptr FlowBox00; nChildren: uint32) {.
    importc: "gtk_flow_box_set_max_children_per_line", libprag.}

proc setMaxChildrenPerLine*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_max_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc `maxChildrenPerLine=`*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_max_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc gtk_flow_box_set_min_children_per_line*(self: ptr FlowBox00; nChildren: uint32) {.
    importc: "gtk_flow_box_set_min_children_per_line", libprag.}

proc setMinChildrenPerLine*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_min_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc `minChildrenPerLine=`*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_min_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc gtk_flow_box_set_row_spacing*(self: ptr FlowBox00; spacing: uint32) {.
    importc: "gtk_flow_box_set_row_spacing", libprag.}

proc setRowSpacing*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_row_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc `rowSpacing=`*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_row_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc gtk_flow_box_set_vadjustment*(self: ptr FlowBox00; adjustment: ptr Adjustment00) {.
    importc: "gtk_flow_box_set_vadjustment", libprag.}

proc setVadjustment*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_vadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `vadjustment=`*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_vadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_flow_box_unselect_all*(self: ptr FlowBox00) {.
    importc: "gtk_flow_box_unselect_all", libprag.}

proc unselectAll*(self: FlowBox) =
  gtk_flow_box_unselect_all(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_unselect_child*(self: ptr FlowBox00; child: ptr FlowBoxChild00) {.
    importc: "gtk_flow_box_unselect_child", libprag.}

proc unselectChild*(self: FlowBox; child: FlowBoxChild) =
  gtk_flow_box_unselect_child(cast[ptr FlowBox00](self.impl), cast[ptr FlowBoxChild00](child.impl))

type
  SelectionMode* {.size: sizeof(cint), pure.} = enum
    none = 0
    single = 1
    browse = 2
    multiple = 3

proc gtk_flow_box_get_selection_mode*(self: ptr FlowBox00): SelectionMode {.
    importc: "gtk_flow_box_get_selection_mode", libprag.}

proc getSelectionMode*(self: FlowBox): SelectionMode =
  gtk_flow_box_get_selection_mode(cast[ptr FlowBox00](self.impl))

proc selectionMode*(self: FlowBox): SelectionMode =
  gtk_flow_box_get_selection_mode(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_set_selection_mode*(self: ptr FlowBox00; mode: SelectionMode) {.
    importc: "gtk_flow_box_set_selection_mode", libprag.}

proc setSelectionMode*(self: FlowBox; mode: SelectionMode) =
  gtk_flow_box_set_selection_mode(cast[ptr FlowBox00](self.impl), mode)

proc `selectionMode=`*(self: FlowBox; mode: SelectionMode) =
  gtk_flow_box_set_selection_mode(cast[ptr FlowBox00](self.impl), mode)

type
  FlowBoxAccessiblePrivate00* {.pure.} = object
  FlowBoxAccessiblePrivate* = ref object
    impl*: ptr FlowBoxAccessiblePrivate00

type
  FlowBoxAccessible* = ref object of ContainerAccessible
  FlowBoxAccessible00* = object of ContainerAccessible00
    priv4: ptr FlowBoxAccessiblePrivate00

type
  FlowBoxAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  FlowBoxAccessibleClass* = ref object
    impl*: ptr FlowBoxAccessibleClass00

type
  FlowBoxChildAccessible* = ref object of ContainerAccessible
  FlowBoxChildAccessible00* = object of ContainerAccessible00

type
  FlowBoxChildAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  FlowBoxChildAccessibleClass* = ref object
    impl*: ptr FlowBoxChildAccessibleClass00

type
  FlowBoxChildClass00* {.pure.} = object
    parentClass*: BinClass00
    activate*: proc(child: ptr FlowBoxChild00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
  FlowBoxChildClass* = ref object
    impl*: ptr FlowBoxChildClass00

type
  FlowBoxClass00* {.pure.} = object
    parentClass*: ContainerClass00
    childActivated*: proc(box: ptr FlowBox00; child: ptr FlowBoxChild00) {.cdecl.}
    selectedChildrenChanged*: proc(box: ptr FlowBox00) {.cdecl.}
    activateCursorChild*: proc(box: ptr FlowBox00) {.cdecl.}
    toggleCursorChild*: proc(box: ptr FlowBox00) {.cdecl.}
    moveCursor*: proc(box: ptr FlowBox00; step: MovementStep; count: int32): gboolean {.cdecl.}
    selectAll*: proc(box: ptr FlowBox00) {.cdecl.}
    unselectAll*: proc(box: ptr FlowBox00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
  FlowBoxClass* = ref object
    impl*: ptr FlowBoxClass00

type
  FlowBoxCreateWidgetFunc* = proc (item: pointer; userData: pointer): ptr Widget00 {.cdecl.}

proc gtk_flow_box_bind_model*(self: ptr FlowBox00; model: ptr gio.ListModel00; createWidgetFunc: FlowBoxCreateWidgetFunc; 
    userData: pointer; userDataFreeFunc: DestroyNotify) {.
    importc: "gtk_flow_box_bind_model", libprag.}

proc bindModel*(self: FlowBox; model: gio.ListModel; createWidgetFunc: FlowBoxCreateWidgetFunc; 
    userData: pointer; userDataFreeFunc: DestroyNotify) =
  gtk_flow_box_bind_model(cast[ptr FlowBox00](self.impl), cast[ptr gio.ListModel00](model.impl), createWidgetFunc, userData, userDataFreeFunc)

type
  FlowBoxFilterFunc* = proc (child: ptr FlowBoxChild00; userData: pointer): gboolean {.cdecl.}

proc gtk_flow_box_set_filter_func*(self: ptr FlowBox00; filterFunc: FlowBoxFilterFunc; 
    userData: pointer; destroy: DestroyNotify) {.
    importc: "gtk_flow_box_set_filter_func", libprag.}

proc setFilterFunc*(self: FlowBox; filterFunc: FlowBoxFilterFunc; userData: pointer; 
    destroy: DestroyNotify) =
  gtk_flow_box_set_filter_func(cast[ptr FlowBox00](self.impl), filterFunc, userData, destroy)

type
  FlowBoxForeachFunc* = proc (box: ptr FlowBox00; child: ptr FlowBoxChild00; userData: pointer) {.cdecl.}

proc gtk_flow_box_selected_foreach*(self: ptr FlowBox00; `func`: FlowBoxForeachFunc; data: pointer) {.
    importc: "gtk_flow_box_selected_foreach", libprag.}

proc selectedForeach*(self: FlowBox; `func`: FlowBoxForeachFunc; data: pointer) =
  gtk_flow_box_selected_foreach(cast[ptr FlowBox00](self.impl), `func`, data)

type
  FlowBoxSortFunc* = proc (child1: ptr FlowBoxChild00; child2: ptr FlowBoxChild00; 
    userData: pointer): int32 {.cdecl.}

proc gtk_flow_box_set_sort_func*(self: ptr FlowBox00; sortFunc: FlowBoxSortFunc; userData: pointer; 
    destroy: DestroyNotify) {.
    importc: "gtk_flow_box_set_sort_func", libprag.}

proc setSortFunc*(self: FlowBox; sortFunc: FlowBoxSortFunc; userData: pointer; 
    destroy: DestroyNotify) =
  gtk_flow_box_set_sort_func(cast[ptr FlowBox00](self.impl), sortFunc, userData, destroy)

type
  FontButtonPrivate00* {.pure.} = object
  FontButtonPrivate* = ref object
    impl*: ptr FontButtonPrivate00

type
  FontButton* = ref object of Button
  FontButton00* = object of Button00
    priv5: ptr FontButtonPrivate00

proc scFontSet*(self: FontButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "font-set", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_font_button_new*(): ptr FontButton00 {.
    importc: "gtk_font_button_new", libprag.}

proc newFontButton*(): FontButton =
  new(result, finalizeGObject)
  result.impl = gtk_font_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontButton*[T](result: var T) =
  assert(result is FontButton)
  new(result, finalizeGObject)
  result.impl = gtk_font_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_button_new_with_font*(fontname: cstring): ptr FontButton00 {.
    importc: "gtk_font_button_new_with_font", libprag.}

proc newFontButtonWithFont*(fontname: string): FontButton =
  new(result, finalizeGObject)
  result.impl = gtk_font_button_new_with_font(cstring(fontname))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontButtonWithFont*[T](result: var T; fontname: string) =
  assert(result is FontButton)
  new(result, finalizeGObject)
  result.impl = gtk_font_button_new_with_font(cstring(fontname))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_button_get_font_name*(self: ptr FontButton00): cstring {.
    importc: "gtk_font_button_get_font_name", libprag.}

proc getFontName*(self: FontButton): string =
  let resul0 = gtk_font_button_get_font_name(cast[ptr FontButton00](self.impl))
  result = $resul0

proc fontName*(self: FontButton): string =
  let resul0 = gtk_font_button_get_font_name(cast[ptr FontButton00](self.impl))
  result = $resul0

proc gtk_font_button_get_show_size*(self: ptr FontButton00): gboolean {.
    importc: "gtk_font_button_get_show_size", libprag.}

proc getShowSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_show_size(cast[ptr FontButton00](self.impl)))

proc showSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_show_size(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_get_show_style*(self: ptr FontButton00): gboolean {.
    importc: "gtk_font_button_get_show_style", libprag.}

proc getShowStyle*(self: FontButton): bool =
  toBool(gtk_font_button_get_show_style(cast[ptr FontButton00](self.impl)))

proc showStyle*(self: FontButton): bool =
  toBool(gtk_font_button_get_show_style(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_get_title*(self: ptr FontButton00): cstring {.
    importc: "gtk_font_button_get_title", libprag.}

proc getTitle*(self: FontButton): string =
  let resul0 = gtk_font_button_get_title(cast[ptr FontButton00](self.impl))
  result = $resul0

proc title*(self: FontButton): string =
  let resul0 = gtk_font_button_get_title(cast[ptr FontButton00](self.impl))
  result = $resul0

proc gtk_font_button_get_use_font*(self: ptr FontButton00): gboolean {.
    importc: "gtk_font_button_get_use_font", libprag.}

proc getUseFont*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_font(cast[ptr FontButton00](self.impl)))

proc useFont*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_font(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_get_use_size*(self: ptr FontButton00): gboolean {.
    importc: "gtk_font_button_get_use_size", libprag.}

proc getUseSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_size(cast[ptr FontButton00](self.impl)))

proc useSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_size(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_set_font_name*(self: ptr FontButton00; fontname: cstring): gboolean {.
    importc: "gtk_font_button_set_font_name", libprag.}

proc setFontName*(self: FontButton; fontname: string): bool =
  toBool(gtk_font_button_set_font_name(cast[ptr FontButton00](self.impl), cstring(fontname)))

proc `fontName=`*(self: FontButton; fontname: string): bool =
  toBool(gtk_font_button_set_font_name(cast[ptr FontButton00](self.impl), cstring(fontname)))

proc gtk_font_button_set_show_size*(self: ptr FontButton00; showSize: gboolean) {.
    importc: "gtk_font_button_set_show_size", libprag.}

proc setShowSize*(self: FontButton; showSize: bool) =
  gtk_font_button_set_show_size(cast[ptr FontButton00](self.impl), gboolean(showSize))

proc `showSize=`*(self: FontButton; showSize: bool) =
  gtk_font_button_set_show_size(cast[ptr FontButton00](self.impl), gboolean(showSize))

proc gtk_font_button_set_show_style*(self: ptr FontButton00; showStyle: gboolean) {.
    importc: "gtk_font_button_set_show_style", libprag.}

proc setShowStyle*(self: FontButton; showStyle: bool) =
  gtk_font_button_set_show_style(cast[ptr FontButton00](self.impl), gboolean(showStyle))

proc `showStyle=`*(self: FontButton; showStyle: bool) =
  gtk_font_button_set_show_style(cast[ptr FontButton00](self.impl), gboolean(showStyle))

proc gtk_font_button_set_title*(self: ptr FontButton00; title: cstring) {.
    importc: "gtk_font_button_set_title", libprag.}

proc setTitle*(self: FontButton; title: string) =
  gtk_font_button_set_title(cast[ptr FontButton00](self.impl), cstring(title))

proc `title=`*(self: FontButton; title: string) =
  gtk_font_button_set_title(cast[ptr FontButton00](self.impl), cstring(title))

proc gtk_font_button_set_use_font*(self: ptr FontButton00; useFont: gboolean) {.
    importc: "gtk_font_button_set_use_font", libprag.}

proc setUseFont*(self: FontButton; useFont: bool) =
  gtk_font_button_set_use_font(cast[ptr FontButton00](self.impl), gboolean(useFont))

proc `useFont=`*(self: FontButton; useFont: bool) =
  gtk_font_button_set_use_font(cast[ptr FontButton00](self.impl), gboolean(useFont))

proc gtk_font_button_set_use_size*(self: ptr FontButton00; useSize: gboolean) {.
    importc: "gtk_font_button_set_use_size", libprag.}

proc setUseSize*(self: FontButton; useSize: bool) =
  gtk_font_button_set_use_size(cast[ptr FontButton00](self.impl), gboolean(useSize))

proc `useSize=`*(self: FontButton; useSize: bool) =
  gtk_font_button_set_use_size(cast[ptr FontButton00](self.impl), gboolean(useSize))

type
  FontButtonClass00* {.pure.} = object
    parentClass*: ButtonClass00
    fontSet*: proc(gfp: ptr FontButton00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  FontButtonClass* = ref object
    impl*: ptr FontButtonClass00

type
  FontChooser00* {.pure.} = object
  FontChooser* = ref object
    impl*: ptr FontChooser00

proc gtk_font_chooser_get_font*(self: ptr FontChooser00): cstring {.
    importc: "gtk_font_chooser_get_font", libprag.}

proc getFont*(self: FontChooser): string =
  let resul0 = gtk_font_chooser_get_font(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc font*(self: FontChooser): string =
  let resul0 = gtk_font_chooser_get_font(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_font_desc*(self: ptr FontChooser00): ptr pango.FontDescription00 {.
    importc: "gtk_font_chooser_get_font_desc", libprag.}

proc getFontDesc*(self: FontChooser): pango.FontDescription =
  new(result)
  result.impl = gtk_font_chooser_get_font_desc(cast[ptr FontChooser00](self.impl))

proc fontDesc*(self: FontChooser): pango.FontDescription =
  new(result)
  result.impl = gtk_font_chooser_get_font_desc(cast[ptr FontChooser00](self.impl))

proc gtk_font_chooser_get_font_face*(self: ptr FontChooser00): ptr pango.FontFace00 {.
    importc: "gtk_font_chooser_get_font_face", libprag.}

proc getFontFace*(self: FontChooser): pango.FontFace =
  let gobj = gtk_font_chooser_get_font_face(cast[ptr FontChooser00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontFace](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontFace*(self: FontChooser): pango.FontFace =
  let gobj = gtk_font_chooser_get_font_face(cast[ptr FontChooser00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontFace](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_chooser_get_font_family*(self: ptr FontChooser00): ptr pango.FontFamily00 {.
    importc: "gtk_font_chooser_get_font_family", libprag.}

proc getFontFamily*(self: FontChooser): pango.FontFamily =
  let gobj = gtk_font_chooser_get_font_family(cast[ptr FontChooser00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontFamily](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontFamily*(self: FontChooser): pango.FontFamily =
  let gobj = gtk_font_chooser_get_font_family(cast[ptr FontChooser00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontFamily](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_chooser_get_font_map*(self: ptr FontChooser00): ptr pango.FontMap00 {.
    importc: "gtk_font_chooser_get_font_map", libprag.}

proc getFontMap*(self: FontChooser): pango.FontMap =
  let gobj = gtk_font_chooser_get_font_map(cast[ptr FontChooser00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontMap](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontMap*(self: FontChooser): pango.FontMap =
  let gobj = gtk_font_chooser_get_font_map(cast[ptr FontChooser00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontMap](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_chooser_get_font_size*(self: ptr FontChooser00): int32 {.
    importc: "gtk_font_chooser_get_font_size", libprag.}

proc getFontSize*(self: FontChooser): int =
  int(gtk_font_chooser_get_font_size(cast[ptr FontChooser00](self.impl)))

proc fontSize*(self: FontChooser): int =
  int(gtk_font_chooser_get_font_size(cast[ptr FontChooser00](self.impl)))

proc gtk_font_chooser_get_preview_text*(self: ptr FontChooser00): cstring {.
    importc: "gtk_font_chooser_get_preview_text", libprag.}

proc getPreviewText*(self: FontChooser): string =
  let resul0 = gtk_font_chooser_get_preview_text(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc previewText*(self: FontChooser): string =
  let resul0 = gtk_font_chooser_get_preview_text(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_show_preview_entry*(self: ptr FontChooser00): gboolean {.
    importc: "gtk_font_chooser_get_show_preview_entry", libprag.}

proc getShowPreviewEntry*(self: FontChooser): bool =
  toBool(gtk_font_chooser_get_show_preview_entry(cast[ptr FontChooser00](self.impl)))

proc showPreviewEntry*(self: FontChooser): bool =
  toBool(gtk_font_chooser_get_show_preview_entry(cast[ptr FontChooser00](self.impl)))

proc gtk_font_chooser_set_font*(self: ptr FontChooser00; fontname: cstring) {.
    importc: "gtk_font_chooser_set_font", libprag.}

proc setFont*(self: FontChooser; fontname: string) =
  gtk_font_chooser_set_font(cast[ptr FontChooser00](self.impl), cstring(fontname))

proc `font=`*(self: FontChooser; fontname: string) =
  gtk_font_chooser_set_font(cast[ptr FontChooser00](self.impl), cstring(fontname))

proc gtk_font_chooser_set_font_desc*(self: ptr FontChooser00; fontDesc: ptr pango.FontDescription00) {.
    importc: "gtk_font_chooser_set_font_desc", libprag.}

proc setFontDesc*(self: FontChooser; fontDesc: pango.FontDescription) =
  gtk_font_chooser_set_font_desc(cast[ptr FontChooser00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc `fontDesc=`*(self: FontChooser; fontDesc: pango.FontDescription) =
  gtk_font_chooser_set_font_desc(cast[ptr FontChooser00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc gtk_font_chooser_set_font_map*(self: ptr FontChooser00; fontmap: ptr pango.FontMap00) {.
    importc: "gtk_font_chooser_set_font_map", libprag.}

proc setFontMap*(self: FontChooser; fontmap: pango.FontMap) =
  gtk_font_chooser_set_font_map(cast[ptr FontChooser00](self.impl), cast[ptr pango.FontMap00](fontmap.impl))

proc `fontMap=`*(self: FontChooser; fontmap: pango.FontMap) =
  gtk_font_chooser_set_font_map(cast[ptr FontChooser00](self.impl), cast[ptr pango.FontMap00](fontmap.impl))

proc gtk_font_chooser_set_preview_text*(self: ptr FontChooser00; text: cstring) {.
    importc: "gtk_font_chooser_set_preview_text", libprag.}

proc setPreviewText*(self: FontChooser; text: string) =
  gtk_font_chooser_set_preview_text(cast[ptr FontChooser00](self.impl), cstring(text))

proc `previewText=`*(self: FontChooser; text: string) =
  gtk_font_chooser_set_preview_text(cast[ptr FontChooser00](self.impl), cstring(text))

proc gtk_font_chooser_set_show_preview_entry*(self: ptr FontChooser00; showPreviewEntry: gboolean) {.
    importc: "gtk_font_chooser_set_show_preview_entry", libprag.}

proc setShowPreviewEntry*(self: FontChooser; showPreviewEntry: bool) =
  gtk_font_chooser_set_show_preview_entry(cast[ptr FontChooser00](self.impl), gboolean(showPreviewEntry))

proc `showPreviewEntry=`*(self: FontChooser; showPreviewEntry: bool) =
  gtk_font_chooser_set_show_preview_entry(cast[ptr FontChooser00](self.impl), gboolean(showPreviewEntry))

type
  FontChooserDialogPrivate00* {.pure.} = object
  FontChooserDialogPrivate* = ref object
    impl*: ptr FontChooserDialogPrivate00

type
  FontChooserDialog* = ref object of Dialog
  FontChooserDialog00* = object of Dialog00
    priv6: ptr FontChooserDialogPrivate00

proc gtk_font_chooser_dialog_new*(title: cstring; parent: ptr Window00): ptr FontChooserDialog00 {.
    importc: "gtk_font_chooser_dialog_new", libprag.}

proc newFontChooserDialog*(title: string; parent: Window): FontChooserDialog =
  new(result, finalizeGObject)
  result.impl = gtk_font_chooser_dialog_new(cstring(title), cast[ptr Window00](parent.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontChooserDialog*[T](result: var T; title: string; parent: Window) =
  assert(result is FontChooserDialog)
  new(result, finalizeGObject)
  result.impl = gtk_font_chooser_dialog_new(cstring(title), cast[ptr Window00](parent.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  FontChooserDialogClass00* {.pure.} = object
    parentClass*: DialogClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  FontChooserDialogClass* = ref object
    impl*: ptr FontChooserDialogClass00

type
  FontChooserWidgetPrivate00* {.pure.} = object
  FontChooserWidgetPrivate* = ref object
    impl*: ptr FontChooserWidgetPrivate00

type
  FontChooserWidget* = ref object of Box
  FontChooserWidget00* = object of Box00
    priv4: ptr FontChooserWidgetPrivate00

proc gtk_font_chooser_widget_new*(): ptr FontChooserWidget00 {.
    importc: "gtk_font_chooser_widget_new", libprag.}

proc newFontChooserWidget*(): FontChooserWidget =
  new(result, finalizeGObject)
  result.impl = gtk_font_chooser_widget_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontChooserWidget*[T](result: var T) =
  assert(result is FontChooserWidget)
  new(result, finalizeGObject)
  result.impl = gtk_font_chooser_widget_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  FontChooserWidgetClass00* {.pure.} = object
    parentClass*: BoxClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  FontChooserWidgetClass* = ref object
    impl*: ptr FontChooserWidgetClass00

type
  FontFilterFunc* = proc (family: ptr pango.FontFamily00; face: ptr pango.FontFace00; 
    data: pointer): gboolean {.cdecl.}

type
  FontChooserIface00* {.pure.} = object
    baseIface*: gobject.TypeInterface00
    getFontFamily*: proc(fontchooser: ptr FontChooser00): ptr pango.FontFamily00 {.cdecl.}
    getFontFace*: proc(fontchooser: ptr FontChooser00): ptr pango.FontFace00 {.cdecl.}
    getFontSize*: proc(fontchooser: ptr FontChooser00): int32 {.cdecl.}
    setFilterFunc*: proc(fontchooser: ptr FontChooser00; filter: FontFilterFunc; 
    userData: pointer; destroy: DestroyNotify) {.cdecl.}
    fontActivated*: proc(chooser: ptr FontChooser00; fontname: cstring) {.cdecl.}
    setFontMap*: proc(fontchooser: ptr FontChooser00; fontmap: ptr pango.FontMap00) {.cdecl.}
    getFontMap*: proc(fontchooser: ptr FontChooser00): ptr pango.FontMap00 {.cdecl.}
    padding*: array[10, pointer]
  FontChooserIface* = ref object
    impl*: ptr FontChooserIface00

proc gtk_font_chooser_set_filter_func*(self: ptr FontChooser00; filter: FontFilterFunc; userData: pointer; 
    destroy: DestroyNotify) {.
    importc: "gtk_font_chooser_set_filter_func", libprag.}

proc setFilterFunc*(self: FontChooser; filter: FontFilterFunc; userData: pointer; 
    destroy: DestroyNotify) =
  gtk_font_chooser_set_filter_func(cast[ptr FontChooser00](self.impl), filter, userData, destroy)

type
  FontSelectionPrivate00* {.pure.} = object
  FontSelectionPrivate* = ref object
    impl*: ptr FontSelectionPrivate00

type
  FontSelection* = ref object of Box
  FontSelection00* = object of Box00
    priv4: ptr FontSelectionPrivate00

proc gtk_font_selection_new*(): ptr FontSelection00 {.
    importc: "gtk_font_selection_new", libprag.}

proc newFontSelection*(): FontSelection =
  new(result, finalizeGObject)
  result.impl = gtk_font_selection_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontSelection*[T](result: var T) =
  assert(result is FontSelection)
  new(result, finalizeGObject)
  result.impl = gtk_font_selection_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_face*(self: ptr FontSelection00): ptr pango.FontFace00 {.
    importc: "gtk_font_selection_get_face", libprag.}

proc getFace*(self: FontSelection): pango.FontFace =
  let gobj = gtk_font_selection_get_face(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontFace](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc face*(self: FontSelection): pango.FontFace =
  let gobj = gtk_font_selection_get_face(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontFace](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_face_list*(self: ptr FontSelection00): ptr Widget00 {.
    importc: "gtk_font_selection_get_face_list", libprag.}

proc getFaceList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_face_list(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc faceList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_face_list(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_family*(self: ptr FontSelection00): ptr pango.FontFamily00 {.
    importc: "gtk_font_selection_get_family", libprag.}

proc getFamily*(self: FontSelection): pango.FontFamily =
  let gobj = gtk_font_selection_get_family(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontFamily](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc family*(self: FontSelection): pango.FontFamily =
  let gobj = gtk_font_selection_get_family(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontFamily](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_family_list*(self: ptr FontSelection00): ptr Widget00 {.
    importc: "gtk_font_selection_get_family_list", libprag.}

proc getFamilyList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_family_list(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc familyList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_family_list(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_font_name*(self: ptr FontSelection00): cstring {.
    importc: "gtk_font_selection_get_font_name", libprag.}

proc getFontName*(self: FontSelection): string =
  let resul0 = gtk_font_selection_get_font_name(cast[ptr FontSelection00](self.impl))
  result = $resul0
  cogfree(resul0)

proc fontName*(self: FontSelection): string =
  let resul0 = gtk_font_selection_get_font_name(cast[ptr FontSelection00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_selection_get_preview_entry*(self: ptr FontSelection00): ptr Widget00 {.
    importc: "gtk_font_selection_get_preview_entry", libprag.}

proc getPreviewEntry*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_preview_entry(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc previewEntry*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_preview_entry(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_preview_text*(self: ptr FontSelection00): cstring {.
    importc: "gtk_font_selection_get_preview_text", libprag.}

proc getPreviewText*(self: FontSelection): string =
  let resul0 = gtk_font_selection_get_preview_text(cast[ptr FontSelection00](self.impl))
  result = $resul0

proc previewText*(self: FontSelection): string =
  let resul0 = gtk_font_selection_get_preview_text(cast[ptr FontSelection00](self.impl))
  result = $resul0

proc gtk_font_selection_get_size*(self: ptr FontSelection00): int32 {.
    importc: "gtk_font_selection_get_size", libprag.}

proc getSize*(self: FontSelection): int =
  int(gtk_font_selection_get_size(cast[ptr FontSelection00](self.impl)))

proc size*(self: FontSelection): int =
  int(gtk_font_selection_get_size(cast[ptr FontSelection00](self.impl)))

proc gtk_font_selection_get_size_entry*(self: ptr FontSelection00): ptr Widget00 {.
    importc: "gtk_font_selection_get_size_entry", libprag.}

proc getSizeEntry*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_size_entry(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc sizeEntry*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_size_entry(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_size_list*(self: ptr FontSelection00): ptr Widget00 {.
    importc: "gtk_font_selection_get_size_list", libprag.}

proc getSizeList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_size_list(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc sizeList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_size_list(cast[ptr FontSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_set_font_name*(self: ptr FontSelection00; fontname: cstring): gboolean {.
    importc: "gtk_font_selection_set_font_name", libprag.}

proc setFontName*(self: FontSelection; fontname: string): bool =
  toBool(gtk_font_selection_set_font_name(cast[ptr FontSelection00](self.impl), cstring(fontname)))

proc `fontName=`*(self: FontSelection; fontname: string): bool =
  toBool(gtk_font_selection_set_font_name(cast[ptr FontSelection00](self.impl), cstring(fontname)))

proc gtk_font_selection_set_preview_text*(self: ptr FontSelection00; text: cstring) {.
    importc: "gtk_font_selection_set_preview_text", libprag.}

proc setPreviewText*(self: FontSelection; text: string) =
  gtk_font_selection_set_preview_text(cast[ptr FontSelection00](self.impl), cstring(text))

proc `previewText=`*(self: FontSelection; text: string) =
  gtk_font_selection_set_preview_text(cast[ptr FontSelection00](self.impl), cstring(text))

type
  FontSelectionClass00* {.pure.} = object
    parentClass*: BoxClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  FontSelectionClass* = ref object
    impl*: ptr FontSelectionClass00

type
  FontSelectionDialogPrivate00* {.pure.} = object
  FontSelectionDialogPrivate* = ref object
    impl*: ptr FontSelectionDialogPrivate00

type
  FontSelectionDialog* = ref object of Dialog
  FontSelectionDialog00* = object of Dialog00
    priv6: ptr FontSelectionDialogPrivate00

proc gtk_font_selection_dialog_new*(title: cstring): ptr FontSelectionDialog00 {.
    importc: "gtk_font_selection_dialog_new", libprag.}

proc newFontSelectionDialog*(title: string): FontSelectionDialog =
  new(result, finalizeGObject)
  result.impl = gtk_font_selection_dialog_new(cstring(title))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontSelectionDialog*[T](result: var T; title: string) =
  assert(result is FontSelectionDialog)
  new(result, finalizeGObject)
  result.impl = gtk_font_selection_dialog_new(cstring(title))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_dialog_get_cancel_button*(self: ptr FontSelectionDialog00): ptr Widget00 {.
    importc: "gtk_font_selection_dialog_get_cancel_button", libprag.}

proc getCancelButton*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_cancel_button(cast[ptr FontSelectionDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc cancelButton*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_cancel_button(cast[ptr FontSelectionDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_dialog_get_font_name*(self: ptr FontSelectionDialog00): cstring {.
    importc: "gtk_font_selection_dialog_get_font_name", libprag.}

proc getFontName*(self: FontSelectionDialog): string =
  let resul0 = gtk_font_selection_dialog_get_font_name(cast[ptr FontSelectionDialog00](self.impl))
  result = $resul0
  cogfree(resul0)

proc fontName*(self: FontSelectionDialog): string =
  let resul0 = gtk_font_selection_dialog_get_font_name(cast[ptr FontSelectionDialog00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_selection_dialog_get_font_selection*(self: ptr FontSelectionDialog00): ptr Widget00 {.
    importc: "gtk_font_selection_dialog_get_font_selection", libprag.}

proc getFontSelection*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_font_selection(cast[ptr FontSelectionDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontSelection*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_font_selection(cast[ptr FontSelectionDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_dialog_get_ok_button*(self: ptr FontSelectionDialog00): ptr Widget00 {.
    importc: "gtk_font_selection_dialog_get_ok_button", libprag.}

proc getOkButton*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_ok_button(cast[ptr FontSelectionDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc okButton*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_ok_button(cast[ptr FontSelectionDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_dialog_get_preview_text*(self: ptr FontSelectionDialog00): cstring {.
    importc: "gtk_font_selection_dialog_get_preview_text", libprag.}

proc getPreviewText*(self: FontSelectionDialog): string =
  let resul0 = gtk_font_selection_dialog_get_preview_text(cast[ptr FontSelectionDialog00](self.impl))
  result = $resul0

proc previewText*(self: FontSelectionDialog): string =
  let resul0 = gtk_font_selection_dialog_get_preview_text(cast[ptr FontSelectionDialog00](self.impl))
  result = $resul0

proc gtk_font_selection_dialog_set_font_name*(self: ptr FontSelectionDialog00; fontname: cstring): gboolean {.
    importc: "gtk_font_selection_dialog_set_font_name", libprag.}

proc setFontName*(self: FontSelectionDialog; fontname: string): bool =
  toBool(gtk_font_selection_dialog_set_font_name(cast[ptr FontSelectionDialog00](self.impl), cstring(fontname)))

proc `fontName=`*(self: FontSelectionDialog; fontname: string): bool =
  toBool(gtk_font_selection_dialog_set_font_name(cast[ptr FontSelectionDialog00](self.impl), cstring(fontname)))

proc gtk_font_selection_dialog_set_preview_text*(self: ptr FontSelectionDialog00; text: cstring) {.
    importc: "gtk_font_selection_dialog_set_preview_text", libprag.}

proc setPreviewText*(self: FontSelectionDialog; text: string) =
  gtk_font_selection_dialog_set_preview_text(cast[ptr FontSelectionDialog00](self.impl), cstring(text))

proc `previewText=`*(self: FontSelectionDialog; text: string) =
  gtk_font_selection_dialog_set_preview_text(cast[ptr FontSelectionDialog00](self.impl), cstring(text))

type
  FontSelectionDialogClass00* {.pure.} = object
    parentClass*: DialogClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  FontSelectionDialogClass* = ref object
    impl*: ptr FontSelectionDialogClass00

type
  FrameAccessiblePrivate00* {.pure.} = object
  FrameAccessiblePrivate* = ref object
    impl*: ptr FrameAccessiblePrivate00

type
  FrameAccessible* = ref object of ContainerAccessible
  FrameAccessible00* = object of ContainerAccessible00
    priv4: ptr FrameAccessiblePrivate00

type
  FrameAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  FrameAccessibleClass* = ref object
    impl*: ptr FrameAccessibleClass00

type
  GLArea* = ref object of Widget
  GLArea00* = object of Widget00

proc scCreateContext*(self: GLArea;  p: proc (self: ptr gobject.Object00; xdata: pointer): gdk.GLContext00 {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "create-context", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRender*(self: GLArea;  p: proc (self: ptr gobject.Object00; context: gdk.GLContext00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "render", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scResize*(self: GLArea;  p: proc (self: ptr gobject.Object00; width: int32; height: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "resize", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_gl_area_new*(): ptr GLArea00 {.
    importc: "gtk_gl_area_new", libprag.}

proc newGLArea*(): GLArea =
  new(result, finalizeGObject)
  result.impl = gtk_gl_area_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGLArea*[T](result: var T) =
  assert(result is GLArea)
  new(result, finalizeGObject)
  result.impl = gtk_gl_area_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gl_area_attach_buffers*(self: ptr GLArea00) {.
    importc: "gtk_gl_area_attach_buffers", libprag.}

proc attachBuffers*(self: GLArea) =
  gtk_gl_area_attach_buffers(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_get_auto_render*(self: ptr GLArea00): gboolean {.
    importc: "gtk_gl_area_get_auto_render", libprag.}

proc getAutoRender*(self: GLArea): bool =
  toBool(gtk_gl_area_get_auto_render(cast[ptr GLArea00](self.impl)))

proc autoRender*(self: GLArea): bool =
  toBool(gtk_gl_area_get_auto_render(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_context*(self: ptr GLArea00): ptr gdk.GLContext00 {.
    importc: "gtk_gl_area_get_context", libprag.}

proc getContext*(self: GLArea): gdk.GLContext =
  let gobj = gtk_gl_area_get_context(cast[ptr GLArea00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.GLContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc context*(self: GLArea): gdk.GLContext =
  let gobj = gtk_gl_area_get_context(cast[ptr GLArea00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.GLContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gl_area_get_error*(self: ptr GLArea00): ptr Error00 {.
    importc: "gtk_gl_area_get_error", libprag.}

proc getError*(self: GLArea): ptr Error00 =
  gtk_gl_area_get_error(cast[ptr GLArea00](self.impl))

proc error*(self: GLArea): ptr Error00 =
  gtk_gl_area_get_error(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_get_has_alpha*(self: ptr GLArea00): gboolean {.
    importc: "gtk_gl_area_get_has_alpha", libprag.}

proc getHasAlpha*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_alpha(cast[ptr GLArea00](self.impl)))

proc hasAlpha*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_alpha(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_has_depth_buffer*(self: ptr GLArea00): gboolean {.
    importc: "gtk_gl_area_get_has_depth_buffer", libprag.}

proc getHasDepthBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_depth_buffer(cast[ptr GLArea00](self.impl)))

proc hasDepthBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_depth_buffer(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_has_stencil_buffer*(self: ptr GLArea00): gboolean {.
    importc: "gtk_gl_area_get_has_stencil_buffer", libprag.}

proc getHasStencilBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_stencil_buffer(cast[ptr GLArea00](self.impl)))

proc hasStencilBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_stencil_buffer(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_required_version*(self: ptr GLArea00; major: var int32; minor: var int32) {.
    importc: "gtk_gl_area_get_required_version", libprag.}

proc getRequiredVersion*(self: GLArea; major: var int; minor: var int) =
  var minor_00 = int32(minor)
  var major_00 = int32(major)
  gtk_gl_area_get_required_version(cast[ptr GLArea00](self.impl), major_00, minor_00)
  minor = int(minor_00)
  major = int(major_00)

proc requiredVersion*(self: GLArea; major: var int; minor: var int) =
  var minor_00 = int32(minor)
  var major_00 = int32(major)
  gtk_gl_area_get_required_version(cast[ptr GLArea00](self.impl), major_00, minor_00)
  minor = int(minor_00)
  major = int(major_00)

proc gtk_gl_area_get_use_es*(self: ptr GLArea00): gboolean {.
    importc: "gtk_gl_area_get_use_es", libprag.}

proc getUseEs*(self: GLArea): bool =
  toBool(gtk_gl_area_get_use_es(cast[ptr GLArea00](self.impl)))

proc useEs*(self: GLArea): bool =
  toBool(gtk_gl_area_get_use_es(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_make_current*(self: ptr GLArea00) {.
    importc: "gtk_gl_area_make_current", libprag.}

proc makeCurrent*(self: GLArea) =
  gtk_gl_area_make_current(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_queue_render*(self: ptr GLArea00) {.
    importc: "gtk_gl_area_queue_render", libprag.}

proc queueRender*(self: GLArea) =
  gtk_gl_area_queue_render(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_set_auto_render*(self: ptr GLArea00; autoRender: gboolean) {.
    importc: "gtk_gl_area_set_auto_render", libprag.}

proc setAutoRender*(self: GLArea; autoRender: bool) =
  gtk_gl_area_set_auto_render(cast[ptr GLArea00](self.impl), gboolean(autoRender))

proc `autoRender=`*(self: GLArea; autoRender: bool) =
  gtk_gl_area_set_auto_render(cast[ptr GLArea00](self.impl), gboolean(autoRender))

proc gtk_gl_area_set_error*(self: ptr GLArea00; error: ptr Error00) {.
    importc: "gtk_gl_area_set_error", libprag.}

proc setError*(self: GLArea; error: ptr Error00) =
  gtk_gl_area_set_error(cast[ptr GLArea00](self.impl), error)

proc `error=`*(self: GLArea; error: ptr Error00) =
  gtk_gl_area_set_error(cast[ptr GLArea00](self.impl), error)

proc gtk_gl_area_set_has_alpha*(self: ptr GLArea00; hasAlpha: gboolean) {.
    importc: "gtk_gl_area_set_has_alpha", libprag.}

proc setHasAlpha*(self: GLArea; hasAlpha: bool) =
  gtk_gl_area_set_has_alpha(cast[ptr GLArea00](self.impl), gboolean(hasAlpha))

proc `hasAlpha=`*(self: GLArea; hasAlpha: bool) =
  gtk_gl_area_set_has_alpha(cast[ptr GLArea00](self.impl), gboolean(hasAlpha))

proc gtk_gl_area_set_has_depth_buffer*(self: ptr GLArea00; hasDepthBuffer: gboolean) {.
    importc: "gtk_gl_area_set_has_depth_buffer", libprag.}

proc setHasDepthBuffer*(self: GLArea; hasDepthBuffer: bool) =
  gtk_gl_area_set_has_depth_buffer(cast[ptr GLArea00](self.impl), gboolean(hasDepthBuffer))

proc `hasDepthBuffer=`*(self: GLArea; hasDepthBuffer: bool) =
  gtk_gl_area_set_has_depth_buffer(cast[ptr GLArea00](self.impl), gboolean(hasDepthBuffer))

proc gtk_gl_area_set_has_stencil_buffer*(self: ptr GLArea00; hasStencilBuffer: gboolean) {.
    importc: "gtk_gl_area_set_has_stencil_buffer", libprag.}

proc setHasStencilBuffer*(self: GLArea; hasStencilBuffer: bool) =
  gtk_gl_area_set_has_stencil_buffer(cast[ptr GLArea00](self.impl), gboolean(hasStencilBuffer))

proc `hasStencilBuffer=`*(self: GLArea; hasStencilBuffer: bool) =
  gtk_gl_area_set_has_stencil_buffer(cast[ptr GLArea00](self.impl), gboolean(hasStencilBuffer))

proc gtk_gl_area_set_required_version*(self: ptr GLArea00; major: int32; minor: int32) {.
    importc: "gtk_gl_area_set_required_version", libprag.}

proc setRequiredVersion*(self: GLArea; major: int; minor: int) =
  gtk_gl_area_set_required_version(cast[ptr GLArea00](self.impl), int32(major), int32(minor))

proc gtk_gl_area_set_use_es*(self: ptr GLArea00; useEs: gboolean) {.
    importc: "gtk_gl_area_set_use_es", libprag.}

proc setUseEs*(self: GLArea; useEs: bool) =
  gtk_gl_area_set_use_es(cast[ptr GLArea00](self.impl), gboolean(useEs))

proc `useEs=`*(self: GLArea; useEs: bool) =
  gtk_gl_area_set_use_es(cast[ptr GLArea00](self.impl), gboolean(useEs))

type
  GLAreaClass00* {.pure.} = object
    parentClass*: WidgetClass00
    render*: proc(area: ptr GLArea00; context: ptr gdk.GLContext00): gboolean {.cdecl.}
    resize*: proc(area: ptr GLArea00; width: int32; height: int32) {.cdecl.}
    createContext*: pointer
    padding*: array[6, pointer]
  GLAreaClass* = ref object
    impl*: ptr GLAreaClass00

type
  Gesture* = ref object of EventController
  Gesture00* = object of EventController00

proc scBegin*(self: Gesture;  p: proc (self: ptr gobject.Object00; sequence: gdk.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "begin", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCancel*(self: Gesture;  p: proc (self: ptr gobject.Object00; sequence: gdk.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cancel", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEnd*(self: Gesture;  p: proc (self: ptr gobject.Object00; sequence: gdk.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "end", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSequenceStateChanged*(self: Gesture;  p: proc (self: ptr gobject.Object00; sequence: gdk.EventSequence00; state: EventSequenceState; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "sequence-state-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUpdate*(self: Gesture;  p: proc (self: ptr gobject.Object00; sequence: gdk.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "update", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_gesture_get_bounding_box*(self: ptr Gesture00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_gesture_get_bounding_box", libprag.}

proc getBoundingBox*(self: ptr Gesture00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_gesture_get_bounding_box", libprag.}

proc boundingBox*(self: ptr Gesture00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_gesture_get_bounding_box", libprag.}

proc gtk_gesture_get_bounding_box_center*(self: ptr Gesture00; x: var cdouble; y: var cdouble): gboolean {.
    importc: "gtk_gesture_get_bounding_box_center", libprag.}

proc getBoundingBoxCenter*(self: Gesture; x: var cdouble; y: var cdouble): bool =
  toBool(gtk_gesture_get_bounding_box_center(cast[ptr Gesture00](self.impl), x, y))

proc boundingBoxCenter*(self: Gesture; x: var cdouble; y: var cdouble): bool =
  toBool(gtk_gesture_get_bounding_box_center(cast[ptr Gesture00](self.impl), x, y))

proc gtk_gesture_get_device*(self: ptr Gesture00): ptr gdk.Device00 {.
    importc: "gtk_gesture_get_device", libprag.}

proc getDevice*(self: Gesture): gdk.Device =
  let gobj = gtk_gesture_get_device(cast[ptr Gesture00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Device](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc device*(self: Gesture): gdk.Device =
  let gobj = gtk_gesture_get_device(cast[ptr Gesture00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Device](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_get_group*(self: ptr Gesture00): ptr pointer {.
    importc: "gtk_gesture_get_group", libprag.}

proc getGroup*(self: Gesture): ptr pointer =
  gtk_gesture_get_group(cast[ptr Gesture00](self.impl))

proc group*(self: Gesture): ptr pointer =
  gtk_gesture_get_group(cast[ptr Gesture00](self.impl))

proc gtk_gesture_get_last_event*(self: ptr Gesture00; sequence: ptr gdk.EventSequence00): ptr gdk.Event00 {.
    importc: "gtk_gesture_get_last_event", libprag.}

proc getLastEvent*(self: Gesture; sequence: gdk.EventSequence): gdk.Event =
  new(result)
  result.impl = gtk_gesture_get_last_event(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl))

proc lastEvent*(self: Gesture; sequence: gdk.EventSequence): gdk.Event =
  new(result)
  result.impl = gtk_gesture_get_last_event(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl))

proc gtk_gesture_get_last_updated_sequence*(self: ptr Gesture00): ptr gdk.EventSequence00 {.
    importc: "gtk_gesture_get_last_updated_sequence", libprag.}

proc getLastUpdatedSequence*(self: Gesture): gdk.EventSequence =
  new(result)
  result.impl = gtk_gesture_get_last_updated_sequence(cast[ptr Gesture00](self.impl))

proc lastUpdatedSequence*(self: Gesture): gdk.EventSequence =
  new(result)
  result.impl = gtk_gesture_get_last_updated_sequence(cast[ptr Gesture00](self.impl))

proc gtk_gesture_get_point*(self: ptr Gesture00; sequence: ptr gdk.EventSequence00; 
    x: var cdouble; y: var cdouble): gboolean {.
    importc: "gtk_gesture_get_point", libprag.}

proc getPoint*(self: Gesture; sequence: gdk.EventSequence; x: var cdouble; 
    y: var cdouble): bool =
  toBool(gtk_gesture_get_point(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl), x, y))

proc point*(self: Gesture; sequence: gdk.EventSequence; x: var cdouble; 
    y: var cdouble): bool =
  toBool(gtk_gesture_get_point(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl), x, y))

proc gtk_gesture_get_sequence_state*(self: ptr Gesture00; sequence: ptr gdk.EventSequence00): EventSequenceState {.
    importc: "gtk_gesture_get_sequence_state", libprag.}

proc getSequenceState*(self: Gesture; sequence: gdk.EventSequence): EventSequenceState =
  gtk_gesture_get_sequence_state(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl))

proc sequenceState*(self: Gesture; sequence: gdk.EventSequence): EventSequenceState =
  gtk_gesture_get_sequence_state(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl))

proc gtk_gesture_get_sequences*(self: ptr Gesture00): ptr pointer {.
    importc: "gtk_gesture_get_sequences", libprag.}

proc getSequences*(self: Gesture): ptr pointer =
  gtk_gesture_get_sequences(cast[ptr Gesture00](self.impl))

proc sequences*(self: Gesture): ptr pointer =
  gtk_gesture_get_sequences(cast[ptr Gesture00](self.impl))

proc gtk_gesture_get_window*(self: ptr Gesture00): ptr gdk.Window00 {.
    importc: "gtk_gesture_get_window", libprag.}

proc getWindow*(self: Gesture): gdk.Window =
  let gobj = gtk_gesture_get_window(cast[ptr Gesture00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc window*(self: Gesture): gdk.Window =
  let gobj = gtk_gesture_get_window(cast[ptr Gesture00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_group*(self: ptr Gesture00; gesture: ptr Gesture00) {.
    importc: "gtk_gesture_group", libprag.}

proc group*(self: Gesture; gesture: Gesture) =
  gtk_gesture_group(cast[ptr Gesture00](self.impl), cast[ptr Gesture00](gesture.impl))

proc gtk_gesture_handles_sequence*(self: ptr Gesture00; sequence: ptr gdk.EventSequence00): gboolean {.
    importc: "gtk_gesture_handles_sequence", libprag.}

proc handlesSequence*(self: Gesture; sequence: gdk.EventSequence): bool =
  toBool(gtk_gesture_handles_sequence(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl)))

proc gtk_gesture_is_active*(self: ptr Gesture00): gboolean {.
    importc: "gtk_gesture_is_active", libprag.}

proc isActive*(self: Gesture): bool =
  toBool(gtk_gesture_is_active(cast[ptr Gesture00](self.impl)))

proc gtk_gesture_is_grouped_with*(self: ptr Gesture00; other: ptr Gesture00): gboolean {.
    importc: "gtk_gesture_is_grouped_with", libprag.}

proc isGroupedWith*(self: Gesture; other: Gesture): bool =
  toBool(gtk_gesture_is_grouped_with(cast[ptr Gesture00](self.impl), cast[ptr Gesture00](other.impl)))

proc gtk_gesture_is_recognized*(self: ptr Gesture00): gboolean {.
    importc: "gtk_gesture_is_recognized", libprag.}

proc isRecognized*(self: Gesture): bool =
  toBool(gtk_gesture_is_recognized(cast[ptr Gesture00](self.impl)))

proc gtk_gesture_set_sequence_state*(self: ptr Gesture00; sequence: ptr gdk.EventSequence00; 
    state: EventSequenceState): gboolean {.
    importc: "gtk_gesture_set_sequence_state", libprag.}

proc setSequenceState*(self: Gesture; sequence: gdk.EventSequence; state: EventSequenceState): bool =
  toBool(gtk_gesture_set_sequence_state(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl), state))

proc gtk_gesture_set_state*(self: ptr Gesture00; state: EventSequenceState): gboolean {.
    importc: "gtk_gesture_set_state", libprag.}

proc setState*(self: Gesture; state: EventSequenceState): bool =
  toBool(gtk_gesture_set_state(cast[ptr Gesture00](self.impl), state))

proc `state=`*(self: Gesture; state: EventSequenceState): bool =
  toBool(gtk_gesture_set_state(cast[ptr Gesture00](self.impl), state))

proc gtk_gesture_set_window*(self: ptr Gesture00; window: ptr gdk.Window00) {.
    importc: "gtk_gesture_set_window", libprag.}

proc setWindow*(self: Gesture; window: gdk.Window) =
  gtk_gesture_set_window(cast[ptr Gesture00](self.impl), cast[ptr gdk.Window00](window.impl))

proc `window=`*(self: Gesture; window: gdk.Window) =
  gtk_gesture_set_window(cast[ptr Gesture00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_gesture_ungroup*(self: ptr Gesture00) {.
    importc: "gtk_gesture_ungroup", libprag.}

proc ungroup*(self: Gesture) =
  gtk_gesture_ungroup(cast[ptr Gesture00](self.impl))

type
  GestureClass00* {.pure.} = object
  GestureClass* = ref object
    impl*: ptr GestureClass00

type
  GestureSingle* = ref object of Gesture
  GestureSingle00* = object of Gesture00

proc gtk_gesture_single_get_button*(self: ptr GestureSingle00): uint32 {.
    importc: "gtk_gesture_single_get_button", libprag.}

proc getButton*(self: GestureSingle): int =
  int(gtk_gesture_single_get_button(cast[ptr GestureSingle00](self.impl)))

proc button*(self: GestureSingle): int =
  int(gtk_gesture_single_get_button(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_get_current_button*(self: ptr GestureSingle00): uint32 {.
    importc: "gtk_gesture_single_get_current_button", libprag.}

proc getCurrentButton*(self: GestureSingle): int =
  int(gtk_gesture_single_get_current_button(cast[ptr GestureSingle00](self.impl)))

proc currentButton*(self: GestureSingle): int =
  int(gtk_gesture_single_get_current_button(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_get_current_sequence*(self: ptr GestureSingle00): ptr gdk.EventSequence00 {.
    importc: "gtk_gesture_single_get_current_sequence", libprag.}

proc getCurrentSequence*(self: GestureSingle): gdk.EventSequence =
  new(result)
  result.impl = gtk_gesture_single_get_current_sequence(cast[ptr GestureSingle00](self.impl))

proc currentSequence*(self: GestureSingle): gdk.EventSequence =
  new(result)
  result.impl = gtk_gesture_single_get_current_sequence(cast[ptr GestureSingle00](self.impl))

proc gtk_gesture_single_get_exclusive*(self: ptr GestureSingle00): gboolean {.
    importc: "gtk_gesture_single_get_exclusive", libprag.}

proc getExclusive*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_exclusive(cast[ptr GestureSingle00](self.impl)))

proc exclusive*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_exclusive(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_get_touch_only*(self: ptr GestureSingle00): gboolean {.
    importc: "gtk_gesture_single_get_touch_only", libprag.}

proc getTouchOnly*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_touch_only(cast[ptr GestureSingle00](self.impl)))

proc touchOnly*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_touch_only(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_set_button*(self: ptr GestureSingle00; button: uint32) {.
    importc: "gtk_gesture_single_set_button", libprag.}

proc setButton*(self: GestureSingle; button: int) =
  gtk_gesture_single_set_button(cast[ptr GestureSingle00](self.impl), uint32(button))

proc `button=`*(self: GestureSingle; button: int) =
  gtk_gesture_single_set_button(cast[ptr GestureSingle00](self.impl), uint32(button))

proc gtk_gesture_single_set_exclusive*(self: ptr GestureSingle00; exclusive: gboolean) {.
    importc: "gtk_gesture_single_set_exclusive", libprag.}

proc setExclusive*(self: GestureSingle; exclusive: bool) =
  gtk_gesture_single_set_exclusive(cast[ptr GestureSingle00](self.impl), gboolean(exclusive))

proc `exclusive=`*(self: GestureSingle; exclusive: bool) =
  gtk_gesture_single_set_exclusive(cast[ptr GestureSingle00](self.impl), gboolean(exclusive))

proc gtk_gesture_single_set_touch_only*(self: ptr GestureSingle00; touchOnly: gboolean) {.
    importc: "gtk_gesture_single_set_touch_only", libprag.}

proc setTouchOnly*(self: GestureSingle; touchOnly: bool) =
  gtk_gesture_single_set_touch_only(cast[ptr GestureSingle00](self.impl), gboolean(touchOnly))

proc `touchOnly=`*(self: GestureSingle; touchOnly: bool) =
  gtk_gesture_single_set_touch_only(cast[ptr GestureSingle00](self.impl), gboolean(touchOnly))

type
  GestureDrag* = ref object of GestureSingle
  GestureDrag00* = object of GestureSingle00

proc scDragBegin*(self: GestureDrag;  p: proc (self: ptr gobject.Object00; startX: cdouble; startY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-begin", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragEnd*(self: GestureDrag;  p: proc (self: ptr gobject.Object00; offsetX: cdouble; offsetY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-end", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragUpdate*(self: GestureDrag;  p: proc (self: ptr gobject.Object00; offsetX: cdouble; offsetY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-update", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_gesture_drag_new*(widget: ptr Widget00): ptr GestureDrag00 {.
    importc: "gtk_gesture_drag_new", libprag.}

proc newGestureDrag*(widget: Widget): GestureDrag =
  new(result, finalizeGObject)
  result.impl = gtk_gesture_drag_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureDrag*[T](result: var T; widget: Widget) =
  assert(result is GestureDrag)
  new(result, finalizeGObject)
  result.impl = gtk_gesture_drag_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_drag_get_offset*(self: ptr GestureDrag00; x: var cdouble; y: var cdouble): gboolean {.
    importc: "gtk_gesture_drag_get_offset", libprag.}

proc getOffset*(self: GestureDrag; x: var cdouble; y: var cdouble): bool =
  toBool(gtk_gesture_drag_get_offset(cast[ptr GestureDrag00](self.impl), x, y))

proc offset*(self: GestureDrag; x: var cdouble; y: var cdouble): bool =
  toBool(gtk_gesture_drag_get_offset(cast[ptr GestureDrag00](self.impl), x, y))

proc gtk_gesture_drag_get_start_point*(self: ptr GestureDrag00; x: var cdouble; y: var cdouble): gboolean {.
    importc: "gtk_gesture_drag_get_start_point", libprag.}

proc getStartPoint*(self: GestureDrag; x: var cdouble; y: var cdouble): bool =
  toBool(gtk_gesture_drag_get_start_point(cast[ptr GestureDrag00](self.impl), x, y))

proc startPoint*(self: GestureDrag; x: var cdouble; y: var cdouble): bool =
  toBool(gtk_gesture_drag_get_start_point(cast[ptr GestureDrag00](self.impl), x, y))

type
  GestureDragClass00* {.pure.} = object
  GestureDragClass* = ref object
    impl*: ptr GestureDragClass00

type
  GestureLongPress* = ref object of GestureSingle
  GestureLongPress00* = object of GestureSingle00

proc scCancelled*(self: GestureLongPress;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cancelled", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPressed*(self: GestureLongPress;  p: proc (self: ptr gobject.Object00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "pressed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_gesture_long_press_new*(widget: ptr Widget00): ptr GestureLongPress00 {.
    importc: "gtk_gesture_long_press_new", libprag.}

proc newGestureLongPress*(widget: Widget): GestureLongPress =
  new(result, finalizeGObject)
  result.impl = gtk_gesture_long_press_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureLongPress*[T](result: var T; widget: Widget) =
  assert(result is GestureLongPress)
  new(result, finalizeGObject)
  result.impl = gtk_gesture_long_press_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  GestureLongPressClass00* {.pure.} = object
  GestureLongPressClass* = ref object
    impl*: ptr GestureLongPressClass00

type
  GestureMultiPress* = ref object of GestureSingle
  GestureMultiPress00* = object of GestureSingle00

proc scPressed*(self: GestureMultiPress;  p: proc (self: ptr gobject.Object00; nPress: int32; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "pressed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scReleased*(self: GestureMultiPress;  p: proc (self: ptr gobject.Object00; nPress: int32; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "released", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStopped*(self: GestureMultiPress;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "stopped", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_gesture_multi_press_new*(widget: ptr Widget00): ptr GestureMultiPress00 {.
    importc: "gtk_gesture_multi_press_new", libprag.}

proc newGestureMultiPress*(widget: Widget): GestureMultiPress =
  new(result, finalizeGObject)
  result.impl = gtk_gesture_multi_press_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureMultiPress*[T](result: var T; widget: Widget) =
  assert(result is GestureMultiPress)
  new(result, finalizeGObject)
  result.impl = gtk_gesture_multi_press_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_multi_press_get_area*(self: ptr GestureMultiPress00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_gesture_multi_press_get_area", libprag.}

proc getArea*(self: ptr GestureMultiPress00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_gesture_multi_press_get_area", libprag.}

proc area*(self: ptr GestureMultiPress00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_gesture_multi_press_get_area", libprag.}

proc gtk_gesture_multi_press_set_area*(self: ptr GestureMultiPress00; rect: ptr gdk.Rectangle00) {.
    importc: "gtk_gesture_multi_press_set_area", libprag.}

proc setArea*(self: GestureMultiPress; rect: gdk.Rectangle) =
  gtk_gesture_multi_press_set_area(cast[ptr GestureMultiPress00](self.impl), cast[ptr gdk.Rectangle00](rect.impl))

proc `area=`*(self: GestureMultiPress; rect: gdk.Rectangle) =
  gtk_gesture_multi_press_set_area(cast[ptr GestureMultiPress00](self.impl), cast[ptr gdk.Rectangle00](rect.impl))

type
  GestureMultiPressClass00* {.pure.} = object
  GestureMultiPressClass* = ref object
    impl*: ptr GestureMultiPressClass00

type
  PanDirection* {.size: sizeof(cint), pure.} = enum
    left = 0
    right = 1
    up = 2
    down = 3

type
  GesturePan* = ref object of GestureDrag
  GesturePan00* = object of GestureDrag00

proc scPan*(self: GesturePan;  p: proc (self: ptr gobject.Object00; direction: PanDirection; offset: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "pan", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_gesture_pan_new*(widget: ptr Widget00; orientation: Orientation): ptr GesturePan00 {.
    importc: "gtk_gesture_pan_new", libprag.}

proc newGesturePan*(widget: Widget; orientation: Orientation): GesturePan =
  new(result, finalizeGObject)
  result.impl = gtk_gesture_pan_new(cast[ptr Widget00](widget.impl), orientation)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGesturePan*[T](result: var T; widget: Widget; orientation: Orientation) =
  assert(result is GesturePan)
  new(result, finalizeGObject)
  result.impl = gtk_gesture_pan_new(cast[ptr Widget00](widget.impl), orientation)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_pan_get_orientation*(self: ptr GesturePan00): Orientation {.
    importc: "gtk_gesture_pan_get_orientation", libprag.}

proc getOrientation*(self: GesturePan): Orientation =
  gtk_gesture_pan_get_orientation(cast[ptr GesturePan00](self.impl))

proc orientation*(self: GesturePan): Orientation =
  gtk_gesture_pan_get_orientation(cast[ptr GesturePan00](self.impl))

proc gtk_gesture_pan_set_orientation*(self: ptr GesturePan00; orientation: Orientation) {.
    importc: "gtk_gesture_pan_set_orientation", libprag.}

proc setOrientation*(self: GesturePan; orientation: Orientation) =
  gtk_gesture_pan_set_orientation(cast[ptr GesturePan00](self.impl), orientation)

proc `orientation=`*(self: GesturePan; orientation: Orientation) =
  gtk_gesture_pan_set_orientation(cast[ptr GesturePan00](self.impl), orientation)

type
  GesturePanClass00* {.pure.} = object
  GesturePanClass* = ref object
    impl*: ptr GesturePanClass00

type
  GestureRotate* = ref object of Gesture
  GestureRotate00* = object of Gesture00

proc scAngleChanged*(self: GestureRotate;  p: proc (self: ptr gobject.Object00; angle: cdouble; angleDelta: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "angle-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_gesture_rotate_new*(widget: ptr Widget00): ptr GestureRotate00 {.
    importc: "gtk_gesture_rotate_new", libprag.}

proc newGestureRotate*(widget: Widget): GestureRotate =
  new(result, finalizeGObject)
  result.impl = gtk_gesture_rotate_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureRotate*[T](result: var T; widget: Widget) =
  assert(result is GestureRotate)
  new(result, finalizeGObject)
  result.impl = gtk_gesture_rotate_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_rotate_get_angle_delta*(self: ptr GestureRotate00): cdouble {.
    importc: "gtk_gesture_rotate_get_angle_delta", libprag.}

proc getAngleDelta*(self: GestureRotate): cdouble =
  gtk_gesture_rotate_get_angle_delta(cast[ptr GestureRotate00](self.impl))

proc angleDelta*(self: GestureRotate): cdouble =
  gtk_gesture_rotate_get_angle_delta(cast[ptr GestureRotate00](self.impl))

type
  GestureRotateClass00* {.pure.} = object
  GestureRotateClass* = ref object
    impl*: ptr GestureRotateClass00

type
  GestureSingleClass00* {.pure.} = object
  GestureSingleClass* = ref object
    impl*: ptr GestureSingleClass00

type
  GestureSwipe* = ref object of GestureSingle
  GestureSwipe00* = object of GestureSingle00

proc scSwipe*(self: GestureSwipe;  p: proc (self: ptr gobject.Object00; velocityX: cdouble; velocityY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "swipe", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_gesture_swipe_new*(widget: ptr Widget00): ptr GestureSwipe00 {.
    importc: "gtk_gesture_swipe_new", libprag.}

proc newGestureSwipe*(widget: Widget): GestureSwipe =
  new(result, finalizeGObject)
  result.impl = gtk_gesture_swipe_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureSwipe*[T](result: var T; widget: Widget) =
  assert(result is GestureSwipe)
  new(result, finalizeGObject)
  result.impl = gtk_gesture_swipe_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_swipe_get_velocity*(self: ptr GestureSwipe00; velocityX: var cdouble; 
    velocityY: var cdouble): gboolean {.
    importc: "gtk_gesture_swipe_get_velocity", libprag.}

proc getVelocity*(self: GestureSwipe; velocityX: var cdouble; velocityY: var cdouble): bool =
  toBool(gtk_gesture_swipe_get_velocity(cast[ptr GestureSwipe00](self.impl), velocityX, velocityY))

proc velocity*(self: GestureSwipe; velocityX: var cdouble; velocityY: var cdouble): bool =
  toBool(gtk_gesture_swipe_get_velocity(cast[ptr GestureSwipe00](self.impl), velocityX, velocityY))

type
  GestureSwipeClass00* {.pure.} = object
  GestureSwipeClass* = ref object
    impl*: ptr GestureSwipeClass00

type
  GestureZoom* = ref object of Gesture
  GestureZoom00* = object of Gesture00

proc scScaleChanged*(self: GestureZoom;  p: proc (self: ptr gobject.Object00; scale: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "scale-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_gesture_zoom_new*(widget: ptr Widget00): ptr GestureZoom00 {.
    importc: "gtk_gesture_zoom_new", libprag.}

proc newGestureZoom*(widget: Widget): GestureZoom =
  new(result, finalizeGObject)
  result.impl = gtk_gesture_zoom_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureZoom*[T](result: var T; widget: Widget) =
  assert(result is GestureZoom)
  new(result, finalizeGObject)
  result.impl = gtk_gesture_zoom_new(cast[ptr Widget00](widget.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_zoom_get_scale_delta*(self: ptr GestureZoom00): cdouble {.
    importc: "gtk_gesture_zoom_get_scale_delta", libprag.}

proc getScaleDelta*(self: GestureZoom): cdouble =
  gtk_gesture_zoom_get_scale_delta(cast[ptr GestureZoom00](self.impl))

proc scaleDelta*(self: GestureZoom): cdouble =
  gtk_gesture_zoom_get_scale_delta(cast[ptr GestureZoom00](self.impl))

type
  GestureZoomClass00* {.pure.} = object
  GestureZoomClass* = ref object
    impl*: ptr GestureZoomClass00

type
  Gradient00* {.pure.} = object
  Gradient* = ref object
    impl*: ptr Gradient00

proc gtk_gradient_new_linear*(x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble): ptr Gradient00 {.
    importc: "gtk_gradient_new_linear", libprag.}

proc newGradientLinear*(x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble): Gradient =
  new(result)
  result.impl = gtk_gradient_new_linear(x0, y0, x1, y1)

proc initGradientLinear*[T](result: var T; x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble) =
  assert(result is Gradient)
  new(result)
  result.impl = gtk_gradient_new_linear(x0, y0, x1, y1)

proc gtk_gradient_new_radial*(x0: cdouble; y0: cdouble; radius0: cdouble; x1: cdouble; 
    y1: cdouble; radius1: cdouble): ptr Gradient00 {.
    importc: "gtk_gradient_new_radial", libprag.}

proc newGradientRadial*(x0: cdouble; y0: cdouble; radius0: cdouble; x1: cdouble; 
    y1: cdouble; radius1: cdouble): Gradient =
  new(result)
  result.impl = gtk_gradient_new_radial(x0, y0, radius0, x1, y1, radius1)

proc initGradientRadial*[T](result: var T; x0: cdouble; y0: cdouble; radius0: cdouble; x1: cdouble; 
    y1: cdouble; radius1: cdouble) =
  assert(result is Gradient)
  new(result)
  result.impl = gtk_gradient_new_radial(x0, y0, radius0, x1, y1, radius1)

proc gtk_gradient_add_color_stop*(self: ptr Gradient00; offset: cdouble; color: ptr SymbolicColor00) {.
    importc: "gtk_gradient_add_color_stop", libprag.}

proc addColorStop*(self: Gradient; offset: cdouble; color: SymbolicColor) =
  gtk_gradient_add_color_stop(cast[ptr Gradient00](self.impl), offset, cast[ptr SymbolicColor00](color.impl))

proc gtk_gradient_ref*(self: ptr Gradient00): ptr Gradient00 {.
    importc: "gtk_gradient_ref", libprag.}

proc `ref`*(self: Gradient): Gradient =
  new(result)
  result.impl = gtk_gradient_ref(cast[ptr Gradient00](self.impl))

proc gtk_gradient_resolve*(self: ptr Gradient00; props: ptr StyleProperties00; 
    resolvedGradient: var ptr cairo.Pattern00): gboolean {.
    importc: "gtk_gradient_resolve", libprag.}

proc resolve*(self: ptr Gradient00; props: ptr StyleProperties00; 
    resolvedGradient: var ptr cairo.Pattern00): gboolean {.
    importc: "gtk_gradient_resolve", libprag.}

proc gtk_gradient_resolve_for_context*(self: ptr Gradient00; context: ptr StyleContext00): ptr cairo.Pattern00 {.
    importc: "gtk_gradient_resolve_for_context", libprag.}

proc resolveForContext*(self: Gradient; context: StyleContext): cairo.Pattern =
  new(result)
  result.impl = gtk_gradient_resolve_for_context(cast[ptr Gradient00](self.impl), cast[ptr StyleContext00](context.impl))

proc gtk_gradient_to_string*(self: ptr Gradient00): cstring {.
    importc: "gtk_gradient_to_string", libprag.}

proc toString*(self: Gradient): string =
  let resul0 = gtk_gradient_to_string(cast[ptr Gradient00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_gradient_unref*(self: ptr Gradient00) {.
    importc: "gtk_gradient_unref", libprag.}

proc unref*(self: Gradient) =
  gtk_gradient_unref(cast[ptr Gradient00](self.impl))

type
  GridPrivate00* {.pure.} = object
  GridPrivate* = ref object
    impl*: ptr GridPrivate00

type
  Grid* = ref object of Container
  Grid00* = object of Container00
    priv3: ptr GridPrivate00

proc gtk_grid_new*(): ptr Grid00 {.
    importc: "gtk_grid_new", libprag.}

proc newGrid*(): Grid =
  new(result, finalizeGObject)
  result.impl = gtk_grid_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGrid*[T](result: var T) =
  assert(result is Grid)
  new(result, finalizeGObject)
  result.impl = gtk_grid_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_attach*(self: ptr Grid00; child: ptr Widget00; left: int32; 
    top: int32; width: int32; height: int32) {.
    importc: "gtk_grid_attach", libprag.}

proc attach*(self: Grid; child: Widget; left: int; top: int; width: int; 
    height: int) =
  gtk_grid_attach(cast[ptr Grid00](self.impl), cast[ptr Widget00](child.impl), int32(left), int32(top), int32(width), int32(height))

proc gtk_grid_attach_next_to*(self: ptr Grid00; child: ptr Widget00; sibling: ptr Widget00; 
    side: PositionType; width: int32; height: int32) {.
    importc: "gtk_grid_attach_next_to", libprag.}

proc attachNextTo*(self: Grid; child: Widget; sibling: Widget; side: PositionType; 
    width: int; height: int) =
  gtk_grid_attach_next_to(cast[ptr Grid00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](sibling.impl), side, int32(width), int32(height))

proc gtk_grid_get_baseline_row*(self: ptr Grid00): int32 {.
    importc: "gtk_grid_get_baseline_row", libprag.}

proc getBaselineRow*(self: Grid): int =
  int(gtk_grid_get_baseline_row(cast[ptr Grid00](self.impl)))

proc baselineRow*(self: Grid): int =
  int(gtk_grid_get_baseline_row(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_child_at*(self: ptr Grid00; left: int32; top: int32): ptr Widget00 {.
    importc: "gtk_grid_get_child_at", libprag.}

proc getChildAt*(self: Grid; left: int; top: int): Widget =
  let gobj = gtk_grid_get_child_at(cast[ptr Grid00](self.impl), int32(left), int32(top))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc childAt*(self: Grid; left: int; top: int): Widget =
  let gobj = gtk_grid_get_child_at(cast[ptr Grid00](self.impl), int32(left), int32(top))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_get_column_homogeneous*(self: ptr Grid00): gboolean {.
    importc: "gtk_grid_get_column_homogeneous", libprag.}

proc getColumnHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_column_homogeneous(cast[ptr Grid00](self.impl)))

proc columnHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_column_homogeneous(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_column_spacing*(self: ptr Grid00): uint32 {.
    importc: "gtk_grid_get_column_spacing", libprag.}

proc getColumnSpacing*(self: Grid): int =
  int(gtk_grid_get_column_spacing(cast[ptr Grid00](self.impl)))

proc columnSpacing*(self: Grid): int =
  int(gtk_grid_get_column_spacing(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_row_baseline_position*(self: ptr Grid00; row: int32): BaselinePosition {.
    importc: "gtk_grid_get_row_baseline_position", libprag.}

proc getRowBaselinePosition*(self: Grid; row: int): BaselinePosition =
  gtk_grid_get_row_baseline_position(cast[ptr Grid00](self.impl), int32(row))

proc rowBaselinePosition*(self: Grid; row: int): BaselinePosition =
  gtk_grid_get_row_baseline_position(cast[ptr Grid00](self.impl), int32(row))

proc gtk_grid_get_row_homogeneous*(self: ptr Grid00): gboolean {.
    importc: "gtk_grid_get_row_homogeneous", libprag.}

proc getRowHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_row_homogeneous(cast[ptr Grid00](self.impl)))

proc rowHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_row_homogeneous(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_row_spacing*(self: ptr Grid00): uint32 {.
    importc: "gtk_grid_get_row_spacing", libprag.}

proc getRowSpacing*(self: Grid): int =
  int(gtk_grid_get_row_spacing(cast[ptr Grid00](self.impl)))

proc rowSpacing*(self: Grid): int =
  int(gtk_grid_get_row_spacing(cast[ptr Grid00](self.impl)))

proc gtk_grid_insert_column*(self: ptr Grid00; position: int32) {.
    importc: "gtk_grid_insert_column", libprag.}

proc insertColumn*(self: Grid; position: int) =
  gtk_grid_insert_column(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_insert_next_to*(self: ptr Grid00; sibling: ptr Widget00; side: PositionType) {.
    importc: "gtk_grid_insert_next_to", libprag.}

proc insertNextTo*(self: Grid; sibling: Widget; side: PositionType) =
  gtk_grid_insert_next_to(cast[ptr Grid00](self.impl), cast[ptr Widget00](sibling.impl), side)

proc gtk_grid_insert_row*(self: ptr Grid00; position: int32) {.
    importc: "gtk_grid_insert_row", libprag.}

proc insertRow*(self: Grid; position: int) =
  gtk_grid_insert_row(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_remove_column*(self: ptr Grid00; position: int32) {.
    importc: "gtk_grid_remove_column", libprag.}

proc removeColumn*(self: Grid; position: int) =
  gtk_grid_remove_column(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_remove_row*(self: ptr Grid00; position: int32) {.
    importc: "gtk_grid_remove_row", libprag.}

proc removeRow*(self: Grid; position: int) =
  gtk_grid_remove_row(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_set_baseline_row*(self: ptr Grid00; row: int32) {.
    importc: "gtk_grid_set_baseline_row", libprag.}

proc setBaselineRow*(self: Grid; row: int) =
  gtk_grid_set_baseline_row(cast[ptr Grid00](self.impl), int32(row))

proc `baselineRow=`*(self: Grid; row: int) =
  gtk_grid_set_baseline_row(cast[ptr Grid00](self.impl), int32(row))

proc gtk_grid_set_column_homogeneous*(self: ptr Grid00; homogeneous: gboolean) {.
    importc: "gtk_grid_set_column_homogeneous", libprag.}

proc setColumnHomogeneous*(self: Grid; homogeneous: bool) =
  gtk_grid_set_column_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc `columnHomogeneous=`*(self: Grid; homogeneous: bool) =
  gtk_grid_set_column_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc gtk_grid_set_column_spacing*(self: ptr Grid00; spacing: uint32) {.
    importc: "gtk_grid_set_column_spacing", libprag.}

proc setColumnSpacing*(self: Grid; spacing: int) =
  gtk_grid_set_column_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

proc `columnSpacing=`*(self: Grid; spacing: int) =
  gtk_grid_set_column_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

proc gtk_grid_set_row_baseline_position*(self: ptr Grid00; row: int32; pos: BaselinePosition) {.
    importc: "gtk_grid_set_row_baseline_position", libprag.}

proc setRowBaselinePosition*(self: Grid; row: int; pos: BaselinePosition) =
  gtk_grid_set_row_baseline_position(cast[ptr Grid00](self.impl), int32(row), pos)

proc gtk_grid_set_row_homogeneous*(self: ptr Grid00; homogeneous: gboolean) {.
    importc: "gtk_grid_set_row_homogeneous", libprag.}

proc setRowHomogeneous*(self: Grid; homogeneous: bool) =
  gtk_grid_set_row_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc `rowHomogeneous=`*(self: Grid; homogeneous: bool) =
  gtk_grid_set_row_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc gtk_grid_set_row_spacing*(self: ptr Grid00; spacing: uint32) {.
    importc: "gtk_grid_set_row_spacing", libprag.}

proc setRowSpacing*(self: Grid; spacing: int) =
  gtk_grid_set_row_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

proc `rowSpacing=`*(self: Grid; spacing: int) =
  gtk_grid_set_row_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

type
  GridClass00* {.pure.} = object
    parentClass*: ContainerClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  GridClass* = ref object
    impl*: ptr GridClass00

type
  HBox* = ref object of Box
  HBox00* = object of Box00

proc gtk_hbox_new*(homogeneous: gboolean; spacing: int32): ptr HBox00 {.
    importc: "gtk_hbox_new", libprag.}

proc newHBox*(homogeneous: bool; spacing: int): HBox =
  new(result, finalizeGObject)
  result.impl = gtk_hbox_new(gboolean(homogeneous), int32(spacing))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHBox*[T](result: var T; homogeneous: bool; spacing: int) =
  assert(result is HBox)
  new(result, finalizeGObject)
  result.impl = gtk_hbox_new(gboolean(homogeneous), int32(spacing))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  HBoxClass00* {.pure.} = object
    parentClass*: BoxClass00
  HBoxClass* = ref object
    impl*: ptr HBoxClass00

type
  HButtonBox* = ref object of ButtonBox
  HButtonBox00* = object of ButtonBox00

proc gtk_hbutton_box_new*(): ptr HButtonBox00 {.
    importc: "gtk_hbutton_box_new", libprag.}

proc newHButtonBox*(): HButtonBox =
  new(result, finalizeGObject)
  result.impl = gtk_hbutton_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHButtonBox*[T](result: var T) =
  assert(result is HButtonBox)
  new(result, finalizeGObject)
  result.impl = gtk_hbutton_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  HButtonBoxClass00* {.pure.} = object
    parentClass*: ButtonBoxClass00
  HButtonBoxClass* = ref object
    impl*: ptr HButtonBoxClass00

type
  PanedPrivate00* {.pure.} = object
  PanedPrivate* = ref object
    impl*: ptr PanedPrivate00

type
  Paned* = ref object of Container
  Paned00* = object of Container00
    priv3: ptr PanedPrivate00

proc scAcceptPosition*(self: Paned;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "accept-position", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCancelPosition*(self: Paned;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cancel-position", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCycleChildFocus*(self: Paned;  p: proc (self: ptr gobject.Object00; reversed: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cycle-child-focus", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCycleHandleFocus*(self: Paned;  p: proc (self: ptr gobject.Object00; reversed: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cycle-handle-focus", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveHandle*(self: Paned;  p: proc (self: ptr gobject.Object00; scrollType: ScrollType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-handle", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleHandleFocus*(self: Paned;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-handle-focus", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_paned_new*(orientation: Orientation): ptr Paned00 {.
    importc: "gtk_paned_new", libprag.}

proc newPaned*(orientation: Orientation): Paned =
  new(result, finalizeGObject)
  result.impl = gtk_paned_new(orientation)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPaned*[T](result: var T; orientation: Orientation) =
  assert(result is Paned)
  new(result, finalizeGObject)
  result.impl = gtk_paned_new(orientation)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_add1*(self: ptr Paned00; child: ptr Widget00) {.
    importc: "gtk_paned_add1", libprag.}

proc add1*(self: Paned; child: Widget) =
  gtk_paned_add1(cast[ptr Paned00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_paned_add2*(self: ptr Paned00; child: ptr Widget00) {.
    importc: "gtk_paned_add2", libprag.}

proc add2*(self: Paned; child: Widget) =
  gtk_paned_add2(cast[ptr Paned00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_paned_get_child1*(self: ptr Paned00): ptr Widget00 {.
    importc: "gtk_paned_get_child1", libprag.}

proc getChild1*(self: Paned): Widget =
  let gobj = gtk_paned_get_child1(cast[ptr Paned00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child1*(self: Paned): Widget =
  let gobj = gtk_paned_get_child1(cast[ptr Paned00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_get_child2*(self: ptr Paned00): ptr Widget00 {.
    importc: "gtk_paned_get_child2", libprag.}

proc getChild2*(self: Paned): Widget =
  let gobj = gtk_paned_get_child2(cast[ptr Paned00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child2*(self: Paned): Widget =
  let gobj = gtk_paned_get_child2(cast[ptr Paned00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_get_handle_window*(self: ptr Paned00): ptr gdk.Window00 {.
    importc: "gtk_paned_get_handle_window", libprag.}

proc getHandleWindow*(self: Paned): gdk.Window =
  let gobj = gtk_paned_get_handle_window(cast[ptr Paned00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc handleWindow*(self: Paned): gdk.Window =
  let gobj = gtk_paned_get_handle_window(cast[ptr Paned00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_get_position*(self: ptr Paned00): int32 {.
    importc: "gtk_paned_get_position", libprag.}

proc getPosition*(self: Paned): int =
  int(gtk_paned_get_position(cast[ptr Paned00](self.impl)))

proc position*(self: Paned): int =
  int(gtk_paned_get_position(cast[ptr Paned00](self.impl)))

proc gtk_paned_get_wide_handle*(self: ptr Paned00): gboolean {.
    importc: "gtk_paned_get_wide_handle", libprag.}

proc getWideHandle*(self: Paned): bool =
  toBool(gtk_paned_get_wide_handle(cast[ptr Paned00](self.impl)))

proc wideHandle*(self: Paned): bool =
  toBool(gtk_paned_get_wide_handle(cast[ptr Paned00](self.impl)))

proc gtk_paned_pack1*(self: ptr Paned00; child: ptr Widget00; resize: gboolean; 
    shrink: gboolean) {.
    importc: "gtk_paned_pack1", libprag.}

proc pack1*(self: Paned; child: Widget; resize: bool; shrink: bool) =
  gtk_paned_pack1(cast[ptr Paned00](self.impl), cast[ptr Widget00](child.impl), gboolean(resize), gboolean(shrink))

proc gtk_paned_pack2*(self: ptr Paned00; child: ptr Widget00; resize: gboolean; 
    shrink: gboolean) {.
    importc: "gtk_paned_pack2", libprag.}

proc pack2*(self: Paned; child: Widget; resize: bool; shrink: bool) =
  gtk_paned_pack2(cast[ptr Paned00](self.impl), cast[ptr Widget00](child.impl), gboolean(resize), gboolean(shrink))

proc gtk_paned_set_position*(self: ptr Paned00; position: int32) {.
    importc: "gtk_paned_set_position", libprag.}

proc setPosition*(self: Paned; position: int) =
  gtk_paned_set_position(cast[ptr Paned00](self.impl), int32(position))

proc `position=`*(self: Paned; position: int) =
  gtk_paned_set_position(cast[ptr Paned00](self.impl), int32(position))

proc gtk_paned_set_wide_handle*(self: ptr Paned00; wide: gboolean) {.
    importc: "gtk_paned_set_wide_handle", libprag.}

proc setWideHandle*(self: Paned; wide: bool) =
  gtk_paned_set_wide_handle(cast[ptr Paned00](self.impl), gboolean(wide))

proc `wideHandle=`*(self: Paned; wide: bool) =
  gtk_paned_set_wide_handle(cast[ptr Paned00](self.impl), gboolean(wide))

type
  HPaned* = ref object of Paned
  HPaned00* = object of Paned00

proc gtk_hpaned_new*(): ptr HPaned00 {.
    importc: "gtk_hpaned_new", libprag.}

proc newHPaned*(): HPaned =
  new(result, finalizeGObject)
  result.impl = gtk_hpaned_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHPaned*[T](result: var T) =
  assert(result is HPaned)
  new(result, finalizeGObject)
  result.impl = gtk_hpaned_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  PanedClass00* {.pure.} = object
    parentClass*: ContainerClass00
    cycleChildFocus*: proc(paned: ptr Paned00; reverse: gboolean): gboolean {.cdecl.}
    toggleHandleFocus*: proc(paned: ptr Paned00): gboolean {.cdecl.}
    moveHandle*: proc(paned: ptr Paned00; scroll: ScrollType): gboolean {.cdecl.}
    cycleHandleFocus*: proc(paned: ptr Paned00; reverse: gboolean): gboolean {.cdecl.}
    acceptPosition*: proc(paned: ptr Paned00): gboolean {.cdecl.}
    cancelPosition*: proc(paned: ptr Paned00): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  PanedClass* = ref object
    impl*: ptr PanedClass00

type
  HPanedClass00* {.pure.} = object
    parentClass*: PanedClass00
  HPanedClass* = ref object
    impl*: ptr HPanedClass00

type
  HSVPrivate00* {.pure.} = object
  HSVPrivate* = ref object
    impl*: ptr HSVPrivate00

type
  HSV* = ref object of Widget
  HSV00* = object of Widget00
    priv2: ptr HSVPrivate00

proc scChanged*(self: HSV;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMove*(self: HSV;  p: proc (self: ptr gobject.Object00; `object`: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_hsv_new*(): ptr HSV00 {.
    importc: "gtk_hsv_new", libprag.}

proc newHSV*(): HSV =
  new(result, finalizeGObject)
  result.impl = gtk_hsv_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHSV*[T](result: var T) =
  assert(result is HSV)
  new(result, finalizeGObject)
  result.impl = gtk_hsv_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_hsv_to_rgb*(h: cdouble; s: cdouble; v: cdouble; r: var cdouble; 
    g: var cdouble; b: var cdouble) {.
    importc: "gtk_hsv_to_rgb", libprag.}

proc toRgb*(h: cdouble; s: cdouble; v: cdouble; r: var cdouble; 
    g: var cdouble; b: var cdouble) {.
    importc: "gtk_hsv_to_rgb", libprag.}

proc gtk_hsv_get_color*(self: ptr HSV00; h: var cdouble; s: var cdouble; v: var cdouble) {.
    importc: "gtk_hsv_get_color", libprag.}

proc getColor*(self: HSV; h: var cdouble; s: var cdouble; v: var cdouble) =
  gtk_hsv_get_color(cast[ptr HSV00](self.impl), h, s, v)

proc color*(self: HSV; h: var cdouble; s: var cdouble; v: var cdouble) =
  gtk_hsv_get_color(cast[ptr HSV00](self.impl), h, s, v)

proc gtk_hsv_get_metrics*(self: ptr HSV00; size: var int32; ringWidth: var int32) {.
    importc: "gtk_hsv_get_metrics", libprag.}

proc getMetrics*(self: HSV; size: var int; ringWidth: var int) =
  var ringWidth_00 = int32(ringWidth)
  var size_00 = int32(size)
  gtk_hsv_get_metrics(cast[ptr HSV00](self.impl), size_00, ringWidth_00)
  ringWidth = int(ringWidth_00)
  size = int(size_00)

proc metrics*(self: HSV; size: var int; ringWidth: var int) =
  var ringWidth_00 = int32(ringWidth)
  var size_00 = int32(size)
  gtk_hsv_get_metrics(cast[ptr HSV00](self.impl), size_00, ringWidth_00)
  ringWidth = int(ringWidth_00)
  size = int(size_00)

proc gtk_hsv_is_adjusting*(self: ptr HSV00): gboolean {.
    importc: "gtk_hsv_is_adjusting", libprag.}

proc isAdjusting*(self: HSV): bool =
  toBool(gtk_hsv_is_adjusting(cast[ptr HSV00](self.impl)))

proc gtk_hsv_set_color*(self: ptr HSV00; h: cdouble; s: cdouble; v: cdouble) {.
    importc: "gtk_hsv_set_color", libprag.}

proc setColor*(self: HSV; h: cdouble; s: cdouble; v: cdouble) =
  gtk_hsv_set_color(cast[ptr HSV00](self.impl), h, s, v)

proc gtk_hsv_set_metrics*(self: ptr HSV00; size: int32; ringWidth: int32) {.
    importc: "gtk_hsv_set_metrics", libprag.}

proc setMetrics*(self: HSV; size: int; ringWidth: int) =
  gtk_hsv_set_metrics(cast[ptr HSV00](self.impl), int32(size), int32(ringWidth))

type
  HSVClass00* {.pure.} = object
    parentClass*: WidgetClass00
    changed*: proc(hsv: ptr HSV00) {.cdecl.}
    move*: proc(hsv: ptr HSV00; `type`: DirectionType) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  HSVClass* = ref object
    impl*: ptr HSVClass00

type
  RangePrivate00* {.pure.} = object
  RangePrivate* = ref object
    impl*: ptr RangePrivate00

type
  Range* = ref object of Widget
  Range00* = object of Widget00
    priv2: ptr RangePrivate00

proc scAdjustBounds*(self: Range;  p: proc (self: ptr gobject.Object00; value: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "adjust-bounds", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scChangeValue*(self: Range;  p: proc (self: ptr gobject.Object00; scroll: ScrollType; value: cdouble; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "change-value", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveSlider*(self: Range;  p: proc (self: ptr gobject.Object00; step: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-slider", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scValueChanged*(self: Range;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_range_get_adjustment*(self: ptr Range00): ptr Adjustment00 {.
    importc: "gtk_range_get_adjustment", libprag.}

proc getAdjustment*(self: Range): Adjustment =
  let gobj = gtk_range_get_adjustment(cast[ptr Range00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: Range): Adjustment =
  let gobj = gtk_range_get_adjustment(cast[ptr Range00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_range_get_fill_level*(self: ptr Range00): cdouble {.
    importc: "gtk_range_get_fill_level", libprag.}

proc getFillLevel*(self: Range): cdouble =
  gtk_range_get_fill_level(cast[ptr Range00](self.impl))

proc fillLevel*(self: Range): cdouble =
  gtk_range_get_fill_level(cast[ptr Range00](self.impl))

proc gtk_range_get_flippable*(self: ptr Range00): gboolean {.
    importc: "gtk_range_get_flippable", libprag.}

proc getFlippable*(self: Range): bool =
  toBool(gtk_range_get_flippable(cast[ptr Range00](self.impl)))

proc flippable*(self: Range): bool =
  toBool(gtk_range_get_flippable(cast[ptr Range00](self.impl)))

proc gtk_range_get_inverted*(self: ptr Range00): gboolean {.
    importc: "gtk_range_get_inverted", libprag.}

proc getInverted*(self: Range): bool =
  toBool(gtk_range_get_inverted(cast[ptr Range00](self.impl)))

proc inverted*(self: Range): bool =
  toBool(gtk_range_get_inverted(cast[ptr Range00](self.impl)))

proc gtk_range_get_lower_stepper_sensitivity*(self: ptr Range00): SensitivityType {.
    importc: "gtk_range_get_lower_stepper_sensitivity", libprag.}

proc getLowerStepperSensitivity*(self: Range): SensitivityType =
  gtk_range_get_lower_stepper_sensitivity(cast[ptr Range00](self.impl))

proc lowerStepperSensitivity*(self: Range): SensitivityType =
  gtk_range_get_lower_stepper_sensitivity(cast[ptr Range00](self.impl))

proc gtk_range_get_min_slider_size*(self: ptr Range00): int32 {.
    importc: "gtk_range_get_min_slider_size", libprag.}

proc getMinSliderSize*(self: Range): int =
  int(gtk_range_get_min_slider_size(cast[ptr Range00](self.impl)))

proc minSliderSize*(self: Range): int =
  int(gtk_range_get_min_slider_size(cast[ptr Range00](self.impl)))

proc gtk_range_get_range_rect*(self: ptr Range00; rangeRect: var gdk.Rectangle00) {.
    importc: "gtk_range_get_range_rect", libprag.}

proc getRangeRect*(self: ptr Range00; rangeRect: var gdk.Rectangle00) {.
    importc: "gtk_range_get_range_rect", libprag.}

proc rangeRect*(self: ptr Range00; rangeRect: var gdk.Rectangle00) {.
    importc: "gtk_range_get_range_rect", libprag.}

proc gtk_range_get_restrict_to_fill_level*(self: ptr Range00): gboolean {.
    importc: "gtk_range_get_restrict_to_fill_level", libprag.}

proc getRestrictToFillLevel*(self: Range): bool =
  toBool(gtk_range_get_restrict_to_fill_level(cast[ptr Range00](self.impl)))

proc restrictToFillLevel*(self: Range): bool =
  toBool(gtk_range_get_restrict_to_fill_level(cast[ptr Range00](self.impl)))

proc gtk_range_get_round_digits*(self: ptr Range00): int32 {.
    importc: "gtk_range_get_round_digits", libprag.}

proc getRoundDigits*(self: Range): int =
  int(gtk_range_get_round_digits(cast[ptr Range00](self.impl)))

proc roundDigits*(self: Range): int =
  int(gtk_range_get_round_digits(cast[ptr Range00](self.impl)))

proc gtk_range_get_show_fill_level*(self: ptr Range00): gboolean {.
    importc: "gtk_range_get_show_fill_level", libprag.}

proc getShowFillLevel*(self: Range): bool =
  toBool(gtk_range_get_show_fill_level(cast[ptr Range00](self.impl)))

proc showFillLevel*(self: Range): bool =
  toBool(gtk_range_get_show_fill_level(cast[ptr Range00](self.impl)))

proc gtk_range_get_slider_range*(self: ptr Range00; sliderStart: var int32; sliderEnd: var int32) {.
    importc: "gtk_range_get_slider_range", libprag.}

proc getSliderRange*(self: Range; sliderStart: var int; sliderEnd: var int) =
  var sliderEnd_00 = int32(sliderEnd)
  var sliderStart_00 = int32(sliderStart)
  gtk_range_get_slider_range(cast[ptr Range00](self.impl), sliderStart_00, sliderEnd_00)
  sliderEnd = int(sliderEnd_00)
  sliderStart = int(sliderStart_00)

proc sliderRange*(self: Range; sliderStart: var int; sliderEnd: var int) =
  var sliderEnd_00 = int32(sliderEnd)
  var sliderStart_00 = int32(sliderStart)
  gtk_range_get_slider_range(cast[ptr Range00](self.impl), sliderStart_00, sliderEnd_00)
  sliderEnd = int(sliderEnd_00)
  sliderStart = int(sliderStart_00)

proc gtk_range_get_slider_size_fixed*(self: ptr Range00): gboolean {.
    importc: "gtk_range_get_slider_size_fixed", libprag.}

proc getSliderSizeFixed*(self: Range): bool =
  toBool(gtk_range_get_slider_size_fixed(cast[ptr Range00](self.impl)))

proc sliderSizeFixed*(self: Range): bool =
  toBool(gtk_range_get_slider_size_fixed(cast[ptr Range00](self.impl)))

proc gtk_range_get_upper_stepper_sensitivity*(self: ptr Range00): SensitivityType {.
    importc: "gtk_range_get_upper_stepper_sensitivity", libprag.}

proc getUpperStepperSensitivity*(self: Range): SensitivityType =
  gtk_range_get_upper_stepper_sensitivity(cast[ptr Range00](self.impl))

proc upperStepperSensitivity*(self: Range): SensitivityType =
  gtk_range_get_upper_stepper_sensitivity(cast[ptr Range00](self.impl))

proc gtk_range_get_value*(self: ptr Range00): cdouble {.
    importc: "gtk_range_get_value", libprag.}

proc getValue*(self: Range): cdouble =
  gtk_range_get_value(cast[ptr Range00](self.impl))

proc value*(self: Range): cdouble =
  gtk_range_get_value(cast[ptr Range00](self.impl))

proc gtk_range_set_adjustment*(self: ptr Range00; adjustment: ptr Adjustment00) {.
    importc: "gtk_range_set_adjustment", libprag.}

proc setAdjustment*(self: Range; adjustment: Adjustment) =
  gtk_range_set_adjustment(cast[ptr Range00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: Range; adjustment: Adjustment) =
  gtk_range_set_adjustment(cast[ptr Range00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_range_set_fill_level*(self: ptr Range00; fillLevel: cdouble) {.
    importc: "gtk_range_set_fill_level", libprag.}

proc setFillLevel*(self: Range; fillLevel: cdouble) =
  gtk_range_set_fill_level(cast[ptr Range00](self.impl), fillLevel)

proc `fillLevel=`*(self: Range; fillLevel: cdouble) =
  gtk_range_set_fill_level(cast[ptr Range00](self.impl), fillLevel)

proc gtk_range_set_flippable*(self: ptr Range00; flippable: gboolean) {.
    importc: "gtk_range_set_flippable", libprag.}

proc setFlippable*(self: Range; flippable: bool) =
  gtk_range_set_flippable(cast[ptr Range00](self.impl), gboolean(flippable))

proc `flippable=`*(self: Range; flippable: bool) =
  gtk_range_set_flippable(cast[ptr Range00](self.impl), gboolean(flippable))

proc gtk_range_set_increments*(self: ptr Range00; step: cdouble; page: cdouble) {.
    importc: "gtk_range_set_increments", libprag.}

proc setIncrements*(self: Range; step: cdouble; page: cdouble) =
  gtk_range_set_increments(cast[ptr Range00](self.impl), step, page)

proc gtk_range_set_inverted*(self: ptr Range00; setting: gboolean) {.
    importc: "gtk_range_set_inverted", libprag.}

proc setInverted*(self: Range; setting: bool) =
  gtk_range_set_inverted(cast[ptr Range00](self.impl), gboolean(setting))

proc `inverted=`*(self: Range; setting: bool) =
  gtk_range_set_inverted(cast[ptr Range00](self.impl), gboolean(setting))

proc gtk_range_set_lower_stepper_sensitivity*(self: ptr Range00; sensitivity: SensitivityType) {.
    importc: "gtk_range_set_lower_stepper_sensitivity", libprag.}

proc setLowerStepperSensitivity*(self: Range; sensitivity: SensitivityType) =
  gtk_range_set_lower_stepper_sensitivity(cast[ptr Range00](self.impl), sensitivity)

proc `lowerStepperSensitivity=`*(self: Range; sensitivity: SensitivityType) =
  gtk_range_set_lower_stepper_sensitivity(cast[ptr Range00](self.impl), sensitivity)

proc gtk_range_set_min_slider_size*(self: ptr Range00; minSize: int32) {.
    importc: "gtk_range_set_min_slider_size", libprag.}

proc setMinSliderSize*(self: Range; minSize: int) =
  gtk_range_set_min_slider_size(cast[ptr Range00](self.impl), int32(minSize))

proc `minSliderSize=`*(self: Range; minSize: int) =
  gtk_range_set_min_slider_size(cast[ptr Range00](self.impl), int32(minSize))

proc gtk_range_set_range*(self: ptr Range00; min: cdouble; max: cdouble) {.
    importc: "gtk_range_set_range", libprag.}

proc setRange*(self: Range; min: cdouble; max: cdouble) =
  gtk_range_set_range(cast[ptr Range00](self.impl), min, max)

proc gtk_range_set_restrict_to_fill_level*(self: ptr Range00; restrictToFillLevel: gboolean) {.
    importc: "gtk_range_set_restrict_to_fill_level", libprag.}

proc setRestrictToFillLevel*(self: Range; restrictToFillLevel: bool) =
  gtk_range_set_restrict_to_fill_level(cast[ptr Range00](self.impl), gboolean(restrictToFillLevel))

proc `restrictToFillLevel=`*(self: Range; restrictToFillLevel: bool) =
  gtk_range_set_restrict_to_fill_level(cast[ptr Range00](self.impl), gboolean(restrictToFillLevel))

proc gtk_range_set_round_digits*(self: ptr Range00; roundDigits: int32) {.
    importc: "gtk_range_set_round_digits", libprag.}

proc setRoundDigits*(self: Range; roundDigits: int) =
  gtk_range_set_round_digits(cast[ptr Range00](self.impl), int32(roundDigits))

proc `roundDigits=`*(self: Range; roundDigits: int) =
  gtk_range_set_round_digits(cast[ptr Range00](self.impl), int32(roundDigits))

proc gtk_range_set_show_fill_level*(self: ptr Range00; showFillLevel: gboolean) {.
    importc: "gtk_range_set_show_fill_level", libprag.}

proc setShowFillLevel*(self: Range; showFillLevel: bool) =
  gtk_range_set_show_fill_level(cast[ptr Range00](self.impl), gboolean(showFillLevel))

proc `showFillLevel=`*(self: Range; showFillLevel: bool) =
  gtk_range_set_show_fill_level(cast[ptr Range00](self.impl), gboolean(showFillLevel))

proc gtk_range_set_slider_size_fixed*(self: ptr Range00; sizeFixed: gboolean) {.
    importc: "gtk_range_set_slider_size_fixed", libprag.}

proc setSliderSizeFixed*(self: Range; sizeFixed: bool) =
  gtk_range_set_slider_size_fixed(cast[ptr Range00](self.impl), gboolean(sizeFixed))

proc `sliderSizeFixed=`*(self: Range; sizeFixed: bool) =
  gtk_range_set_slider_size_fixed(cast[ptr Range00](self.impl), gboolean(sizeFixed))

proc gtk_range_set_upper_stepper_sensitivity*(self: ptr Range00; sensitivity: SensitivityType) {.
    importc: "gtk_range_set_upper_stepper_sensitivity", libprag.}

proc setUpperStepperSensitivity*(self: Range; sensitivity: SensitivityType) =
  gtk_range_set_upper_stepper_sensitivity(cast[ptr Range00](self.impl), sensitivity)

proc `upperStepperSensitivity=`*(self: Range; sensitivity: SensitivityType) =
  gtk_range_set_upper_stepper_sensitivity(cast[ptr Range00](self.impl), sensitivity)

proc gtk_range_set_value*(self: ptr Range00; value: cdouble) {.
    importc: "gtk_range_set_value", libprag.}

proc setValue*(self: Range; value: cdouble) =
  gtk_range_set_value(cast[ptr Range00](self.impl), value)

proc `value=`*(self: Range; value: cdouble) =
  gtk_range_set_value(cast[ptr Range00](self.impl), value)

type
  ScalePrivate00* {.pure.} = object
  ScalePrivate* = ref object
    impl*: ptr ScalePrivate00

type
  Scale* = ref object of Range
  Scale00* = object of Range00
    priv3: ptr ScalePrivate00

proc scFormatValue*(self: Scale;  p: proc (self: ptr gobject.Object00; value: cdouble; xdata: pointer): cstring {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "format-value", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_scale_new*(orientation: Orientation; adjustment: ptr Adjustment00): ptr Scale00 {.
    importc: "gtk_scale_new", libprag.}

proc newScale*(orientation: Orientation; adjustment: Adjustment): Scale =
  new(result, finalizeGObject)
  result.impl = gtk_scale_new(orientation, cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScale*[T](result: var T; orientation: Orientation; adjustment: Adjustment) =
  assert(result is Scale)
  new(result, finalizeGObject)
  result.impl = gtk_scale_new(orientation, cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_new_with_range*(orientation: Orientation; min: cdouble; max: cdouble; 
    step: cdouble): ptr Scale00 {.
    importc: "gtk_scale_new_with_range", libprag.}

proc newScaleWithRange*(orientation: Orientation; min: cdouble; max: cdouble; 
    step: cdouble): Scale =
  new(result, finalizeGObject)
  result.impl = gtk_scale_new_with_range(orientation, min, max, step)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScaleWithRange*[T](result: var T; orientation: Orientation; min: cdouble; max: cdouble; 
    step: cdouble) =
  assert(result is Scale)
  new(result, finalizeGObject)
  result.impl = gtk_scale_new_with_range(orientation, min, max, step)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_add_mark*(self: ptr Scale00; value: cdouble; position: PositionType; 
    markup: cstring) {.
    importc: "gtk_scale_add_mark", libprag.}

proc addMark*(self: Scale; value: cdouble; position: PositionType; 
    markup: string) =
  gtk_scale_add_mark(cast[ptr Scale00](self.impl), value, position, cstring(markup))

proc gtk_scale_clear_marks*(self: ptr Scale00) {.
    importc: "gtk_scale_clear_marks", libprag.}

proc clearMarks*(self: Scale) =
  gtk_scale_clear_marks(cast[ptr Scale00](self.impl))

proc gtk_scale_get_digits*(self: ptr Scale00): int32 {.
    importc: "gtk_scale_get_digits", libprag.}

proc getDigits*(self: Scale): int =
  int(gtk_scale_get_digits(cast[ptr Scale00](self.impl)))

proc digits*(self: Scale): int =
  int(gtk_scale_get_digits(cast[ptr Scale00](self.impl)))

proc gtk_scale_get_draw_value*(self: ptr Scale00): gboolean {.
    importc: "gtk_scale_get_draw_value", libprag.}

proc getDrawValue*(self: Scale): bool =
  toBool(gtk_scale_get_draw_value(cast[ptr Scale00](self.impl)))

proc drawValue*(self: Scale): bool =
  toBool(gtk_scale_get_draw_value(cast[ptr Scale00](self.impl)))

proc gtk_scale_get_has_origin*(self: ptr Scale00): gboolean {.
    importc: "gtk_scale_get_has_origin", libprag.}

proc getHasOrigin*(self: Scale): bool =
  toBool(gtk_scale_get_has_origin(cast[ptr Scale00](self.impl)))

proc hasOrigin*(self: Scale): bool =
  toBool(gtk_scale_get_has_origin(cast[ptr Scale00](self.impl)))

proc gtk_scale_get_layout*(self: ptr Scale00): ptr pango.Layout00 {.
    importc: "gtk_scale_get_layout", libprag.}

proc getLayout*(self: Scale): pango.Layout =
  let gobj = gtk_scale_get_layout(cast[ptr Scale00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Layout](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layout*(self: Scale): pango.Layout =
  let gobj = gtk_scale_get_layout(cast[ptr Scale00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Layout](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_get_layout_offsets*(self: ptr Scale00; x: var int32; y: var int32) {.
    importc: "gtk_scale_get_layout_offsets", libprag.}

proc getLayoutOffsets*(self: Scale; x: var int; y: var int) =
  var y_00 = int32(y)
  var x_00 = int32(x)
  gtk_scale_get_layout_offsets(cast[ptr Scale00](self.impl), x_00, y_00)
  y = int(y_00)
  x = int(x_00)

proc layoutOffsets*(self: Scale; x: var int; y: var int) =
  var y_00 = int32(y)
  var x_00 = int32(x)
  gtk_scale_get_layout_offsets(cast[ptr Scale00](self.impl), x_00, y_00)
  y = int(y_00)
  x = int(x_00)

proc gtk_scale_get_value_pos*(self: ptr Scale00): PositionType {.
    importc: "gtk_scale_get_value_pos", libprag.}

proc getValuePos*(self: Scale): PositionType =
  gtk_scale_get_value_pos(cast[ptr Scale00](self.impl))

proc valuePos*(self: Scale): PositionType =
  gtk_scale_get_value_pos(cast[ptr Scale00](self.impl))

proc gtk_scale_set_digits*(self: ptr Scale00; digits: int32) {.
    importc: "gtk_scale_set_digits", libprag.}

proc setDigits*(self: Scale; digits: int) =
  gtk_scale_set_digits(cast[ptr Scale00](self.impl), int32(digits))

proc `digits=`*(self: Scale; digits: int) =
  gtk_scale_set_digits(cast[ptr Scale00](self.impl), int32(digits))

proc gtk_scale_set_draw_value*(self: ptr Scale00; drawValue: gboolean) {.
    importc: "gtk_scale_set_draw_value", libprag.}

proc setDrawValue*(self: Scale; drawValue: bool) =
  gtk_scale_set_draw_value(cast[ptr Scale00](self.impl), gboolean(drawValue))

proc `drawValue=`*(self: Scale; drawValue: bool) =
  gtk_scale_set_draw_value(cast[ptr Scale00](self.impl), gboolean(drawValue))

proc gtk_scale_set_has_origin*(self: ptr Scale00; hasOrigin: gboolean) {.
    importc: "gtk_scale_set_has_origin", libprag.}

proc setHasOrigin*(self: Scale; hasOrigin: bool) =
  gtk_scale_set_has_origin(cast[ptr Scale00](self.impl), gboolean(hasOrigin))

proc `hasOrigin=`*(self: Scale; hasOrigin: bool) =
  gtk_scale_set_has_origin(cast[ptr Scale00](self.impl), gboolean(hasOrigin))

proc gtk_scale_set_value_pos*(self: ptr Scale00; pos: PositionType) {.
    importc: "gtk_scale_set_value_pos", libprag.}

proc setValuePos*(self: Scale; pos: PositionType) =
  gtk_scale_set_value_pos(cast[ptr Scale00](self.impl), pos)

proc `valuePos=`*(self: Scale; pos: PositionType) =
  gtk_scale_set_value_pos(cast[ptr Scale00](self.impl), pos)

type
  HScale* = ref object of Scale
  HScale00* = object of Scale00

proc gtk_hscale_new*(adjustment: ptr Adjustment00): ptr HScale00 {.
    importc: "gtk_hscale_new", libprag.}

proc newHScale*(adjustment: Adjustment): HScale =
  new(result, finalizeGObject)
  result.impl = gtk_hscale_new(cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHScale*[T](result: var T; adjustment: Adjustment) =
  assert(result is HScale)
  new(result, finalizeGObject)
  result.impl = gtk_hscale_new(cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_hscale_new_with_range*(min: cdouble; max: cdouble; step: cdouble): ptr HScale00 {.
    importc: "gtk_hscale_new_with_range", libprag.}

proc newHScaleWithRange*(min: cdouble; max: cdouble; step: cdouble): HScale =
  new(result, finalizeGObject)
  result.impl = gtk_hscale_new_with_range(min, max, step)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHScaleWithRange*[T](result: var T; min: cdouble; max: cdouble; step: cdouble) =
  assert(result is HScale)
  new(result, finalizeGObject)
  result.impl = gtk_hscale_new_with_range(min, max, step)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  RangeClass00* {.pure.} = object
    parentClass*: WidgetClass00
    sliderDetail*: cstring
    stepperDetail*: cstring
    valueChanged*: proc(range: ptr Range00) {.cdecl.}
    adjustBounds*: proc(range: ptr Range00; newValue: cdouble) {.cdecl.}
    moveSlider*: proc(range: ptr Range00; scroll: ScrollType) {.cdecl.}
    getRangeBorder*: proc(range: ptr Range00; border: ptr Border00) {.cdecl.}
    changeValue*: proc(range: ptr Range00; scroll: ScrollType; newValue: cdouble): gboolean {.cdecl.}
    getRangeSizeRequest*: proc(range: ptr Range00; orientation: Orientation; minimum: ptr int32; 
    natural: ptr int32) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
  RangeClass* = ref object
    impl*: ptr RangeClass00

type
  ScaleClass00* {.pure.} = object
    parentClass*: RangeClass00
    formatValue*: proc(scale: ptr Scale00; value: cdouble): cstring {.cdecl.}
    drawValue*: proc(scale: ptr Scale00) {.cdecl.}
    getLayoutOffsets*: proc(scale: ptr Scale00; x: var int32; y: var int32) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ScaleClass* = ref object
    impl*: ptr ScaleClass00

type
  HScaleClass00* {.pure.} = object
    parentClass*: ScaleClass00
  HScaleClass* = ref object
    impl*: ptr HScaleClass00

type
  Scrollbar* = ref object of Range
  Scrollbar00* = object of Range00

proc gtk_scrollbar_new*(orientation: Orientation; adjustment: ptr Adjustment00): ptr Scrollbar00 {.
    importc: "gtk_scrollbar_new", libprag.}

proc newScrollbar*(orientation: Orientation; adjustment: Adjustment): Scrollbar =
  new(result, finalizeGObject)
  result.impl = gtk_scrollbar_new(orientation, cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScrollbar*[T](result: var T; orientation: Orientation; adjustment: Adjustment) =
  assert(result is Scrollbar)
  new(result, finalizeGObject)
  result.impl = gtk_scrollbar_new(orientation, cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  HScrollbar* = ref object of Scrollbar
  HScrollbar00* = object of Scrollbar00

proc gtk_hscrollbar_new*(adjustment: ptr Adjustment00): ptr HScrollbar00 {.
    importc: "gtk_hscrollbar_new", libprag.}

proc newHScrollbar*(adjustment: Adjustment): HScrollbar =
  new(result, finalizeGObject)
  result.impl = gtk_hscrollbar_new(cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHScrollbar*[T](result: var T; adjustment: Adjustment) =
  assert(result is HScrollbar)
  new(result, finalizeGObject)
  result.impl = gtk_hscrollbar_new(cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ScrollbarClass00* {.pure.} = object
    parentClass*: RangeClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ScrollbarClass* = ref object
    impl*: ptr ScrollbarClass00

type
  HScrollbarClass00* {.pure.} = object
    parentClass*: ScrollbarClass00
  HScrollbarClass* = ref object
    impl*: ptr HScrollbarClass00

type
  SeparatorPrivate00* {.pure.} = object
  SeparatorPrivate* = ref object
    impl*: ptr SeparatorPrivate00

type
  Separator* = ref object of Widget
  Separator00* = object of Widget00
    priv2: ptr SeparatorPrivate00

proc gtk_separator_new*(orientation: Orientation): ptr Separator00 {.
    importc: "gtk_separator_new", libprag.}

proc newSeparator*(orientation: Orientation): Separator =
  new(result, finalizeGObject)
  result.impl = gtk_separator_new(orientation)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSeparator*[T](result: var T; orientation: Orientation) =
  assert(result is Separator)
  new(result, finalizeGObject)
  result.impl = gtk_separator_new(orientation)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  HSeparator* = ref object of Separator
  HSeparator00* = object of Separator00

proc gtk_hseparator_new*(): ptr HSeparator00 {.
    importc: "gtk_hseparator_new", libprag.}

proc newHSeparator*(): HSeparator =
  new(result, finalizeGObject)
  result.impl = gtk_hseparator_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHSeparator*[T](result: var T) =
  assert(result is HSeparator)
  new(result, finalizeGObject)
  result.impl = gtk_hseparator_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SeparatorClass00* {.pure.} = object
    parentClass*: WidgetClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  SeparatorClass* = ref object
    impl*: ptr SeparatorClass00

type
  HSeparatorClass00* {.pure.} = object
    parentClass*: SeparatorClass00
  HSeparatorClass* = ref object
    impl*: ptr HSeparatorClass00

type
  HandleBoxPrivate00* {.pure.} = object
  HandleBoxPrivate* = ref object
    impl*: ptr HandleBoxPrivate00

type
  HandleBox* = ref object of Bin
  HandleBox00* = object of Bin00
    priv4: ptr HandleBoxPrivate00

proc scChildAttached*(self: HandleBox;  p: proc (self: ptr gobject.Object00; widget: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "child-attached", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scChildDetached*(self: HandleBox;  p: proc (self: ptr gobject.Object00; widget: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "child-detached", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_handle_box_new*(): ptr HandleBox00 {.
    importc: "gtk_handle_box_new", libprag.}

proc newHandleBox*(): HandleBox =
  new(result, finalizeGObject)
  result.impl = gtk_handle_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHandleBox*[T](result: var T) =
  assert(result is HandleBox)
  new(result, finalizeGObject)
  result.impl = gtk_handle_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_handle_box_get_child_detached*(self: ptr HandleBox00): gboolean {.
    importc: "gtk_handle_box_get_child_detached", libprag.}

proc getChildDetached*(self: HandleBox): bool =
  toBool(gtk_handle_box_get_child_detached(cast[ptr HandleBox00](self.impl)))

proc childDetached*(self: HandleBox): bool =
  toBool(gtk_handle_box_get_child_detached(cast[ptr HandleBox00](self.impl)))

proc gtk_handle_box_get_handle_position*(self: ptr HandleBox00): PositionType {.
    importc: "gtk_handle_box_get_handle_position", libprag.}

proc getHandlePosition*(self: HandleBox): PositionType =
  gtk_handle_box_get_handle_position(cast[ptr HandleBox00](self.impl))

proc handlePosition*(self: HandleBox): PositionType =
  gtk_handle_box_get_handle_position(cast[ptr HandleBox00](self.impl))

proc gtk_handle_box_get_shadow_type*(self: ptr HandleBox00): ShadowType {.
    importc: "gtk_handle_box_get_shadow_type", libprag.}

proc getShadowType*(self: HandleBox): ShadowType =
  gtk_handle_box_get_shadow_type(cast[ptr HandleBox00](self.impl))

proc shadowType*(self: HandleBox): ShadowType =
  gtk_handle_box_get_shadow_type(cast[ptr HandleBox00](self.impl))

proc gtk_handle_box_get_snap_edge*(self: ptr HandleBox00): PositionType {.
    importc: "gtk_handle_box_get_snap_edge", libprag.}

proc getSnapEdge*(self: HandleBox): PositionType =
  gtk_handle_box_get_snap_edge(cast[ptr HandleBox00](self.impl))

proc snapEdge*(self: HandleBox): PositionType =
  gtk_handle_box_get_snap_edge(cast[ptr HandleBox00](self.impl))

proc gtk_handle_box_set_handle_position*(self: ptr HandleBox00; position: PositionType) {.
    importc: "gtk_handle_box_set_handle_position", libprag.}

proc setHandlePosition*(self: HandleBox; position: PositionType) =
  gtk_handle_box_set_handle_position(cast[ptr HandleBox00](self.impl), position)

proc `handlePosition=`*(self: HandleBox; position: PositionType) =
  gtk_handle_box_set_handle_position(cast[ptr HandleBox00](self.impl), position)

proc gtk_handle_box_set_shadow_type*(self: ptr HandleBox00; `type`: ShadowType) {.
    importc: "gtk_handle_box_set_shadow_type", libprag.}

proc setShadowType*(self: HandleBox; `type`: ShadowType) =
  gtk_handle_box_set_shadow_type(cast[ptr HandleBox00](self.impl), `type`)

proc `shadowType=`*(self: HandleBox; `type`: ShadowType) =
  gtk_handle_box_set_shadow_type(cast[ptr HandleBox00](self.impl), `type`)

proc gtk_handle_box_set_snap_edge*(self: ptr HandleBox00; edge: PositionType) {.
    importc: "gtk_handle_box_set_snap_edge", libprag.}

proc setSnapEdge*(self: HandleBox; edge: PositionType) =
  gtk_handle_box_set_snap_edge(cast[ptr HandleBox00](self.impl), edge)

proc `snapEdge=`*(self: HandleBox; edge: PositionType) =
  gtk_handle_box_set_snap_edge(cast[ptr HandleBox00](self.impl), edge)

type
  HandleBoxClass00* {.pure.} = object
    parentClass*: BinClass00
    childAttached*: proc(handleBox: ptr HandleBox00; child: ptr Widget00) {.cdecl.}
    childDetached*: proc(handleBox: ptr HandleBox00; child: ptr Widget00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  HandleBoxClass* = ref object
    impl*: ptr HandleBoxClass00

type
  HeaderBar* = ref object of Container
  HeaderBar00* = object of Container00

proc gtk_header_bar_new*(): ptr HeaderBar00 {.
    importc: "gtk_header_bar_new", libprag.}

proc newHeaderBar*(): HeaderBar =
  new(result, finalizeGObject)
  result.impl = gtk_header_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHeaderBar*[T](result: var T) =
  assert(result is HeaderBar)
  new(result, finalizeGObject)
  result.impl = gtk_header_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_header_bar_get_custom_title*(self: ptr HeaderBar00): ptr Widget00 {.
    importc: "gtk_header_bar_get_custom_title", libprag.}

proc getCustomTitle*(self: HeaderBar): Widget =
  let gobj = gtk_header_bar_get_custom_title(cast[ptr HeaderBar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc customTitle*(self: HeaderBar): Widget =
  let gobj = gtk_header_bar_get_custom_title(cast[ptr HeaderBar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_header_bar_get_decoration_layout*(self: ptr HeaderBar00): cstring {.
    importc: "gtk_header_bar_get_decoration_layout", libprag.}

proc getDecorationLayout*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_decoration_layout(cast[ptr HeaderBar00](self.impl))
  result = $resul0

proc decorationLayout*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_decoration_layout(cast[ptr HeaderBar00](self.impl))
  result = $resul0

proc gtk_header_bar_get_has_subtitle*(self: ptr HeaderBar00): gboolean {.
    importc: "gtk_header_bar_get_has_subtitle", libprag.}

proc getHasSubtitle*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_has_subtitle(cast[ptr HeaderBar00](self.impl)))

proc hasSubtitle*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_has_subtitle(cast[ptr HeaderBar00](self.impl)))

proc gtk_header_bar_get_show_close_button*(self: ptr HeaderBar00): gboolean {.
    importc: "gtk_header_bar_get_show_close_button", libprag.}

proc getShowCloseButton*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_show_close_button(cast[ptr HeaderBar00](self.impl)))

proc showCloseButton*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_show_close_button(cast[ptr HeaderBar00](self.impl)))

proc gtk_header_bar_get_subtitle*(self: ptr HeaderBar00): cstring {.
    importc: "gtk_header_bar_get_subtitle", libprag.}

proc getSubtitle*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_subtitle(cast[ptr HeaderBar00](self.impl))
  result = $resul0

proc subtitle*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_subtitle(cast[ptr HeaderBar00](self.impl))
  result = $resul0

proc gtk_header_bar_get_title*(self: ptr HeaderBar00): cstring {.
    importc: "gtk_header_bar_get_title", libprag.}

proc getTitle*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_title(cast[ptr HeaderBar00](self.impl))
  result = $resul0

proc title*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_title(cast[ptr HeaderBar00](self.impl))
  result = $resul0

proc gtk_header_bar_pack_end*(self: ptr HeaderBar00; child: ptr Widget00) {.
    importc: "gtk_header_bar_pack_end", libprag.}

proc packEnd*(self: HeaderBar; child: Widget) =
  gtk_header_bar_pack_end(cast[ptr HeaderBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_header_bar_pack_start*(self: ptr HeaderBar00; child: ptr Widget00) {.
    importc: "gtk_header_bar_pack_start", libprag.}

proc packStart*(self: HeaderBar; child: Widget) =
  gtk_header_bar_pack_start(cast[ptr HeaderBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_header_bar_set_custom_title*(self: ptr HeaderBar00; titleWidget: ptr Widget00) {.
    importc: "gtk_header_bar_set_custom_title", libprag.}

proc setCustomTitle*(self: HeaderBar; titleWidget: Widget) =
  gtk_header_bar_set_custom_title(cast[ptr HeaderBar00](self.impl), cast[ptr Widget00](titleWidget.impl))

proc `customTitle=`*(self: HeaderBar; titleWidget: Widget) =
  gtk_header_bar_set_custom_title(cast[ptr HeaderBar00](self.impl), cast[ptr Widget00](titleWidget.impl))

proc gtk_header_bar_set_decoration_layout*(self: ptr HeaderBar00; layout: cstring) {.
    importc: "gtk_header_bar_set_decoration_layout", libprag.}

proc setDecorationLayout*(self: HeaderBar; layout: string) =
  gtk_header_bar_set_decoration_layout(cast[ptr HeaderBar00](self.impl), cstring(layout))

proc `decorationLayout=`*(self: HeaderBar; layout: string) =
  gtk_header_bar_set_decoration_layout(cast[ptr HeaderBar00](self.impl), cstring(layout))

proc gtk_header_bar_set_has_subtitle*(self: ptr HeaderBar00; setting: gboolean) {.
    importc: "gtk_header_bar_set_has_subtitle", libprag.}

proc setHasSubtitle*(self: HeaderBar; setting: bool) =
  gtk_header_bar_set_has_subtitle(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc `hasSubtitle=`*(self: HeaderBar; setting: bool) =
  gtk_header_bar_set_has_subtitle(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc gtk_header_bar_set_show_close_button*(self: ptr HeaderBar00; setting: gboolean) {.
    importc: "gtk_header_bar_set_show_close_button", libprag.}

proc setShowCloseButton*(self: HeaderBar; setting: bool) =
  gtk_header_bar_set_show_close_button(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc `showCloseButton=`*(self: HeaderBar; setting: bool) =
  gtk_header_bar_set_show_close_button(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc gtk_header_bar_set_subtitle*(self: ptr HeaderBar00; subtitle: cstring) {.
    importc: "gtk_header_bar_set_subtitle", libprag.}

proc setSubtitle*(self: HeaderBar; subtitle: string) =
  gtk_header_bar_set_subtitle(cast[ptr HeaderBar00](self.impl), cstring(subtitle))

proc `subtitle=`*(self: HeaderBar; subtitle: string) =
  gtk_header_bar_set_subtitle(cast[ptr HeaderBar00](self.impl), cstring(subtitle))

proc gtk_header_bar_set_title*(self: ptr HeaderBar00; title: cstring) {.
    importc: "gtk_header_bar_set_title", libprag.}

proc setTitle*(self: HeaderBar; title: string) =
  gtk_header_bar_set_title(cast[ptr HeaderBar00](self.impl), cstring(title))

proc `title=`*(self: HeaderBar; title: string) =
  gtk_header_bar_set_title(cast[ptr HeaderBar00](self.impl), cstring(title))

type
  HeaderBarClass00* {.pure.} = object
    parentClass*: ContainerClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  HeaderBarClass* = ref object
    impl*: ptr HeaderBarClass00

type
  HeaderBarPrivate00* {.pure.} = object
  HeaderBarPrivate* = ref object
    impl*: ptr HeaderBarPrivate00

type
  IMContext* = ref object of gobject.Object
  IMContext00* = object of gobject.Object00

proc scCommit*(self: IMContext;  p: proc (self: ptr gobject.Object00; str: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "commit", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDeleteSurrounding*(self: IMContext;  p: proc (self: ptr gobject.Object00; offset: int32; nChars: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "delete-surrounding", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPreeditChanged*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "preedit-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPreeditEnd*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "preedit-end", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPreeditStart*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "preedit-start", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRetrieveSurrounding*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "retrieve-surrounding", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_im_context_delete_surrounding*(self: ptr IMContext00; offset: int32; nChars: int32): gboolean {.
    importc: "gtk_im_context_delete_surrounding", libprag.}

proc deleteSurrounding*(self: IMContext; offset: int; nChars: int): bool =
  toBool(gtk_im_context_delete_surrounding(cast[ptr IMContext00](self.impl), int32(offset), int32(nChars)))

proc gtk_im_context_filter_keypress*(self: ptr IMContext00; event: ptr gdk.EventKey00): gboolean {.
    importc: "gtk_im_context_filter_keypress", libprag.}

proc filterKeypress*(self: IMContext; event: gdk.EventKey): bool =
  toBool(gtk_im_context_filter_keypress(cast[ptr IMContext00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_im_context_focus_in*(self: ptr IMContext00) {.
    importc: "gtk_im_context_focus_in", libprag.}

proc focusIn*(self: IMContext) =
  gtk_im_context_focus_in(cast[ptr IMContext00](self.impl))

proc gtk_im_context_focus_out*(self: ptr IMContext00) {.
    importc: "gtk_im_context_focus_out", libprag.}

proc focusOut*(self: IMContext) =
  gtk_im_context_focus_out(cast[ptr IMContext00](self.impl))

proc gtk_im_context_get_preedit_string*(self: ptr IMContext00; str: var cstring; attrs: var ptr pango.AttrList00; 
    cursorPos: var int32) {.
    importc: "gtk_im_context_get_preedit_string", libprag.}

proc getPreeditString*(self: ptr IMContext00; str: var cstring; attrs: var ptr pango.AttrList00; 
    cursorPos: var int32) {.
    importc: "gtk_im_context_get_preedit_string", libprag.}

proc preeditString*(self: ptr IMContext00; str: var cstring; attrs: var ptr pango.AttrList00; 
    cursorPos: var int32) {.
    importc: "gtk_im_context_get_preedit_string", libprag.}

proc gtk_im_context_get_surrounding*(self: ptr IMContext00; text: var cstring; cursorIndex: var int32): gboolean {.
    importc: "gtk_im_context_get_surrounding", libprag.}

proc getSurrounding*(self: IMContext; text: var string; cursorIndex: var int): bool =
  var cursorIndex_00 = int32(cursorIndex)
  var text_00 = cstring(text)
  result = toBool(gtk_im_context_get_surrounding(cast[ptr IMContext00](self.impl), text_00, cursorIndex_00))
  cursorIndex = int(cursorIndex_00)
  text = $(text_00)

proc surrounding*(self: IMContext; text: var string; cursorIndex: var int): bool =
  var cursorIndex_00 = int32(cursorIndex)
  var text_00 = cstring(text)
  result = toBool(gtk_im_context_get_surrounding(cast[ptr IMContext00](self.impl), text_00, cursorIndex_00))
  cursorIndex = int(cursorIndex_00)
  text = $(text_00)

proc gtk_im_context_reset*(self: ptr IMContext00) {.
    importc: "gtk_im_context_reset", libprag.}

proc reset*(self: IMContext) =
  gtk_im_context_reset(cast[ptr IMContext00](self.impl))

proc gtk_im_context_set_client_window*(self: ptr IMContext00; window: ptr gdk.Window00) {.
    importc: "gtk_im_context_set_client_window", libprag.}

proc setClientWindow*(self: IMContext; window: gdk.Window) =
  gtk_im_context_set_client_window(cast[ptr IMContext00](self.impl), cast[ptr gdk.Window00](window.impl))

proc `clientWindow=`*(self: IMContext; window: gdk.Window) =
  gtk_im_context_set_client_window(cast[ptr IMContext00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_im_context_set_cursor_location*(self: ptr IMContext00; area: ptr gdk.Rectangle00) {.
    importc: "gtk_im_context_set_cursor_location", libprag.}

proc setCursorLocation*(self: IMContext; area: gdk.Rectangle) =
  gtk_im_context_set_cursor_location(cast[ptr IMContext00](self.impl), cast[ptr gdk.Rectangle00](area.impl))

proc `cursorLocation=`*(self: IMContext; area: gdk.Rectangle) =
  gtk_im_context_set_cursor_location(cast[ptr IMContext00](self.impl), cast[ptr gdk.Rectangle00](area.impl))

proc gtk_im_context_set_surrounding*(self: ptr IMContext00; text: cstring; len: int32; 
    cursorIndex: int32) {.
    importc: "gtk_im_context_set_surrounding", libprag.}

proc setSurrounding*(self: IMContext; text: string; len: int; cursorIndex: int) =
  gtk_im_context_set_surrounding(cast[ptr IMContext00](self.impl), cstring(text), int32(len), int32(cursorIndex))

proc gtk_im_context_set_use_preedit*(self: ptr IMContext00; usePreedit: gboolean) {.
    importc: "gtk_im_context_set_use_preedit", libprag.}

proc setUsePreedit*(self: IMContext; usePreedit: bool) =
  gtk_im_context_set_use_preedit(cast[ptr IMContext00](self.impl), gboolean(usePreedit))

proc `usePreedit=`*(self: IMContext; usePreedit: bool) =
  gtk_im_context_set_use_preedit(cast[ptr IMContext00](self.impl), gboolean(usePreedit))

type
  IMContextClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    preeditStart*: proc(context: ptr IMContext00) {.cdecl.}
    preeditEnd*: proc(context: ptr IMContext00) {.cdecl.}
    preeditChanged*: proc(context: ptr IMContext00) {.cdecl.}
    commit*: proc(context: ptr IMContext00; str: cstring) {.cdecl.}
    retrieveSurrounding*: proc(context: ptr IMContext00): gboolean {.cdecl.}
    deleteSurrounding*: proc(context: ptr IMContext00; offset: int32; nChars: int32): gboolean {.cdecl.}
    setClientWindow*: proc(context: ptr IMContext00; window: ptr gdk.Window00) {.cdecl.}
    getPreeditString*: proc(context: ptr IMContext00; str: var cstring; attrs: var ptr pango.AttrList00; 
    cursorPos: var int32) {.cdecl.}
    filterKeypress*: proc(context: ptr IMContext00; event: ptr gdk.EventKey00): gboolean {.cdecl.}
    focusIn*: proc(context: ptr IMContext00) {.cdecl.}
    focusOut*: proc(context: ptr IMContext00) {.cdecl.}
    reset*: proc(context: ptr IMContext00) {.cdecl.}
    setCursorLocation*: proc(context: ptr IMContext00; area: ptr gdk.Rectangle00) {.cdecl.}
    setUsePreedit*: proc(context: ptr IMContext00; usePreedit: gboolean) {.cdecl.}
    setSurrounding*: proc(context: ptr IMContext00; text: cstring; len: int32; 
    cursorIndex: int32) {.cdecl.}
    getSurrounding*: proc(context: ptr IMContext00; text: var cstring; cursorIndex: var int32): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
  IMContextClass* = ref object
    impl*: ptr IMContextClass00

type
  IMContextInfo00* {.pure.} = object
    contextId*: cstring
    contextName*: cstring
    domain*: cstring
    domainDirname*: cstring
    defaultLocales*: cstring
  IMContextInfo* = ref object
    impl*: ptr IMContextInfo00

type
  IMContextSimplePrivate00* {.pure.} = object
  IMContextSimplePrivate* = ref object
    impl*: ptr IMContextSimplePrivate00

type
  IMContextSimple* = ref object of IMContext
  IMContextSimple00* = object of IMContext00
    priv2: ptr IMContextSimplePrivate00

proc gtk_im_context_simple_new*(): ptr IMContextSimple00 {.
    importc: "gtk_im_context_simple_new", libprag.}

proc newIMContextSimple*(): IMContextSimple =
  new(result, finalizeGObject)
  result.impl = gtk_im_context_simple_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIMContextSimple*[T](result: var T) =
  assert(result is IMContextSimple)
  new(result, finalizeGObject)
  result.impl = gtk_im_context_simple_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_im_context_simple_add_compose_file*(self: ptr IMContextSimple00; composeFile: cstring) {.
    importc: "gtk_im_context_simple_add_compose_file", libprag.}

proc addComposeFile*(self: IMContextSimple; composeFile: string) =
  gtk_im_context_simple_add_compose_file(cast[ptr IMContextSimple00](self.impl), cstring(composeFile))

type
  IMContextSimpleClass00* {.pure.} = object
    parentClass*: IMContextClass00
  IMContextSimpleClass* = ref object
    impl*: ptr IMContextSimpleClass00

type
  IMMulticontextPrivate00* {.pure.} = object
  IMMulticontextPrivate* = ref object
    impl*: ptr IMMulticontextPrivate00

type
  IMMulticontext* = ref object of IMContext
  IMMulticontext00* = object of IMContext00
    priv2: ptr IMMulticontextPrivate00

proc gtk_im_multicontext_new*(): ptr IMMulticontext00 {.
    importc: "gtk_im_multicontext_new", libprag.}

proc newIMMulticontext*(): IMMulticontext =
  new(result, finalizeGObject)
  result.impl = gtk_im_multicontext_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIMMulticontext*[T](result: var T) =
  assert(result is IMMulticontext)
  new(result, finalizeGObject)
  result.impl = gtk_im_multicontext_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_im_multicontext_append_menuitems*(self: ptr IMMulticontext00; menushell: ptr MenuShell00) {.
    importc: "gtk_im_multicontext_append_menuitems", libprag.}

proc appendMenuitems*(self: IMMulticontext; menushell: MenuShell) =
  gtk_im_multicontext_append_menuitems(cast[ptr IMMulticontext00](self.impl), cast[ptr MenuShell00](menushell.impl))

proc gtk_im_multicontext_get_context_id*(self: ptr IMMulticontext00): cstring {.
    importc: "gtk_im_multicontext_get_context_id", libprag.}

proc getContextId*(self: IMMulticontext): string =
  let resul0 = gtk_im_multicontext_get_context_id(cast[ptr IMMulticontext00](self.impl))
  result = $resul0

proc contextId*(self: IMMulticontext): string =
  let resul0 = gtk_im_multicontext_get_context_id(cast[ptr IMMulticontext00](self.impl))
  result = $resul0

proc gtk_im_multicontext_set_context_id*(self: ptr IMMulticontext00; contextId: cstring) {.
    importc: "gtk_im_multicontext_set_context_id", libprag.}

proc setContextId*(self: IMMulticontext; contextId: string) =
  gtk_im_multicontext_set_context_id(cast[ptr IMMulticontext00](self.impl), cstring(contextId))

proc `contextId=`*(self: IMMulticontext; contextId: string) =
  gtk_im_multicontext_set_context_id(cast[ptr IMMulticontext00](self.impl), cstring(contextId))

type
  IMMulticontextClass00* {.pure.} = object
    parentClass*: IMContextClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  IMMulticontextClass* = ref object
    impl*: ptr IMMulticontextClass00

type
  IMPreeditStyle* {.size: sizeof(cint), pure.} = enum
    nothing = 0
    callback = 1
    none = 2

type
  IMStatusStyle* {.size: sizeof(cint), pure.} = enum
    nothing = 0
    callback = 1
    none = 2

const INPUT_ERROR* = -1'i32

const INTERFACE_AGE* = 15'i32

type
  IconFactoryClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  IconFactoryClass* = ref object
    impl*: ptr IconFactoryClass00

type
  IconInfo* = ref object of gobject.Object
  IconInfo00* = object of gobject.Object00

proc gtk_icon_info_get_attach_points*(self: ptr IconInfo00; points: var gdk.Point00Array; 
    nPoints: var int32): gboolean {.
    importc: "gtk_icon_info_get_attach_points", libprag.}

proc getAttachPoints*(self: IconInfo; points: var gdk.Point00Array; nPoints: var int): bool =
  var nPoints_00 = int32(nPoints)
  result = toBool(gtk_icon_info_get_attach_points(cast[ptr IconInfo00](self.impl), points, nPoints_00))
  nPoints = int(nPoints_00)

proc attachPoints*(self: IconInfo; points: var gdk.Point00Array; nPoints: var int): bool =
  var nPoints_00 = int32(nPoints)
  result = toBool(gtk_icon_info_get_attach_points(cast[ptr IconInfo00](self.impl), points, nPoints_00))
  nPoints = int(nPoints_00)

proc gtk_icon_info_get_base_scale*(self: ptr IconInfo00): int32 {.
    importc: "gtk_icon_info_get_base_scale", libprag.}

proc getBaseScale*(self: IconInfo): int =
  int(gtk_icon_info_get_base_scale(cast[ptr IconInfo00](self.impl)))

proc baseScale*(self: IconInfo): int =
  int(gtk_icon_info_get_base_scale(cast[ptr IconInfo00](self.impl)))

proc gtk_icon_info_get_base_size*(self: ptr IconInfo00): int32 {.
    importc: "gtk_icon_info_get_base_size", libprag.}

proc getBaseSize*(self: IconInfo): int =
  int(gtk_icon_info_get_base_size(cast[ptr IconInfo00](self.impl)))

proc baseSize*(self: IconInfo): int =
  int(gtk_icon_info_get_base_size(cast[ptr IconInfo00](self.impl)))

proc gtk_icon_info_get_builtin_pixbuf*(self: ptr IconInfo00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_info_get_builtin_pixbuf", libprag.}

proc getBuiltinPixbuf*(self: IconInfo): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_info_get_builtin_pixbuf(cast[ptr IconInfo00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc builtinPixbuf*(self: IconInfo): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_info_get_builtin_pixbuf(cast[ptr IconInfo00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_info_get_display_name*(self: ptr IconInfo00): cstring {.
    importc: "gtk_icon_info_get_display_name", libprag.}

proc getDisplayName*(self: IconInfo): string =
  let resul0 = gtk_icon_info_get_display_name(cast[ptr IconInfo00](self.impl))
  result = $resul0

proc displayName*(self: IconInfo): string =
  let resul0 = gtk_icon_info_get_display_name(cast[ptr IconInfo00](self.impl))
  result = $resul0

proc gtk_icon_info_get_embedded_rect*(self: ptr IconInfo00; rectangle: var gdk.Rectangle00): gboolean {.
    importc: "gtk_icon_info_get_embedded_rect", libprag.}

proc getEmbeddedRect*(self: ptr IconInfo00; rectangle: var gdk.Rectangle00): gboolean {.
    importc: "gtk_icon_info_get_embedded_rect", libprag.}

proc embeddedRect*(self: ptr IconInfo00; rectangle: var gdk.Rectangle00): gboolean {.
    importc: "gtk_icon_info_get_embedded_rect", libprag.}

proc gtk_icon_info_get_filename*(self: ptr IconInfo00): ucstring {.
    importc: "gtk_icon_info_get_filename", libprag.}

proc getFilename*(self: IconInfo): ucstring =
  gtk_icon_info_get_filename(cast[ptr IconInfo00](self.impl))

proc filename*(self: IconInfo): ucstring =
  gtk_icon_info_get_filename(cast[ptr IconInfo00](self.impl))

proc gtk_icon_info_is_symbolic*(self: ptr IconInfo00): gboolean {.
    importc: "gtk_icon_info_is_symbolic", libprag.}

proc isSymbolic*(self: IconInfo): bool =
  toBool(gtk_icon_info_is_symbolic(cast[ptr IconInfo00](self.impl)))

proc gtk_icon_info_load_icon*(self: ptr IconInfo00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_info_load_icon", libprag.}

proc loadIcon*(self: IconInfo): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_info_load_icon(cast[ptr IconInfo00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_info_load_icon_async*(self: ptr IconInfo00; cancellable: ptr gio.Cancellable00; 
    callback: AsyncReadyCallback; userData: pointer) {.
    importc: "gtk_icon_info_load_icon_async", libprag.}

proc loadIconAsync*(self: IconInfo; cancellable: gio.Cancellable; callback: AsyncReadyCallback; 
    userData: pointer) =
  gtk_icon_info_load_icon_async(cast[ptr IconInfo00](self.impl), cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_icon_info_load_icon_finish*(self: ptr IconInfo00; res: ptr gio.AsyncResult00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_info_load_icon_finish", libprag.}

proc loadIconFinish*(self: IconInfo; res: gio.AsyncResult): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_info_load_icon_finish(cast[ptr IconInfo00](self.impl), cast[ptr gio.AsyncResult00](res.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_info_load_surface*(self: ptr IconInfo00; forWindow: ptr gdk.Window00): ptr cairo.Surface00 {.
    importc: "gtk_icon_info_load_surface", libprag.}

proc loadSurface*(self: IconInfo; forWindow: gdk.Window): cairo.Surface =
  new(result)
  result.impl = gtk_icon_info_load_surface(cast[ptr IconInfo00](self.impl), cast[ptr gdk.Window00](forWindow.impl))

proc gtk_icon_info_load_symbolic*(self: ptr IconInfo00; fg: ptr gdk.RGBA00; successColor: ptr gdk.RGBA00; 
    warningColor: ptr gdk.RGBA00; errorColor: ptr gdk.RGBA00; wasSymbolic: var gboolean): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_info_load_symbolic", libprag.}

proc loadSymbolic*(self: IconInfo; fg: gdk.RGBA; successColor: gdk.RGBA; 
    warningColor: gdk.RGBA; errorColor: gdk.RGBA; wasSymbolic: var bool): gdkpixbuf.Pixbuf =
  var wasSymbolic_00 = gboolean(wasSymbolic)
  let gobj = gtk_icon_info_load_symbolic(cast[ptr IconInfo00](self.impl), cast[ptr gdk.RGBA00](fg.impl), cast[ptr gdk.RGBA00](successColor.impl), cast[ptr gdk.RGBA00](warningColor.impl), cast[ptr gdk.RGBA00](errorColor.impl), wasSymbolic_00)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_load_symbolic_async*(self: ptr IconInfo00; fg: ptr gdk.RGBA00; successColor: ptr gdk.RGBA00; 
    warningColor: ptr gdk.RGBA00; errorColor: ptr gdk.RGBA00; cancellable: ptr gio.Cancellable00; 
    callback: AsyncReadyCallback; userData: pointer) {.
    importc: "gtk_icon_info_load_symbolic_async", libprag.}

proc loadSymbolicAsync*(self: IconInfo; fg: gdk.RGBA; successColor: gdk.RGBA; 
    warningColor: gdk.RGBA; errorColor: gdk.RGBA; cancellable: gio.Cancellable; callback: AsyncReadyCallback; 
    userData: pointer) =
  gtk_icon_info_load_symbolic_async(cast[ptr IconInfo00](self.impl), cast[ptr gdk.RGBA00](fg.impl), cast[ptr gdk.RGBA00](successColor.impl), cast[ptr gdk.RGBA00](warningColor.impl), cast[ptr gdk.RGBA00](errorColor.impl), cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_icon_info_load_symbolic_finish*(self: ptr IconInfo00; res: ptr gio.AsyncResult00; 
    wasSymbolic: var gboolean): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_info_load_symbolic_finish", libprag.}

proc loadSymbolicFinish*(self: IconInfo; res: gio.AsyncResult; wasSymbolic: var bool): gdkpixbuf.Pixbuf =
  var wasSymbolic_00 = gboolean(wasSymbolic)
  let gobj = gtk_icon_info_load_symbolic_finish(cast[ptr IconInfo00](self.impl), cast[ptr gio.AsyncResult00](res.impl), wasSymbolic_00)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_load_symbolic_for_context*(self: ptr IconInfo00; context: ptr StyleContext00; 
    wasSymbolic: var gboolean): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_info_load_symbolic_for_context", libprag.}

proc loadSymbolicForContext*(self: IconInfo; context: StyleContext; wasSymbolic: var bool): gdkpixbuf.Pixbuf =
  var wasSymbolic_00 = gboolean(wasSymbolic)
  let gobj = gtk_icon_info_load_symbolic_for_context(cast[ptr IconInfo00](self.impl), cast[ptr StyleContext00](context.impl), wasSymbolic_00)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_load_symbolic_for_context_async*(self: ptr IconInfo00; context: ptr StyleContext00; 
    cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback; userData: pointer) {.
    importc: "gtk_icon_info_load_symbolic_for_context_async", libprag.}

proc loadSymbolicForContextAsync*(self: IconInfo; context: StyleContext; cancellable: gio.Cancellable; 
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_icon_info_load_symbolic_for_context_async(cast[ptr IconInfo00](self.impl), cast[ptr StyleContext00](context.impl), cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_icon_info_load_symbolic_for_context_finish*(self: ptr IconInfo00; res: ptr gio.AsyncResult00; 
    wasSymbolic: var gboolean): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_info_load_symbolic_for_context_finish", libprag.}

proc loadSymbolicForContextFinish*(self: IconInfo; res: gio.AsyncResult; wasSymbolic: var bool): gdkpixbuf.Pixbuf =
  var wasSymbolic_00 = gboolean(wasSymbolic)
  let gobj = gtk_icon_info_load_symbolic_for_context_finish(cast[ptr IconInfo00](self.impl), cast[ptr gio.AsyncResult00](res.impl), wasSymbolic_00)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_load_symbolic_for_style*(self: ptr IconInfo00; style: ptr Style00; state: StateType; 
    wasSymbolic: var gboolean): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_info_load_symbolic_for_style", libprag.}

proc loadSymbolicForStyle*(self: IconInfo; style: Style; state: StateType; wasSymbolic: var bool): gdkpixbuf.Pixbuf =
  var wasSymbolic_00 = gboolean(wasSymbolic)
  let gobj = gtk_icon_info_load_symbolic_for_style(cast[ptr IconInfo00](self.impl), cast[ptr Style00](style.impl), state, wasSymbolic_00)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_set_raw_coordinates*(self: ptr IconInfo00; rawCoordinates: gboolean) {.
    importc: "gtk_icon_info_set_raw_coordinates", libprag.}

proc setRawCoordinates*(self: IconInfo; rawCoordinates: bool) =
  gtk_icon_info_set_raw_coordinates(cast[ptr IconInfo00](self.impl), gboolean(rawCoordinates))

proc `rawCoordinates=`*(self: IconInfo; rawCoordinates: bool) =
  gtk_icon_info_set_raw_coordinates(cast[ptr IconInfo00](self.impl), gboolean(rawCoordinates))

type
  IconThemePrivate00* {.pure.} = object
  IconThemePrivate* = ref object
    impl*: ptr IconThemePrivate00

type
  IconTheme* = ref object of gobject.Object
  IconTheme00* = object of gobject.Object00
    priv1: ptr IconThemePrivate00

proc scChanged*(self: IconTheme;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_icon_theme_new*(): ptr IconTheme00 {.
    importc: "gtk_icon_theme_new", libprag.}

proc newIconTheme*(): IconTheme =
  new(result, finalizeGObject)
  result.impl = gtk_icon_theme_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconTheme*[T](result: var T) =
  assert(result is IconTheme)
  new(result, finalizeGObject)
  result.impl = gtk_icon_theme_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_add_builtin_icon*(iconName: cstring; size: int32; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_icon_theme_add_builtin_icon", libprag.}

proc addBuiltinIcon*(iconName: string; size: int; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_icon_theme_add_builtin_icon(cstring(iconName), int32(size), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_icon_theme_get_default*(): ptr IconTheme00 {.
    importc: "gtk_icon_theme_get_default", libprag.}

proc getDefault*(): IconTheme =
  let gobj = gtk_icon_theme_get_default()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconTheme](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc default*(): IconTheme =
  let gobj = gtk_icon_theme_get_default()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconTheme](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_get_for_screen*(screen: ptr gdk.Screen00): ptr IconTheme00 {.
    importc: "gtk_icon_theme_get_for_screen", libprag.}

proc getForScreen*(screen: gdk.Screen): IconTheme =
  let gobj = gtk_icon_theme_get_for_screen(cast[ptr gdk.Screen00](screen.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconTheme](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc forScreen*(screen: gdk.Screen): IconTheme =
  let gobj = gtk_icon_theme_get_for_screen(cast[ptr gdk.Screen00](screen.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconTheme](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_add_resource_path*(self: ptr IconTheme00; path: cstring) {.
    importc: "gtk_icon_theme_add_resource_path", libprag.}

proc addResourcePath*(self: IconTheme; path: string) =
  gtk_icon_theme_add_resource_path(cast[ptr IconTheme00](self.impl), cstring(path))

proc gtk_icon_theme_append_search_path*(self: ptr IconTheme00; path: ucstring) {.
    importc: "gtk_icon_theme_append_search_path", libprag.}

proc appendSearchPath*(self: IconTheme; path: ucstring) =
  gtk_icon_theme_append_search_path(cast[ptr IconTheme00](self.impl), path)

proc gtk_icon_theme_get_example_icon_name*(self: ptr IconTheme00): cstring {.
    importc: "gtk_icon_theme_get_example_icon_name", libprag.}

proc getExampleIconName*(self: IconTheme): string =
  let resul0 = gtk_icon_theme_get_example_icon_name(cast[ptr IconTheme00](self.impl))
  result = $resul0
  cogfree(resul0)

proc exampleIconName*(self: IconTheme): string =
  let resul0 = gtk_icon_theme_get_example_icon_name(cast[ptr IconTheme00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_icon_theme_get_icon_sizes*(self: ptr IconTheme00; iconName: cstring): int32Array {.
    importc: "gtk_icon_theme_get_icon_sizes", libprag.}

proc getIconSizes*(self: IconTheme; iconName: string): int32Array =
  gtk_icon_theme_get_icon_sizes(cast[ptr IconTheme00](self.impl), cstring(iconName))

proc iconSizes*(self: IconTheme; iconName: string): int32Array =
  gtk_icon_theme_get_icon_sizes(cast[ptr IconTheme00](self.impl), cstring(iconName))

proc gtk_icon_theme_get_search_path*(self: ptr IconTheme00; path: var ucstringArray; nElements: var int32) {.
    importc: "gtk_icon_theme_get_search_path", libprag.}

proc getSearchPath*(self: IconTheme; path: var ucstringArray; nElements: var int) =
  var nElements_00 = int32(nElements)
  gtk_icon_theme_get_search_path(cast[ptr IconTheme00](self.impl), path, nElements_00)
  nElements = int(nElements_00)

proc searchPath*(self: IconTheme; path: var ucstringArray; nElements: var int) =
  var nElements_00 = int32(nElements)
  gtk_icon_theme_get_search_path(cast[ptr IconTheme00](self.impl), path, nElements_00)
  nElements = int(nElements_00)

proc gtk_icon_theme_has_icon*(self: ptr IconTheme00; iconName: cstring): gboolean {.
    importc: "gtk_icon_theme_has_icon", libprag.}

proc hasIcon*(self: IconTheme; iconName: string): bool =
  toBool(gtk_icon_theme_has_icon(cast[ptr IconTheme00](self.impl), cstring(iconName)))

proc gtk_icon_theme_list_contexts*(self: ptr IconTheme00): ptr pointer {.
    importc: "gtk_icon_theme_list_contexts", libprag.}

proc listContexts*(self: IconTheme): ptr pointer =
  gtk_icon_theme_list_contexts(cast[ptr IconTheme00](self.impl))

proc gtk_icon_theme_list_icons*(self: ptr IconTheme00; context: cstring): ptr pointer {.
    importc: "gtk_icon_theme_list_icons", libprag.}

proc listIcons*(self: IconTheme; context: string): ptr pointer =
  gtk_icon_theme_list_icons(cast[ptr IconTheme00](self.impl), cstring(context))

proc gtk_icon_theme_prepend_search_path*(self: ptr IconTheme00; path: ucstring) {.
    importc: "gtk_icon_theme_prepend_search_path", libprag.}

proc prependSearchPath*(self: IconTheme; path: ucstring) =
  gtk_icon_theme_prepend_search_path(cast[ptr IconTheme00](self.impl), path)

proc gtk_icon_theme_rescan_if_needed*(self: ptr IconTheme00): gboolean {.
    importc: "gtk_icon_theme_rescan_if_needed", libprag.}

proc rescanIfNeeded*(self: IconTheme): bool =
  toBool(gtk_icon_theme_rescan_if_needed(cast[ptr IconTheme00](self.impl)))

proc gtk_icon_theme_set_custom_theme*(self: ptr IconTheme00; themeName: cstring) {.
    importc: "gtk_icon_theme_set_custom_theme", libprag.}

proc setCustomTheme*(self: IconTheme; themeName: string) =
  gtk_icon_theme_set_custom_theme(cast[ptr IconTheme00](self.impl), cstring(themeName))

proc `customTheme=`*(self: IconTheme; themeName: string) =
  gtk_icon_theme_set_custom_theme(cast[ptr IconTheme00](self.impl), cstring(themeName))

proc gtk_icon_theme_set_screen*(self: ptr IconTheme00; screen: ptr gdk.Screen00) {.
    importc: "gtk_icon_theme_set_screen", libprag.}

proc setScreen*(self: IconTheme; screen: gdk.Screen) =
  gtk_icon_theme_set_screen(cast[ptr IconTheme00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: IconTheme; screen: gdk.Screen) =
  gtk_icon_theme_set_screen(cast[ptr IconTheme00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc gtk_icon_theme_set_search_path*(self: ptr IconTheme00; path: ucstringArray; nElements: int32) {.
    importc: "gtk_icon_theme_set_search_path", libprag.}

proc setSearchPath*(self: IconTheme; path: ucstringArray; nElements: int) =
  gtk_icon_theme_set_search_path(cast[ptr IconTheme00](self.impl), path, int32(nElements))

proc gtk_icon_info_new_for_pixbuf*(iconTheme: ptr IconTheme00; pixbuf: ptr gdkpixbuf.Pixbuf00): ptr IconInfo00 {.
    importc: "gtk_icon_info_new_for_pixbuf", libprag.}

proc newIconInfoForPixbuf*(iconTheme: IconTheme; pixbuf: gdkpixbuf.Pixbuf): IconInfo =
  new(result, finalizeGObject)
  result.impl = gtk_icon_info_new_for_pixbuf(cast[ptr IconTheme00](iconTheme.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconInfoForPixbuf*[T](result: var T; iconTheme: IconTheme; pixbuf: gdkpixbuf.Pixbuf) =
  assert(result is IconInfo)
  new(result, finalizeGObject)
  result.impl = gtk_icon_info_new_for_pixbuf(cast[ptr IconTheme00](iconTheme.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  IconLookupFlag* {.size: sizeof(cint), pure.} = enum
    noSvg = 1
    forceSvg = 2
    useBuiltin = 3
    genericFallback = 4
    forceSize = 5
    forceRegular = 6
    forceSymbolic = 7
    dirLtr = 8
    dirRtl = 9

  IconLookupFlags* {.size: sizeof(cint).} = set[IconLookupFlag]

proc gtk_icon_theme_choose_icon*(self: ptr IconTheme00; iconNames: cstringArray; size: int32; 
    flags: IconLookupFlags): ptr IconInfo00 {.
    importc: "gtk_icon_theme_choose_icon", libprag.}

proc chooseIcon*(self: IconTheme; iconNames: cstringArray; size: int; 
    flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_choose_icon(cast[ptr IconTheme00](self.impl), iconNames, int32(size), flags)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconInfo](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_choose_icon_for_scale*(self: ptr IconTheme00; iconNames: cstringArray; size: int32; 
    scale: int32; flags: IconLookupFlags): ptr IconInfo00 {.
    importc: "gtk_icon_theme_choose_icon_for_scale", libprag.}

proc chooseIconForScale*(self: IconTheme; iconNames: cstringArray; size: int; 
    scale: int; flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_choose_icon_for_scale(cast[ptr IconTheme00](self.impl), iconNames, int32(size), int32(scale), flags)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconInfo](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_load_icon*(self: ptr IconTheme00; iconName: cstring; size: int32; 
    flags: IconLookupFlags): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_theme_load_icon", libprag.}

proc loadIcon*(self: IconTheme; iconName: string; size: int; flags: IconLookupFlags): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_theme_load_icon(cast[ptr IconTheme00](self.impl), cstring(iconName), int32(size), flags)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_load_icon_for_scale*(self: ptr IconTheme00; iconName: cstring; size: int32; 
    scale: int32; flags: IconLookupFlags): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_icon_theme_load_icon_for_scale", libprag.}

proc loadIconForScale*(self: IconTheme; iconName: string; size: int; scale: int; 
    flags: IconLookupFlags): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_theme_load_icon_for_scale(cast[ptr IconTheme00](self.impl), cstring(iconName), int32(size), int32(scale), flags)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_load_surface*(self: ptr IconTheme00; iconName: cstring; size: int32; 
    scale: int32; forWindow: ptr gdk.Window00; flags: IconLookupFlags): ptr cairo.Surface00 {.
    importc: "gtk_icon_theme_load_surface", libprag.}

proc loadSurface*(self: IconTheme; iconName: string; size: int; scale: int; 
    forWindow: gdk.Window; flags: IconLookupFlags): cairo.Surface =
  new(result)
  result.impl = gtk_icon_theme_load_surface(cast[ptr IconTheme00](self.impl), cstring(iconName), int32(size), int32(scale), cast[ptr gdk.Window00](forWindow.impl), flags)

proc gtk_icon_theme_lookup_by_gicon*(self: ptr IconTheme00; icon: ptr gio.Icon00; size: int32; 
    flags: IconLookupFlags): ptr IconInfo00 {.
    importc: "gtk_icon_theme_lookup_by_gicon", libprag.}

proc lookupByGicon*(self: IconTheme; icon: gio.Icon; size: int; flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_lookup_by_gicon(cast[ptr IconTheme00](self.impl), cast[ptr gio.Icon00](icon.impl), int32(size), flags)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconInfo](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_lookup_by_gicon_for_scale*(self: ptr IconTheme00; icon: ptr gio.Icon00; size: int32; 
    scale: int32; flags: IconLookupFlags): ptr IconInfo00 {.
    importc: "gtk_icon_theme_lookup_by_gicon_for_scale", libprag.}

proc lookupByGiconForScale*(self: IconTheme; icon: gio.Icon; size: int; scale: int; 
    flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_lookup_by_gicon_for_scale(cast[ptr IconTheme00](self.impl), cast[ptr gio.Icon00](icon.impl), int32(size), int32(scale), flags)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconInfo](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_lookup_icon*(self: ptr IconTheme00; iconName: cstring; size: int32; 
    flags: IconLookupFlags): ptr IconInfo00 {.
    importc: "gtk_icon_theme_lookup_icon", libprag.}

proc lookupIcon*(self: IconTheme; iconName: string; size: int; flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_lookup_icon(cast[ptr IconTheme00](self.impl), cstring(iconName), int32(size), flags)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconInfo](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_lookup_icon_for_scale*(self: ptr IconTheme00; iconName: cstring; size: int32; 
    scale: int32; flags: IconLookupFlags): ptr IconInfo00 {.
    importc: "gtk_icon_theme_lookup_icon_for_scale", libprag.}

proc lookupIconForScale*(self: IconTheme; iconName: string; size: int; scale: int; 
    flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_lookup_icon_for_scale(cast[ptr IconTheme00](self.impl), cstring(iconName), int32(size), int32(scale), flags)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[IconInfo](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  IconInfoClass00* {.pure.} = object
  IconInfoClass* = ref object
    impl*: ptr IconInfoClass00

type
  IconSize* {.size: sizeof(cint), pure.} = enum
    invalid = 0
    menu = 1
    smallToolbar = 2
    largeToolbar = 3
    button = 4
    dnd = 5
    dialog = 6

proc gtk_icon_size_from_name*(name: cstring): int32 {.
    importc: "gtk_icon_size_from_name", libprag.}

proc fromName*(name: cstring): int32 {.
    importc: "gtk_icon_size_from_name", libprag.}

proc gtk_icon_size_get_name*(size: int32): cstring {.
    importc: "gtk_icon_size_get_name", libprag.}

proc getName*(size: int): string =
  let resul0 = gtk_icon_size_get_name(int32(size))
  result = $resul0

proc name*(size: int): string =
  let resul0 = gtk_icon_size_get_name(int32(size))
  result = $resul0

proc gtk_icon_size_lookup*(size: int32; width: var int32; height: var int32): gboolean {.
    importc: "gtk_icon_size_lookup", libprag.}

proc lookup*(size: int32; width: var int32; height: var int32): gboolean {.
    importc: "gtk_icon_size_lookup", libprag.}

proc gtk_icon_size_lookup_for_settings*(settings: ptr Settings00; size: int32; width: var int32; 
    height: var int32): gboolean {.
    importc: "gtk_icon_size_lookup_for_settings", libprag.}

proc lookupForSettings*(settings: Settings; size: int; width: var int; height: var int): bool =
  var height_00 = int32(height)
  var width_00 = int32(width)
  result = toBool(gtk_icon_size_lookup_for_settings(cast[ptr Settings00](settings.impl), int32(size), width_00, height_00))
  height = int(height_00)
  width = int(width_00)

proc gtk_icon_size_register*(name: cstring; width: int32; height: int32): int32 {.
    importc: "gtk_icon_size_register", libprag.}

proc register*(name: cstring; width: int32; height: int32): int32 {.
    importc: "gtk_icon_size_register", libprag.}

proc gtk_icon_size_register_alias*(alias: cstring; target: int32) {.
    importc: "gtk_icon_size_register_alias", libprag.}

proc registerAlias*(alias: cstring; target: int32) {.
    importc: "gtk_icon_size_register_alias", libprag.}

type
  IconThemeClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    changed*: proc(iconTheme: ptr IconTheme00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  IconThemeClass* = ref object
    impl*: ptr IconThemeClass00

type
  IconThemeError* {.size: sizeof(cint), pure.} = enum
    notFound = 0
    failed = 1

proc gtk_icon_theme_error_quark*(): uint32 {.
    importc: "gtk_icon_theme_error_quark", libprag.}

type
  IconViewPrivate00* {.pure.} = object
  IconViewPrivate* = ref object
    impl*: ptr IconViewPrivate00

type
  IconView* = ref object of Container
  IconView00* = object of Container00
    priv3: ptr IconViewPrivate00

proc scActivateCursorItem*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-cursor-item", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scItemActivated*(self: IconView;  p: proc (self: ptr gobject.Object00; path: TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "item-activated", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveCursor*(self: IconView;  p: proc (self: ptr gobject.Object00; step: MovementStep; count: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectAll*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectCursorItem*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select-cursor-item", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectionChanged*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "selection-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleCursorItem*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-cursor-item", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUnselectAll*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_icon_view_new*(): ptr IconView00 {.
    importc: "gtk_icon_view_new", libprag.}

proc newIconView*(): IconView =
  new(result, finalizeGObject)
  result.impl = gtk_icon_view_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconView*[T](result: var T) =
  assert(result is IconView)
  new(result, finalizeGObject)
  result.impl = gtk_icon_view_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_new_with_area*(area: ptr CellArea00): ptr IconView00 {.
    importc: "gtk_icon_view_new_with_area", libprag.}

proc newIconViewWithArea*(area: CellArea): IconView =
  new(result, finalizeGObject)
  result.impl = gtk_icon_view_new_with_area(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconViewWithArea*[T](result: var T; area: CellArea) =
  assert(result is IconView)
  new(result, finalizeGObject)
  result.impl = gtk_icon_view_new_with_area(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_new_with_model*(model: ptr TreeModel00): ptr IconView00 {.
    importc: "gtk_icon_view_new_with_model", libprag.}

proc newIconViewWithModel*(model: TreeModel): IconView =
  new(result, finalizeGObject)
  result.impl = gtk_icon_view_new_with_model(cast[ptr TreeModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconViewWithModel*[T](result: var T; model: TreeModel) =
  assert(result is IconView)
  new(result, finalizeGObject)
  result.impl = gtk_icon_view_new_with_model(cast[ptr TreeModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_convert_widget_to_bin_window_coords*(self: ptr IconView00; wx: int32; wy: int32; bx: var int32; 
    by: var int32) {.
    importc: "gtk_icon_view_convert_widget_to_bin_window_coords", libprag.}

proc convertWidgetToBinWindowCoords*(self: IconView; wx: int; wy: int; bx: var int; by: var int) =
  var bx_00 = int32(bx)
  var by_00 = int32(by)
  gtk_icon_view_convert_widget_to_bin_window_coords(cast[ptr IconView00](self.impl), int32(wx), int32(wy), bx_00, by_00)
  bx = int(bx_00)
  by = int(by_00)

proc gtk_icon_view_create_drag_icon*(self: ptr IconView00; path: ptr TreePath00): ptr cairo.Surface00 {.
    importc: "gtk_icon_view_create_drag_icon", libprag.}

proc createDragIcon*(self: IconView; path: TreePath): cairo.Surface =
  new(result)
  result.impl = gtk_icon_view_create_drag_icon(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_enable_model_drag_dest*(self: ptr IconView00; targets: TargetEntry00Array; 
    nTargets: int32; actions: gdk.DragAction) {.
    importc: "gtk_icon_view_enable_model_drag_dest", libprag.}

proc enableModelDragDest*(self: IconView; targets: TargetEntry00Array; nTargets: int; 
    actions: gdk.DragAction) =
  gtk_icon_view_enable_model_drag_dest(cast[ptr IconView00](self.impl), targets, int32(nTargets), actions)

proc gtk_icon_view_enable_model_drag_source*(self: ptr IconView00; startButtonMask: gdk.ModifierType; 
    targets: TargetEntry00Array; nTargets: int32; actions: gdk.DragAction) {.
    importc: "gtk_icon_view_enable_model_drag_source", libprag.}

proc enableModelDragSource*(self: IconView; startButtonMask: gdk.ModifierType; 
    targets: TargetEntry00Array; nTargets: int; actions: gdk.DragAction) =
  gtk_icon_view_enable_model_drag_source(cast[ptr IconView00](self.impl), startButtonMask, targets, int32(nTargets), actions)

proc gtk_icon_view_get_activate_on_single_click*(self: ptr IconView00): gboolean {.
    importc: "gtk_icon_view_get_activate_on_single_click", libprag.}

proc getActivateOnSingleClick*(self: IconView): bool =
  toBool(gtk_icon_view_get_activate_on_single_click(cast[ptr IconView00](self.impl)))

proc activateOnSingleClick*(self: IconView): bool =
  toBool(gtk_icon_view_get_activate_on_single_click(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_cell_rect*(self: ptr IconView00; path: ptr TreePath00; cell: ptr CellRenderer00; 
    rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_icon_view_get_cell_rect", libprag.}

proc getCellRect*(self: ptr IconView00; path: ptr TreePath00; cell: ptr CellRenderer00; 
    rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_icon_view_get_cell_rect", libprag.}

proc cellRect*(self: ptr IconView00; path: ptr TreePath00; cell: ptr CellRenderer00; 
    rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_icon_view_get_cell_rect", libprag.}

proc gtk_icon_view_get_column_spacing*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_column_spacing", libprag.}

proc getColumnSpacing*(self: IconView): int =
  int(gtk_icon_view_get_column_spacing(cast[ptr IconView00](self.impl)))

proc columnSpacing*(self: IconView): int =
  int(gtk_icon_view_get_column_spacing(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_columns*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_columns", libprag.}

proc getColumns*(self: IconView): int =
  int(gtk_icon_view_get_columns(cast[ptr IconView00](self.impl)))

proc columns*(self: IconView): int =
  int(gtk_icon_view_get_columns(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_cursor*(self: ptr IconView00; path: var ptr TreePath00; cell: var ptr CellRenderer00): gboolean {.
    importc: "gtk_icon_view_get_cursor", libprag.}

proc getCursor*(self: ptr IconView00; path: var ptr TreePath00; cell: var ptr CellRenderer00): gboolean {.
    importc: "gtk_icon_view_get_cursor", libprag.}

proc cursor*(self: ptr IconView00; path: var ptr TreePath00; cell: var ptr CellRenderer00): gboolean {.
    importc: "gtk_icon_view_get_cursor", libprag.}

proc gtk_icon_view_get_item_at_pos*(self: ptr IconView00; x: int32; y: int32; path: var ptr TreePath00; 
    cell: var ptr CellRenderer00): gboolean {.
    importc: "gtk_icon_view_get_item_at_pos", libprag.}

proc getItemAtPos*(self: ptr IconView00; x: int32; y: int32; path: var ptr TreePath00; 
    cell: var ptr CellRenderer00): gboolean {.
    importc: "gtk_icon_view_get_item_at_pos", libprag.}

proc itemAtPos*(self: ptr IconView00; x: int32; y: int32; path: var ptr TreePath00; 
    cell: var ptr CellRenderer00): gboolean {.
    importc: "gtk_icon_view_get_item_at_pos", libprag.}

proc gtk_icon_view_get_item_column*(self: ptr IconView00; path: ptr TreePath00): int32 {.
    importc: "gtk_icon_view_get_item_column", libprag.}

proc getItemColumn*(self: IconView; path: TreePath): int =
  int(gtk_icon_view_get_item_column(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc itemColumn*(self: IconView; path: TreePath): int =
  int(gtk_icon_view_get_item_column(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_icon_view_get_item_orientation*(self: ptr IconView00): Orientation {.
    importc: "gtk_icon_view_get_item_orientation", libprag.}

proc getItemOrientation*(self: IconView): Orientation =
  gtk_icon_view_get_item_orientation(cast[ptr IconView00](self.impl))

proc itemOrientation*(self: IconView): Orientation =
  gtk_icon_view_get_item_orientation(cast[ptr IconView00](self.impl))

proc gtk_icon_view_get_item_padding*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_item_padding", libprag.}

proc getItemPadding*(self: IconView): int =
  int(gtk_icon_view_get_item_padding(cast[ptr IconView00](self.impl)))

proc itemPadding*(self: IconView): int =
  int(gtk_icon_view_get_item_padding(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_item_row*(self: ptr IconView00; path: ptr TreePath00): int32 {.
    importc: "gtk_icon_view_get_item_row", libprag.}

proc getItemRow*(self: IconView; path: TreePath): int =
  int(gtk_icon_view_get_item_row(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc itemRow*(self: IconView; path: TreePath): int =
  int(gtk_icon_view_get_item_row(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_icon_view_get_item_width*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_item_width", libprag.}

proc getItemWidth*(self: IconView): int =
  int(gtk_icon_view_get_item_width(cast[ptr IconView00](self.impl)))

proc itemWidth*(self: IconView): int =
  int(gtk_icon_view_get_item_width(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_margin*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_margin", libprag.}

proc getMargin*(self: IconView): int =
  int(gtk_icon_view_get_margin(cast[ptr IconView00](self.impl)))

proc margin*(self: IconView): int =
  int(gtk_icon_view_get_margin(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_markup_column*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_markup_column", libprag.}

proc getMarkupColumn*(self: IconView): int =
  int(gtk_icon_view_get_markup_column(cast[ptr IconView00](self.impl)))

proc markupColumn*(self: IconView): int =
  int(gtk_icon_view_get_markup_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_model*(self: ptr IconView00): ptr TreeModel00 {.
    importc: "gtk_icon_view_get_model", libprag.}

proc getModel*(self: IconView): TreeModel =
  new(result)
  result.impl = gtk_icon_view_get_model(cast[ptr IconView00](self.impl))

proc model*(self: IconView): TreeModel =
  new(result)
  result.impl = gtk_icon_view_get_model(cast[ptr IconView00](self.impl))

proc gtk_icon_view_get_path_at_pos*(self: ptr IconView00; x: int32; y: int32): ptr TreePath00 {.
    importc: "gtk_icon_view_get_path_at_pos", libprag.}

proc getPathAtPos*(self: IconView; x: int; y: int): TreePath =
  new(result)
  result.impl = gtk_icon_view_get_path_at_pos(cast[ptr IconView00](self.impl), int32(x), int32(y))

proc pathAtPos*(self: IconView; x: int; y: int): TreePath =
  new(result)
  result.impl = gtk_icon_view_get_path_at_pos(cast[ptr IconView00](self.impl), int32(x), int32(y))

proc gtk_icon_view_get_pixbuf_column*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_pixbuf_column", libprag.}

proc getPixbufColumn*(self: IconView): int =
  int(gtk_icon_view_get_pixbuf_column(cast[ptr IconView00](self.impl)))

proc pixbufColumn*(self: IconView): int =
  int(gtk_icon_view_get_pixbuf_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_reorderable*(self: ptr IconView00): gboolean {.
    importc: "gtk_icon_view_get_reorderable", libprag.}

proc getReorderable*(self: IconView): bool =
  toBool(gtk_icon_view_get_reorderable(cast[ptr IconView00](self.impl)))

proc reorderable*(self: IconView): bool =
  toBool(gtk_icon_view_get_reorderable(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_row_spacing*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_row_spacing", libprag.}

proc getRowSpacing*(self: IconView): int =
  int(gtk_icon_view_get_row_spacing(cast[ptr IconView00](self.impl)))

proc rowSpacing*(self: IconView): int =
  int(gtk_icon_view_get_row_spacing(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_selected_items*(self: ptr IconView00): ptr pointer {.
    importc: "gtk_icon_view_get_selected_items", libprag.}

proc getSelectedItems*(self: IconView): ptr pointer =
  gtk_icon_view_get_selected_items(cast[ptr IconView00](self.impl))

proc selectedItems*(self: IconView): ptr pointer =
  gtk_icon_view_get_selected_items(cast[ptr IconView00](self.impl))

proc gtk_icon_view_get_selection_mode*(self: ptr IconView00): SelectionMode {.
    importc: "gtk_icon_view_get_selection_mode", libprag.}

proc getSelectionMode*(self: IconView): SelectionMode =
  gtk_icon_view_get_selection_mode(cast[ptr IconView00](self.impl))

proc selectionMode*(self: IconView): SelectionMode =
  gtk_icon_view_get_selection_mode(cast[ptr IconView00](self.impl))

proc gtk_icon_view_get_spacing*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_spacing", libprag.}

proc getSpacing*(self: IconView): int =
  int(gtk_icon_view_get_spacing(cast[ptr IconView00](self.impl)))

proc spacing*(self: IconView): int =
  int(gtk_icon_view_get_spacing(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_text_column*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_text_column", libprag.}

proc getTextColumn*(self: IconView): int =
  int(gtk_icon_view_get_text_column(cast[ptr IconView00](self.impl)))

proc textColumn*(self: IconView): int =
  int(gtk_icon_view_get_text_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_tooltip_column*(self: ptr IconView00): int32 {.
    importc: "gtk_icon_view_get_tooltip_column", libprag.}

proc getTooltipColumn*(self: IconView): int =
  int(gtk_icon_view_get_tooltip_column(cast[ptr IconView00](self.impl)))

proc tooltipColumn*(self: IconView): int =
  int(gtk_icon_view_get_tooltip_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_tooltip_context*(self: ptr IconView00; x: int32; y: int32; keyboardTip: gboolean; 
    model: var ptr TreeModel00; path: var ptr TreePath00; iter: var TreeIter00): gboolean {.
    importc: "gtk_icon_view_get_tooltip_context", libprag.}

proc getTooltipContext*(self: ptr IconView00; x: int32; y: int32; keyboardTip: gboolean; 
    model: var ptr TreeModel00; path: var ptr TreePath00; iter: var TreeIter00): gboolean {.
    importc: "gtk_icon_view_get_tooltip_context", libprag.}

proc tooltipContext*(self: ptr IconView00; x: int32; y: int32; keyboardTip: gboolean; 
    model: var ptr TreeModel00; path: var ptr TreePath00; iter: var TreeIter00): gboolean {.
    importc: "gtk_icon_view_get_tooltip_context", libprag.}

proc gtk_icon_view_get_visible_range*(self: ptr IconView00; startPath: var ptr TreePath00; 
    endPath: var ptr TreePath00): gboolean {.
    importc: "gtk_icon_view_get_visible_range", libprag.}

proc getVisibleRange*(self: ptr IconView00; startPath: var ptr TreePath00; 
    endPath: var ptr TreePath00): gboolean {.
    importc: "gtk_icon_view_get_visible_range", libprag.}

proc visibleRange*(self: ptr IconView00; startPath: var ptr TreePath00; 
    endPath: var ptr TreePath00): gboolean {.
    importc: "gtk_icon_view_get_visible_range", libprag.}

proc gtk_icon_view_item_activated*(self: ptr IconView00; path: ptr TreePath00) {.
    importc: "gtk_icon_view_item_activated", libprag.}

proc itemActivated*(self: IconView; path: TreePath) =
  gtk_icon_view_item_activated(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_path_is_selected*(self: ptr IconView00; path: ptr TreePath00): gboolean {.
    importc: "gtk_icon_view_path_is_selected", libprag.}

proc pathIsSelected*(self: IconView; path: TreePath): bool =
  toBool(gtk_icon_view_path_is_selected(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_icon_view_scroll_to_path*(self: ptr IconView00; path: ptr TreePath00; useAlign: gboolean; 
    rowAlign: cfloat; colAlign: cfloat) {.
    importc: "gtk_icon_view_scroll_to_path", libprag.}

proc scrollToPath*(self: IconView; path: TreePath; useAlign: bool; rowAlign: cfloat; 
    colAlign: cfloat) =
  gtk_icon_view_scroll_to_path(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl), gboolean(useAlign), rowAlign, colAlign)

proc gtk_icon_view_select_all*(self: ptr IconView00) {.
    importc: "gtk_icon_view_select_all", libprag.}

proc selectAll*(self: IconView) =
  gtk_icon_view_select_all(cast[ptr IconView00](self.impl))

proc gtk_icon_view_select_path*(self: ptr IconView00; path: ptr TreePath00) {.
    importc: "gtk_icon_view_select_path", libprag.}

proc selectPath*(self: IconView; path: TreePath) =
  gtk_icon_view_select_path(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_set_activate_on_single_click*(self: ptr IconView00; single: gboolean) {.
    importc: "gtk_icon_view_set_activate_on_single_click", libprag.}

proc setActivateOnSingleClick*(self: IconView; single: bool) =
  gtk_icon_view_set_activate_on_single_click(cast[ptr IconView00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: IconView; single: bool) =
  gtk_icon_view_set_activate_on_single_click(cast[ptr IconView00](self.impl), gboolean(single))

proc gtk_icon_view_set_column_spacing*(self: ptr IconView00; columnSpacing: int32) {.
    importc: "gtk_icon_view_set_column_spacing", libprag.}

proc setColumnSpacing*(self: IconView; columnSpacing: int) =
  gtk_icon_view_set_column_spacing(cast[ptr IconView00](self.impl), int32(columnSpacing))

proc `columnSpacing=`*(self: IconView; columnSpacing: int) =
  gtk_icon_view_set_column_spacing(cast[ptr IconView00](self.impl), int32(columnSpacing))

proc gtk_icon_view_set_columns*(self: ptr IconView00; columns: int32) {.
    importc: "gtk_icon_view_set_columns", libprag.}

proc setColumns*(self: IconView; columns: int) =
  gtk_icon_view_set_columns(cast[ptr IconView00](self.impl), int32(columns))

proc `columns=`*(self: IconView; columns: int) =
  gtk_icon_view_set_columns(cast[ptr IconView00](self.impl), int32(columns))

proc gtk_icon_view_set_cursor*(self: ptr IconView00; path: ptr TreePath00; cell: ptr CellRenderer00; 
    startEditing: gboolean) {.
    importc: "gtk_icon_view_set_cursor", libprag.}

proc setCursor*(self: IconView; path: TreePath; cell: CellRenderer; 
    startEditing: bool) =
  gtk_icon_view_set_cursor(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr CellRenderer00](cell.impl), gboolean(startEditing))

proc gtk_icon_view_set_item_orientation*(self: ptr IconView00; orientation: Orientation) {.
    importc: "gtk_icon_view_set_item_orientation", libprag.}

proc setItemOrientation*(self: IconView; orientation: Orientation) =
  gtk_icon_view_set_item_orientation(cast[ptr IconView00](self.impl), orientation)

proc `itemOrientation=`*(self: IconView; orientation: Orientation) =
  gtk_icon_view_set_item_orientation(cast[ptr IconView00](self.impl), orientation)

proc gtk_icon_view_set_item_padding*(self: ptr IconView00; itemPadding: int32) {.
    importc: "gtk_icon_view_set_item_padding", libprag.}

proc setItemPadding*(self: IconView; itemPadding: int) =
  gtk_icon_view_set_item_padding(cast[ptr IconView00](self.impl), int32(itemPadding))

proc `itemPadding=`*(self: IconView; itemPadding: int) =
  gtk_icon_view_set_item_padding(cast[ptr IconView00](self.impl), int32(itemPadding))

proc gtk_icon_view_set_item_width*(self: ptr IconView00; itemWidth: int32) {.
    importc: "gtk_icon_view_set_item_width", libprag.}

proc setItemWidth*(self: IconView; itemWidth: int) =
  gtk_icon_view_set_item_width(cast[ptr IconView00](self.impl), int32(itemWidth))

proc `itemWidth=`*(self: IconView; itemWidth: int) =
  gtk_icon_view_set_item_width(cast[ptr IconView00](self.impl), int32(itemWidth))

proc gtk_icon_view_set_margin*(self: ptr IconView00; margin: int32) {.
    importc: "gtk_icon_view_set_margin", libprag.}

proc setMargin*(self: IconView; margin: int) =
  gtk_icon_view_set_margin(cast[ptr IconView00](self.impl), int32(margin))

proc `margin=`*(self: IconView; margin: int) =
  gtk_icon_view_set_margin(cast[ptr IconView00](self.impl), int32(margin))

proc gtk_icon_view_set_markup_column*(self: ptr IconView00; column: int32) {.
    importc: "gtk_icon_view_set_markup_column", libprag.}

proc setMarkupColumn*(self: IconView; column: int) =
  gtk_icon_view_set_markup_column(cast[ptr IconView00](self.impl), int32(column))

proc `markupColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_markup_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_model*(self: ptr IconView00; model: ptr TreeModel00) {.
    importc: "gtk_icon_view_set_model", libprag.}

proc setModel*(self: IconView; model: TreeModel) =
  gtk_icon_view_set_model(cast[ptr IconView00](self.impl), cast[ptr TreeModel00](model.impl))

proc `model=`*(self: IconView; model: TreeModel) =
  gtk_icon_view_set_model(cast[ptr IconView00](self.impl), cast[ptr TreeModel00](model.impl))

proc gtk_icon_view_set_pixbuf_column*(self: ptr IconView00; column: int32) {.
    importc: "gtk_icon_view_set_pixbuf_column", libprag.}

proc setPixbufColumn*(self: IconView; column: int) =
  gtk_icon_view_set_pixbuf_column(cast[ptr IconView00](self.impl), int32(column))

proc `pixbufColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_pixbuf_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_reorderable*(self: ptr IconView00; reorderable: gboolean) {.
    importc: "gtk_icon_view_set_reorderable", libprag.}

proc setReorderable*(self: IconView; reorderable: bool) =
  gtk_icon_view_set_reorderable(cast[ptr IconView00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: IconView; reorderable: bool) =
  gtk_icon_view_set_reorderable(cast[ptr IconView00](self.impl), gboolean(reorderable))

proc gtk_icon_view_set_row_spacing*(self: ptr IconView00; rowSpacing: int32) {.
    importc: "gtk_icon_view_set_row_spacing", libprag.}

proc setRowSpacing*(self: IconView; rowSpacing: int) =
  gtk_icon_view_set_row_spacing(cast[ptr IconView00](self.impl), int32(rowSpacing))

proc `rowSpacing=`*(self: IconView; rowSpacing: int) =
  gtk_icon_view_set_row_spacing(cast[ptr IconView00](self.impl), int32(rowSpacing))

proc gtk_icon_view_set_selection_mode*(self: ptr IconView00; mode: SelectionMode) {.
    importc: "gtk_icon_view_set_selection_mode", libprag.}

proc setSelectionMode*(self: IconView; mode: SelectionMode) =
  gtk_icon_view_set_selection_mode(cast[ptr IconView00](self.impl), mode)

proc `selectionMode=`*(self: IconView; mode: SelectionMode) =
  gtk_icon_view_set_selection_mode(cast[ptr IconView00](self.impl), mode)

proc gtk_icon_view_set_spacing*(self: ptr IconView00; spacing: int32) {.
    importc: "gtk_icon_view_set_spacing", libprag.}

proc setSpacing*(self: IconView; spacing: int) =
  gtk_icon_view_set_spacing(cast[ptr IconView00](self.impl), int32(spacing))

proc `spacing=`*(self: IconView; spacing: int) =
  gtk_icon_view_set_spacing(cast[ptr IconView00](self.impl), int32(spacing))

proc gtk_icon_view_set_text_column*(self: ptr IconView00; column: int32) {.
    importc: "gtk_icon_view_set_text_column", libprag.}

proc setTextColumn*(self: IconView; column: int) =
  gtk_icon_view_set_text_column(cast[ptr IconView00](self.impl), int32(column))

proc `textColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_text_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_tooltip_cell*(self: ptr IconView00; tooltip: ptr Tooltip00; path: ptr TreePath00; 
    cell: ptr CellRenderer00) {.
    importc: "gtk_icon_view_set_tooltip_cell", libprag.}

proc setTooltipCell*(self: IconView; tooltip: Tooltip; path: TreePath; 
    cell: CellRenderer) =
  gtk_icon_view_set_tooltip_cell(cast[ptr IconView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl), cast[ptr CellRenderer00](cell.impl))

proc gtk_icon_view_set_tooltip_column*(self: ptr IconView00; column: int32) {.
    importc: "gtk_icon_view_set_tooltip_column", libprag.}

proc setTooltipColumn*(self: IconView; column: int) =
  gtk_icon_view_set_tooltip_column(cast[ptr IconView00](self.impl), int32(column))

proc `tooltipColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_tooltip_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_tooltip_item*(self: ptr IconView00; tooltip: ptr Tooltip00; path: ptr TreePath00) {.
    importc: "gtk_icon_view_set_tooltip_item", libprag.}

proc setTooltipItem*(self: IconView; tooltip: Tooltip; path: TreePath) =
  gtk_icon_view_set_tooltip_item(cast[ptr IconView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_unselect_all*(self: ptr IconView00) {.
    importc: "gtk_icon_view_unselect_all", libprag.}

proc unselectAll*(self: IconView) =
  gtk_icon_view_unselect_all(cast[ptr IconView00](self.impl))

proc gtk_icon_view_unselect_path*(self: ptr IconView00; path: ptr TreePath00) {.
    importc: "gtk_icon_view_unselect_path", libprag.}

proc unselectPath*(self: IconView; path: TreePath) =
  gtk_icon_view_unselect_path(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_unset_model_drag_dest*(self: ptr IconView00) {.
    importc: "gtk_icon_view_unset_model_drag_dest", libprag.}

proc unsetModelDragDest*(self: IconView) =
  gtk_icon_view_unset_model_drag_dest(cast[ptr IconView00](self.impl))

proc gtk_icon_view_unset_model_drag_source*(self: ptr IconView00) {.
    importc: "gtk_icon_view_unset_model_drag_source", libprag.}

proc unsetModelDragSource*(self: IconView) =
  gtk_icon_view_unset_model_drag_source(cast[ptr IconView00](self.impl))

type
  IconViewDropPosition* {.size: sizeof(cint), pure.} = enum
    noDrop = 0
    dropInto = 1
    dropLeft = 2
    dropRight = 3
    dropAbove = 4
    dropBelow = 5

proc gtk_icon_view_get_dest_item_at_pos*(self: ptr IconView00; dragX: int32; dragY: int32; 
    path: var ptr TreePath00; pos: var IconViewDropPosition): gboolean {.
    importc: "gtk_icon_view_get_dest_item_at_pos", libprag.}

proc getDestItemAtPos*(self: ptr IconView00; dragX: int32; dragY: int32; 
    path: var ptr TreePath00; pos: var IconViewDropPosition): gboolean {.
    importc: "gtk_icon_view_get_dest_item_at_pos", libprag.}

proc destItemAtPos*(self: ptr IconView00; dragX: int32; dragY: int32; 
    path: var ptr TreePath00; pos: var IconViewDropPosition): gboolean {.
    importc: "gtk_icon_view_get_dest_item_at_pos", libprag.}

proc gtk_icon_view_get_drag_dest_item*(self: ptr IconView00; path: var ptr TreePath00; pos: var IconViewDropPosition) {.
    importc: "gtk_icon_view_get_drag_dest_item", libprag.}

proc getDragDestItem*(self: ptr IconView00; path: var ptr TreePath00; pos: var IconViewDropPosition) {.
    importc: "gtk_icon_view_get_drag_dest_item", libprag.}

proc dragDestItem*(self: ptr IconView00; path: var ptr TreePath00; pos: var IconViewDropPosition) {.
    importc: "gtk_icon_view_get_drag_dest_item", libprag.}

proc gtk_icon_view_set_drag_dest_item*(self: ptr IconView00; path: ptr TreePath00; pos: IconViewDropPosition) {.
    importc: "gtk_icon_view_set_drag_dest_item", libprag.}

proc setDragDestItem*(self: IconView; path: TreePath; pos: IconViewDropPosition) =
  gtk_icon_view_set_drag_dest_item(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl), pos)

type
  IconViewAccessiblePrivate00* {.pure.} = object
  IconViewAccessiblePrivate* = ref object
    impl*: ptr IconViewAccessiblePrivate00

type
  IconViewAccessible* = ref object of ContainerAccessible
  IconViewAccessible00* = object of ContainerAccessible00
    priv4: ptr IconViewAccessiblePrivate00

type
  IconViewAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  IconViewAccessibleClass* = ref object
    impl*: ptr IconViewAccessibleClass00

type
  IconViewClass00* {.pure.} = object
    parentClass*: ContainerClass00
    itemActivated*: proc(iconView: ptr IconView00; path: ptr TreePath00) {.cdecl.}
    selectionChanged*: proc(iconView: ptr IconView00) {.cdecl.}
    selectAll*: proc(iconView: ptr IconView00) {.cdecl.}
    unselectAll*: proc(iconView: ptr IconView00) {.cdecl.}
    selectCursorItem*: proc(iconView: ptr IconView00) {.cdecl.}
    toggleCursorItem*: proc(iconView: ptr IconView00) {.cdecl.}
    moveCursor*: proc(iconView: ptr IconView00; step: MovementStep; count: int32): gboolean {.cdecl.}
    activateCursorItem*: proc(iconView: ptr IconView00): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  IconViewClass* = ref object
    impl*: ptr IconViewClass00

type
  IconViewForeachFunc* = proc (iconView: ptr IconView00; path: ptr TreePath00; data: pointer) {.cdecl.}

proc gtk_icon_view_selected_foreach*(self: ptr IconView00; `func`: IconViewForeachFunc; 
    data: pointer) {.
    importc: "gtk_icon_view_selected_foreach", libprag.}

proc selectedForeach*(self: IconView; `func`: IconViewForeachFunc; data: pointer) =
  gtk_icon_view_selected_foreach(cast[ptr IconView00](self.impl), `func`, data)

type
  ImagePrivate00* {.pure.} = object
  ImagePrivate* = ref object
    impl*: ptr ImagePrivate00

type
  Image* = ref object of Misc
  Image00* = object of Misc00
    priv3: ptr ImagePrivate00

proc gtk_image_new*(): ptr Image00 {.
    importc: "gtk_image_new", libprag.}

proc newImage*(): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImage*[T](result: var T) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_animation*(animation: ptr gdkpixbuf.PixbufAnimation00): ptr Image00 {.
    importc: "gtk_image_new_from_animation", libprag.}

proc newImageFromAnimation*(animation: gdkpixbuf.PixbufAnimation): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_animation(cast[ptr gdkpixbuf.PixbufAnimation00](animation.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromAnimation*[T](result: var T; animation: gdkpixbuf.PixbufAnimation) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_animation(cast[ptr gdkpixbuf.PixbufAnimation00](animation.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_file*(filename: ucstring): ptr Image00 {.
    importc: "gtk_image_new_from_file", libprag.}

proc newImageFromFile*(filename: ucstring): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_file(filename)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromFile*[T](result: var T; filename: ucstring) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_file(filename)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_gicon*(icon: ptr gio.Icon00; size: int32): ptr Image00 {.
    importc: "gtk_image_new_from_gicon", libprag.}

proc newImageFromGicon*(icon: gio.Icon; size: int): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_gicon(cast[ptr gio.Icon00](icon.impl), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromGicon*[T](result: var T; icon: gio.Icon; size: int) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_gicon(cast[ptr gio.Icon00](icon.impl), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_icon_name*(iconName: cstring; size: int32): ptr Image00 {.
    importc: "gtk_image_new_from_icon_name", libprag.}

proc newImageFromIconName*(iconName: string; size: int): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_icon_name(cstring(iconName), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromIconName*[T](result: var T; iconName: string; size: int) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_icon_name(cstring(iconName), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_icon_set*(iconSet: ptr IconSet00; size: int32): ptr Image00 {.
    importc: "gtk_image_new_from_icon_set", libprag.}

proc newImageFromIconSet*(iconSet: IconSet; size: int): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_icon_set(cast[ptr IconSet00](iconSet.impl), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromIconSet*[T](result: var T; iconSet: IconSet; size: int) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_icon_set(cast[ptr IconSet00](iconSet.impl), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_pixbuf*(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr Image00 {.
    importc: "gtk_image_new_from_pixbuf", libprag.}

proc newImageFromPixbuf*(pixbuf: gdkpixbuf.Pixbuf): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_resource*(resourcePath: cstring): ptr Image00 {.
    importc: "gtk_image_new_from_resource", libprag.}

proc newImageFromResource*(resourcePath: string): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_resource(cstring(resourcePath))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromResource*[T](result: var T; resourcePath: string) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_resource(cstring(resourcePath))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_stock*(stockId: cstring; size: int32): ptr Image00 {.
    importc: "gtk_image_new_from_stock", libprag.}

proc newImageFromStock*(stockId: string; size: int): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_stock(cstring(stockId), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromStock*[T](result: var T; stockId: string; size: int) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_stock(cstring(stockId), int32(size))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_surface*(surface: ptr cairo.Surface00): ptr Image00 {.
    importc: "gtk_image_new_from_surface", libprag.}

proc newImageFromSurface*(surface: cairo.Surface): Image =
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_surface(cast[ptr cairo.Surface00](surface.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromSurface*[T](result: var T; surface: cairo.Surface) =
  assert(result is Image)
  new(result, finalizeGObject)
  result.impl = gtk_image_new_from_surface(cast[ptr cairo.Surface00](surface.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_clear*(self: ptr Image00) {.
    importc: "gtk_image_clear", libprag.}

proc clear*(self: Image) =
  gtk_image_clear(cast[ptr Image00](self.impl))

proc gtk_image_get_animation*(self: ptr Image00): ptr gdkpixbuf.PixbufAnimation00 {.
    importc: "gtk_image_get_animation", libprag.}

proc getAnimation*(self: Image): gdkpixbuf.PixbufAnimation =
  let gobj = gtk_image_get_animation(cast[ptr Image00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.PixbufAnimation](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc animation*(self: Image): gdkpixbuf.PixbufAnimation =
  let gobj = gtk_image_get_animation(cast[ptr Image00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.PixbufAnimation](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_get_gicon*(self: ptr Image00; gicon: var ptr gio.Icon00; size: var int32) {.
    importc: "gtk_image_get_gicon", libprag.}

proc getGicon*(self: ptr Image00; gicon: var ptr gio.Icon00; size: var int32) {.
    importc: "gtk_image_get_gicon", libprag.}

proc gicon*(self: ptr Image00; gicon: var ptr gio.Icon00; size: var int32) {.
    importc: "gtk_image_get_gicon", libprag.}

proc gtk_image_get_icon_name*(self: ptr Image00; iconName: var cstring; size: var int32) {.
    importc: "gtk_image_get_icon_name", libprag.}

proc getIconName*(self: Image; iconName: var string; size: var int) =
  var iconName_00 = cstring(iconName)
  var size_00 = int32(size)
  gtk_image_get_icon_name(cast[ptr Image00](self.impl), iconName_00, size_00)
  iconName = $(iconName_00)
  size = int(size_00)

proc iconName*(self: Image; iconName: var string; size: var int) =
  var iconName_00 = cstring(iconName)
  var size_00 = int32(size)
  gtk_image_get_icon_name(cast[ptr Image00](self.impl), iconName_00, size_00)
  iconName = $(iconName_00)
  size = int(size_00)

proc gtk_image_get_icon_set*(self: ptr Image00; iconSet: var ptr IconSet00; size: var int32) {.
    importc: "gtk_image_get_icon_set", libprag.}

proc getIconSet*(self: ptr Image00; iconSet: var ptr IconSet00; size: var int32) {.
    importc: "gtk_image_get_icon_set", libprag.}

proc iconSet*(self: ptr Image00; iconSet: var ptr IconSet00; size: var int32) {.
    importc: "gtk_image_get_icon_set", libprag.}

proc gtk_image_get_pixbuf*(self: ptr Image00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_image_get_pixbuf", libprag.}

proc getPixbuf*(self: Image): gdkpixbuf.Pixbuf =
  let gobj = gtk_image_get_pixbuf(cast[ptr Image00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: Image): gdkpixbuf.Pixbuf =
  let gobj = gtk_image_get_pixbuf(cast[ptr Image00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_get_pixel_size*(self: ptr Image00): int32 {.
    importc: "gtk_image_get_pixel_size", libprag.}

proc getPixelSize*(self: Image): int =
  int(gtk_image_get_pixel_size(cast[ptr Image00](self.impl)))

proc pixelSize*(self: Image): int =
  int(gtk_image_get_pixel_size(cast[ptr Image00](self.impl)))

proc gtk_image_get_stock*(self: ptr Image00; stockId: var cstring; size: var int32) {.
    importc: "gtk_image_get_stock", libprag.}

proc getStock*(self: Image; stockId: var string; size: var int) =
  var stockId_00 = cstring(stockId)
  var size_00 = int32(size)
  gtk_image_get_stock(cast[ptr Image00](self.impl), stockId_00, size_00)
  stockId = $(stockId_00)
  size = int(size_00)

proc stock*(self: Image; stockId: var string; size: var int) =
  var stockId_00 = cstring(stockId)
  var size_00 = int32(size)
  gtk_image_get_stock(cast[ptr Image00](self.impl), stockId_00, size_00)
  stockId = $(stockId_00)
  size = int(size_00)

proc gtk_image_get_storage_type*(self: ptr Image00): ImageType {.
    importc: "gtk_image_get_storage_type", libprag.}

proc getStorageType*(self: Image): ImageType =
  gtk_image_get_storage_type(cast[ptr Image00](self.impl))

proc storageType*(self: Image): ImageType =
  gtk_image_get_storage_type(cast[ptr Image00](self.impl))

proc gtk_image_set_from_animation*(self: ptr Image00; animation: ptr gdkpixbuf.PixbufAnimation00) {.
    importc: "gtk_image_set_from_animation", libprag.}

proc setFromAnimation*(self: Image; animation: gdkpixbuf.PixbufAnimation) =
  gtk_image_set_from_animation(cast[ptr Image00](self.impl), cast[ptr gdkpixbuf.PixbufAnimation00](animation.impl))

proc `fromAnimation=`*(self: Image; animation: gdkpixbuf.PixbufAnimation) =
  gtk_image_set_from_animation(cast[ptr Image00](self.impl), cast[ptr gdkpixbuf.PixbufAnimation00](animation.impl))

proc gtk_image_set_from_file*(self: ptr Image00; filename: ucstring) {.
    importc: "gtk_image_set_from_file", libprag.}

proc setFromFile*(self: Image; filename: ucstring) =
  gtk_image_set_from_file(cast[ptr Image00](self.impl), filename)

proc `fromFile=`*(self: Image; filename: ucstring) =
  gtk_image_set_from_file(cast[ptr Image00](self.impl), filename)

proc gtk_image_set_from_gicon*(self: ptr Image00; icon: ptr gio.Icon00; size: int32) {.
    importc: "gtk_image_set_from_gicon", libprag.}

proc setFromGicon*(self: Image; icon: gio.Icon; size: int) =
  gtk_image_set_from_gicon(cast[ptr Image00](self.impl), cast[ptr gio.Icon00](icon.impl), int32(size))

proc gtk_image_set_from_icon_name*(self: ptr Image00; iconName: cstring; size: int32) {.
    importc: "gtk_image_set_from_icon_name", libprag.}

proc setFromIconName*(self: Image; iconName: string; size: int) =
  gtk_image_set_from_icon_name(cast[ptr Image00](self.impl), cstring(iconName), int32(size))

proc gtk_image_set_from_icon_set*(self: ptr Image00; iconSet: ptr IconSet00; size: int32) {.
    importc: "gtk_image_set_from_icon_set", libprag.}

proc setFromIconSet*(self: Image; iconSet: IconSet; size: int) =
  gtk_image_set_from_icon_set(cast[ptr Image00](self.impl), cast[ptr IconSet00](iconSet.impl), int32(size))

proc gtk_image_set_from_pixbuf*(self: ptr Image00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_image_set_from_pixbuf", libprag.}

proc setFromPixbuf*(self: Image; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_image_set_from_pixbuf(cast[ptr Image00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `fromPixbuf=`*(self: Image; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_image_set_from_pixbuf(cast[ptr Image00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_image_set_from_resource*(self: ptr Image00; resourcePath: cstring) {.
    importc: "gtk_image_set_from_resource", libprag.}

proc setFromResource*(self: Image; resourcePath: string) =
  gtk_image_set_from_resource(cast[ptr Image00](self.impl), cstring(resourcePath))

proc `fromResource=`*(self: Image; resourcePath: string) =
  gtk_image_set_from_resource(cast[ptr Image00](self.impl), cstring(resourcePath))

proc gtk_image_set_from_stock*(self: ptr Image00; stockId: cstring; size: int32) {.
    importc: "gtk_image_set_from_stock", libprag.}

proc setFromStock*(self: Image; stockId: string; size: int) =
  gtk_image_set_from_stock(cast[ptr Image00](self.impl), cstring(stockId), int32(size))

proc gtk_image_set_from_surface*(self: ptr Image00; surface: ptr cairo.Surface00) {.
    importc: "gtk_image_set_from_surface", libprag.}

proc setFromSurface*(self: Image; surface: cairo.Surface) =
  gtk_image_set_from_surface(cast[ptr Image00](self.impl), cast[ptr cairo.Surface00](surface.impl))

proc `fromSurface=`*(self: Image; surface: cairo.Surface) =
  gtk_image_set_from_surface(cast[ptr Image00](self.impl), cast[ptr cairo.Surface00](surface.impl))

proc gtk_image_set_pixel_size*(self: ptr Image00; pixelSize: int32) {.
    importc: "gtk_image_set_pixel_size", libprag.}

proc setPixelSize*(self: Image; pixelSize: int) =
  gtk_image_set_pixel_size(cast[ptr Image00](self.impl), int32(pixelSize))

proc `pixelSize=`*(self: Image; pixelSize: int) =
  gtk_image_set_pixel_size(cast[ptr Image00](self.impl), int32(pixelSize))

type
  ImageAccessiblePrivate00* {.pure.} = object
  ImageAccessiblePrivate* = ref object
    impl*: ptr ImageAccessiblePrivate00

type
  ImageAccessible* = ref object of WidgetAccessible
  ImageAccessible00* = object of WidgetAccessible00
    priv3: ptr ImageAccessiblePrivate00

type
  ImageAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
  ImageAccessibleClass* = ref object
    impl*: ptr ImageAccessibleClass00

type
  ImageCellAccessiblePrivate00* {.pure.} = object
  ImageCellAccessiblePrivate* = ref object
    impl*: ptr ImageCellAccessiblePrivate00

type
  ImageCellAccessible* = ref object of RendererCellAccessible
  ImageCellAccessible00* = object of RendererCellAccessible00
    priv4: ptr ImageCellAccessiblePrivate00

type
  ImageCellAccessibleClass00* {.pure.} = object
    parentClass*: RendererCellAccessibleClass00
  ImageCellAccessibleClass* = ref object
    impl*: ptr ImageCellAccessibleClass00

type
  ImageClass00* {.pure.} = object
    parentClass*: MiscClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ImageClass* = ref object
    impl*: ptr ImageClass00

type
  ImageMenuItemPrivate00* {.pure.} = object
  ImageMenuItemPrivate* = ref object
    impl*: ptr ImageMenuItemPrivate00

type
  ImageMenuItem* = ref object of MenuItem
  ImageMenuItem00* = object of MenuItem00
    priv5: ptr ImageMenuItemPrivate00

proc gtk_image_menu_item_new*(): ptr ImageMenuItem00 {.
    importc: "gtk_image_menu_item_new", libprag.}

proc newImageMenuItem*(): ImageMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_image_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageMenuItem*[T](result: var T) =
  assert(result is ImageMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_image_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_new_from_stock*(stockId: cstring; accelGroup: ptr AccelGroup00): ptr ImageMenuItem00 {.
    importc: "gtk_image_menu_item_new_from_stock", libprag.}

proc newImageMenuItemFromStock*(stockId: string; accelGroup: AccelGroup): ImageMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_image_menu_item_new_from_stock(cstring(stockId), cast[ptr AccelGroup00](accelGroup.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageMenuItemFromStock*[T](result: var T; stockId: string; accelGroup: AccelGroup) =
  assert(result is ImageMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_image_menu_item_new_from_stock(cstring(stockId), cast[ptr AccelGroup00](accelGroup.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_new_with_label*(label: cstring): ptr ImageMenuItem00 {.
    importc: "gtk_image_menu_item_new_with_label", libprag.}

proc newImageMenuItemWithLabel*(label: string): ImageMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_image_menu_item_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageMenuItemWithLabel*[T](result: var T; label: string) =
  assert(result is ImageMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_image_menu_item_new_with_label(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_new_with_mnemonic*(label: cstring): ptr ImageMenuItem00 {.
    importc: "gtk_image_menu_item_new_with_mnemonic", libprag.}

proc newImageMenuItemWithMnemonic*(label: string): ImageMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_image_menu_item_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageMenuItemWithMnemonic*[T](result: var T; label: string) =
  assert(result is ImageMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_image_menu_item_new_with_mnemonic(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_get_always_show_image*(self: ptr ImageMenuItem00): gboolean {.
    importc: "gtk_image_menu_item_get_always_show_image", libprag.}

proc getAlwaysShowImage*(self: ImageMenuItem): bool =
  toBool(gtk_image_menu_item_get_always_show_image(cast[ptr ImageMenuItem00](self.impl)))

proc alwaysShowImage*(self: ImageMenuItem): bool =
  toBool(gtk_image_menu_item_get_always_show_image(cast[ptr ImageMenuItem00](self.impl)))

proc gtk_image_menu_item_get_image*(self: ptr ImageMenuItem00): ptr Widget00 {.
    importc: "gtk_image_menu_item_get_image", libprag.}

proc getImage*(self: ImageMenuItem): Widget =
  let gobj = gtk_image_menu_item_get_image(cast[ptr ImageMenuItem00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc image*(self: ImageMenuItem): Widget =
  let gobj = gtk_image_menu_item_get_image(cast[ptr ImageMenuItem00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_get_use_stock*(self: ptr ImageMenuItem00): gboolean {.
    importc: "gtk_image_menu_item_get_use_stock", libprag.}

proc getUseStock*(self: ImageMenuItem): bool =
  toBool(gtk_image_menu_item_get_use_stock(cast[ptr ImageMenuItem00](self.impl)))

proc useStock*(self: ImageMenuItem): bool =
  toBool(gtk_image_menu_item_get_use_stock(cast[ptr ImageMenuItem00](self.impl)))

proc gtk_image_menu_item_set_accel_group*(self: ptr ImageMenuItem00; accelGroup: ptr AccelGroup00) {.
    importc: "gtk_image_menu_item_set_accel_group", libprag.}

proc setAccelGroup*(self: ImageMenuItem; accelGroup: AccelGroup) =
  gtk_image_menu_item_set_accel_group(cast[ptr ImageMenuItem00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc `accelGroup=`*(self: ImageMenuItem; accelGroup: AccelGroup) =
  gtk_image_menu_item_set_accel_group(cast[ptr ImageMenuItem00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_image_menu_item_set_always_show_image*(self: ptr ImageMenuItem00; alwaysShow: gboolean) {.
    importc: "gtk_image_menu_item_set_always_show_image", libprag.}

proc setAlwaysShowImage*(self: ImageMenuItem; alwaysShow: bool) =
  gtk_image_menu_item_set_always_show_image(cast[ptr ImageMenuItem00](self.impl), gboolean(alwaysShow))

proc `alwaysShowImage=`*(self: ImageMenuItem; alwaysShow: bool) =
  gtk_image_menu_item_set_always_show_image(cast[ptr ImageMenuItem00](self.impl), gboolean(alwaysShow))

proc gtk_image_menu_item_set_image*(self: ptr ImageMenuItem00; image: ptr Widget00) {.
    importc: "gtk_image_menu_item_set_image", libprag.}

proc setImage*(self: ImageMenuItem; image: Widget) =
  gtk_image_menu_item_set_image(cast[ptr ImageMenuItem00](self.impl), cast[ptr Widget00](image.impl))

proc `image=`*(self: ImageMenuItem; image: Widget) =
  gtk_image_menu_item_set_image(cast[ptr ImageMenuItem00](self.impl), cast[ptr Widget00](image.impl))

proc gtk_image_menu_item_set_use_stock*(self: ptr ImageMenuItem00; useStock: gboolean) {.
    importc: "gtk_image_menu_item_set_use_stock", libprag.}

proc setUseStock*(self: ImageMenuItem; useStock: bool) =
  gtk_image_menu_item_set_use_stock(cast[ptr ImageMenuItem00](self.impl), gboolean(useStock))

proc `useStock=`*(self: ImageMenuItem; useStock: bool) =
  gtk_image_menu_item_set_use_stock(cast[ptr ImageMenuItem00](self.impl), gboolean(useStock))

type
  ImageMenuItemClass00* {.pure.} = object
    parentClass*: MenuItemClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ImageMenuItemClass* = ref object
    impl*: ptr ImageMenuItemClass00

type
  InfoBarPrivate00* {.pure.} = object
  InfoBarPrivate* = ref object
    impl*: ptr InfoBarPrivate00

type
  InfoBar* = ref object of Box
  InfoBar00* = object of Box00
    priv4: ptr InfoBarPrivate00

proc scClose*(self: InfoBar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scResponse*(self: InfoBar;  p: proc (self: ptr gobject.Object00; responseId: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "response", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_info_bar_new*(): ptr InfoBar00 {.
    importc: "gtk_info_bar_new", libprag.}

proc newInfoBar*(): InfoBar =
  new(result, finalizeGObject)
  result.impl = gtk_info_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initInfoBar*[T](result: var T) =
  assert(result is InfoBar)
  new(result, finalizeGObject)
  result.impl = gtk_info_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_add_action_widget*(self: ptr InfoBar00; child: ptr Widget00; responseId: int32) {.
    importc: "gtk_info_bar_add_action_widget", libprag.}

proc addActionWidget*(self: InfoBar; child: Widget; responseId: int) =
  gtk_info_bar_add_action_widget(cast[ptr InfoBar00](self.impl), cast[ptr Widget00](child.impl), int32(responseId))

proc gtk_info_bar_add_button*(self: ptr InfoBar00; buttonText: cstring; responseId: int32): ptr Button00 {.
    importc: "gtk_info_bar_add_button", libprag.}

proc addButton*(self: InfoBar; buttonText: string; responseId: int): Button =
  let gobj = gtk_info_bar_add_button(cast[ptr InfoBar00](self.impl), cstring(buttonText), int32(responseId))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Button](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_get_action_area*(self: ptr InfoBar00): ptr Widget00 {.
    importc: "gtk_info_bar_get_action_area", libprag.}

proc getActionArea*(self: InfoBar): Widget =
  let gobj = gtk_info_bar_get_action_area(cast[ptr InfoBar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc actionArea*(self: InfoBar): Widget =
  let gobj = gtk_info_bar_get_action_area(cast[ptr InfoBar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_get_content_area*(self: ptr InfoBar00): ptr Widget00 {.
    importc: "gtk_info_bar_get_content_area", libprag.}

proc getContentArea*(self: InfoBar): Widget =
  let gobj = gtk_info_bar_get_content_area(cast[ptr InfoBar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc contentArea*(self: InfoBar): Widget =
  let gobj = gtk_info_bar_get_content_area(cast[ptr InfoBar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_get_show_close_button*(self: ptr InfoBar00): gboolean {.
    importc: "gtk_info_bar_get_show_close_button", libprag.}

proc getShowCloseButton*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_show_close_button(cast[ptr InfoBar00](self.impl)))

proc showCloseButton*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_show_close_button(cast[ptr InfoBar00](self.impl)))

proc gtk_info_bar_response*(self: ptr InfoBar00; responseId: int32) {.
    importc: "gtk_info_bar_response", libprag.}

proc response*(self: InfoBar; responseId: int) =
  gtk_info_bar_response(cast[ptr InfoBar00](self.impl), int32(responseId))

proc gtk_info_bar_set_default_response*(self: ptr InfoBar00; responseId: int32) {.
    importc: "gtk_info_bar_set_default_response", libprag.}

proc setDefaultResponse*(self: InfoBar; responseId: int) =
  gtk_info_bar_set_default_response(cast[ptr InfoBar00](self.impl), int32(responseId))

proc `defaultResponse=`*(self: InfoBar; responseId: int) =
  gtk_info_bar_set_default_response(cast[ptr InfoBar00](self.impl), int32(responseId))

proc gtk_info_bar_set_response_sensitive*(self: ptr InfoBar00; responseId: int32; setting: gboolean) {.
    importc: "gtk_info_bar_set_response_sensitive", libprag.}

proc setResponseSensitive*(self: InfoBar; responseId: int; setting: bool) =
  gtk_info_bar_set_response_sensitive(cast[ptr InfoBar00](self.impl), int32(responseId), gboolean(setting))

proc gtk_info_bar_set_show_close_button*(self: ptr InfoBar00; setting: gboolean) {.
    importc: "gtk_info_bar_set_show_close_button", libprag.}

proc setShowCloseButton*(self: InfoBar; setting: bool) =
  gtk_info_bar_set_show_close_button(cast[ptr InfoBar00](self.impl), gboolean(setting))

proc `showCloseButton=`*(self: InfoBar; setting: bool) =
  gtk_info_bar_set_show_close_button(cast[ptr InfoBar00](self.impl), gboolean(setting))

type
  MessageType* {.size: sizeof(cint), pure.} = enum
    info = 0
    warning = 1
    question = 2
    error = 3
    other = 4

proc gtk_info_bar_get_message_type*(self: ptr InfoBar00): MessageType {.
    importc: "gtk_info_bar_get_message_type", libprag.}

proc getMessageType*(self: InfoBar): MessageType =
  gtk_info_bar_get_message_type(cast[ptr InfoBar00](self.impl))

proc messageType*(self: InfoBar): MessageType =
  gtk_info_bar_get_message_type(cast[ptr InfoBar00](self.impl))

proc gtk_info_bar_set_message_type*(self: ptr InfoBar00; messageType: MessageType) {.
    importc: "gtk_info_bar_set_message_type", libprag.}

proc setMessageType*(self: InfoBar; messageType: MessageType) =
  gtk_info_bar_set_message_type(cast[ptr InfoBar00](self.impl), messageType)

proc `messageType=`*(self: InfoBar; messageType: MessageType) =
  gtk_info_bar_set_message_type(cast[ptr InfoBar00](self.impl), messageType)

type
  InfoBarClass00* {.pure.} = object
    parentClass*: BoxClass00
    response*: proc(infoBar: ptr InfoBar00; responseId: int32) {.cdecl.}
    close*: proc(infoBar: ptr InfoBar00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  InfoBarClass* = ref object
    impl*: ptr InfoBarClass00

type
  InvisiblePrivate00* {.pure.} = object
  InvisiblePrivate* = ref object
    impl*: ptr InvisiblePrivate00

type
  Invisible* = ref object of Widget
  Invisible00* = object of Widget00
    priv2: ptr InvisiblePrivate00

proc gtk_invisible_new*(): ptr Invisible00 {.
    importc: "gtk_invisible_new", libprag.}

proc newInvisible*(): Invisible =
  new(result, finalizeGObject)
  result.impl = gtk_invisible_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initInvisible*[T](result: var T) =
  assert(result is Invisible)
  new(result, finalizeGObject)
  result.impl = gtk_invisible_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_invisible_new_for_screen*(screen: ptr gdk.Screen00): ptr Invisible00 {.
    importc: "gtk_invisible_new_for_screen", libprag.}

proc newInvisibleForScreen*(screen: gdk.Screen): Invisible =
  new(result, finalizeGObject)
  result.impl = gtk_invisible_new_for_screen(cast[ptr gdk.Screen00](screen.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initInvisibleForScreen*[T](result: var T; screen: gdk.Screen) =
  assert(result is Invisible)
  new(result, finalizeGObject)
  result.impl = gtk_invisible_new_for_screen(cast[ptr gdk.Screen00](screen.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_invisible_get_screen*(self: ptr Invisible00): ptr gdk.Screen00 {.
    importc: "gtk_invisible_get_screen", libprag.}

proc getScreen*(self: Invisible): gdk.Screen =
  let gobj = gtk_invisible_get_screen(cast[ptr Invisible00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: Invisible): gdk.Screen =
  let gobj = gtk_invisible_get_screen(cast[ptr Invisible00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_invisible_set_screen*(self: ptr Invisible00; screen: ptr gdk.Screen00) {.
    importc: "gtk_invisible_set_screen", libprag.}

proc setScreen*(self: Invisible; screen: gdk.Screen) =
  gtk_invisible_set_screen(cast[ptr Invisible00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: Invisible; screen: gdk.Screen) =
  gtk_invisible_set_screen(cast[ptr Invisible00](self.impl), cast[ptr gdk.Screen00](screen.impl))

type
  InvisibleClass00* {.pure.} = object
    parentClass*: WidgetClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  InvisibleClass* = ref object
    impl*: ptr InvisibleClass00

type
  KeySnoopFunc* = proc (grabWidget: ptr Widget00; event: ptr gdk.EventKey00; 
    funcData: pointer): int32 {.cdecl.}

const LEVEL_BAR_OFFSET_FULL* = "full"

const LEVEL_BAR_OFFSET_HIGH* = "high"

const LEVEL_BAR_OFFSET_LOW* = "low"

type
  LabelAccessiblePrivate00* {.pure.} = object
  LabelAccessiblePrivate* = ref object
    impl*: ptr LabelAccessiblePrivate00

type
  LabelAccessible* = ref object of WidgetAccessible
  LabelAccessible00* = object of WidgetAccessible00
    priv3: ptr LabelAccessiblePrivate00

type
  LabelAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
  LabelAccessibleClass* = ref object
    impl*: ptr LabelAccessibleClass00

type
  LabelSelectionInfo00* {.pure.} = object
  LabelSelectionInfo* = ref object
    impl*: ptr LabelSelectionInfo00

type
  LayoutPrivate00* {.pure.} = object
  LayoutPrivate* = ref object
    impl*: ptr LayoutPrivate00

type
  Layout* = ref object of Container
  Layout00* = object of Container00
    priv3: ptr LayoutPrivate00

proc gtk_layout_new*(hadjustment: ptr Adjustment00; vadjustment: ptr Adjustment00): ptr Layout00 {.
    importc: "gtk_layout_new", libprag.}

proc newLayout*(hadjustment: Adjustment; vadjustment: Adjustment): Layout =
  new(result, finalizeGObject)
  result.impl = gtk_layout_new(cast[ptr Adjustment00](hadjustment.impl), cast[ptr Adjustment00](vadjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLayout*[T](result: var T; hadjustment: Adjustment; vadjustment: Adjustment) =
  assert(result is Layout)
  new(result, finalizeGObject)
  result.impl = gtk_layout_new(cast[ptr Adjustment00](hadjustment.impl), cast[ptr Adjustment00](vadjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_get_bin_window*(self: ptr Layout00): ptr gdk.Window00 {.
    importc: "gtk_layout_get_bin_window", libprag.}

proc getBinWindow*(self: Layout): gdk.Window =
  let gobj = gtk_layout_get_bin_window(cast[ptr Layout00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc binWindow*(self: Layout): gdk.Window =
  let gobj = gtk_layout_get_bin_window(cast[ptr Layout00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_get_hadjustment*(self: ptr Layout00): ptr Adjustment00 {.
    importc: "gtk_layout_get_hadjustment", libprag.}

proc getHadjustment*(self: Layout): Adjustment =
  let gobj = gtk_layout_get_hadjustment(cast[ptr Layout00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: Layout): Adjustment =
  let gobj = gtk_layout_get_hadjustment(cast[ptr Layout00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_get_size*(self: ptr Layout00; width: var uint32; height: var uint32) {.
    importc: "gtk_layout_get_size", libprag.}

proc getSize*(self: Layout; width: var int; height: var int) =
  var height_00 = uint32(height)
  var width_00 = uint32(width)
  gtk_layout_get_size(cast[ptr Layout00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc size*(self: Layout; width: var int; height: var int) =
  var height_00 = uint32(height)
  var width_00 = uint32(width)
  gtk_layout_get_size(cast[ptr Layout00](self.impl), width_00, height_00)
  height = int(height_00)
  width = int(width_00)

proc gtk_layout_get_vadjustment*(self: ptr Layout00): ptr Adjustment00 {.
    importc: "gtk_layout_get_vadjustment", libprag.}

proc getVadjustment*(self: Layout): Adjustment =
  let gobj = gtk_layout_get_vadjustment(cast[ptr Layout00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: Layout): Adjustment =
  let gobj = gtk_layout_get_vadjustment(cast[ptr Layout00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_move*(self: ptr Layout00; childWidget: ptr Widget00; x: int32; 
    y: int32) {.
    importc: "gtk_layout_move", libprag.}

proc move*(self: Layout; childWidget: Widget; x: int; y: int) =
  gtk_layout_move(cast[ptr Layout00](self.impl), cast[ptr Widget00](childWidget.impl), int32(x), int32(y))

proc gtk_layout_put*(self: ptr Layout00; childWidget: ptr Widget00; x: int32; 
    y: int32) {.
    importc: "gtk_layout_put", libprag.}

proc put*(self: Layout; childWidget: Widget; x: int; y: int) =
  gtk_layout_put(cast[ptr Layout00](self.impl), cast[ptr Widget00](childWidget.impl), int32(x), int32(y))

proc gtk_layout_set_hadjustment*(self: ptr Layout00; adjustment: ptr Adjustment00) {.
    importc: "gtk_layout_set_hadjustment", libprag.}

proc setHadjustment*(self: Layout; adjustment: Adjustment) =
  gtk_layout_set_hadjustment(cast[ptr Layout00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `hadjustment=`*(self: Layout; adjustment: Adjustment) =
  gtk_layout_set_hadjustment(cast[ptr Layout00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_layout_set_size*(self: ptr Layout00; width: uint32; height: uint32) {.
    importc: "gtk_layout_set_size", libprag.}

proc setSize*(self: Layout; width: int; height: int) =
  gtk_layout_set_size(cast[ptr Layout00](self.impl), uint32(width), uint32(height))

proc gtk_layout_set_vadjustment*(self: ptr Layout00; adjustment: ptr Adjustment00) {.
    importc: "gtk_layout_set_vadjustment", libprag.}

proc setVadjustment*(self: Layout; adjustment: Adjustment) =
  gtk_layout_set_vadjustment(cast[ptr Layout00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `vadjustment=`*(self: Layout; adjustment: Adjustment) =
  gtk_layout_set_vadjustment(cast[ptr Layout00](self.impl), cast[ptr Adjustment00](adjustment.impl))

type
  LayoutClass00* {.pure.} = object
    parentClass*: ContainerClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  LayoutClass* = ref object
    impl*: ptr LayoutClass00

type
  LevelBarPrivate00* {.pure.} = object
  LevelBarPrivate* = ref object
    impl*: ptr LevelBarPrivate00

type
  LevelBar* = ref object of Widget
  LevelBar00* = object of Widget00
    priv2: ptr LevelBarPrivate00

proc scOffsetChanged*(self: LevelBar;  p: proc (self: ptr gobject.Object00; name: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "offset-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_level_bar_new*(): ptr LevelBar00 {.
    importc: "gtk_level_bar_new", libprag.}

proc newLevelBar*(): LevelBar =
  new(result, finalizeGObject)
  result.impl = gtk_level_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLevelBar*[T](result: var T) =
  assert(result is LevelBar)
  new(result, finalizeGObject)
  result.impl = gtk_level_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_level_bar_new_for_interval*(minValue: cdouble; maxValue: cdouble): ptr LevelBar00 {.
    importc: "gtk_level_bar_new_for_interval", libprag.}

proc newLevelBarForInterval*(minValue: cdouble; maxValue: cdouble): LevelBar =
  new(result, finalizeGObject)
  result.impl = gtk_level_bar_new_for_interval(minValue, maxValue)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLevelBarForInterval*[T](result: var T; minValue: cdouble; maxValue: cdouble) =
  assert(result is LevelBar)
  new(result, finalizeGObject)
  result.impl = gtk_level_bar_new_for_interval(minValue, maxValue)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_level_bar_add_offset_value*(self: ptr LevelBar00; name: cstring; value: cdouble) {.
    importc: "gtk_level_bar_add_offset_value", libprag.}

proc addOffsetValue*(self: LevelBar; name: string; value: cdouble) =
  gtk_level_bar_add_offset_value(cast[ptr LevelBar00](self.impl), cstring(name), value)

proc gtk_level_bar_get_inverted*(self: ptr LevelBar00): gboolean {.
    importc: "gtk_level_bar_get_inverted", libprag.}

proc getInverted*(self: LevelBar): bool =
  toBool(gtk_level_bar_get_inverted(cast[ptr LevelBar00](self.impl)))

proc inverted*(self: LevelBar): bool =
  toBool(gtk_level_bar_get_inverted(cast[ptr LevelBar00](self.impl)))

proc gtk_level_bar_get_max_value*(self: ptr LevelBar00): cdouble {.
    importc: "gtk_level_bar_get_max_value", libprag.}

proc getMaxValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_max_value(cast[ptr LevelBar00](self.impl))

proc maxValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_max_value(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_get_min_value*(self: ptr LevelBar00): cdouble {.
    importc: "gtk_level_bar_get_min_value", libprag.}

proc getMinValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_min_value(cast[ptr LevelBar00](self.impl))

proc minValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_min_value(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_get_offset_value*(self: ptr LevelBar00; name: cstring; value: var cdouble): gboolean {.
    importc: "gtk_level_bar_get_offset_value", libprag.}

proc getOffsetValue*(self: LevelBar; name: string; value: var cdouble): bool =
  toBool(gtk_level_bar_get_offset_value(cast[ptr LevelBar00](self.impl), cstring(name), value))

proc offsetValue*(self: LevelBar; name: string; value: var cdouble): bool =
  toBool(gtk_level_bar_get_offset_value(cast[ptr LevelBar00](self.impl), cstring(name), value))

proc gtk_level_bar_get_value*(self: ptr LevelBar00): cdouble {.
    importc: "gtk_level_bar_get_value", libprag.}

proc getValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_value(cast[ptr LevelBar00](self.impl))

proc value*(self: LevelBar): cdouble =
  gtk_level_bar_get_value(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_remove_offset_value*(self: ptr LevelBar00; name: cstring) {.
    importc: "gtk_level_bar_remove_offset_value", libprag.}

proc removeOffsetValue*(self: LevelBar; name: string) =
  gtk_level_bar_remove_offset_value(cast[ptr LevelBar00](self.impl), cstring(name))

proc gtk_level_bar_set_inverted*(self: ptr LevelBar00; inverted: gboolean) {.
    importc: "gtk_level_bar_set_inverted", libprag.}

proc setInverted*(self: LevelBar; inverted: bool) =
  gtk_level_bar_set_inverted(cast[ptr LevelBar00](self.impl), gboolean(inverted))

proc `inverted=`*(self: LevelBar; inverted: bool) =
  gtk_level_bar_set_inverted(cast[ptr LevelBar00](self.impl), gboolean(inverted))

proc gtk_level_bar_set_max_value*(self: ptr LevelBar00; value: cdouble) {.
    importc: "gtk_level_bar_set_max_value", libprag.}

proc setMaxValue*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_max_value(cast[ptr LevelBar00](self.impl), value)

proc `maxValue=`*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_max_value(cast[ptr LevelBar00](self.impl), value)

proc gtk_level_bar_set_min_value*(self: ptr LevelBar00; value: cdouble) {.
    importc: "gtk_level_bar_set_min_value", libprag.}

proc setMinValue*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_min_value(cast[ptr LevelBar00](self.impl), value)

proc `minValue=`*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_min_value(cast[ptr LevelBar00](self.impl), value)

proc gtk_level_bar_set_value*(self: ptr LevelBar00; value: cdouble) {.
    importc: "gtk_level_bar_set_value", libprag.}

proc setValue*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_value(cast[ptr LevelBar00](self.impl), value)

proc `value=`*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_value(cast[ptr LevelBar00](self.impl), value)

type
  LevelBarMode* {.size: sizeof(cint), pure.} = enum
    continuous = 0
    discrete = 1

proc gtk_level_bar_get_mode*(self: ptr LevelBar00): LevelBarMode {.
    importc: "gtk_level_bar_get_mode", libprag.}

proc getMode*(self: LevelBar): LevelBarMode =
  gtk_level_bar_get_mode(cast[ptr LevelBar00](self.impl))

proc mode*(self: LevelBar): LevelBarMode =
  gtk_level_bar_get_mode(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_set_mode*(self: ptr LevelBar00; mode: LevelBarMode) {.
    importc: "gtk_level_bar_set_mode", libprag.}

proc setMode*(self: LevelBar; mode: LevelBarMode) =
  gtk_level_bar_set_mode(cast[ptr LevelBar00](self.impl), mode)

proc `mode=`*(self: LevelBar; mode: LevelBarMode) =
  gtk_level_bar_set_mode(cast[ptr LevelBar00](self.impl), mode)

type
  LevelBarAccessiblePrivate00* {.pure.} = object
  LevelBarAccessiblePrivate* = ref object
    impl*: ptr LevelBarAccessiblePrivate00

type
  LevelBarAccessible* = ref object of WidgetAccessible
  LevelBarAccessible00* = object of WidgetAccessible00
    priv3: ptr LevelBarAccessiblePrivate00

type
  LevelBarAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
  LevelBarAccessibleClass* = ref object
    impl*: ptr LevelBarAccessibleClass00

type
  LevelBarClass00* {.pure.} = object
    parentClass*: WidgetClass00
    offsetChanged*: proc(self: ptr LevelBar00; name: cstring) {.cdecl.}
    padding*: array[16, pointer]
  LevelBarClass* = ref object
    impl*: ptr LevelBarClass00

type
  LinkButtonPrivate00* {.pure.} = object
  LinkButtonPrivate* = ref object
    impl*: ptr LinkButtonPrivate00

type
  LinkButton* = ref object of Button
  LinkButton00* = object of Button00
    priv5: ptr LinkButtonPrivate00

proc scActivateLink*(self: LinkButton;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-link", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_link_button_new*(uri: cstring): ptr LinkButton00 {.
    importc: "gtk_link_button_new", libprag.}

proc newLinkButton*(uri: string): LinkButton =
  new(result, finalizeGObject)
  result.impl = gtk_link_button_new(cstring(uri))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLinkButton*[T](result: var T; uri: string) =
  assert(result is LinkButton)
  new(result, finalizeGObject)
  result.impl = gtk_link_button_new(cstring(uri))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_link_button_new_with_label*(uri: cstring; label: cstring): ptr LinkButton00 {.
    importc: "gtk_link_button_new_with_label", libprag.}

proc newLinkButtonWithLabel*(uri: string; label: string): LinkButton =
  new(result, finalizeGObject)
  result.impl = gtk_link_button_new_with_label(cstring(uri), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLinkButtonWithLabel*[T](result: var T; uri: string; label: string) =
  assert(result is LinkButton)
  new(result, finalizeGObject)
  result.impl = gtk_link_button_new_with_label(cstring(uri), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_link_button_get_uri*(self: ptr LinkButton00): cstring {.
    importc: "gtk_link_button_get_uri", libprag.}

proc getUri*(self: LinkButton): string =
  let resul0 = gtk_link_button_get_uri(cast[ptr LinkButton00](self.impl))
  result = $resul0

proc uri*(self: LinkButton): string =
  let resul0 = gtk_link_button_get_uri(cast[ptr LinkButton00](self.impl))
  result = $resul0

proc gtk_link_button_get_visited*(self: ptr LinkButton00): gboolean {.
    importc: "gtk_link_button_get_visited", libprag.}

proc getVisited*(self: LinkButton): bool =
  toBool(gtk_link_button_get_visited(cast[ptr LinkButton00](self.impl)))

proc visited*(self: LinkButton): bool =
  toBool(gtk_link_button_get_visited(cast[ptr LinkButton00](self.impl)))

proc gtk_link_button_set_uri*(self: ptr LinkButton00; uri: cstring) {.
    importc: "gtk_link_button_set_uri", libprag.}

proc setUri*(self: LinkButton; uri: string) =
  gtk_link_button_set_uri(cast[ptr LinkButton00](self.impl), cstring(uri))

proc `uri=`*(self: LinkButton; uri: string) =
  gtk_link_button_set_uri(cast[ptr LinkButton00](self.impl), cstring(uri))

proc gtk_link_button_set_visited*(self: ptr LinkButton00; visited: gboolean) {.
    importc: "gtk_link_button_set_visited", libprag.}

proc setVisited*(self: LinkButton; visited: bool) =
  gtk_link_button_set_visited(cast[ptr LinkButton00](self.impl), gboolean(visited))

proc `visited=`*(self: LinkButton; visited: bool) =
  gtk_link_button_set_visited(cast[ptr LinkButton00](self.impl), gboolean(visited))

type
  LinkButtonAccessiblePrivate00* {.pure.} = object
  LinkButtonAccessiblePrivate* = ref object
    impl*: ptr LinkButtonAccessiblePrivate00

type
  LinkButtonAccessible* = ref object of ButtonAccessible
  LinkButtonAccessible00* = object of ButtonAccessible00
    priv5: ptr LinkButtonAccessiblePrivate00

type
  LinkButtonAccessibleClass00* {.pure.} = object
    parentClass*: ButtonAccessibleClass00
  LinkButtonAccessibleClass* = ref object
    impl*: ptr LinkButtonAccessibleClass00

type
  LinkButtonClass00* {.pure.} = object
    parentClass*: ButtonClass00
    activateLink*: proc(button: ptr LinkButton00): gboolean {.cdecl.}
    gtkPadding1*: pointer
    gtkPadding2*: pointer
    gtkPadding3*: pointer
    gtkPadding4*: pointer
  LinkButtonClass* = ref object
    impl*: ptr LinkButtonClass00

type
  ListBoxRow* = ref object of Bin
  ListBoxRow00* = object of Bin00

proc scActivate*(self: ListBoxRow;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_list_box_row_new*(): ptr ListBoxRow00 {.
    importc: "gtk_list_box_row_new", libprag.}

proc newListBoxRow*(): ListBoxRow =
  new(result, finalizeGObject)
  result.impl = gtk_list_box_row_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListBoxRow*[T](result: var T) =
  assert(result is ListBoxRow)
  new(result, finalizeGObject)
  result.impl = gtk_list_box_row_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_row_changed*(self: ptr ListBoxRow00) {.
    importc: "gtk_list_box_row_changed", libprag.}

proc changed*(self: ListBoxRow) =
  gtk_list_box_row_changed(cast[ptr ListBoxRow00](self.impl))

proc gtk_list_box_row_get_activatable*(self: ptr ListBoxRow00): gboolean {.
    importc: "gtk_list_box_row_get_activatable", libprag.}

proc getActivatable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_activatable(cast[ptr ListBoxRow00](self.impl)))

proc activatable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_activatable(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_get_header*(self: ptr ListBoxRow00): ptr Widget00 {.
    importc: "gtk_list_box_row_get_header", libprag.}

proc getHeader*(self: ListBoxRow): Widget =
  let gobj = gtk_list_box_row_get_header(cast[ptr ListBoxRow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc header*(self: ListBoxRow): Widget =
  let gobj = gtk_list_box_row_get_header(cast[ptr ListBoxRow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_row_get_index*(self: ptr ListBoxRow00): int32 {.
    importc: "gtk_list_box_row_get_index", libprag.}

proc getIndex*(self: ListBoxRow): int =
  int(gtk_list_box_row_get_index(cast[ptr ListBoxRow00](self.impl)))

proc index*(self: ListBoxRow): int =
  int(gtk_list_box_row_get_index(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_get_selectable*(self: ptr ListBoxRow00): gboolean {.
    importc: "gtk_list_box_row_get_selectable", libprag.}

proc getSelectable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_selectable(cast[ptr ListBoxRow00](self.impl)))

proc selectable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_selectable(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_is_selected*(self: ptr ListBoxRow00): gboolean {.
    importc: "gtk_list_box_row_is_selected", libprag.}

proc isSelected*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_is_selected(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_set_activatable*(self: ptr ListBoxRow00; activatable: gboolean) {.
    importc: "gtk_list_box_row_set_activatable", libprag.}

proc setActivatable*(self: ListBoxRow; activatable: bool) =
  gtk_list_box_row_set_activatable(cast[ptr ListBoxRow00](self.impl), gboolean(activatable))

proc `activatable=`*(self: ListBoxRow; activatable: bool) =
  gtk_list_box_row_set_activatable(cast[ptr ListBoxRow00](self.impl), gboolean(activatable))

proc gtk_list_box_row_set_header*(self: ptr ListBoxRow00; header: ptr Widget00) {.
    importc: "gtk_list_box_row_set_header", libprag.}

proc setHeader*(self: ListBoxRow; header: Widget) =
  gtk_list_box_row_set_header(cast[ptr ListBoxRow00](self.impl), cast[ptr Widget00](header.impl))

proc `header=`*(self: ListBoxRow; header: Widget) =
  gtk_list_box_row_set_header(cast[ptr ListBoxRow00](self.impl), cast[ptr Widget00](header.impl))

proc gtk_list_box_row_set_selectable*(self: ptr ListBoxRow00; selectable: gboolean) {.
    importc: "gtk_list_box_row_set_selectable", libprag.}

proc setSelectable*(self: ListBoxRow; selectable: bool) =
  gtk_list_box_row_set_selectable(cast[ptr ListBoxRow00](self.impl), gboolean(selectable))

proc `selectable=`*(self: ListBoxRow; selectable: bool) =
  gtk_list_box_row_set_selectable(cast[ptr ListBoxRow00](self.impl), gboolean(selectable))

type
  ListBox* = ref object of Container
  ListBox00* = object of Container00

proc scActivateCursorRow*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate-cursor-row", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveCursor*(self: ListBox;  p: proc (self: ptr gobject.Object00; `object`: MovementStep; p0: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRowActivated*(self: ListBox;  p: proc (self: ptr gobject.Object00; row: ListBoxRow00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "row-activated", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRowSelected*(self: ListBox;  p: proc (self: ptr gobject.Object00; row: ListBoxRow00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "row-selected", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectAll*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectedRowsChanged*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "selected-rows-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleCursorRow*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-cursor-row", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUnselectAll*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_list_box_new*(): ptr ListBox00 {.
    importc: "gtk_list_box_new", libprag.}

proc newListBox*(): ListBox =
  new(result, finalizeGObject)
  result.impl = gtk_list_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListBox*[T](result: var T) =
  assert(result is ListBox)
  new(result, finalizeGObject)
  result.impl = gtk_list_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_drag_highlight_row*(self: ptr ListBox00; row: ptr ListBoxRow00) {.
    importc: "gtk_list_box_drag_highlight_row", libprag.}

proc dragHighlightRow*(self: ListBox; row: ListBoxRow) =
  gtk_list_box_drag_highlight_row(cast[ptr ListBox00](self.impl), cast[ptr ListBoxRow00](row.impl))

proc gtk_list_box_drag_unhighlight_row*(self: ptr ListBox00) {.
    importc: "gtk_list_box_drag_unhighlight_row", libprag.}

proc dragUnhighlightRow*(self: ListBox) =
  gtk_list_box_drag_unhighlight_row(cast[ptr ListBox00](self.impl))

proc gtk_list_box_get_activate_on_single_click*(self: ptr ListBox00): gboolean {.
    importc: "gtk_list_box_get_activate_on_single_click", libprag.}

proc getActivateOnSingleClick*(self: ListBox): bool =
  toBool(gtk_list_box_get_activate_on_single_click(cast[ptr ListBox00](self.impl)))

proc activateOnSingleClick*(self: ListBox): bool =
  toBool(gtk_list_box_get_activate_on_single_click(cast[ptr ListBox00](self.impl)))

proc gtk_list_box_get_adjustment*(self: ptr ListBox00): ptr Adjustment00 {.
    importc: "gtk_list_box_get_adjustment", libprag.}

proc getAdjustment*(self: ListBox): Adjustment =
  let gobj = gtk_list_box_get_adjustment(cast[ptr ListBox00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: ListBox): Adjustment =
  let gobj = gtk_list_box_get_adjustment(cast[ptr ListBox00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_row_at_index*(self: ptr ListBox00; index: int32): ptr ListBoxRow00 {.
    importc: "gtk_list_box_get_row_at_index", libprag.}

proc getRowAtIndex*(self: ListBox; index: int): ListBoxRow =
  let gobj = gtk_list_box_get_row_at_index(cast[ptr ListBox00](self.impl), int32(index))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ListBoxRow](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc rowAtIndex*(self: ListBox; index: int): ListBoxRow =
  let gobj = gtk_list_box_get_row_at_index(cast[ptr ListBox00](self.impl), int32(index))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ListBoxRow](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_row_at_y*(self: ptr ListBox00; y: int32): ptr ListBoxRow00 {.
    importc: "gtk_list_box_get_row_at_y", libprag.}

proc getRowAtY*(self: ListBox; y: int): ListBoxRow =
  let gobj = gtk_list_box_get_row_at_y(cast[ptr ListBox00](self.impl), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ListBoxRow](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc rowAtY*(self: ListBox; y: int): ListBoxRow =
  let gobj = gtk_list_box_get_row_at_y(cast[ptr ListBox00](self.impl), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ListBoxRow](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_selected_row*(self: ptr ListBox00): ptr ListBoxRow00 {.
    importc: "gtk_list_box_get_selected_row", libprag.}

proc getSelectedRow*(self: ListBox): ListBoxRow =
  let gobj = gtk_list_box_get_selected_row(cast[ptr ListBox00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ListBoxRow](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectedRow*(self: ListBox): ListBoxRow =
  let gobj = gtk_list_box_get_selected_row(cast[ptr ListBox00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ListBoxRow](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_selected_rows*(self: ptr ListBox00): ptr pointer {.
    importc: "gtk_list_box_get_selected_rows", libprag.}

proc getSelectedRows*(self: ListBox): ptr pointer =
  gtk_list_box_get_selected_rows(cast[ptr ListBox00](self.impl))

proc selectedRows*(self: ListBox): ptr pointer =
  gtk_list_box_get_selected_rows(cast[ptr ListBox00](self.impl))

proc gtk_list_box_get_selection_mode*(self: ptr ListBox00): SelectionMode {.
    importc: "gtk_list_box_get_selection_mode", libprag.}

proc getSelectionMode*(self: ListBox): SelectionMode =
  gtk_list_box_get_selection_mode(cast[ptr ListBox00](self.impl))

proc selectionMode*(self: ListBox): SelectionMode =
  gtk_list_box_get_selection_mode(cast[ptr ListBox00](self.impl))

proc gtk_list_box_insert*(self: ptr ListBox00; child: ptr Widget00; position: int32) {.
    importc: "gtk_list_box_insert", libprag.}

proc insert*(self: ListBox; child: Widget; position: int) =
  gtk_list_box_insert(cast[ptr ListBox00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_list_box_invalidate_filter*(self: ptr ListBox00) {.
    importc: "gtk_list_box_invalidate_filter", libprag.}

proc invalidateFilter*(self: ListBox) =
  gtk_list_box_invalidate_filter(cast[ptr ListBox00](self.impl))

proc gtk_list_box_invalidate_headers*(self: ptr ListBox00) {.
    importc: "gtk_list_box_invalidate_headers", libprag.}

proc invalidateHeaders*(self: ListBox) =
  gtk_list_box_invalidate_headers(cast[ptr ListBox00](self.impl))

proc gtk_list_box_invalidate_sort*(self: ptr ListBox00) {.
    importc: "gtk_list_box_invalidate_sort", libprag.}

proc invalidateSort*(self: ListBox) =
  gtk_list_box_invalidate_sort(cast[ptr ListBox00](self.impl))

proc gtk_list_box_prepend*(self: ptr ListBox00; child: ptr Widget00) {.
    importc: "gtk_list_box_prepend", libprag.}

proc prepend*(self: ListBox; child: Widget) =
  gtk_list_box_prepend(cast[ptr ListBox00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_list_box_select_all*(self: ptr ListBox00) {.
    importc: "gtk_list_box_select_all", libprag.}

proc selectAll*(self: ListBox) =
  gtk_list_box_select_all(cast[ptr ListBox00](self.impl))

proc gtk_list_box_select_row*(self: ptr ListBox00; row: ptr ListBoxRow00) {.
    importc: "gtk_list_box_select_row", libprag.}

proc selectRow*(self: ListBox; row: ListBoxRow) =
  gtk_list_box_select_row(cast[ptr ListBox00](self.impl), cast[ptr ListBoxRow00](row.impl))

proc gtk_list_box_set_activate_on_single_click*(self: ptr ListBox00; single: gboolean) {.
    importc: "gtk_list_box_set_activate_on_single_click", libprag.}

proc setActivateOnSingleClick*(self: ListBox; single: bool) =
  gtk_list_box_set_activate_on_single_click(cast[ptr ListBox00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: ListBox; single: bool) =
  gtk_list_box_set_activate_on_single_click(cast[ptr ListBox00](self.impl), gboolean(single))

proc gtk_list_box_set_adjustment*(self: ptr ListBox00; adjustment: ptr Adjustment00) {.
    importc: "gtk_list_box_set_adjustment", libprag.}

proc setAdjustment*(self: ListBox; adjustment: Adjustment) =
  gtk_list_box_set_adjustment(cast[ptr ListBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: ListBox; adjustment: Adjustment) =
  gtk_list_box_set_adjustment(cast[ptr ListBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_list_box_set_placeholder*(self: ptr ListBox00; placeholder: ptr Widget00) {.
    importc: "gtk_list_box_set_placeholder", libprag.}

proc setPlaceholder*(self: ListBox; placeholder: Widget) =
  gtk_list_box_set_placeholder(cast[ptr ListBox00](self.impl), cast[ptr Widget00](placeholder.impl))

proc `placeholder=`*(self: ListBox; placeholder: Widget) =
  gtk_list_box_set_placeholder(cast[ptr ListBox00](self.impl), cast[ptr Widget00](placeholder.impl))

proc gtk_list_box_set_selection_mode*(self: ptr ListBox00; mode: SelectionMode) {.
    importc: "gtk_list_box_set_selection_mode", libprag.}

proc setSelectionMode*(self: ListBox; mode: SelectionMode) =
  gtk_list_box_set_selection_mode(cast[ptr ListBox00](self.impl), mode)

proc `selectionMode=`*(self: ListBox; mode: SelectionMode) =
  gtk_list_box_set_selection_mode(cast[ptr ListBox00](self.impl), mode)

proc gtk_list_box_unselect_all*(self: ptr ListBox00) {.
    importc: "gtk_list_box_unselect_all", libprag.}

proc unselectAll*(self: ListBox) =
  gtk_list_box_unselect_all(cast[ptr ListBox00](self.impl))

proc gtk_list_box_unselect_row*(self: ptr ListBox00; row: ptr ListBoxRow00) {.
    importc: "gtk_list_box_unselect_row", libprag.}

proc unselectRow*(self: ListBox; row: ListBoxRow) =
  gtk_list_box_unselect_row(cast[ptr ListBox00](self.impl), cast[ptr ListBoxRow00](row.impl))

type
  ListBoxAccessiblePrivate00* {.pure.} = object
  ListBoxAccessiblePrivate* = ref object
    impl*: ptr ListBoxAccessiblePrivate00

type
  ListBoxAccessible* = ref object of ContainerAccessible
  ListBoxAccessible00* = object of ContainerAccessible00
    priv4: ptr ListBoxAccessiblePrivate00

type
  ListBoxAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  ListBoxAccessibleClass* = ref object
    impl*: ptr ListBoxAccessibleClass00

type
  ListBoxClass00* {.pure.} = object
    parentClass*: ContainerClass00
    rowSelected*: proc(box: ptr ListBox00; row: ptr ListBoxRow00) {.cdecl.}
    rowActivated*: proc(box: ptr ListBox00; row: ptr ListBoxRow00) {.cdecl.}
    activateCursorRow*: proc(box: ptr ListBox00) {.cdecl.}
    toggleCursorRow*: proc(box: ptr ListBox00) {.cdecl.}
    moveCursor*: proc(box: ptr ListBox00; step: MovementStep; count: int32) {.cdecl.}
    selectedRowsChanged*: proc(box: ptr ListBox00) {.cdecl.}
    selectAll*: proc(box: ptr ListBox00) {.cdecl.}
    unselectAll*: proc(box: ptr ListBox00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
  ListBoxClass* = ref object
    impl*: ptr ListBoxClass00

type
  ListBoxCreateWidgetFunc* = proc (item: ptr gobject.Object00; userData: pointer): ptr Widget00 {.cdecl.}

proc gtk_list_box_bind_model*(self: ptr ListBox00; model: ptr gio.ListModel00; createWidgetFunc: ListBoxCreateWidgetFunc; 
    userData: pointer; userDataFreeFunc: DestroyNotify) {.
    importc: "gtk_list_box_bind_model", libprag.}

proc bindModel*(self: ListBox; model: gio.ListModel; createWidgetFunc: ListBoxCreateWidgetFunc; 
    userData: pointer; userDataFreeFunc: DestroyNotify) =
  gtk_list_box_bind_model(cast[ptr ListBox00](self.impl), cast[ptr gio.ListModel00](model.impl), createWidgetFunc, userData, userDataFreeFunc)

type
  ListBoxFilterFunc* = proc (row: ptr ListBoxRow00; userData: pointer): gboolean {.cdecl.}

proc gtk_list_box_set_filter_func*(self: ptr ListBox00; filterFunc: ListBoxFilterFunc; 
    userData: pointer; destroy: DestroyNotify) {.
    importc: "gtk_list_box_set_filter_func", libprag.}

proc setFilterFunc*(self: ListBox; filterFunc: ListBoxFilterFunc; userData: pointer; 
    destroy: DestroyNotify) =
  gtk_list_box_set_filter_func(cast[ptr ListBox00](self.impl), filterFunc, userData, destroy)

type
  ListBoxForeachFunc* = proc (box: ptr ListBox00; row: ptr ListBoxRow00; userData: pointer) {.cdecl.}

proc gtk_list_box_selected_foreach*(self: ptr ListBox00; `func`: ListBoxForeachFunc; data: pointer) {.
    importc: "gtk_list_box_selected_foreach", libprag.}

proc selectedForeach*(self: ListBox; `func`: ListBoxForeachFunc; data: pointer) =
  gtk_list_box_selected_foreach(cast[ptr ListBox00](self.impl), `func`, data)

type
  ListBoxRowAccessible* = ref object of ContainerAccessible
  ListBoxRowAccessible00* = object of ContainerAccessible00

type
  ListBoxRowAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  ListBoxRowAccessibleClass* = ref object
    impl*: ptr ListBoxRowAccessibleClass00

type
  ListBoxRowClass00* {.pure.} = object
    parentClass*: BinClass00
    activate*: proc(row: ptr ListBoxRow00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
  ListBoxRowClass* = ref object
    impl*: ptr ListBoxRowClass00

type
  ListBoxSortFunc* = proc (row1: ptr ListBoxRow00; row2: ptr ListBoxRow00; userData: pointer): int32 {.cdecl.}

proc gtk_list_box_set_sort_func*(self: ptr ListBox00; sortFunc: ListBoxSortFunc; userData: pointer; 
    destroy: DestroyNotify) {.
    importc: "gtk_list_box_set_sort_func", libprag.}

proc setSortFunc*(self: ListBox; sortFunc: ListBoxSortFunc; userData: pointer; 
    destroy: DestroyNotify) =
  gtk_list_box_set_sort_func(cast[ptr ListBox00](self.impl), sortFunc, userData, destroy)

type
  ListBoxUpdateHeaderFunc* = proc (row: ptr ListBoxRow00; before: ptr ListBoxRow00; userData: pointer) {.cdecl.}

proc gtk_list_box_set_header_func*(self: ptr ListBox00; updateHeader: ListBoxUpdateHeaderFunc; 
    userData: pointer; destroy: DestroyNotify) {.
    importc: "gtk_list_box_set_header_func", libprag.}

proc setHeaderFunc*(self: ListBox; updateHeader: ListBoxUpdateHeaderFunc; 
    userData: pointer; destroy: DestroyNotify) =
  gtk_list_box_set_header_func(cast[ptr ListBox00](self.impl), updateHeader, userData, destroy)

type
  ListStorePrivate00* {.pure.} = object
  ListStorePrivate* = ref object
    impl*: ptr ListStorePrivate00

type
  ListStore* = ref object of gobject.Object
  ListStore00* = object of gobject.Object00
    priv1: ptr ListStorePrivate00

proc gtk_list_store_newv*(nColumns: int32; types: GTypeArray): ptr ListStore00 {.
    importc: "gtk_list_store_newv", libprag.}

proc newListStore*(nColumns: int; types: GTypeArray): ListStore =
  new(result, finalizeGObject)
  result.impl = gtk_list_store_newv(int32(nColumns), types)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListStore*[T](result: var T; nColumns: int; types: GTypeArray) =
  assert(result is ListStore)
  new(result, finalizeGObject)
  result.impl = gtk_list_store_newv(int32(nColumns), types)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_store_append*(self: ptr ListStore00; iter: var TreeIter00) {.
    importc: "gtk_list_store_append", libprag.}

proc append*(self: ptr ListStore00; iter: var TreeIter00) {.
    importc: "gtk_list_store_append", libprag.}

proc gtk_list_store_clear*(self: ptr ListStore00) {.
    importc: "gtk_list_store_clear", libprag.}

proc clear*(self: ListStore) =
  gtk_list_store_clear(cast[ptr ListStore00](self.impl))

proc gtk_list_store_insert*(self: ptr ListStore00; iter: var TreeIter00; position: int32) {.
    importc: "gtk_list_store_insert", libprag.}

proc insert*(self: ptr ListStore00; iter: var TreeIter00; position: int32) {.
    importc: "gtk_list_store_insert", libprag.}

proc gtk_list_store_insert_after*(self: ptr ListStore00; iter: var TreeIter00; sibling: ptr TreeIter00) {.
    importc: "gtk_list_store_insert_after", libprag.}

proc insertAfter*(self: ptr ListStore00; iter: var TreeIter00; sibling: ptr TreeIter00) {.
    importc: "gtk_list_store_insert_after", libprag.}

proc gtk_list_store_insert_before*(self: ptr ListStore00; iter: var TreeIter00; sibling: ptr TreeIter00) {.
    importc: "gtk_list_store_insert_before", libprag.}

proc insertBefore*(self: ptr ListStore00; iter: var TreeIter00; sibling: ptr TreeIter00) {.
    importc: "gtk_list_store_insert_before", libprag.}

proc gtk_list_store_insert_with_valuesv*(self: ptr ListStore00; iter: var TreeIter00; position: int32; 
    columns: int32Array; values: gobject.Value00Array; nValues: int32) {.
    importc: "gtk_list_store_insert_with_valuesv", libprag.}

proc insertWithValuesv*(self: ptr ListStore00; iter: var TreeIter00; position: int32; 
    columns: int32Array; values: gobject.Value00Array; nValues: int32) {.
    importc: "gtk_list_store_insert_with_valuesv", libprag.}

proc gtk_list_store_iter_is_valid*(self: ptr ListStore00; iter: ptr TreeIter00): gboolean {.
    importc: "gtk_list_store_iter_is_valid", libprag.}

proc iterIsValid*(self: ListStore; iter: TreeIter): bool =
  toBool(gtk_list_store_iter_is_valid(cast[ptr ListStore00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_list_store_move_after*(self: ptr ListStore00; iter: ptr TreeIter00; position: ptr TreeIter00) {.
    importc: "gtk_list_store_move_after", libprag.}

proc moveAfter*(self: ListStore; iter: TreeIter; position: TreeIter) =
  gtk_list_store_move_after(cast[ptr ListStore00](self.impl), cast[ptr TreeIter00](iter.impl), cast[ptr TreeIter00](position.impl))

proc gtk_list_store_move_before*(self: ptr ListStore00; iter: ptr TreeIter00; position: ptr TreeIter00) {.
    importc: "gtk_list_store_move_before", libprag.}

proc moveBefore*(self: ListStore; iter: TreeIter; position: TreeIter) =
  gtk_list_store_move_before(cast[ptr ListStore00](self.impl), cast[ptr TreeIter00](iter.impl), cast[ptr TreeIter00](position.impl))

proc gtk_list_store_prepend*(self: ptr ListStore00; iter: var TreeIter00) {.
    importc: "gtk_list_store_prepend", libprag.}

proc prepend*(self: ptr ListStore00; iter: var TreeIter00) {.
    importc: "gtk_list_store_prepend", libprag.}

proc gtk_list_store_remove*(self: ptr ListStore00; iter: ptr TreeIter00): gboolean {.
    importc: "gtk_list_store_remove", libprag.}

proc remove*(self: ListStore; iter: TreeIter): bool =
  toBool(gtk_list_store_remove(cast[ptr ListStore00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_list_store_reorder*(self: ptr ListStore00; newOrder: int32Array) {.
    importc: "gtk_list_store_reorder", libprag.}

proc reorder*(self: ListStore; newOrder: int32Array) =
  gtk_list_store_reorder(cast[ptr ListStore00](self.impl), newOrder)

proc gtk_list_store_set_column_types*(self: ptr ListStore00; nColumns: int32; types: GTypeArray) {.
    importc: "gtk_list_store_set_column_types", libprag.}

proc setColumnTypes*(self: ListStore; nColumns: int; types: GTypeArray) =
  gtk_list_store_set_column_types(cast[ptr ListStore00](self.impl), int32(nColumns), types)

proc gtk_list_store_set_value*(self: ptr ListStore00; iter: ptr TreeIter00; column: int32; 
    value: ptr gobject.Value00) {.
    importc: "gtk_list_store_set_value", libprag.}

proc setValue*(self: ListStore; iter: TreeIter; column: int; value: gobject.Value) =
  gtk_list_store_set_value(cast[ptr ListStore00](self.impl), cast[ptr TreeIter00](iter.impl), int32(column), cast[ptr gobject.Value00](value.impl))

proc gtk_list_store_set_valuesv*(self: ptr ListStore00; iter: ptr TreeIter00; columns: int32Array; 
    values: gobject.Value00Array; nValues: int32) {.
    importc: "gtk_list_store_set_valuesv", libprag.}

proc set*(self: ListStore; iter: TreeIter; columns: int32Array; 
    values: gobject.Value00Array; nValues: int) =
  gtk_list_store_set_valuesv(cast[ptr ListStore00](self.impl), cast[ptr TreeIter00](iter.impl), columns, values, int32(nValues))

proc gtk_list_store_swap*(self: ptr ListStore00; a: ptr TreeIter00; b: ptr TreeIter00) {.
    importc: "gtk_list_store_swap", libprag.}

proc swap*(self: ListStore; a: TreeIter; b: TreeIter) =
  gtk_list_store_swap(cast[ptr ListStore00](self.impl), cast[ptr TreeIter00](a.impl), cast[ptr TreeIter00](b.impl))

type
  ListStoreClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ListStoreClass* = ref object
    impl*: ptr ListStoreClass00

type
  LockButtonPrivate00* {.pure.} = object
  LockButtonPrivate* = ref object
    impl*: ptr LockButtonPrivate00

type
  LockButton* = ref object of Button
  LockButton00* = object of Button00
    priv5: ptr LockButtonPrivate00

proc gtk_lock_button_new*(permission: ptr gio.Permission00): ptr LockButton00 {.
    importc: "gtk_lock_button_new", libprag.}

proc newLockButton*(permission: gio.Permission): LockButton =
  new(result, finalizeGObject)
  result.impl = gtk_lock_button_new(cast[ptr gio.Permission00](permission.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLockButton*[T](result: var T; permission: gio.Permission) =
  assert(result is LockButton)
  new(result, finalizeGObject)
  result.impl = gtk_lock_button_new(cast[ptr gio.Permission00](permission.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_lock_button_get_permission*(self: ptr LockButton00): ptr gio.Permission00 {.
    importc: "gtk_lock_button_get_permission", libprag.}

proc getPermission*(self: LockButton): gio.Permission =
  let gobj = gtk_lock_button_get_permission(cast[ptr LockButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.Permission](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc permission*(self: LockButton): gio.Permission =
  let gobj = gtk_lock_button_get_permission(cast[ptr LockButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.Permission](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_lock_button_set_permission*(self: ptr LockButton00; permission: ptr gio.Permission00) {.
    importc: "gtk_lock_button_set_permission", libprag.}

proc setPermission*(self: LockButton; permission: gio.Permission) =
  gtk_lock_button_set_permission(cast[ptr LockButton00](self.impl), cast[ptr gio.Permission00](permission.impl))

proc `permission=`*(self: LockButton; permission: gio.Permission) =
  gtk_lock_button_set_permission(cast[ptr LockButton00](self.impl), cast[ptr gio.Permission00](permission.impl))

type
  LockButtonAccessiblePrivate00* {.pure.} = object
  LockButtonAccessiblePrivate* = ref object
    impl*: ptr LockButtonAccessiblePrivate00

type
  LockButtonAccessible* = ref object of ButtonAccessible
  LockButtonAccessible00* = object of ButtonAccessible00
    priv5: ptr LockButtonAccessiblePrivate00

type
  LockButtonAccessibleClass00* {.pure.} = object
    parentClass*: ButtonAccessibleClass00
  LockButtonAccessibleClass* = ref object
    impl*: ptr LockButtonAccessibleClass00

type
  LockButtonClass00* {.pure.} = object
    parentClass*: ButtonClass00
    reserved0*: proc() {.cdecl.}
    reserved1*: proc() {.cdecl.}
    reserved2*: proc() {.cdecl.}
    reserved3*: proc() {.cdecl.}
    reserved4*: proc() {.cdecl.}
    reserved5*: proc() {.cdecl.}
    reserved6*: proc() {.cdecl.}
    reserved7*: proc() {.cdecl.}
  LockButtonClass* = ref object
    impl*: ptr LockButtonClass00

const MAJOR_VERSION* = 3'i32

const MAX_COMPOSE_LEN* = 7'i32

const MICRO_VERSION* = 15'i32

const MINOR_VERSION* = 22'i32

type
  MenuShellAccessiblePrivate00* {.pure.} = object
  MenuShellAccessiblePrivate* = ref object
    impl*: ptr MenuShellAccessiblePrivate00

type
  MenuShellAccessible* = ref object of ContainerAccessible
  MenuShellAccessible00* = object of ContainerAccessible00
    priv4: ptr MenuShellAccessiblePrivate00

type
  MenuAccessiblePrivate00* {.pure.} = object
  MenuAccessiblePrivate* = ref object
    impl*: ptr MenuAccessiblePrivate00

type
  MenuAccessible* = ref object of MenuShellAccessible
  MenuAccessible00* = object of MenuShellAccessible00
    priv5: ptr MenuAccessiblePrivate00

type
  MenuShellAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  MenuShellAccessibleClass* = ref object
    impl*: ptr MenuShellAccessibleClass00

type
  MenuAccessibleClass00* {.pure.} = object
    parentClass*: MenuShellAccessibleClass00
  MenuAccessibleClass* = ref object
    impl*: ptr MenuAccessibleClass00

type
  MenuBarPrivate00* {.pure.} = object
  MenuBarPrivate* = ref object
    impl*: ptr MenuBarPrivate00

type
  MenuBar* = ref object of MenuShell
  MenuBar00* = object of MenuShell00
    priv4: ptr MenuBarPrivate00

proc gtk_menu_bar_new*(): ptr MenuBar00 {.
    importc: "gtk_menu_bar_new", libprag.}

proc newMenuBar*(): MenuBar =
  new(result, finalizeGObject)
  result.impl = gtk_menu_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuBar*[T](result: var T) =
  assert(result is MenuBar)
  new(result, finalizeGObject)
  result.impl = gtk_menu_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_bar_new_from_model*(model: ptr gio.MenuModel00): ptr MenuBar00 {.
    importc: "gtk_menu_bar_new_from_model", libprag.}

proc newMenuBarFromModel*(model: gio.MenuModel): MenuBar =
  new(result, finalizeGObject)
  result.impl = gtk_menu_bar_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuBarFromModel*[T](result: var T; model: gio.MenuModel) =
  assert(result is MenuBar)
  new(result, finalizeGObject)
  result.impl = gtk_menu_bar_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  PackDirection* {.size: sizeof(cint), pure.} = enum
    ltr = 0
    rtl = 1
    ttb = 2
    btt = 3

proc gtk_menu_bar_get_child_pack_direction*(self: ptr MenuBar00): PackDirection {.
    importc: "gtk_menu_bar_get_child_pack_direction", libprag.}

proc getChildPackDirection*(self: MenuBar): PackDirection =
  gtk_menu_bar_get_child_pack_direction(cast[ptr MenuBar00](self.impl))

proc childPackDirection*(self: MenuBar): PackDirection =
  gtk_menu_bar_get_child_pack_direction(cast[ptr MenuBar00](self.impl))

proc gtk_menu_bar_get_pack_direction*(self: ptr MenuBar00): PackDirection {.
    importc: "gtk_menu_bar_get_pack_direction", libprag.}

proc getPackDirection*(self: MenuBar): PackDirection =
  gtk_menu_bar_get_pack_direction(cast[ptr MenuBar00](self.impl))

proc packDirection*(self: MenuBar): PackDirection =
  gtk_menu_bar_get_pack_direction(cast[ptr MenuBar00](self.impl))

proc gtk_menu_bar_set_child_pack_direction*(self: ptr MenuBar00; childPackDir: PackDirection) {.
    importc: "gtk_menu_bar_set_child_pack_direction", libprag.}

proc setChildPackDirection*(self: MenuBar; childPackDir: PackDirection) =
  gtk_menu_bar_set_child_pack_direction(cast[ptr MenuBar00](self.impl), childPackDir)

proc `childPackDirection=`*(self: MenuBar; childPackDir: PackDirection) =
  gtk_menu_bar_set_child_pack_direction(cast[ptr MenuBar00](self.impl), childPackDir)

proc gtk_menu_bar_set_pack_direction*(self: ptr MenuBar00; packDir: PackDirection) {.
    importc: "gtk_menu_bar_set_pack_direction", libprag.}

proc setPackDirection*(self: MenuBar; packDir: PackDirection) =
  gtk_menu_bar_set_pack_direction(cast[ptr MenuBar00](self.impl), packDir)

proc `packDirection=`*(self: MenuBar; packDir: PackDirection) =
  gtk_menu_bar_set_pack_direction(cast[ptr MenuBar00](self.impl), packDir)

type
  MenuShellClass00* {.pure.} = object
    parentClass*: ContainerClass00
    submenuPlacement*: uint32
    deactivate*: proc(menuShell: ptr MenuShell00) {.cdecl.}
    selectionDone*: proc(menuShell: ptr MenuShell00) {.cdecl.}
    moveCurrent*: proc(menuShell: ptr MenuShell00; direction: MenuDirectionType) {.cdecl.}
    activateCurrent*: proc(menuShell: ptr MenuShell00; forceHide: gboolean) {.cdecl.}
    cancel*: proc(menuShell: ptr MenuShell00) {.cdecl.}
    selectItem*: proc(menuShell: ptr MenuShell00; menuItem: ptr Widget00) {.cdecl.}
    insert*: proc(menuShell: ptr MenuShell00; child: ptr Widget00; position: int32) {.cdecl.}
    getPopupDelay*: proc(menuShell: ptr MenuShell00): int32 {.cdecl.}
    moveSelected*: proc(menuShell: ptr MenuShell00; distance: int32): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  MenuShellClass* = ref object
    impl*: ptr MenuShellClass00

type
  MenuBarClass00* {.pure.} = object
    parentClass*: MenuShellClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  MenuBarClass* = ref object
    impl*: ptr MenuBarClass00

type
  MenuButtonPrivate00* {.pure.} = object
  MenuButtonPrivate* = ref object
    impl*: ptr MenuButtonPrivate00

type
  MenuButton* = ref object of ToggleButton
  MenuButton00* = object of ToggleButton00
    priv6: ptr MenuButtonPrivate00

proc gtk_menu_button_new*(): ptr MenuButton00 {.
    importc: "gtk_menu_button_new", libprag.}

proc newMenuButton*(): MenuButton =
  new(result, finalizeGObject)
  result.impl = gtk_menu_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuButton*[T](result: var T) =
  assert(result is MenuButton)
  new(result, finalizeGObject)
  result.impl = gtk_menu_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_align_widget*(self: ptr MenuButton00): ptr Widget00 {.
    importc: "gtk_menu_button_get_align_widget", libprag.}

proc getAlignWidget*(self: MenuButton): Widget =
  let gobj = gtk_menu_button_get_align_widget(cast[ptr MenuButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc alignWidget*(self: MenuButton): Widget =
  let gobj = gtk_menu_button_get_align_widget(cast[ptr MenuButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_direction*(self: ptr MenuButton00): ArrowType {.
    importc: "gtk_menu_button_get_direction", libprag.}

proc getDirection*(self: MenuButton): ArrowType =
  gtk_menu_button_get_direction(cast[ptr MenuButton00](self.impl))

proc direction*(self: MenuButton): ArrowType =
  gtk_menu_button_get_direction(cast[ptr MenuButton00](self.impl))

proc gtk_menu_button_get_menu_model*(self: ptr MenuButton00): ptr gio.MenuModel00 {.
    importc: "gtk_menu_button_get_menu_model", libprag.}

proc getMenuModel*(self: MenuButton): gio.MenuModel =
  let gobj = gtk_menu_button_get_menu_model(cast[ptr MenuButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.MenuModel](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menuModel*(self: MenuButton): gio.MenuModel =
  let gobj = gtk_menu_button_get_menu_model(cast[ptr MenuButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gio.MenuModel](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_popup*(self: ptr MenuButton00): ptr Menu00 {.
    importc: "gtk_menu_button_get_popup", libprag.}

proc getPopup*(self: MenuButton): Menu =
  let gobj = gtk_menu_button_get_popup(cast[ptr MenuButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Menu](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popup*(self: MenuButton): Menu =
  let gobj = gtk_menu_button_get_popup(cast[ptr MenuButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Menu](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_use_popover*(self: ptr MenuButton00): gboolean {.
    importc: "gtk_menu_button_get_use_popover", libprag.}

proc getUsePopover*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_use_popover(cast[ptr MenuButton00](self.impl)))

proc usePopover*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_use_popover(cast[ptr MenuButton00](self.impl)))

proc gtk_menu_button_set_align_widget*(self: ptr MenuButton00; alignWidget: ptr Widget00) {.
    importc: "gtk_menu_button_set_align_widget", libprag.}

proc setAlignWidget*(self: MenuButton; alignWidget: Widget) =
  gtk_menu_button_set_align_widget(cast[ptr MenuButton00](self.impl), cast[ptr Widget00](alignWidget.impl))

proc `alignWidget=`*(self: MenuButton; alignWidget: Widget) =
  gtk_menu_button_set_align_widget(cast[ptr MenuButton00](self.impl), cast[ptr Widget00](alignWidget.impl))

proc gtk_menu_button_set_direction*(self: ptr MenuButton00; direction: ArrowType) {.
    importc: "gtk_menu_button_set_direction", libprag.}

proc setDirection*(self: MenuButton; direction: ArrowType) =
  gtk_menu_button_set_direction(cast[ptr MenuButton00](self.impl), direction)

proc `direction=`*(self: MenuButton; direction: ArrowType) =
  gtk_menu_button_set_direction(cast[ptr MenuButton00](self.impl), direction)

proc gtk_menu_button_set_menu_model*(self: ptr MenuButton00; menuModel: ptr gio.MenuModel00) {.
    importc: "gtk_menu_button_set_menu_model", libprag.}

proc setMenuModel*(self: MenuButton; menuModel: gio.MenuModel) =
  gtk_menu_button_set_menu_model(cast[ptr MenuButton00](self.impl), cast[ptr gio.MenuModel00](menuModel.impl))

proc `menuModel=`*(self: MenuButton; menuModel: gio.MenuModel) =
  gtk_menu_button_set_menu_model(cast[ptr MenuButton00](self.impl), cast[ptr gio.MenuModel00](menuModel.impl))

proc gtk_menu_button_set_popover*(self: ptr MenuButton00; popover: ptr Widget00) {.
    importc: "gtk_menu_button_set_popover", libprag.}

proc setPopover*(self: MenuButton; popover: Widget) =
  gtk_menu_button_set_popover(cast[ptr MenuButton00](self.impl), cast[ptr Widget00](popover.impl))

proc `popover=`*(self: MenuButton; popover: Widget) =
  gtk_menu_button_set_popover(cast[ptr MenuButton00](self.impl), cast[ptr Widget00](popover.impl))

proc gtk_menu_button_set_popup*(self: ptr MenuButton00; menu: ptr Widget00) {.
    importc: "gtk_menu_button_set_popup", libprag.}

proc setPopup*(self: MenuButton; menu: Widget) =
  gtk_menu_button_set_popup(cast[ptr MenuButton00](self.impl), cast[ptr Widget00](menu.impl))

proc `popup=`*(self: MenuButton; menu: Widget) =
  gtk_menu_button_set_popup(cast[ptr MenuButton00](self.impl), cast[ptr Widget00](menu.impl))

proc gtk_menu_button_set_use_popover*(self: ptr MenuButton00; usePopover: gboolean) {.
    importc: "gtk_menu_button_set_use_popover", libprag.}

proc setUsePopover*(self: MenuButton; usePopover: bool) =
  gtk_menu_button_set_use_popover(cast[ptr MenuButton00](self.impl), gboolean(usePopover))

proc `usePopover=`*(self: MenuButton; usePopover: bool) =
  gtk_menu_button_set_use_popover(cast[ptr MenuButton00](self.impl), gboolean(usePopover))

type
  PopoverPrivate00* {.pure.} = object
  PopoverPrivate* = ref object
    impl*: ptr PopoverPrivate00

type
  Popover* = ref object of Bin
  Popover00* = object of Bin00
    priv4: ptr PopoverPrivate00

proc scClosed*(self: Popover;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "closed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_popover_new*(relativeTo: ptr Widget00): ptr Popover00 {.
    importc: "gtk_popover_new", libprag.}

proc newPopover*(relativeTo: Widget): Popover =
  new(result, finalizeGObject)
  result.impl = gtk_popover_new(cast[ptr Widget00](relativeTo.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopover*[T](result: var T; relativeTo: Widget) =
  assert(result is Popover)
  new(result, finalizeGObject)
  result.impl = gtk_popover_new(cast[ptr Widget00](relativeTo.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_new_from_model*(relativeTo: ptr Widget00; model: ptr gio.MenuModel00): ptr Popover00 {.
    importc: "gtk_popover_new_from_model", libprag.}

proc newPopoverFromModel*(relativeTo: Widget; model: gio.MenuModel): Popover =
  new(result, finalizeGObject)
  result.impl = gtk_popover_new_from_model(cast[ptr Widget00](relativeTo.impl), cast[ptr gio.MenuModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopoverFromModel*[T](result: var T; relativeTo: Widget; model: gio.MenuModel) =
  assert(result is Popover)
  new(result, finalizeGObject)
  result.impl = gtk_popover_new_from_model(cast[ptr Widget00](relativeTo.impl), cast[ptr gio.MenuModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_bind_model*(self: ptr Popover00; model: ptr gio.MenuModel00; actionNamespace: cstring) {.
    importc: "gtk_popover_bind_model", libprag.}

proc bindModel*(self: Popover; model: gio.MenuModel; actionNamespace: string) =
  gtk_popover_bind_model(cast[ptr Popover00](self.impl), cast[ptr gio.MenuModel00](model.impl), cstring(actionNamespace))

proc gtk_popover_get_default_widget*(self: ptr Popover00): ptr Widget00 {.
    importc: "gtk_popover_get_default_widget", libprag.}

proc getDefaultWidget*(self: Popover): Widget =
  let gobj = gtk_popover_get_default_widget(cast[ptr Popover00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultWidget*(self: Popover): Widget =
  let gobj = gtk_popover_get_default_widget(cast[ptr Popover00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_get_modal*(self: ptr Popover00): gboolean {.
    importc: "gtk_popover_get_modal", libprag.}

proc getModal*(self: Popover): bool =
  toBool(gtk_popover_get_modal(cast[ptr Popover00](self.impl)))

proc modal*(self: Popover): bool =
  toBool(gtk_popover_get_modal(cast[ptr Popover00](self.impl)))

proc gtk_popover_get_pointing_to*(self: ptr Popover00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_popover_get_pointing_to", libprag.}

proc getPointingTo*(self: ptr Popover00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_popover_get_pointing_to", libprag.}

proc pointingTo*(self: ptr Popover00; rect: var gdk.Rectangle00): gboolean {.
    importc: "gtk_popover_get_pointing_to", libprag.}

proc gtk_popover_get_position*(self: ptr Popover00): PositionType {.
    importc: "gtk_popover_get_position", libprag.}

proc getPosition*(self: Popover): PositionType =
  gtk_popover_get_position(cast[ptr Popover00](self.impl))

proc position*(self: Popover): PositionType =
  gtk_popover_get_position(cast[ptr Popover00](self.impl))

proc gtk_popover_get_relative_to*(self: ptr Popover00): ptr Widget00 {.
    importc: "gtk_popover_get_relative_to", libprag.}

proc getRelativeTo*(self: Popover): Widget =
  let gobj = gtk_popover_get_relative_to(cast[ptr Popover00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc relativeTo*(self: Popover): Widget =
  let gobj = gtk_popover_get_relative_to(cast[ptr Popover00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_get_transitions_enabled*(self: ptr Popover00): gboolean {.
    importc: "gtk_popover_get_transitions_enabled", libprag.}

proc getTransitionsEnabled*(self: Popover): bool =
  toBool(gtk_popover_get_transitions_enabled(cast[ptr Popover00](self.impl)))

proc transitionsEnabled*(self: Popover): bool =
  toBool(gtk_popover_get_transitions_enabled(cast[ptr Popover00](self.impl)))

proc gtk_popover_popdown*(self: ptr Popover00) {.
    importc: "gtk_popover_popdown", libprag.}

proc popdown*(self: Popover) =
  gtk_popover_popdown(cast[ptr Popover00](self.impl))

proc gtk_popover_popup*(self: ptr Popover00) {.
    importc: "gtk_popover_popup", libprag.}

proc popup*(self: Popover) =
  gtk_popover_popup(cast[ptr Popover00](self.impl))

proc gtk_popover_set_default_widget*(self: ptr Popover00; widget: ptr Widget00) {.
    importc: "gtk_popover_set_default_widget", libprag.}

proc setDefaultWidget*(self: Popover; widget: Widget) =
  gtk_popover_set_default_widget(cast[ptr Popover00](self.impl), cast[ptr Widget00](widget.impl))

proc `defaultWidget=`*(self: Popover; widget: Widget) =
  gtk_popover_set_default_widget(cast[ptr Popover00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_popover_set_modal*(self: ptr Popover00; modal: gboolean) {.
    importc: "gtk_popover_set_modal", libprag.}

proc setModal*(self: Popover; modal: bool) =
  gtk_popover_set_modal(cast[ptr Popover00](self.impl), gboolean(modal))

proc `modal=`*(self: Popover; modal: bool) =
  gtk_popover_set_modal(cast[ptr Popover00](self.impl), gboolean(modal))

proc gtk_popover_set_pointing_to*(self: ptr Popover00; rect: ptr gdk.Rectangle00) {.
    importc: "gtk_popover_set_pointing_to", libprag.}

proc setPointingTo*(self: Popover; rect: gdk.Rectangle) =
  gtk_popover_set_pointing_to(cast[ptr Popover00](self.impl), cast[ptr gdk.Rectangle00](rect.impl))

proc `pointingTo=`*(self: Popover; rect: gdk.Rectangle) =
  gtk_popover_set_pointing_to(cast[ptr Popover00](self.impl), cast[ptr gdk.Rectangle00](rect.impl))

proc gtk_popover_set_position*(self: ptr Popover00; position: PositionType) {.
    importc: "gtk_popover_set_position", libprag.}

proc setPosition*(self: Popover; position: PositionType) =
  gtk_popover_set_position(cast[ptr Popover00](self.impl), position)

proc `position=`*(self: Popover; position: PositionType) =
  gtk_popover_set_position(cast[ptr Popover00](self.impl), position)

proc gtk_popover_set_relative_to*(self: ptr Popover00; relativeTo: ptr Widget00) {.
    importc: "gtk_popover_set_relative_to", libprag.}

proc setRelativeTo*(self: Popover; relativeTo: Widget) =
  gtk_popover_set_relative_to(cast[ptr Popover00](self.impl), cast[ptr Widget00](relativeTo.impl))

proc `relativeTo=`*(self: Popover; relativeTo: Widget) =
  gtk_popover_set_relative_to(cast[ptr Popover00](self.impl), cast[ptr Widget00](relativeTo.impl))

proc gtk_popover_set_transitions_enabled*(self: ptr Popover00; transitionsEnabled: gboolean) {.
    importc: "gtk_popover_set_transitions_enabled", libprag.}

proc setTransitionsEnabled*(self: Popover; transitionsEnabled: bool) =
  gtk_popover_set_transitions_enabled(cast[ptr Popover00](self.impl), gboolean(transitionsEnabled))

proc `transitionsEnabled=`*(self: Popover; transitionsEnabled: bool) =
  gtk_popover_set_transitions_enabled(cast[ptr Popover00](self.impl), gboolean(transitionsEnabled))

proc gtk_menu_button_get_popover*(self: ptr MenuButton00): ptr Popover00 {.
    importc: "gtk_menu_button_get_popover", libprag.}

proc getPopover*(self: MenuButton): Popover =
  let gobj = gtk_menu_button_get_popover(cast[ptr MenuButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Popover](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popover*(self: MenuButton): Popover =
  let gobj = gtk_menu_button_get_popover(cast[ptr MenuButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Popover](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  PopoverConstraint* {.size: sizeof(cint), pure.} = enum
    none = 0
    window = 1

proc gtk_popover_get_constrain_to*(self: ptr Popover00): PopoverConstraint {.
    importc: "gtk_popover_get_constrain_to", libprag.}

proc getConstrainTo*(self: Popover): PopoverConstraint =
  gtk_popover_get_constrain_to(cast[ptr Popover00](self.impl))

proc constrainTo*(self: Popover): PopoverConstraint =
  gtk_popover_get_constrain_to(cast[ptr Popover00](self.impl))

proc gtk_popover_set_constrain_to*(self: ptr Popover00; constraint: PopoverConstraint) {.
    importc: "gtk_popover_set_constrain_to", libprag.}

proc setConstrainTo*(self: Popover; constraint: PopoverConstraint) =
  gtk_popover_set_constrain_to(cast[ptr Popover00](self.impl), constraint)

proc `constrainTo=`*(self: Popover; constraint: PopoverConstraint) =
  gtk_popover_set_constrain_to(cast[ptr Popover00](self.impl), constraint)

type
  ToggleButtonAccessiblePrivate00* {.pure.} = object
  ToggleButtonAccessiblePrivate* = ref object
    impl*: ptr ToggleButtonAccessiblePrivate00

type
  ToggleButtonAccessible* = ref object of ButtonAccessible
  ToggleButtonAccessible00* = object of ButtonAccessible00
    priv5: ptr ToggleButtonAccessiblePrivate00

type
  MenuButtonAccessiblePrivate00* {.pure.} = object
  MenuButtonAccessiblePrivate* = ref object
    impl*: ptr MenuButtonAccessiblePrivate00

type
  MenuButtonAccessible* = ref object of ToggleButtonAccessible
  MenuButtonAccessible00* = object of ToggleButtonAccessible00
    priv6: ptr MenuButtonAccessiblePrivate00

type
  ToggleButtonAccessibleClass00* {.pure.} = object
    parentClass*: ButtonAccessibleClass00
  ToggleButtonAccessibleClass* = ref object
    impl*: ptr ToggleButtonAccessibleClass00

type
  MenuButtonAccessibleClass00* {.pure.} = object
    parentClass*: ToggleButtonAccessibleClass00
  MenuButtonAccessibleClass* = ref object
    impl*: ptr MenuButtonAccessibleClass00

type
  MenuButtonClass00* {.pure.} = object
    parentClass*: ToggleButtonClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  MenuButtonClass* = ref object
    impl*: ptr MenuButtonClass00

type
  MenuClass00* {.pure.} = object
    parentClass*: MenuShellClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  MenuClass* = ref object
    impl*: ptr MenuClass00

type
  MenuDetachFunc* = proc (attachWidget: ptr Widget00; menu: ptr Menu00) {.cdecl.}

proc gtk_menu_attach_to_widget*(self: ptr Menu00; attachWidget: ptr Widget00; detacher: MenuDetachFunc) {.
    importc: "gtk_menu_attach_to_widget", libprag.}

proc attachToWidget*(self: Menu; attachWidget: Widget; detacher: MenuDetachFunc) =
  gtk_menu_attach_to_widget(cast[ptr Menu00](self.impl), cast[ptr Widget00](attachWidget.impl), detacher)

type
  MenuPositionFunc* = proc (menu: ptr Menu00; x: int32; y: int32; pushIn: var gboolean; 
    userData: pointer) {.cdecl.}

proc gtk_menu_popup*(self: ptr Menu00; parentMenuShell: ptr Widget00; parentMenuItem: ptr Widget00; 
    `func`: MenuPositionFunc; data: pointer; button: uint32; activateTime: uint32) {.
    importc: "gtk_menu_popup", libprag.}

proc popup*(self: Menu; parentMenuShell: Widget; parentMenuItem: Widget; 
    `func`: MenuPositionFunc; data: pointer; button: int; activateTime: int) =
  gtk_menu_popup(cast[ptr Menu00](self.impl), cast[ptr Widget00](parentMenuShell.impl), cast[ptr Widget00](parentMenuItem.impl), `func`, data, uint32(button), uint32(activateTime))

proc gtk_menu_popup_for_device*(self: ptr Menu00; device: ptr gdk.Device00; parentMenuShell: ptr Widget00; 
    parentMenuItem: ptr Widget00; `func`: MenuPositionFunc; data: pointer; 
    destroy: DestroyNotify; button: uint32; activateTime: uint32) {.
    importc: "gtk_menu_popup_for_device", libprag.}

proc popupForDevice*(self: Menu; device: gdk.Device; parentMenuShell: Widget; 
    parentMenuItem: Widget; `func`: MenuPositionFunc; data: pointer; destroy: DestroyNotify; 
    button: int; activateTime: int) =
  gtk_menu_popup_for_device(cast[ptr Menu00](self.impl), cast[ptr gdk.Device00](device.impl), cast[ptr Widget00](parentMenuShell.impl), cast[ptr Widget00](parentMenuItem.impl), `func`, data, destroy, uint32(button), uint32(activateTime))

type
  ToolItemPrivate00* {.pure.} = object
  ToolItemPrivate* = ref object
    impl*: ptr ToolItemPrivate00

type
  ToolItem* = ref object of Bin
  ToolItem00* = object of Bin00
    priv4: ptr ToolItemPrivate00

proc scCreateMenuProxy*(self: ToolItem;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "create-menu-proxy", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToolbarReconfigured*(self: ToolItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toolbar-reconfigured", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_tool_item_new*(): ptr ToolItem00 {.
    importc: "gtk_tool_item_new", libprag.}

proc newToolItem*(): ToolItem =
  new(result, finalizeGObject)
  result.impl = gtk_tool_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolItem*[T](result: var T) =
  assert(result is ToolItem)
  new(result, finalizeGObject)
  result.impl = gtk_tool_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_get_ellipsize_mode*(self: ptr ToolItem00): pango.EllipsizeMode {.
    importc: "gtk_tool_item_get_ellipsize_mode", libprag.}

proc getEllipsizeMode*(self: ToolItem): pango.EllipsizeMode =
  gtk_tool_item_get_ellipsize_mode(cast[ptr ToolItem00](self.impl))

proc ellipsizeMode*(self: ToolItem): pango.EllipsizeMode =
  gtk_tool_item_get_ellipsize_mode(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_get_expand*(self: ptr ToolItem00): gboolean {.
    importc: "gtk_tool_item_get_expand", libprag.}

proc getExpand*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_expand(cast[ptr ToolItem00](self.impl)))

proc expand*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_expand(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_homogeneous*(self: ptr ToolItem00): gboolean {.
    importc: "gtk_tool_item_get_homogeneous", libprag.}

proc getHomogeneous*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_homogeneous(cast[ptr ToolItem00](self.impl)))

proc homogeneous*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_homogeneous(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_icon_size*(self: ptr ToolItem00): int32 {.
    importc: "gtk_tool_item_get_icon_size", libprag.}

proc getIconSize*(self: ToolItem): int =
  int(gtk_tool_item_get_icon_size(cast[ptr ToolItem00](self.impl)))

proc iconSize*(self: ToolItem): int =
  int(gtk_tool_item_get_icon_size(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_is_important*(self: ptr ToolItem00): gboolean {.
    importc: "gtk_tool_item_get_is_important", libprag.}

proc getIsImportant*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_is_important(cast[ptr ToolItem00](self.impl)))

proc isImportant*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_is_important(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_orientation*(self: ptr ToolItem00): Orientation {.
    importc: "gtk_tool_item_get_orientation", libprag.}

proc getOrientation*(self: ToolItem): Orientation =
  gtk_tool_item_get_orientation(cast[ptr ToolItem00](self.impl))

proc orientation*(self: ToolItem): Orientation =
  gtk_tool_item_get_orientation(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_get_proxy_menu_item*(self: ptr ToolItem00; menuItemId: cstring): ptr Widget00 {.
    importc: "gtk_tool_item_get_proxy_menu_item", libprag.}

proc getProxyMenuItem*(self: ToolItem; menuItemId: string): Widget =
  let gobj = gtk_tool_item_get_proxy_menu_item(cast[ptr ToolItem00](self.impl), cstring(menuItemId))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc proxyMenuItem*(self: ToolItem; menuItemId: string): Widget =
  let gobj = gtk_tool_item_get_proxy_menu_item(cast[ptr ToolItem00](self.impl), cstring(menuItemId))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_get_relief_style*(self: ptr ToolItem00): ReliefStyle {.
    importc: "gtk_tool_item_get_relief_style", libprag.}

proc getReliefStyle*(self: ToolItem): ReliefStyle =
  gtk_tool_item_get_relief_style(cast[ptr ToolItem00](self.impl))

proc reliefStyle*(self: ToolItem): ReliefStyle =
  gtk_tool_item_get_relief_style(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_get_text_alignment*(self: ptr ToolItem00): cfloat {.
    importc: "gtk_tool_item_get_text_alignment", libprag.}

proc getTextAlignment*(self: ToolItem): cfloat =
  gtk_tool_item_get_text_alignment(cast[ptr ToolItem00](self.impl))

proc textAlignment*(self: ToolItem): cfloat =
  gtk_tool_item_get_text_alignment(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_get_text_orientation*(self: ptr ToolItem00): Orientation {.
    importc: "gtk_tool_item_get_text_orientation", libprag.}

proc getTextOrientation*(self: ToolItem): Orientation =
  gtk_tool_item_get_text_orientation(cast[ptr ToolItem00](self.impl))

proc textOrientation*(self: ToolItem): Orientation =
  gtk_tool_item_get_text_orientation(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_get_use_drag_window*(self: ptr ToolItem00): gboolean {.
    importc: "gtk_tool_item_get_use_drag_window", libprag.}

proc getUseDragWindow*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_use_drag_window(cast[ptr ToolItem00](self.impl)))

proc useDragWindow*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_use_drag_window(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_visible_horizontal*(self: ptr ToolItem00): gboolean {.
    importc: "gtk_tool_item_get_visible_horizontal", libprag.}

proc getVisibleHorizontal*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_visible_horizontal(cast[ptr ToolItem00](self.impl)))

proc visibleHorizontal*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_visible_horizontal(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_visible_vertical*(self: ptr ToolItem00): gboolean {.
    importc: "gtk_tool_item_get_visible_vertical", libprag.}

proc getVisibleVertical*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_visible_vertical(cast[ptr ToolItem00](self.impl)))

proc visibleVertical*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_visible_vertical(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_rebuild_menu*(self: ptr ToolItem00) {.
    importc: "gtk_tool_item_rebuild_menu", libprag.}

proc rebuildMenu*(self: ToolItem) =
  gtk_tool_item_rebuild_menu(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_retrieve_proxy_menu_item*(self: ptr ToolItem00): ptr Widget00 {.
    importc: "gtk_tool_item_retrieve_proxy_menu_item", libprag.}

proc retrieveProxyMenuItem*(self: ToolItem): Widget =
  let gobj = gtk_tool_item_retrieve_proxy_menu_item(cast[ptr ToolItem00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_set_expand*(self: ptr ToolItem00; expand: gboolean) {.
    importc: "gtk_tool_item_set_expand", libprag.}

proc setExpand*(self: ToolItem; expand: bool) =
  gtk_tool_item_set_expand(cast[ptr ToolItem00](self.impl), gboolean(expand))

proc `expand=`*(self: ToolItem; expand: bool) =
  gtk_tool_item_set_expand(cast[ptr ToolItem00](self.impl), gboolean(expand))

proc gtk_tool_item_set_homogeneous*(self: ptr ToolItem00; homogeneous: gboolean) {.
    importc: "gtk_tool_item_set_homogeneous", libprag.}

proc setHomogeneous*(self: ToolItem; homogeneous: bool) =
  gtk_tool_item_set_homogeneous(cast[ptr ToolItem00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: ToolItem; homogeneous: bool) =
  gtk_tool_item_set_homogeneous(cast[ptr ToolItem00](self.impl), gboolean(homogeneous))

proc gtk_tool_item_set_is_important*(self: ptr ToolItem00; isImportant: gboolean) {.
    importc: "gtk_tool_item_set_is_important", libprag.}

proc setIsImportant*(self: ToolItem; isImportant: bool) =
  gtk_tool_item_set_is_important(cast[ptr ToolItem00](self.impl), gboolean(isImportant))

proc `isImportant=`*(self: ToolItem; isImportant: bool) =
  gtk_tool_item_set_is_important(cast[ptr ToolItem00](self.impl), gboolean(isImportant))

proc gtk_tool_item_set_proxy_menu_item*(self: ptr ToolItem00; menuItemId: cstring; menuItem: ptr Widget00) {.
    importc: "gtk_tool_item_set_proxy_menu_item", libprag.}

proc setProxyMenuItem*(self: ToolItem; menuItemId: string; menuItem: Widget) =
  gtk_tool_item_set_proxy_menu_item(cast[ptr ToolItem00](self.impl), cstring(menuItemId), cast[ptr Widget00](menuItem.impl))

proc gtk_tool_item_set_tooltip_markup*(self: ptr ToolItem00; markup: cstring) {.
    importc: "gtk_tool_item_set_tooltip_markup", libprag.}

proc setTooltipMarkup*(self: ToolItem; markup: string) =
  gtk_tool_item_set_tooltip_markup(cast[ptr ToolItem00](self.impl), cstring(markup))

proc `tooltipMarkup=`*(self: ToolItem; markup: string) =
  gtk_tool_item_set_tooltip_markup(cast[ptr ToolItem00](self.impl), cstring(markup))

proc gtk_tool_item_set_tooltip_text*(self: ptr ToolItem00; text: cstring) {.
    importc: "gtk_tool_item_set_tooltip_text", libprag.}

proc setTooltipText*(self: ToolItem; text: string) =
  gtk_tool_item_set_tooltip_text(cast[ptr ToolItem00](self.impl), cstring(text))

proc `tooltipText=`*(self: ToolItem; text: string) =
  gtk_tool_item_set_tooltip_text(cast[ptr ToolItem00](self.impl), cstring(text))

proc gtk_tool_item_set_use_drag_window*(self: ptr ToolItem00; useDragWindow: gboolean) {.
    importc: "gtk_tool_item_set_use_drag_window", libprag.}

proc setUseDragWindow*(self: ToolItem; useDragWindow: bool) =
  gtk_tool_item_set_use_drag_window(cast[ptr ToolItem00](self.impl), gboolean(useDragWindow))

proc `useDragWindow=`*(self: ToolItem; useDragWindow: bool) =
  gtk_tool_item_set_use_drag_window(cast[ptr ToolItem00](self.impl), gboolean(useDragWindow))

proc gtk_tool_item_set_visible_horizontal*(self: ptr ToolItem00; visibleHorizontal: gboolean) {.
    importc: "gtk_tool_item_set_visible_horizontal", libprag.}

proc setVisibleHorizontal*(self: ToolItem; visibleHorizontal: bool) =
  gtk_tool_item_set_visible_horizontal(cast[ptr ToolItem00](self.impl), gboolean(visibleHorizontal))

proc `visibleHorizontal=`*(self: ToolItem; visibleHorizontal: bool) =
  gtk_tool_item_set_visible_horizontal(cast[ptr ToolItem00](self.impl), gboolean(visibleHorizontal))

proc gtk_tool_item_set_visible_vertical*(self: ptr ToolItem00; visibleVertical: gboolean) {.
    importc: "gtk_tool_item_set_visible_vertical", libprag.}

proc setVisibleVertical*(self: ToolItem; visibleVertical: bool) =
  gtk_tool_item_set_visible_vertical(cast[ptr ToolItem00](self.impl), gboolean(visibleVertical))

proc `visibleVertical=`*(self: ToolItem; visibleVertical: bool) =
  gtk_tool_item_set_visible_vertical(cast[ptr ToolItem00](self.impl), gboolean(visibleVertical))

proc gtk_tool_item_toolbar_reconfigured*(self: ptr ToolItem00) {.
    importc: "gtk_tool_item_toolbar_reconfigured", libprag.}

proc toolbarReconfigured*(self: ToolItem) =
  gtk_tool_item_toolbar_reconfigured(cast[ptr ToolItem00](self.impl))

type
  ToolButtonPrivate00* {.pure.} = object
  ToolButtonPrivate* = ref object
    impl*: ptr ToolButtonPrivate00

type
  ToolButton* = ref object of ToolItem
  ToolButton00* = object of ToolItem00
    priv5: ptr ToolButtonPrivate00

proc scClicked*(self: ToolButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "clicked", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_tool_button_new*(iconWidget: ptr Widget00; label: cstring): ptr ToolButton00 {.
    importc: "gtk_tool_button_new", libprag.}

proc newToolButton*(iconWidget: Widget; label: string): ToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_tool_button_new(cast[ptr Widget00](iconWidget.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolButton*[T](result: var T; iconWidget: Widget; label: string) =
  assert(result is ToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_tool_button_new(cast[ptr Widget00](iconWidget.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_button_new_from_stock*(stockId: cstring): ptr ToolButton00 {.
    importc: "gtk_tool_button_new_from_stock", libprag.}

proc newToolButtonFromStock*(stockId: string): ToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_tool_button_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolButtonFromStock*[T](result: var T; stockId: string) =
  assert(result is ToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_tool_button_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_button_get_icon_name*(self: ptr ToolButton00): cstring {.
    importc: "gtk_tool_button_get_icon_name", libprag.}

proc getIconName*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_icon_name(cast[ptr ToolButton00](self.impl))
  result = $resul0

proc iconName*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_icon_name(cast[ptr ToolButton00](self.impl))
  result = $resul0

proc gtk_tool_button_get_icon_widget*(self: ptr ToolButton00): ptr Widget00 {.
    importc: "gtk_tool_button_get_icon_widget", libprag.}

proc getIconWidget*(self: ToolButton): Widget =
  let gobj = gtk_tool_button_get_icon_widget(cast[ptr ToolButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc iconWidget*(self: ToolButton): Widget =
  let gobj = gtk_tool_button_get_icon_widget(cast[ptr ToolButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_button_get_label*(self: ptr ToolButton00): cstring {.
    importc: "gtk_tool_button_get_label", libprag.}

proc getLabel*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_label(cast[ptr ToolButton00](self.impl))
  result = $resul0

proc label*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_label(cast[ptr ToolButton00](self.impl))
  result = $resul0

proc gtk_tool_button_get_label_widget*(self: ptr ToolButton00): ptr Widget00 {.
    importc: "gtk_tool_button_get_label_widget", libprag.}

proc getLabelWidget*(self: ToolButton): Widget =
  let gobj = gtk_tool_button_get_label_widget(cast[ptr ToolButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: ToolButton): Widget =
  let gobj = gtk_tool_button_get_label_widget(cast[ptr ToolButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_button_get_stock_id*(self: ptr ToolButton00): cstring {.
    importc: "gtk_tool_button_get_stock_id", libprag.}

proc getStockId*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_stock_id(cast[ptr ToolButton00](self.impl))
  result = $resul0

proc stockId*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_stock_id(cast[ptr ToolButton00](self.impl))
  result = $resul0

proc gtk_tool_button_get_use_underline*(self: ptr ToolButton00): gboolean {.
    importc: "gtk_tool_button_get_use_underline", libprag.}

proc getUseUnderline*(self: ToolButton): bool =
  toBool(gtk_tool_button_get_use_underline(cast[ptr ToolButton00](self.impl)))

proc useUnderline*(self: ToolButton): bool =
  toBool(gtk_tool_button_get_use_underline(cast[ptr ToolButton00](self.impl)))

proc gtk_tool_button_set_icon_name*(self: ptr ToolButton00; iconName: cstring) {.
    importc: "gtk_tool_button_set_icon_name", libprag.}

proc setIconName*(self: ToolButton; iconName: string) =
  gtk_tool_button_set_icon_name(cast[ptr ToolButton00](self.impl), cstring(iconName))

proc `iconName=`*(self: ToolButton; iconName: string) =
  gtk_tool_button_set_icon_name(cast[ptr ToolButton00](self.impl), cstring(iconName))

proc gtk_tool_button_set_icon_widget*(self: ptr ToolButton00; iconWidget: ptr Widget00) {.
    importc: "gtk_tool_button_set_icon_widget", libprag.}

proc setIconWidget*(self: ToolButton; iconWidget: Widget) =
  gtk_tool_button_set_icon_widget(cast[ptr ToolButton00](self.impl), cast[ptr Widget00](iconWidget.impl))

proc `iconWidget=`*(self: ToolButton; iconWidget: Widget) =
  gtk_tool_button_set_icon_widget(cast[ptr ToolButton00](self.impl), cast[ptr Widget00](iconWidget.impl))

proc gtk_tool_button_set_label*(self: ptr ToolButton00; label: cstring) {.
    importc: "gtk_tool_button_set_label", libprag.}

proc setLabel*(self: ToolButton; label: string) =
  gtk_tool_button_set_label(cast[ptr ToolButton00](self.impl), cstring(label))

proc `label=`*(self: ToolButton; label: string) =
  gtk_tool_button_set_label(cast[ptr ToolButton00](self.impl), cstring(label))

proc gtk_tool_button_set_label_widget*(self: ptr ToolButton00; labelWidget: ptr Widget00) {.
    importc: "gtk_tool_button_set_label_widget", libprag.}

proc setLabelWidget*(self: ToolButton; labelWidget: Widget) =
  gtk_tool_button_set_label_widget(cast[ptr ToolButton00](self.impl), cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: ToolButton; labelWidget: Widget) =
  gtk_tool_button_set_label_widget(cast[ptr ToolButton00](self.impl), cast[ptr Widget00](labelWidget.impl))

proc gtk_tool_button_set_stock_id*(self: ptr ToolButton00; stockId: cstring) {.
    importc: "gtk_tool_button_set_stock_id", libprag.}

proc setStockId*(self: ToolButton; stockId: string) =
  gtk_tool_button_set_stock_id(cast[ptr ToolButton00](self.impl), cstring(stockId))

proc `stockId=`*(self: ToolButton; stockId: string) =
  gtk_tool_button_set_stock_id(cast[ptr ToolButton00](self.impl), cstring(stockId))

proc gtk_tool_button_set_use_underline*(self: ptr ToolButton00; useUnderline: gboolean) {.
    importc: "gtk_tool_button_set_use_underline", libprag.}

proc setUseUnderline*(self: ToolButton; useUnderline: bool) =
  gtk_tool_button_set_use_underline(cast[ptr ToolButton00](self.impl), gboolean(useUnderline))

proc `useUnderline=`*(self: ToolButton; useUnderline: bool) =
  gtk_tool_button_set_use_underline(cast[ptr ToolButton00](self.impl), gboolean(useUnderline))

type
  MenuToolButtonPrivate00* {.pure.} = object
  MenuToolButtonPrivate* = ref object
    impl*: ptr MenuToolButtonPrivate00

type
  MenuToolButton* = ref object of ToolButton
  MenuToolButton00* = object of ToolButton00
    priv6: ptr MenuToolButtonPrivate00

proc scShowMenu*(self: MenuToolButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "show-menu", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_menu_tool_button_new*(iconWidget: ptr Widget00; label: cstring): ptr MenuToolButton00 {.
    importc: "gtk_menu_tool_button_new", libprag.}

proc newMenuToolButton*(iconWidget: Widget; label: string): MenuToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_menu_tool_button_new(cast[ptr Widget00](iconWidget.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuToolButton*[T](result: var T; iconWidget: Widget; label: string) =
  assert(result is MenuToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_menu_tool_button_new(cast[ptr Widget00](iconWidget.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_tool_button_new_from_stock*(stockId: cstring): ptr MenuToolButton00 {.
    importc: "gtk_menu_tool_button_new_from_stock", libprag.}

proc newMenuToolButtonFromStock*(stockId: string): MenuToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_menu_tool_button_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuToolButtonFromStock*[T](result: var T; stockId: string) =
  assert(result is MenuToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_menu_tool_button_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_tool_button_get_menu*(self: ptr MenuToolButton00): ptr Widget00 {.
    importc: "gtk_menu_tool_button_get_menu", libprag.}

proc getMenu*(self: MenuToolButton): Widget =
  let gobj = gtk_menu_tool_button_get_menu(cast[ptr MenuToolButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menu*(self: MenuToolButton): Widget =
  let gobj = gtk_menu_tool_button_get_menu(cast[ptr MenuToolButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_tool_button_set_arrow_tooltip_markup*(self: ptr MenuToolButton00; markup: cstring) {.
    importc: "gtk_menu_tool_button_set_arrow_tooltip_markup", libprag.}

proc setArrowTooltipMarkup*(self: MenuToolButton; markup: string) =
  gtk_menu_tool_button_set_arrow_tooltip_markup(cast[ptr MenuToolButton00](self.impl), cstring(markup))

proc `arrowTooltipMarkup=`*(self: MenuToolButton; markup: string) =
  gtk_menu_tool_button_set_arrow_tooltip_markup(cast[ptr MenuToolButton00](self.impl), cstring(markup))

proc gtk_menu_tool_button_set_arrow_tooltip_text*(self: ptr MenuToolButton00; text: cstring) {.
    importc: "gtk_menu_tool_button_set_arrow_tooltip_text", libprag.}

proc setArrowTooltipText*(self: MenuToolButton; text: string) =
  gtk_menu_tool_button_set_arrow_tooltip_text(cast[ptr MenuToolButton00](self.impl), cstring(text))

proc `arrowTooltipText=`*(self: MenuToolButton; text: string) =
  gtk_menu_tool_button_set_arrow_tooltip_text(cast[ptr MenuToolButton00](self.impl), cstring(text))

proc gtk_menu_tool_button_set_menu*(self: ptr MenuToolButton00; menu: ptr Widget00) {.
    importc: "gtk_menu_tool_button_set_menu", libprag.}

proc setMenu*(self: MenuToolButton; menu: Widget) =
  gtk_menu_tool_button_set_menu(cast[ptr MenuToolButton00](self.impl), cast[ptr Widget00](menu.impl))

proc `menu=`*(self: MenuToolButton; menu: Widget) =
  gtk_menu_tool_button_set_menu(cast[ptr MenuToolButton00](self.impl), cast[ptr Widget00](menu.impl))

type
  SizeGroupPrivate00* {.pure.} = object
  SizeGroupPrivate* = ref object
    impl*: ptr SizeGroupPrivate00

type
  SizeGroup* = ref object of gobject.Object
  SizeGroup00* = object of gobject.Object00
    priv1: ptr SizeGroupPrivate00

proc gtk_size_group_add_widget*(self: ptr SizeGroup00; widget: ptr Widget00) {.
    importc: "gtk_size_group_add_widget", libprag.}

proc addWidget*(self: SizeGroup; widget: Widget) =
  gtk_size_group_add_widget(cast[ptr SizeGroup00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_size_group_get_ignore_hidden*(self: ptr SizeGroup00): gboolean {.
    importc: "gtk_size_group_get_ignore_hidden", libprag.}

proc getIgnoreHidden*(self: SizeGroup): bool =
  toBool(gtk_size_group_get_ignore_hidden(cast[ptr SizeGroup00](self.impl)))

proc ignoreHidden*(self: SizeGroup): bool =
  toBool(gtk_size_group_get_ignore_hidden(cast[ptr SizeGroup00](self.impl)))

proc gtk_size_group_get_widgets*(self: ptr SizeGroup00): ptr pointer {.
    importc: "gtk_size_group_get_widgets", libprag.}

proc getWidgets*(self: SizeGroup): ptr pointer =
  gtk_size_group_get_widgets(cast[ptr SizeGroup00](self.impl))

proc widgets*(self: SizeGroup): ptr pointer =
  gtk_size_group_get_widgets(cast[ptr SizeGroup00](self.impl))

proc gtk_size_group_remove_widget*(self: ptr SizeGroup00; widget: ptr Widget00) {.
    importc: "gtk_size_group_remove_widget", libprag.}

proc removeWidget*(self: SizeGroup; widget: Widget) =
  gtk_size_group_remove_widget(cast[ptr SizeGroup00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_size_group_set_ignore_hidden*(self: ptr SizeGroup00; ignoreHidden: gboolean) {.
    importc: "gtk_size_group_set_ignore_hidden", libprag.}

proc setIgnoreHidden*(self: SizeGroup; ignoreHidden: bool) =
  gtk_size_group_set_ignore_hidden(cast[ptr SizeGroup00](self.impl), gboolean(ignoreHidden))

proc `ignoreHidden=`*(self: SizeGroup; ignoreHidden: bool) =
  gtk_size_group_set_ignore_hidden(cast[ptr SizeGroup00](self.impl), gboolean(ignoreHidden))

proc gtk_tool_item_get_text_size_group*(self: ptr ToolItem00): ptr SizeGroup00 {.
    importc: "gtk_tool_item_get_text_size_group", libprag.}

proc getTextSizeGroup*(self: ToolItem): SizeGroup =
  let gobj = gtk_tool_item_get_text_size_group(cast[ptr ToolItem00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[SizeGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc textSizeGroup*(self: ToolItem): SizeGroup =
  let gobj = gtk_tool_item_get_text_size_group(cast[ptr ToolItem00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[SizeGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SizeGroupMode* {.size: sizeof(cint), pure.} = enum
    none = 0
    horizontal = 1
    vertical = 2
    both = 3

proc gtk_size_group_new*(mode: SizeGroupMode): ptr SizeGroup00 {.
    importc: "gtk_size_group_new", libprag.}

proc newSizeGroup*(mode: SizeGroupMode): SizeGroup =
  new(result, finalizeGObject)
  result.impl = gtk_size_group_new(mode)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSizeGroup*[T](result: var T; mode: SizeGroupMode) =
  assert(result is SizeGroup)
  new(result, finalizeGObject)
  result.impl = gtk_size_group_new(mode)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_size_group_get_mode*(self: ptr SizeGroup00): SizeGroupMode {.
    importc: "gtk_size_group_get_mode", libprag.}

proc getMode*(self: SizeGroup): SizeGroupMode =
  gtk_size_group_get_mode(cast[ptr SizeGroup00](self.impl))

proc mode*(self: SizeGroup): SizeGroupMode =
  gtk_size_group_get_mode(cast[ptr SizeGroup00](self.impl))

proc gtk_size_group_set_mode*(self: ptr SizeGroup00; mode: SizeGroupMode) {.
    importc: "gtk_size_group_set_mode", libprag.}

proc setMode*(self: SizeGroup; mode: SizeGroupMode) =
  gtk_size_group_set_mode(cast[ptr SizeGroup00](self.impl), mode)

proc `mode=`*(self: SizeGroup; mode: SizeGroupMode) =
  gtk_size_group_set_mode(cast[ptr SizeGroup00](self.impl), mode)

type
  ToolbarStyle* {.size: sizeof(cint), pure.} = enum
    icons = 0
    text = 1
    both = 2
    bothHoriz = 3

proc gtk_tool_item_get_toolbar_style*(self: ptr ToolItem00): ToolbarStyle {.
    importc: "gtk_tool_item_get_toolbar_style", libprag.}

proc getToolbarStyle*(self: ToolItem): ToolbarStyle =
  gtk_tool_item_get_toolbar_style(cast[ptr ToolItem00](self.impl))

proc toolbarStyle*(self: ToolItem): ToolbarStyle =
  gtk_tool_item_get_toolbar_style(cast[ptr ToolItem00](self.impl))

type
  ToolItemClass00* {.pure.} = object
    parentClass*: BinClass00
    createMenuProxy*: proc(toolItem: ptr ToolItem00): gboolean {.cdecl.}
    toolbarReconfigured*: proc(toolItem: ptr ToolItem00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ToolItemClass* = ref object
    impl*: ptr ToolItemClass00

type
  ToolButtonClass00* {.pure.} = object
    parentClass*: ToolItemClass00
    buttonType*: GType
    clicked*: proc(toolItem: ptr ToolButton00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ToolButtonClass* = ref object
    impl*: ptr ToolButtonClass00

type
  MenuToolButtonClass00* {.pure.} = object
    parentClass*: ToolButtonClass00
    showMenu*: proc(button: ptr MenuToolButton00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  MenuToolButtonClass* = ref object
    impl*: ptr MenuToolButtonClass00

type
  MessageDialogPrivate00* {.pure.} = object
  MessageDialogPrivate* = ref object
    impl*: ptr MessageDialogPrivate00

type
  MessageDialog* = ref object of Dialog
  MessageDialog00* = object of Dialog00
    priv6: ptr MessageDialogPrivate00

proc gtk_message_dialog_get_image*(self: ptr MessageDialog00): ptr Widget00 {.
    importc: "gtk_message_dialog_get_image", libprag.}

proc getImage*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_image(cast[ptr MessageDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc image*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_image(cast[ptr MessageDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_message_dialog_get_message_area*(self: ptr MessageDialog00): ptr Widget00 {.
    importc: "gtk_message_dialog_get_message_area", libprag.}

proc getMessageArea*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_message_area(cast[ptr MessageDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc messageArea*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_message_area(cast[ptr MessageDialog00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_message_dialog_set_image*(self: ptr MessageDialog00; image: ptr Widget00) {.
    importc: "gtk_message_dialog_set_image", libprag.}

proc setImage*(self: MessageDialog; image: Widget) =
  gtk_message_dialog_set_image(cast[ptr MessageDialog00](self.impl), cast[ptr Widget00](image.impl))

proc `image=`*(self: MessageDialog; image: Widget) =
  gtk_message_dialog_set_image(cast[ptr MessageDialog00](self.impl), cast[ptr Widget00](image.impl))

proc gtk_message_dialog_set_markup*(self: ptr MessageDialog00; str: cstring) {.
    importc: "gtk_message_dialog_set_markup", libprag.}

proc setMarkup*(self: MessageDialog; str: string) =
  gtk_message_dialog_set_markup(cast[ptr MessageDialog00](self.impl), cstring(str))

proc `markup=`*(self: MessageDialog; str: string) =
  gtk_message_dialog_set_markup(cast[ptr MessageDialog00](self.impl), cstring(str))

type
  MessageDialogClass00* {.pure.} = object
    parentClass*: DialogClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  MessageDialogClass* = ref object
    impl*: ptr MessageDialogClass00

type
  ModelButton* = ref object of Button
  ModelButton00* = object of Button00

proc gtk_model_button_new*(): ptr ModelButton00 {.
    importc: "gtk_model_button_new", libprag.}

proc newModelButton*(): ModelButton =
  new(result, finalizeGObject)
  result.impl = gtk_model_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initModelButton*[T](result: var T) =
  assert(result is ModelButton)
  new(result, finalizeGObject)
  result.impl = gtk_model_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ModuleDisplayInitFunc* = proc (display: ptr gdk.Display00) {.cdecl.}

type
  ModuleInitFunc* = proc (argc: ptr int32; argv: cstringArray) {.cdecl.}

type
  MountOperationPrivate00* {.pure.} = object
  MountOperationPrivate* = ref object
    impl*: ptr MountOperationPrivate00

type
  MountOperation* = ref object of gio.MountOperation
  MountOperation00* = object of gio.MountOperation00
    priv9: ptr MountOperationPrivate00

proc gtk_mount_operation_new*(parent: ptr Window00): ptr MountOperation00 {.
    importc: "gtk_mount_operation_new", libprag.}

proc newMountOperation*(parent: Window): MountOperation =
  new(result, finalizeGObject)
  result.impl = gtk_mount_operation_new(cast[ptr Window00](parent.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMountOperation*[T](result: var T; parent: Window) =
  assert(result is MountOperation)
  new(result, finalizeGObject)
  result.impl = gtk_mount_operation_new(cast[ptr Window00](parent.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mount_operation_get_parent*(self: ptr MountOperation00): ptr Window00 {.
    importc: "gtk_mount_operation_get_parent", libprag.}

proc getParent*(self: MountOperation): Window =
  let gobj = gtk_mount_operation_get_parent(cast[ptr MountOperation00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parent*(self: MountOperation): Window =
  let gobj = gtk_mount_operation_get_parent(cast[ptr MountOperation00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mount_operation_get_screen*(self: ptr MountOperation00): ptr gdk.Screen00 {.
    importc: "gtk_mount_operation_get_screen", libprag.}

proc getScreen*(self: MountOperation): gdk.Screen =
  let gobj = gtk_mount_operation_get_screen(cast[ptr MountOperation00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: MountOperation): gdk.Screen =
  let gobj = gtk_mount_operation_get_screen(cast[ptr MountOperation00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mount_operation_is_showing*(self: ptr MountOperation00): gboolean {.
    importc: "gtk_mount_operation_is_showing", libprag.}

proc isShowing*(self: MountOperation): bool =
  toBool(gtk_mount_operation_is_showing(cast[ptr MountOperation00](self.impl)))

proc gtk_mount_operation_set_parent*(self: ptr MountOperation00; parent: ptr Window00) {.
    importc: "gtk_mount_operation_set_parent", libprag.}

proc setParent*(self: MountOperation; parent: Window) =
  gtk_mount_operation_set_parent(cast[ptr MountOperation00](self.impl), cast[ptr Window00](parent.impl))

proc `parent=`*(self: MountOperation; parent: Window) =
  gtk_mount_operation_set_parent(cast[ptr MountOperation00](self.impl), cast[ptr Window00](parent.impl))

proc gtk_mount_operation_set_screen*(self: ptr MountOperation00; screen: ptr gdk.Screen00) {.
    importc: "gtk_mount_operation_set_screen", libprag.}

proc setScreen*(self: MountOperation; screen: gdk.Screen) =
  gtk_mount_operation_set_screen(cast[ptr MountOperation00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: MountOperation; screen: gdk.Screen) =
  gtk_mount_operation_set_screen(cast[ptr MountOperation00](self.impl), cast[ptr gdk.Screen00](screen.impl))

type
  MountOperationClass00* {.pure.} = object
    parentClass*: gio.MountOperationClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  MountOperationClass* = ref object
    impl*: ptr MountOperationClass00

type
  NotebookPrivate00* {.pure.} = object
  NotebookPrivate* = ref object
    impl*: ptr NotebookPrivate00

type
  NotebookTab* {.size: sizeof(cint), pure.} = enum
    first = 0
    last = 1

type
  Notebook* = ref object of Container
  Notebook00* = object of Container00
    priv3: ptr NotebookPrivate00

proc scChangeCurrentPage*(self: Notebook;  p: proc (self: ptr gobject.Object00; `object`: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "change-current-page", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCreateWindow*(self: Notebook;  p: proc (self: ptr gobject.Object00; page: Widget00; x: int32; y: int32; xdata: pointer): Notebook00 {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "create-window", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scFocusTab*(self: Notebook;  p: proc (self: ptr gobject.Object00; `object`: NotebookTab; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "focus-tab", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveFocusOut*(self: Notebook;  p: proc (self: ptr gobject.Object00; `object`: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-focus-out", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPageAdded*(self: Notebook;  p: proc (self: ptr gobject.Object00; child: Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "page-added", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPageRemoved*(self: Notebook;  p: proc (self: ptr gobject.Object00; child: Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "page-removed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPageReordered*(self: Notebook;  p: proc (self: ptr gobject.Object00; child: Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "page-reordered", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scReorderTab*(self: Notebook;  p: proc (self: ptr gobject.Object00; `object`: DirectionType; p0: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "reorder-tab", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectPage*(self: Notebook;  p: proc (self: ptr gobject.Object00; `object`: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select-page", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSwitchPage*(self: Notebook;  p: proc (self: ptr gobject.Object00; page: Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "switch-page", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_notebook_new*(): ptr Notebook00 {.
    importc: "gtk_notebook_new", libprag.}

proc newNotebook*(): Notebook =
  new(result, finalizeGObject)
  result.impl = gtk_notebook_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initNotebook*[T](result: var T) =
  assert(result is Notebook)
  new(result, finalizeGObject)
  result.impl = gtk_notebook_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_append_page*(self: ptr Notebook00; child: ptr Widget00; tabLabel: ptr Widget00): int32 {.
    importc: "gtk_notebook_append_page", libprag.}

proc appendPage*(self: Notebook; child: Widget; tabLabel: Widget): int =
  int(gtk_notebook_append_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](tabLabel.impl)))

proc gtk_notebook_append_page_menu*(self: ptr Notebook00; child: ptr Widget00; tabLabel: ptr Widget00; 
    menuLabel: ptr Widget00): int32 {.
    importc: "gtk_notebook_append_page_menu", libprag.}

proc appendPageMenu*(self: Notebook; child: Widget; tabLabel: Widget; menuLabel: Widget): int =
  int(gtk_notebook_append_page_menu(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](tabLabel.impl), cast[ptr Widget00](menuLabel.impl)))

proc gtk_notebook_detach_tab*(self: ptr Notebook00; child: ptr Widget00) {.
    importc: "gtk_notebook_detach_tab", libprag.}

proc detachTab*(self: Notebook; child: Widget) =
  gtk_notebook_detach_tab(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_notebook_get_action_widget*(self: ptr Notebook00; packType: PackType): ptr Widget00 {.
    importc: "gtk_notebook_get_action_widget", libprag.}

proc getActionWidget*(self: Notebook; packType: PackType): Widget =
  let gobj = gtk_notebook_get_action_widget(cast[ptr Notebook00](self.impl), packType)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc actionWidget*(self: Notebook; packType: PackType): Widget =
  let gobj = gtk_notebook_get_action_widget(cast[ptr Notebook00](self.impl), packType)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_current_page*(self: ptr Notebook00): int32 {.
    importc: "gtk_notebook_get_current_page", libprag.}

proc getCurrentPage*(self: Notebook): int =
  int(gtk_notebook_get_current_page(cast[ptr Notebook00](self.impl)))

proc currentPage*(self: Notebook): int =
  int(gtk_notebook_get_current_page(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_group_name*(self: ptr Notebook00): cstring {.
    importc: "gtk_notebook_get_group_name", libprag.}

proc getGroupName*(self: Notebook): string =
  let resul0 = gtk_notebook_get_group_name(cast[ptr Notebook00](self.impl))
  result = $resul0

proc groupName*(self: Notebook): string =
  let resul0 = gtk_notebook_get_group_name(cast[ptr Notebook00](self.impl))
  result = $resul0

proc gtk_notebook_get_menu_label*(self: ptr Notebook00; child: ptr Widget00): ptr Widget00 {.
    importc: "gtk_notebook_get_menu_label", libprag.}

proc getMenuLabel*(self: Notebook; child: Widget): Widget =
  let gobj = gtk_notebook_get_menu_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menuLabel*(self: Notebook; child: Widget): Widget =
  let gobj = gtk_notebook_get_menu_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_menu_label_text*(self: ptr Notebook00; child: ptr Widget00): cstring {.
    importc: "gtk_notebook_get_menu_label_text", libprag.}

proc getMenuLabelText*(self: Notebook; child: Widget): string =
  let resul0 = gtk_notebook_get_menu_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  result = $resul0

proc menuLabelText*(self: Notebook; child: Widget): string =
  let resul0 = gtk_notebook_get_menu_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  result = $resul0

proc gtk_notebook_get_n_pages*(self: ptr Notebook00): int32 {.
    importc: "gtk_notebook_get_n_pages", libprag.}

proc getNPages*(self: Notebook): int =
  int(gtk_notebook_get_n_pages(cast[ptr Notebook00](self.impl)))

proc nPages*(self: Notebook): int =
  int(gtk_notebook_get_n_pages(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_nth_page*(self: ptr Notebook00; pageNum: int32): ptr Widget00 {.
    importc: "gtk_notebook_get_nth_page", libprag.}

proc getNthPage*(self: Notebook; pageNum: int): Widget =
  let gobj = gtk_notebook_get_nth_page(cast[ptr Notebook00](self.impl), int32(pageNum))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc nthPage*(self: Notebook; pageNum: int): Widget =
  let gobj = gtk_notebook_get_nth_page(cast[ptr Notebook00](self.impl), int32(pageNum))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_scrollable*(self: ptr Notebook00): gboolean {.
    importc: "gtk_notebook_get_scrollable", libprag.}

proc getScrollable*(self: Notebook): bool =
  toBool(gtk_notebook_get_scrollable(cast[ptr Notebook00](self.impl)))

proc scrollable*(self: Notebook): bool =
  toBool(gtk_notebook_get_scrollable(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_show_border*(self: ptr Notebook00): gboolean {.
    importc: "gtk_notebook_get_show_border", libprag.}

proc getShowBorder*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_border(cast[ptr Notebook00](self.impl)))

proc showBorder*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_border(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_show_tabs*(self: ptr Notebook00): gboolean {.
    importc: "gtk_notebook_get_show_tabs", libprag.}

proc getShowTabs*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_tabs(cast[ptr Notebook00](self.impl)))

proc showTabs*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_tabs(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_tab_detachable*(self: ptr Notebook00; child: ptr Widget00): gboolean {.
    importc: "gtk_notebook_get_tab_detachable", libprag.}

proc getTabDetachable*(self: Notebook; child: Widget): bool =
  toBool(gtk_notebook_get_tab_detachable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc tabDetachable*(self: Notebook; child: Widget): bool =
  toBool(gtk_notebook_get_tab_detachable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_notebook_get_tab_hborder*(self: ptr Notebook00): uint16 {.
    importc: "gtk_notebook_get_tab_hborder", libprag.}

proc getTabHborder*(self: Notebook): uint16 =
  gtk_notebook_get_tab_hborder(cast[ptr Notebook00](self.impl))

proc tabHborder*(self: Notebook): uint16 =
  gtk_notebook_get_tab_hborder(cast[ptr Notebook00](self.impl))

proc gtk_notebook_get_tab_label*(self: ptr Notebook00; child: ptr Widget00): ptr Widget00 {.
    importc: "gtk_notebook_get_tab_label", libprag.}

proc getTabLabel*(self: Notebook; child: Widget): Widget =
  let gobj = gtk_notebook_get_tab_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc tabLabel*(self: Notebook; child: Widget): Widget =
  let gobj = gtk_notebook_get_tab_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_tab_label_text*(self: ptr Notebook00; child: ptr Widget00): cstring {.
    importc: "gtk_notebook_get_tab_label_text", libprag.}

proc getTabLabelText*(self: Notebook; child: Widget): string =
  let resul0 = gtk_notebook_get_tab_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  result = $resul0

proc tabLabelText*(self: Notebook; child: Widget): string =
  let resul0 = gtk_notebook_get_tab_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  result = $resul0

proc gtk_notebook_get_tab_pos*(self: ptr Notebook00): PositionType {.
    importc: "gtk_notebook_get_tab_pos", libprag.}

proc getTabPos*(self: Notebook): PositionType =
  gtk_notebook_get_tab_pos(cast[ptr Notebook00](self.impl))

proc tabPos*(self: Notebook): PositionType =
  gtk_notebook_get_tab_pos(cast[ptr Notebook00](self.impl))

proc gtk_notebook_get_tab_reorderable*(self: ptr Notebook00; child: ptr Widget00): gboolean {.
    importc: "gtk_notebook_get_tab_reorderable", libprag.}

proc getTabReorderable*(self: Notebook; child: Widget): bool =
  toBool(gtk_notebook_get_tab_reorderable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc tabReorderable*(self: Notebook; child: Widget): bool =
  toBool(gtk_notebook_get_tab_reorderable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_notebook_get_tab_vborder*(self: ptr Notebook00): uint16 {.
    importc: "gtk_notebook_get_tab_vborder", libprag.}

proc getTabVborder*(self: Notebook): uint16 =
  gtk_notebook_get_tab_vborder(cast[ptr Notebook00](self.impl))

proc tabVborder*(self: Notebook): uint16 =
  gtk_notebook_get_tab_vborder(cast[ptr Notebook00](self.impl))

proc gtk_notebook_insert_page*(self: ptr Notebook00; child: ptr Widget00; tabLabel: ptr Widget00; 
    position: int32): int32 {.
    importc: "gtk_notebook_insert_page", libprag.}

proc insertPage*(self: Notebook; child: Widget; tabLabel: Widget; position: int): int =
  int(gtk_notebook_insert_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](tabLabel.impl), int32(position)))

proc gtk_notebook_insert_page_menu*(self: ptr Notebook00; child: ptr Widget00; tabLabel: ptr Widget00; 
    menuLabel: ptr Widget00; position: int32): int32 {.
    importc: "gtk_notebook_insert_page_menu", libprag.}

proc insertPageMenu*(self: Notebook; child: Widget; tabLabel: Widget; menuLabel: Widget; 
    position: int): int =
  int(gtk_notebook_insert_page_menu(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](tabLabel.impl), cast[ptr Widget00](menuLabel.impl), int32(position)))

proc gtk_notebook_next_page*(self: ptr Notebook00) {.
    importc: "gtk_notebook_next_page", libprag.}

proc nextPage*(self: Notebook) =
  gtk_notebook_next_page(cast[ptr Notebook00](self.impl))

proc gtk_notebook_page_num*(self: ptr Notebook00; child: ptr Widget00): int32 {.
    importc: "gtk_notebook_page_num", libprag.}

proc pageNum*(self: Notebook; child: Widget): int =
  int(gtk_notebook_page_num(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_notebook_popup_disable*(self: ptr Notebook00) {.
    importc: "gtk_notebook_popup_disable", libprag.}

proc popupDisable*(self: Notebook) =
  gtk_notebook_popup_disable(cast[ptr Notebook00](self.impl))

proc gtk_notebook_popup_enable*(self: ptr Notebook00) {.
    importc: "gtk_notebook_popup_enable", libprag.}

proc popupEnable*(self: Notebook) =
  gtk_notebook_popup_enable(cast[ptr Notebook00](self.impl))

proc gtk_notebook_prepend_page*(self: ptr Notebook00; child: ptr Widget00; tabLabel: ptr Widget00): int32 {.
    importc: "gtk_notebook_prepend_page", libprag.}

proc prependPage*(self: Notebook; child: Widget; tabLabel: Widget): int =
  int(gtk_notebook_prepend_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](tabLabel.impl)))

proc gtk_notebook_prepend_page_menu*(self: ptr Notebook00; child: ptr Widget00; tabLabel: ptr Widget00; 
    menuLabel: ptr Widget00): int32 {.
    importc: "gtk_notebook_prepend_page_menu", libprag.}

proc prependPageMenu*(self: Notebook; child: Widget; tabLabel: Widget; menuLabel: Widget): int =
  int(gtk_notebook_prepend_page_menu(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](tabLabel.impl), cast[ptr Widget00](menuLabel.impl)))

proc gtk_notebook_prev_page*(self: ptr Notebook00) {.
    importc: "gtk_notebook_prev_page", libprag.}

proc prevPage*(self: Notebook) =
  gtk_notebook_prev_page(cast[ptr Notebook00](self.impl))

proc gtk_notebook_remove_page*(self: ptr Notebook00; pageNum: int32) {.
    importc: "gtk_notebook_remove_page", libprag.}

proc removePage*(self: Notebook; pageNum: int) =
  gtk_notebook_remove_page(cast[ptr Notebook00](self.impl), int32(pageNum))

proc gtk_notebook_reorder_child*(self: ptr Notebook00; child: ptr Widget00; position: int32) {.
    importc: "gtk_notebook_reorder_child", libprag.}

proc reorderChild*(self: Notebook; child: Widget; position: int) =
  gtk_notebook_reorder_child(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_notebook_set_action_widget*(self: ptr Notebook00; widget: ptr Widget00; packType: PackType) {.
    importc: "gtk_notebook_set_action_widget", libprag.}

proc setActionWidget*(self: Notebook; widget: Widget; packType: PackType) =
  gtk_notebook_set_action_widget(cast[ptr Notebook00](self.impl), cast[ptr Widget00](widget.impl), packType)

proc gtk_notebook_set_current_page*(self: ptr Notebook00; pageNum: int32) {.
    importc: "gtk_notebook_set_current_page", libprag.}

proc setCurrentPage*(self: Notebook; pageNum: int) =
  gtk_notebook_set_current_page(cast[ptr Notebook00](self.impl), int32(pageNum))

proc `currentPage=`*(self: Notebook; pageNum: int) =
  gtk_notebook_set_current_page(cast[ptr Notebook00](self.impl), int32(pageNum))

proc gtk_notebook_set_group_name*(self: ptr Notebook00; groupName: cstring) {.
    importc: "gtk_notebook_set_group_name", libprag.}

proc setGroupName*(self: Notebook; groupName: string) =
  gtk_notebook_set_group_name(cast[ptr Notebook00](self.impl), cstring(groupName))

proc `groupName=`*(self: Notebook; groupName: string) =
  gtk_notebook_set_group_name(cast[ptr Notebook00](self.impl), cstring(groupName))

proc gtk_notebook_set_menu_label*(self: ptr Notebook00; child: ptr Widget00; menuLabel: ptr Widget00) {.
    importc: "gtk_notebook_set_menu_label", libprag.}

proc setMenuLabel*(self: Notebook; child: Widget; menuLabel: Widget) =
  gtk_notebook_set_menu_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](menuLabel.impl))

proc gtk_notebook_set_menu_label_text*(self: ptr Notebook00; child: ptr Widget00; menuText: cstring) {.
    importc: "gtk_notebook_set_menu_label_text", libprag.}

proc setMenuLabelText*(self: Notebook; child: Widget; menuText: string) =
  gtk_notebook_set_menu_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cstring(menuText))

proc gtk_notebook_set_scrollable*(self: ptr Notebook00; scrollable: gboolean) {.
    importc: "gtk_notebook_set_scrollable", libprag.}

proc setScrollable*(self: Notebook; scrollable: bool) =
  gtk_notebook_set_scrollable(cast[ptr Notebook00](self.impl), gboolean(scrollable))

proc `scrollable=`*(self: Notebook; scrollable: bool) =
  gtk_notebook_set_scrollable(cast[ptr Notebook00](self.impl), gboolean(scrollable))

proc gtk_notebook_set_show_border*(self: ptr Notebook00; showBorder: gboolean) {.
    importc: "gtk_notebook_set_show_border", libprag.}

proc setShowBorder*(self: Notebook; showBorder: bool) =
  gtk_notebook_set_show_border(cast[ptr Notebook00](self.impl), gboolean(showBorder))

proc `showBorder=`*(self: Notebook; showBorder: bool) =
  gtk_notebook_set_show_border(cast[ptr Notebook00](self.impl), gboolean(showBorder))

proc gtk_notebook_set_show_tabs*(self: ptr Notebook00; showTabs: gboolean) {.
    importc: "gtk_notebook_set_show_tabs", libprag.}

proc setShowTabs*(self: Notebook; showTabs: bool) =
  gtk_notebook_set_show_tabs(cast[ptr Notebook00](self.impl), gboolean(showTabs))

proc `showTabs=`*(self: Notebook; showTabs: bool) =
  gtk_notebook_set_show_tabs(cast[ptr Notebook00](self.impl), gboolean(showTabs))

proc gtk_notebook_set_tab_detachable*(self: ptr Notebook00; child: ptr Widget00; detachable: gboolean) {.
    importc: "gtk_notebook_set_tab_detachable", libprag.}

proc setTabDetachable*(self: Notebook; child: Widget; detachable: bool) =
  gtk_notebook_set_tab_detachable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), gboolean(detachable))

proc gtk_notebook_set_tab_label*(self: ptr Notebook00; child: ptr Widget00; tabLabel: ptr Widget00) {.
    importc: "gtk_notebook_set_tab_label", libprag.}

proc setTabLabel*(self: Notebook; child: Widget; tabLabel: Widget) =
  gtk_notebook_set_tab_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cast[ptr Widget00](tabLabel.impl))

proc gtk_notebook_set_tab_label_text*(self: ptr Notebook00; child: ptr Widget00; tabText: cstring) {.
    importc: "gtk_notebook_set_tab_label_text", libprag.}

proc setTabLabelText*(self: Notebook; child: Widget; tabText: string) =
  gtk_notebook_set_tab_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), cstring(tabText))

proc gtk_notebook_set_tab_pos*(self: ptr Notebook00; pos: PositionType) {.
    importc: "gtk_notebook_set_tab_pos", libprag.}

proc setTabPos*(self: Notebook; pos: PositionType) =
  gtk_notebook_set_tab_pos(cast[ptr Notebook00](self.impl), pos)

proc `tabPos=`*(self: Notebook; pos: PositionType) =
  gtk_notebook_set_tab_pos(cast[ptr Notebook00](self.impl), pos)

proc gtk_notebook_set_tab_reorderable*(self: ptr Notebook00; child: ptr Widget00; reorderable: gboolean) {.
    importc: "gtk_notebook_set_tab_reorderable", libprag.}

proc setTabReorderable*(self: Notebook; child: Widget; reorderable: bool) =
  gtk_notebook_set_tab_reorderable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), gboolean(reorderable))

type
  NotebookAccessiblePrivate00* {.pure.} = object
  NotebookAccessiblePrivate* = ref object
    impl*: ptr NotebookAccessiblePrivate00

type
  NotebookAccessible* = ref object of ContainerAccessible
  NotebookAccessible00* = object of ContainerAccessible00
    priv4: ptr NotebookAccessiblePrivate00

type
  NotebookAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  NotebookAccessibleClass* = ref object
    impl*: ptr NotebookAccessibleClass00

type
  NotebookClass00* {.pure.} = object
    parentClass*: ContainerClass00
    switchPage*: proc(notebook: ptr Notebook00; page: ptr Widget00; pageNum: uint32) {.cdecl.}
    selectPage*: proc(notebook: ptr Notebook00; moveFocus: gboolean): gboolean {.cdecl.}
    focusTab*: proc(notebook: ptr Notebook00; `type`: NotebookTab): gboolean {.cdecl.}
    changeCurrentPage*: proc(notebook: ptr Notebook00; offset: int32): gboolean {.cdecl.}
    moveFocusOut*: proc(notebook: ptr Notebook00; direction: DirectionType) {.cdecl.}
    reorderTab*: proc(notebook: ptr Notebook00; direction: DirectionType; 
    moveToLast: gboolean): gboolean {.cdecl.}
    insertPage*: proc(notebook: ptr Notebook00; child: ptr Widget00; tabLabel: ptr Widget00; 
    menuLabel: ptr Widget00; position: int32): int32 {.cdecl.}
    createWindow*: pointer
    pageReordered*: proc(notebook: ptr Notebook00; child: ptr Widget00; pageNum: uint32) {.cdecl.}
    pageRemoved*: proc(notebook: ptr Notebook00; child: ptr Widget00; pageNum: uint32) {.cdecl.}
    pageAdded*: proc(notebook: ptr Notebook00; child: ptr Widget00; pageNum: uint32) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  NotebookClass* = ref object
    impl*: ptr NotebookClass00

type
  NotebookPageAccessiblePrivate00* {.pure.} = object
  NotebookPageAccessiblePrivate* = ref object
    impl*: ptr NotebookPageAccessiblePrivate00

type
  NotebookPageAccessible* = ref object of atk.Object
  NotebookPageAccessible00* = object of atk.Object00
    priv1: ptr NotebookPageAccessiblePrivate00

proc gtk_notebook_page_accessible_new*(notebook: ptr NotebookAccessible00; child: ptr Widget00): ptr NotebookPageAccessible00 {.
    importc: "gtk_notebook_page_accessible_new", libprag.}

proc newNotebookPageAccessible*(notebook: NotebookAccessible; child: Widget): NotebookPageAccessible =
  new(result, finalizeGObject)
  result.impl = gtk_notebook_page_accessible_new(cast[ptr NotebookAccessible00](notebook.impl), cast[ptr Widget00](child.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initNotebookPageAccessible*[T](result: var T; notebook: NotebookAccessible; child: Widget) =
  assert(result is NotebookPageAccessible)
  new(result, finalizeGObject)
  result.impl = gtk_notebook_page_accessible_new(cast[ptr NotebookAccessible00](notebook.impl), cast[ptr Widget00](child.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_page_accessible_invalidate*(self: ptr NotebookPageAccessible00) {.
    importc: "gtk_notebook_page_accessible_invalidate", libprag.}

proc invalidate*(self: NotebookPageAccessible) =
  gtk_notebook_page_accessible_invalidate(cast[ptr NotebookPageAccessible00](self.impl))

type
  NotebookPageAccessibleClass00* {.pure.} = object
    parentClass*: atk.ObjectClass00
  NotebookPageAccessibleClass* = ref object
    impl*: ptr NotebookPageAccessibleClass00

type
  NumberUpLayout* {.size: sizeof(cint), pure.} = enum
    lrtb = 0
    lrbt = 1
    rltb = 2
    rlbt = 3
    tblr = 4
    tbrl = 5
    btlr = 6
    btrl = 7

type
  NumerableIconPrivate00* {.pure.} = object
  NumerableIconPrivate* = ref object
    impl*: ptr NumerableIconPrivate00

type
  NumerableIcon* = ref object of gio.EmblemedIcon
  NumerableIcon00* = object of gio.EmblemedIcon00
    priv9: ptr NumerableIconPrivate00

proc gtk_numerable_icon_new*(baseIcon: ptr gio.Icon00): ptr gio.Icon00 {.
    importc: "gtk_numerable_icon_new", libprag.}

proc newNumerableIcon*(baseIcon: gio.Icon): gio.Icon =
  new(result)
  result.impl = gtk_numerable_icon_new(cast[ptr gio.Icon00](baseIcon.impl))

proc gtk_numerable_icon_new_with_style_context*(baseIcon: ptr gio.Icon00; context: ptr StyleContext00): ptr gio.Icon00 {.
    importc: "gtk_numerable_icon_new_with_style_context", libprag.}

proc newNumerableIconWithStyleContext*(baseIcon: gio.Icon; context: StyleContext): gio.Icon =
  new(result)
  result.impl = gtk_numerable_icon_new_with_style_context(cast[ptr gio.Icon00](baseIcon.impl), cast[ptr StyleContext00](context.impl))

proc gtk_numerable_icon_get_background_gicon*(self: ptr NumerableIcon00): ptr gio.Icon00 {.
    importc: "gtk_numerable_icon_get_background_gicon", libprag.}

proc getBackgroundGicon*(self: NumerableIcon): gio.Icon =
  new(result)
  result.impl = gtk_numerable_icon_get_background_gicon(cast[ptr NumerableIcon00](self.impl))

proc backgroundGicon*(self: NumerableIcon): gio.Icon =
  new(result)
  result.impl = gtk_numerable_icon_get_background_gicon(cast[ptr NumerableIcon00](self.impl))

proc gtk_numerable_icon_get_background_icon_name*(self: ptr NumerableIcon00): cstring {.
    importc: "gtk_numerable_icon_get_background_icon_name", libprag.}

proc getBackgroundIconName*(self: NumerableIcon): string =
  let resul0 = gtk_numerable_icon_get_background_icon_name(cast[ptr NumerableIcon00](self.impl))
  result = $resul0

proc backgroundIconName*(self: NumerableIcon): string =
  let resul0 = gtk_numerable_icon_get_background_icon_name(cast[ptr NumerableIcon00](self.impl))
  result = $resul0

proc gtk_numerable_icon_get_count*(self: ptr NumerableIcon00): int32 {.
    importc: "gtk_numerable_icon_get_count", libprag.}

proc getCount*(self: NumerableIcon): int =
  int(gtk_numerable_icon_get_count(cast[ptr NumerableIcon00](self.impl)))

proc count*(self: NumerableIcon): int =
  int(gtk_numerable_icon_get_count(cast[ptr NumerableIcon00](self.impl)))

proc gtk_numerable_icon_get_label*(self: ptr NumerableIcon00): cstring {.
    importc: "gtk_numerable_icon_get_label", libprag.}

proc getLabel*(self: NumerableIcon): string =
  let resul0 = gtk_numerable_icon_get_label(cast[ptr NumerableIcon00](self.impl))
  result = $resul0

proc label*(self: NumerableIcon): string =
  let resul0 = gtk_numerable_icon_get_label(cast[ptr NumerableIcon00](self.impl))
  result = $resul0

proc gtk_numerable_icon_get_style_context*(self: ptr NumerableIcon00): ptr StyleContext00 {.
    importc: "gtk_numerable_icon_get_style_context", libprag.}

proc getStyleContext*(self: NumerableIcon): StyleContext =
  let gobj = gtk_numerable_icon_get_style_context(cast[ptr NumerableIcon00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[StyleContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc styleContext*(self: NumerableIcon): StyleContext =
  let gobj = gtk_numerable_icon_get_style_context(cast[ptr NumerableIcon00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[StyleContext](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_numerable_icon_set_background_gicon*(self: ptr NumerableIcon00; icon: ptr gio.Icon00) {.
    importc: "gtk_numerable_icon_set_background_gicon", libprag.}

proc setBackgroundGicon*(self: NumerableIcon; icon: gio.Icon) =
  gtk_numerable_icon_set_background_gicon(cast[ptr NumerableIcon00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc `backgroundGicon=`*(self: NumerableIcon; icon: gio.Icon) =
  gtk_numerable_icon_set_background_gicon(cast[ptr NumerableIcon00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc gtk_numerable_icon_set_background_icon_name*(self: ptr NumerableIcon00; iconName: cstring) {.
    importc: "gtk_numerable_icon_set_background_icon_name", libprag.}

proc setBackgroundIconName*(self: NumerableIcon; iconName: string) =
  gtk_numerable_icon_set_background_icon_name(cast[ptr NumerableIcon00](self.impl), cstring(iconName))

proc `backgroundIconName=`*(self: NumerableIcon; iconName: string) =
  gtk_numerable_icon_set_background_icon_name(cast[ptr NumerableIcon00](self.impl), cstring(iconName))

proc gtk_numerable_icon_set_count*(self: ptr NumerableIcon00; count: int32) {.
    importc: "gtk_numerable_icon_set_count", libprag.}

proc setCount*(self: NumerableIcon; count: int) =
  gtk_numerable_icon_set_count(cast[ptr NumerableIcon00](self.impl), int32(count))

proc `count=`*(self: NumerableIcon; count: int) =
  gtk_numerable_icon_set_count(cast[ptr NumerableIcon00](self.impl), int32(count))

proc gtk_numerable_icon_set_label*(self: ptr NumerableIcon00; label: cstring) {.
    importc: "gtk_numerable_icon_set_label", libprag.}

proc setLabel*(self: NumerableIcon; label: string) =
  gtk_numerable_icon_set_label(cast[ptr NumerableIcon00](self.impl), cstring(label))

proc `label=`*(self: NumerableIcon; label: string) =
  gtk_numerable_icon_set_label(cast[ptr NumerableIcon00](self.impl), cstring(label))

proc gtk_numerable_icon_set_style_context*(self: ptr NumerableIcon00; style: ptr StyleContext00) {.
    importc: "gtk_numerable_icon_set_style_context", libprag.}

proc setStyleContext*(self: NumerableIcon; style: StyleContext) =
  gtk_numerable_icon_set_style_context(cast[ptr NumerableIcon00](self.impl), cast[ptr StyleContext00](style.impl))

proc `styleContext=`*(self: NumerableIcon; style: StyleContext) =
  gtk_numerable_icon_set_style_context(cast[ptr NumerableIcon00](self.impl), cast[ptr StyleContext00](style.impl))

type
  NumerableIconClass00* {.pure.} = object
    parentClass*: gio.EmblemedIconClass00
    padding*: array[16, pointer]
  NumerableIconClass* = ref object
    impl*: ptr NumerableIconClass00

type
  OffscreenWindow* = ref object of Window
  OffscreenWindow00* = object of Window00

proc gtk_offscreen_window_new*(): ptr OffscreenWindow00 {.
    importc: "gtk_offscreen_window_new", libprag.}

proc newOffscreenWindow*(): OffscreenWindow =
  new(result, finalizeGObject)
  result.impl = gtk_offscreen_window_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initOffscreenWindow*[T](result: var T) =
  assert(result is OffscreenWindow)
  new(result, finalizeGObject)
  result.impl = gtk_offscreen_window_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_offscreen_window_get_pixbuf*(self: ptr OffscreenWindow00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_offscreen_window_get_pixbuf", libprag.}

proc getPixbuf*(self: OffscreenWindow): gdkpixbuf.Pixbuf =
  let gobj = gtk_offscreen_window_get_pixbuf(cast[ptr OffscreenWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: OffscreenWindow): gdkpixbuf.Pixbuf =
  let gobj = gtk_offscreen_window_get_pixbuf(cast[ptr OffscreenWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_offscreen_window_get_surface*(self: ptr OffscreenWindow00): ptr cairo.Surface00 {.
    importc: "gtk_offscreen_window_get_surface", libprag.}

proc getSurface*(self: OffscreenWindow): cairo.Surface =
  new(result)
  result.impl = gtk_offscreen_window_get_surface(cast[ptr OffscreenWindow00](self.impl))

proc surface*(self: OffscreenWindow): cairo.Surface =
  new(result)
  result.impl = gtk_offscreen_window_get_surface(cast[ptr OffscreenWindow00](self.impl))

type
  OffscreenWindowClass00* {.pure.} = object
    parentClass*: WindowClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  OffscreenWindowClass* = ref object
    impl*: ptr OffscreenWindowClass00

type
  Orientable00* {.pure.} = object
  Orientable* = ref object
    impl*: ptr Orientable00

proc gtk_orientable_get_orientation*(self: ptr Orientable00): Orientation {.
    importc: "gtk_orientable_get_orientation", libprag.}

proc getOrientation*(self: Orientable): Orientation =
  gtk_orientable_get_orientation(cast[ptr Orientable00](self.impl))

proc orientation*(self: Orientable): Orientation =
  gtk_orientable_get_orientation(cast[ptr Orientable00](self.impl))

proc gtk_orientable_set_orientation*(self: ptr Orientable00; orientation: Orientation) {.
    importc: "gtk_orientable_set_orientation", libprag.}

proc setOrientation*(self: Orientable; orientation: Orientation) =
  gtk_orientable_set_orientation(cast[ptr Orientable00](self.impl), orientation)

proc `orientation=`*(self: Orientable; orientation: Orientation) =
  gtk_orientable_set_orientation(cast[ptr Orientable00](self.impl), orientation)

type
  OrientableIface00* {.pure.} = object
    baseIface*: gobject.TypeInterface00
  OrientableIface* = ref object
    impl*: ptr OrientableIface00

type
  OverlayPrivate00* {.pure.} = object
  OverlayPrivate* = ref object
    impl*: ptr OverlayPrivate00

type
  Overlay* = ref object of Bin
  Overlay00* = object of Bin00
    priv4: ptr OverlayPrivate00

proc scGetChildPosition*(self: Overlay;  p: proc (self: ptr gobject.Object00; widget: Widget00; allocation: var gdk.Rectangle00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "get-child-position", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_overlay_new*(): ptr Overlay00 {.
    importc: "gtk_overlay_new", libprag.}

proc newOverlay*(): Overlay =
  new(result, finalizeGObject)
  result.impl = gtk_overlay_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initOverlay*[T](result: var T) =
  assert(result is Overlay)
  new(result, finalizeGObject)
  result.impl = gtk_overlay_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_overlay_add_overlay*(self: ptr Overlay00; widget: ptr Widget00) {.
    importc: "gtk_overlay_add_overlay", libprag.}

proc addOverlay*(self: Overlay; widget: Widget) =
  gtk_overlay_add_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_overlay_get_overlay_pass_through*(self: ptr Overlay00; widget: ptr Widget00): gboolean {.
    importc: "gtk_overlay_get_overlay_pass_through", libprag.}

proc getOverlayPassThrough*(self: Overlay; widget: Widget): bool =
  toBool(gtk_overlay_get_overlay_pass_through(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl)))

proc overlayPassThrough*(self: Overlay; widget: Widget): bool =
  toBool(gtk_overlay_get_overlay_pass_through(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_overlay_reorder_overlay*(self: ptr Overlay00; child: ptr Widget00; position: int32) {.
    importc: "gtk_overlay_reorder_overlay", libprag.}

proc reorderOverlay*(self: Overlay; child: Widget; position: int) =
  gtk_overlay_reorder_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_overlay_set_overlay_pass_through*(self: ptr Overlay00; widget: ptr Widget00; passThrough: gboolean) {.
    importc: "gtk_overlay_set_overlay_pass_through", libprag.}

proc setOverlayPassThrough*(self: Overlay; widget: Widget; passThrough: bool) =
  gtk_overlay_set_overlay_pass_through(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl), gboolean(passThrough))

type
  OverlayClass00* {.pure.} = object
    parentClass*: BinClass00
    getChildPosition*: proc(overlay: ptr Overlay00; widget: ptr Widget00; allocation: ptr gdk.Rectangle00): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  OverlayClass* = ref object
    impl*: ptr OverlayClass00

const PAPER_NAME_A3* = "iso_a3"

const PAPER_NAME_A4* = "iso_a4"

const PAPER_NAME_A5* = "iso_a5"

const PAPER_NAME_B5* = "iso_b5"

const PAPER_NAME_EXECUTIVE* = "na_executive"

const PAPER_NAME_LEGAL* = "na_legal"

const PAPER_NAME_LETTER* = "na_letter"

const PATH_PRIO_MASK* = 15'i32

const PRINT_SETTINGS_COLLATE* = "collate"

const PRINT_SETTINGS_DEFAULT_SOURCE* = "default-source"

const PRINT_SETTINGS_DITHER* = "dither"

const PRINT_SETTINGS_DUPLEX* = "duplex"

const PRINT_SETTINGS_FINISHINGS* = "finishings"

const PRINT_SETTINGS_MEDIA_TYPE* = "media-type"

const PRINT_SETTINGS_NUMBER_UP* = "number-up"

const PRINT_SETTINGS_NUMBER_UP_LAYOUT* = "number-up-layout"

const PRINT_SETTINGS_N_COPIES* = "n-copies"

const PRINT_SETTINGS_ORIENTATION* = "orientation"

const PRINT_SETTINGS_OUTPUT_BASENAME* = "output-basename"

const PRINT_SETTINGS_OUTPUT_BIN* = "output-bin"

const PRINT_SETTINGS_OUTPUT_DIR* = "output-dir"

const PRINT_SETTINGS_OUTPUT_FILE_FORMAT* = "output-file-format"

const PRINT_SETTINGS_OUTPUT_URI* = "output-uri"

const PRINT_SETTINGS_PAGE_RANGES* = "page-ranges"

const PRINT_SETTINGS_PAGE_SET* = "page-set"

const PRINT_SETTINGS_PAPER_FORMAT* = "paper-format"

const PRINT_SETTINGS_PAPER_HEIGHT* = "paper-height"

const PRINT_SETTINGS_PAPER_WIDTH* = "paper-width"

const PRINT_SETTINGS_PRINTER* = "printer"

const PRINT_SETTINGS_PRINTER_LPI* = "printer-lpi"

const PRINT_SETTINGS_PRINT_PAGES* = "print-pages"

const PRINT_SETTINGS_QUALITY* = "quality"

const PRINT_SETTINGS_RESOLUTION* = "resolution"

const PRINT_SETTINGS_RESOLUTION_X* = "resolution-x"

const PRINT_SETTINGS_RESOLUTION_Y* = "resolution-y"

const PRINT_SETTINGS_REVERSE* = "reverse"

const PRINT_SETTINGS_SCALE* = "scale"

const PRINT_SETTINGS_USE_COLOR* = "use-color"

const PRINT_SETTINGS_WIN32_DRIVER_EXTRA* = "win32-driver-extra"

const PRINT_SETTINGS_WIN32_DRIVER_VERSION* = "win32-driver-version"

const PRIORITY_RESIZE* = 10'i32

type
  PadActionType* {.size: sizeof(cint), pure.} = enum
    button = 0
    ring = 1
    strip = 2

type
  PadActionEntry00* {.pure.} = object
    `type`*: PadActionType
    index*: int32
    mode*: int32
    label*: cstring
    actionName*: cstring
  PadActionEntry* = ref object
    impl*: ptr PadActionEntry00

type
  PadController* = ref object of EventController
  PadController00* = object of EventController00

proc gtk_pad_controller_new*(window: ptr Window00; group: ptr gio.ActionGroup00; 
    pad: ptr gdk.Device00): ptr PadController00 {.
    importc: "gtk_pad_controller_new", libprag.}

proc newPadController*(window: Window; group: gio.ActionGroup; pad: gdk.Device): PadController =
  new(result, finalizeGObject)
  result.impl = gtk_pad_controller_new(cast[ptr Window00](window.impl), cast[ptr gio.ActionGroup00](group.impl), cast[ptr gdk.Device00](pad.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPadController*[T](result: var T; window: Window; group: gio.ActionGroup; pad: gdk.Device) =
  assert(result is PadController)
  new(result, finalizeGObject)
  result.impl = gtk_pad_controller_new(cast[ptr Window00](window.impl), cast[ptr gio.ActionGroup00](group.impl), cast[ptr gdk.Device00](pad.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_pad_controller_set_action*(self: ptr PadController00; `type`: PadActionType; 
    index: int32; mode: int32; label: cstring; actionName: cstring) {.
    importc: "gtk_pad_controller_set_action", libprag.}

proc setAction*(self: PadController; `type`: PadActionType; index: int; 
    mode: int; label: string; actionName: string) =
  gtk_pad_controller_set_action(cast[ptr PadController00](self.impl), `type`, int32(index), int32(mode), cstring(label), cstring(actionName))

proc gtk_pad_controller_set_action_entries*(self: ptr PadController00; entries: PadActionEntry00Array; 
    nEntries: int32) {.
    importc: "gtk_pad_controller_set_action_entries", libprag.}

proc setActionEntries*(self: PadController; entries: PadActionEntry00Array; 
    nEntries: int) =
  gtk_pad_controller_set_action_entries(cast[ptr PadController00](self.impl), entries, int32(nEntries))

type
  PadControllerClass00* {.pure.} = object
  PadControllerClass* = ref object
    impl*: ptr PadControllerClass00

type
  PageOrientation* {.size: sizeof(cint), pure.} = enum
    portrait = 0
    landscape = 1
    reversePortrait = 2
    reverseLandscape = 3

type
  PageRange00* {.pure.} = object
    start*: int32
    `end`*: int32
  PageRange* = ref object
    impl*: ptr PageRange00

type
  PageSet* {.size: sizeof(cint), pure.} = enum
    all = 0
    even = 1
    odd = 2

type
  PageSetup* = ref object of gobject.Object
  PageSetup00* = object of gobject.Object00

proc gtk_page_setup_new*(): ptr PageSetup00 {.
    importc: "gtk_page_setup_new", libprag.}

proc newPageSetup*(): PageSetup =
  new(result, finalizeGObject)
  result.impl = gtk_page_setup_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetup*[T](result: var T) =
  assert(result is PageSetup)
  new(result, finalizeGObject)
  result.impl = gtk_page_setup_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_new_from_file*(fileName: ucstring): ptr PageSetup00 {.
    importc: "gtk_page_setup_new_from_file", libprag.}

proc newPageSetupFromFile*(fileName: ucstring): PageSetup =
  new(result, finalizeGObject)
  result.impl = gtk_page_setup_new_from_file(fileName)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupFromFile*[T](result: var T; fileName: ucstring) =
  assert(result is PageSetup)
  new(result, finalizeGObject)
  result.impl = gtk_page_setup_new_from_file(fileName)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_new_from_gvariant*(variant: ptr glib.Variant00): ptr PageSetup00 {.
    importc: "gtk_page_setup_new_from_gvariant", libprag.}

proc newPageSetupFromGvariant*(variant: glib.Variant): PageSetup =
  new(result, finalizeGObject)
  result.impl = gtk_page_setup_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupFromGvariant*[T](result: var T; variant: glib.Variant) =
  assert(result is PageSetup)
  new(result, finalizeGObject)
  result.impl = gtk_page_setup_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_new_from_key_file*(keyFile: ptr glib.KeyFile00; groupName: cstring): ptr PageSetup00 {.
    importc: "gtk_page_setup_new_from_key_file", libprag.}

proc newPageSetupFromKeyFile*(keyFile: glib.KeyFile; groupName: string): PageSetup =
  new(result, finalizeGObject)
  result.impl = gtk_page_setup_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupFromKeyFile*[T](result: var T; keyFile: glib.KeyFile; groupName: string) =
  assert(result is PageSetup)
  new(result, finalizeGObject)
  result.impl = gtk_page_setup_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_copy*(self: ptr PageSetup00): ptr PageSetup00 {.
    importc: "gtk_page_setup_copy", libprag.}

proc copy*(self: PageSetup): PageSetup =
  let gobj = gtk_page_setup_copy(cast[ptr PageSetup00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[PageSetup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_get_orientation*(self: ptr PageSetup00): PageOrientation {.
    importc: "gtk_page_setup_get_orientation", libprag.}

proc getOrientation*(self: PageSetup): PageOrientation =
  gtk_page_setup_get_orientation(cast[ptr PageSetup00](self.impl))

proc orientation*(self: PageSetup): PageOrientation =
  gtk_page_setup_get_orientation(cast[ptr PageSetup00](self.impl))

proc gtk_page_setup_load_file*(self: ptr PageSetup00; fileName: ucstring): gboolean {.
    importc: "gtk_page_setup_load_file", libprag.}

proc loadFile*(self: PageSetup; fileName: ucstring): bool =
  toBool(gtk_page_setup_load_file(cast[ptr PageSetup00](self.impl), fileName))

proc gtk_page_setup_load_key_file*(self: ptr PageSetup00; keyFile: ptr glib.KeyFile00; 
    groupName: cstring): gboolean {.
    importc: "gtk_page_setup_load_key_file", libprag.}

proc loadKeyFile*(self: PageSetup; keyFile: glib.KeyFile; groupName: string): bool =
  toBool(gtk_page_setup_load_key_file(cast[ptr PageSetup00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName)))

proc gtk_page_setup_set_orientation*(self: ptr PageSetup00; orientation: PageOrientation) {.
    importc: "gtk_page_setup_set_orientation", libprag.}

proc setOrientation*(self: PageSetup; orientation: PageOrientation) =
  gtk_page_setup_set_orientation(cast[ptr PageSetup00](self.impl), orientation)

proc `orientation=`*(self: PageSetup; orientation: PageOrientation) =
  gtk_page_setup_set_orientation(cast[ptr PageSetup00](self.impl), orientation)

proc gtk_page_setup_to_file*(self: ptr PageSetup00; fileName: ucstring): gboolean {.
    importc: "gtk_page_setup_to_file", libprag.}

proc toFile*(self: PageSetup; fileName: ucstring): bool =
  toBool(gtk_page_setup_to_file(cast[ptr PageSetup00](self.impl), fileName))

proc gtk_page_setup_to_gvariant*(self: ptr PageSetup00): ptr glib.Variant00 {.
    importc: "gtk_page_setup_to_gvariant", libprag.}

proc toGvariant*(self: PageSetup): glib.Variant =
  new(result)
  result.impl = gtk_page_setup_to_gvariant(cast[ptr PageSetup00](self.impl))

proc gtk_page_setup_to_key_file*(self: ptr PageSetup00; keyFile: ptr glib.KeyFile00; 
    groupName: cstring) {.
    importc: "gtk_page_setup_to_key_file", libprag.}

proc toKeyFile*(self: PageSetup; keyFile: glib.KeyFile; groupName: string) =
  gtk_page_setup_to_key_file(cast[ptr PageSetup00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName))

type
  PaperSize00* {.pure.} = object
  PaperSize* = ref object
    impl*: ptr PaperSize00

proc gtk_paper_size_new*(name: cstring): ptr PaperSize00 {.
    importc: "gtk_paper_size_new", libprag.}

proc newPaperSize*(name: string): PaperSize =
  new(result)
  result.impl = gtk_paper_size_new(cstring(name))

proc initPaperSize*[T](result: var T; name: string) =
  assert(result is PaperSize)
  new(result)
  result.impl = gtk_paper_size_new(cstring(name))

proc gtk_paper_size_new_from_gvariant*(variant: ptr glib.Variant00): ptr PaperSize00 {.
    importc: "gtk_paper_size_new_from_gvariant", libprag.}

proc newPaperSizeFromGvariant*(variant: glib.Variant): PaperSize =
  new(result)
  result.impl = gtk_paper_size_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))

proc initPaperSizeFromGvariant*[T](result: var T; variant: glib.Variant) =
  assert(result is PaperSize)
  new(result)
  result.impl = gtk_paper_size_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))

proc gtk_paper_size_new_from_ipp*(ippName: cstring; width: cdouble; height: cdouble): ptr PaperSize00 {.
    importc: "gtk_paper_size_new_from_ipp", libprag.}

proc newPaperSizeFromIpp*(ippName: string; width: cdouble; height: cdouble): PaperSize =
  new(result)
  result.impl = gtk_paper_size_new_from_ipp(cstring(ippName), width, height)

proc initPaperSizeFromIpp*[T](result: var T; ippName: string; width: cdouble; height: cdouble) =
  assert(result is PaperSize)
  new(result)
  result.impl = gtk_paper_size_new_from_ipp(cstring(ippName), width, height)

proc gtk_paper_size_new_from_key_file*(keyFile: ptr glib.KeyFile00; groupName: cstring): ptr PaperSize00 {.
    importc: "gtk_paper_size_new_from_key_file", libprag.}

proc newPaperSizeFromKeyFile*(keyFile: glib.KeyFile; groupName: string): PaperSize =
  new(result)
  result.impl = gtk_paper_size_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName))

proc initPaperSizeFromKeyFile*[T](result: var T; keyFile: glib.KeyFile; groupName: string) =
  assert(result is PaperSize)
  new(result)
  result.impl = gtk_paper_size_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName))

proc gtk_paper_size_new_from_ppd*(ppdName: cstring; ppdDisplayName: cstring; width: cdouble; 
    height: cdouble): ptr PaperSize00 {.
    importc: "gtk_paper_size_new_from_ppd", libprag.}

proc newPaperSizeFromPpd*(ppdName: string; ppdDisplayName: string; width: cdouble; 
    height: cdouble): PaperSize =
  new(result)
  result.impl = gtk_paper_size_new_from_ppd(cstring(ppdName), cstring(ppdDisplayName), width, height)

proc initPaperSizeFromPpd*[T](result: var T; ppdName: string; ppdDisplayName: string; width: cdouble; 
    height: cdouble) =
  assert(result is PaperSize)
  new(result)
  result.impl = gtk_paper_size_new_from_ppd(cstring(ppdName), cstring(ppdDisplayName), width, height)

proc gtk_paper_size_copy*(self: ptr PaperSize00): ptr PaperSize00 {.
    importc: "gtk_paper_size_copy", libprag.}

proc copy*(self: PaperSize): PaperSize =
  new(result)
  result.impl = gtk_paper_size_copy(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_free*(self: ptr PaperSize00) {.
    importc: "gtk_paper_size_free", libprag.}

proc free*(self: PaperSize) =
  gtk_paper_size_free(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_get_display_name*(self: ptr PaperSize00): cstring {.
    importc: "gtk_paper_size_get_display_name", libprag.}

proc getDisplayName*(self: PaperSize): string =
  let resul0 = gtk_paper_size_get_display_name(cast[ptr PaperSize00](self.impl))
  result = $resul0

proc displayName*(self: PaperSize): string =
  let resul0 = gtk_paper_size_get_display_name(cast[ptr PaperSize00](self.impl))
  result = $resul0

proc gtk_paper_size_get_name*(self: ptr PaperSize00): cstring {.
    importc: "gtk_paper_size_get_name", libprag.}

proc getName*(self: PaperSize): string =
  let resul0 = gtk_paper_size_get_name(cast[ptr PaperSize00](self.impl))
  result = $resul0

proc name*(self: PaperSize): string =
  let resul0 = gtk_paper_size_get_name(cast[ptr PaperSize00](self.impl))
  result = $resul0

proc gtk_paper_size_get_ppd_name*(self: ptr PaperSize00): cstring {.
    importc: "gtk_paper_size_get_ppd_name", libprag.}

proc getPpdName*(self: PaperSize): string =
  let resul0 = gtk_paper_size_get_ppd_name(cast[ptr PaperSize00](self.impl))
  result = $resul0

proc ppdName*(self: PaperSize): string =
  let resul0 = gtk_paper_size_get_ppd_name(cast[ptr PaperSize00](self.impl))
  result = $resul0

proc gtk_paper_size_is_custom*(self: ptr PaperSize00): gboolean {.
    importc: "gtk_paper_size_is_custom", libprag.}

proc isCustom*(self: PaperSize): bool =
  toBool(gtk_paper_size_is_custom(cast[ptr PaperSize00](self.impl)))

proc gtk_paper_size_is_equal*(self: ptr PaperSize00; size2: ptr PaperSize00): gboolean {.
    importc: "gtk_paper_size_is_equal", libprag.}

proc isEqual*(self: PaperSize; size2: PaperSize): bool =
  toBool(gtk_paper_size_is_equal(cast[ptr PaperSize00](self.impl), cast[ptr PaperSize00](size2.impl)))

proc gtk_paper_size_is_ipp*(self: ptr PaperSize00): gboolean {.
    importc: "gtk_paper_size_is_ipp", libprag.}

proc isIpp*(self: PaperSize): bool =
  toBool(gtk_paper_size_is_ipp(cast[ptr PaperSize00](self.impl)))

proc gtk_paper_size_to_gvariant*(self: ptr PaperSize00): ptr glib.Variant00 {.
    importc: "gtk_paper_size_to_gvariant", libprag.}

proc toGvariant*(self: PaperSize): glib.Variant =
  new(result)
  result.impl = gtk_paper_size_to_gvariant(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_to_key_file*(self: ptr PaperSize00; keyFile: ptr glib.KeyFile00; 
    groupName: cstring) {.
    importc: "gtk_paper_size_to_key_file", libprag.}

proc toKeyFile*(self: PaperSize; keyFile: glib.KeyFile; groupName: string) =
  gtk_paper_size_to_key_file(cast[ptr PaperSize00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName))

proc gtk_paper_size_get_default*(): cstring {.
    importc: "gtk_paper_size_get_default", libprag.}

proc getDefault*(): string =
  let resul0 = gtk_paper_size_get_default()
  result = $resul0

proc default*(): string =
  let resul0 = gtk_paper_size_get_default()
  result = $resul0

proc gtk_paper_size_get_paper_sizes*(includeCustom: gboolean): ptr pointer {.
    importc: "gtk_paper_size_get_paper_sizes", libprag.}

proc getPaperSizes*(includeCustom: gboolean): ptr pointer {.
    importc: "gtk_paper_size_get_paper_sizes", libprag.}

proc paperSizes*(includeCustom: gboolean): ptr pointer {.
    importc: "gtk_paper_size_get_paper_sizes", libprag.}

proc gtk_page_setup_get_paper_size*(self: ptr PageSetup00): ptr PaperSize00 {.
    importc: "gtk_page_setup_get_paper_size", libprag.}

proc getPaperSize*(self: PageSetup): PaperSize =
  new(result)
  result.impl = gtk_page_setup_get_paper_size(cast[ptr PageSetup00](self.impl))

proc paperSize*(self: PageSetup): PaperSize =
  new(result)
  result.impl = gtk_page_setup_get_paper_size(cast[ptr PageSetup00](self.impl))

proc gtk_page_setup_set_paper_size*(self: ptr PageSetup00; size: ptr PaperSize00) {.
    importc: "gtk_page_setup_set_paper_size", libprag.}

proc setPaperSize*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc `paperSize=`*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc gtk_page_setup_set_paper_size_and_default_margins*(self: ptr PageSetup00; size: ptr PaperSize00) {.
    importc: "gtk_page_setup_set_paper_size_and_default_margins", libprag.}

proc setPaperSizeAndDefaultMargins*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size_and_default_margins(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc `paperSizeAndDefaultMargins=`*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size_and_default_margins(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

type
  Unit* {.size: sizeof(cint), pure.} = enum
    none = 0
    points = 1
    inch = 2
    mm = 3

proc gtk_page_setup_get_bottom_margin*(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc: "gtk_page_setup_get_bottom_margin", libprag.}

proc getBottomMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_bottom_margin(cast[ptr PageSetup00](self.impl), unit)

proc bottomMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_bottom_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_left_margin*(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc: "gtk_page_setup_get_left_margin", libprag.}

proc getLeftMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_left_margin(cast[ptr PageSetup00](self.impl), unit)

proc leftMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_left_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_page_height*(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc: "gtk_page_setup_get_page_height", libprag.}

proc getPageHeight*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_page_height(cast[ptr PageSetup00](self.impl), unit)

proc pageHeight*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_page_height(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_page_width*(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc: "gtk_page_setup_get_page_width", libprag.}

proc getPageWidth*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_page_width(cast[ptr PageSetup00](self.impl), unit)

proc pageWidth*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_page_width(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_paper_height*(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc: "gtk_page_setup_get_paper_height", libprag.}

proc getPaperHeight*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_paper_height(cast[ptr PageSetup00](self.impl), unit)

proc paperHeight*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_paper_height(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_paper_width*(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc: "gtk_page_setup_get_paper_width", libprag.}

proc getPaperWidth*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_paper_width(cast[ptr PageSetup00](self.impl), unit)

proc paperWidth*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_paper_width(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_right_margin*(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc: "gtk_page_setup_get_right_margin", libprag.}

proc getRightMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_right_margin(cast[ptr PageSetup00](self.impl), unit)

proc rightMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_right_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_top_margin*(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc: "gtk_page_setup_get_top_margin", libprag.}

proc getTopMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_top_margin(cast[ptr PageSetup00](self.impl), unit)

proc topMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_top_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_set_bottom_margin*(self: ptr PageSetup00; margin: cdouble; unit: Unit) {.
    importc: "gtk_page_setup_set_bottom_margin", libprag.}

proc setBottomMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_bottom_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_set_left_margin*(self: ptr PageSetup00; margin: cdouble; unit: Unit) {.
    importc: "gtk_page_setup_set_left_margin", libprag.}

proc setLeftMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_left_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_set_right_margin*(self: ptr PageSetup00; margin: cdouble; unit: Unit) {.
    importc: "gtk_page_setup_set_right_margin", libprag.}

proc setRightMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_right_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_set_top_margin*(self: ptr PageSetup00; margin: cdouble; unit: Unit) {.
    importc: "gtk_page_setup_set_top_margin", libprag.}

proc setTopMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_top_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_paper_size_new_custom*(name: cstring; displayName: cstring; width: cdouble; 
    height: cdouble; unit: Unit): ptr PaperSize00 {.
    importc: "gtk_paper_size_new_custom", libprag.}

proc newPaperSizeCustom*(name: string; displayName: string; width: cdouble; 
    height: cdouble; unit: Unit): PaperSize =
  new(result)
  result.impl = gtk_paper_size_new_custom(cstring(name), cstring(displayName), width, height, unit)

proc initPaperSizeCustom*[T](result: var T; name: string; displayName: string; width: cdouble; 
    height: cdouble; unit: Unit) =
  assert(result is PaperSize)
  new(result)
  result.impl = gtk_paper_size_new_custom(cstring(name), cstring(displayName), width, height, unit)

proc gtk_paper_size_get_default_bottom_margin*(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc: "gtk_paper_size_get_default_bottom_margin", libprag.}

proc getDefaultBottomMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_bottom_margin(cast[ptr PaperSize00](self.impl), unit)

proc defaultBottomMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_bottom_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_default_left_margin*(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc: "gtk_paper_size_get_default_left_margin", libprag.}

proc getDefaultLeftMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_left_margin(cast[ptr PaperSize00](self.impl), unit)

proc defaultLeftMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_left_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_default_right_margin*(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc: "gtk_paper_size_get_default_right_margin", libprag.}

proc getDefaultRightMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_right_margin(cast[ptr PaperSize00](self.impl), unit)

proc defaultRightMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_right_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_default_top_margin*(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc: "gtk_paper_size_get_default_top_margin", libprag.}

proc getDefaultTopMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_top_margin(cast[ptr PaperSize00](self.impl), unit)

proc defaultTopMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_top_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_height*(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc: "gtk_paper_size_get_height", libprag.}

proc getHeight*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_height(cast[ptr PaperSize00](self.impl), unit)

proc height*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_height(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_width*(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc: "gtk_paper_size_get_width", libprag.}

proc getWidth*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_width(cast[ptr PaperSize00](self.impl), unit)

proc width*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_width(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_set_size*(self: ptr PaperSize00; width: cdouble; height: cdouble; 
    unit: Unit) {.
    importc: "gtk_paper_size_set_size", libprag.}

proc setSize*(self: PaperSize; width: cdouble; height: cdouble; 
    unit: Unit) =
  gtk_paper_size_set_size(cast[ptr PaperSize00](self.impl), width, height, unit)

type
  PageSetupDoneFunc* = proc (pageSetup: ptr PageSetup00; data: pointer) {.cdecl.}

type
  PanedAccessiblePrivate00* {.pure.} = object
  PanedAccessiblePrivate* = ref object
    impl*: ptr PanedAccessiblePrivate00

type
  PanedAccessible* = ref object of ContainerAccessible
  PanedAccessible00* = object of ContainerAccessible00
    priv4: ptr PanedAccessiblePrivate00

type
  PanedAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  PanedAccessibleClass* = ref object
    impl*: ptr PanedAccessibleClass00

type
  PlacesOpenFlag* {.size: sizeof(cint), pure.} = enum
    normal = 1
    newTab = 2
    newWindow = 3

  PlacesOpenFlags* {.size: sizeof(cint).} = set[PlacesOpenFlag]

type
  ScrolledWindowPrivate00* {.pure.} = object
  ScrolledWindowPrivate* = ref object
    impl*: ptr ScrolledWindowPrivate00

type
  ScrolledWindow* = ref object of Bin
  ScrolledWindow00* = object of Bin00
    priv4: ptr ScrolledWindowPrivate00

proc scEdgeOvershot*(self: ScrolledWindow;  p: proc (self: ptr gobject.Object00; pos: PositionType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "edge-overshot", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEdgeReached*(self: ScrolledWindow;  p: proc (self: ptr gobject.Object00; pos: PositionType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "edge-reached", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveFocusOut*(self: ScrolledWindow;  p: proc (self: ptr gobject.Object00; directionType: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-focus-out", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scScrollChild*(self: ScrolledWindow;  p: proc (self: ptr gobject.Object00; scroll: ScrollType; horizontal: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "scroll-child", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_scrolled_window_new*(hadjustment: ptr Adjustment00; vadjustment: ptr Adjustment00): ptr ScrolledWindow00 {.
    importc: "gtk_scrolled_window_new", libprag.}

proc newScrolledWindow*(hadjustment: Adjustment; vadjustment: Adjustment): ScrolledWindow =
  new(result, finalizeGObject)
  result.impl = gtk_scrolled_window_new(cast[ptr Adjustment00](hadjustment.impl), cast[ptr Adjustment00](vadjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScrolledWindow*[T](result: var T; hadjustment: Adjustment; vadjustment: Adjustment) =
  assert(result is ScrolledWindow)
  new(result, finalizeGObject)
  result.impl = gtk_scrolled_window_new(cast[ptr Adjustment00](hadjustment.impl), cast[ptr Adjustment00](vadjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_add_with_viewport*(self: ptr ScrolledWindow00; child: ptr Widget00) {.
    importc: "gtk_scrolled_window_add_with_viewport", libprag.}

proc addWithViewport*(self: ScrolledWindow; child: Widget) =
  gtk_scrolled_window_add_with_viewport(cast[ptr ScrolledWindow00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_scrolled_window_get_capture_button_press*(self: ptr ScrolledWindow00): gboolean {.
    importc: "gtk_scrolled_window_get_capture_button_press", libprag.}

proc getCaptureButtonPress*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_capture_button_press(cast[ptr ScrolledWindow00](self.impl)))

proc captureButtonPress*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_capture_button_press(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_hadjustment*(self: ptr ScrolledWindow00): ptr Adjustment00 {.
    importc: "gtk_scrolled_window_get_hadjustment", libprag.}

proc getHadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_hadjustment(cast[ptr ScrolledWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_hadjustment(cast[ptr ScrolledWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_hscrollbar*(self: ptr ScrolledWindow00): ptr Widget00 {.
    importc: "gtk_scrolled_window_get_hscrollbar", libprag.}

proc getHscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_hscrollbar(cast[ptr ScrolledWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_hscrollbar(cast[ptr ScrolledWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_kinetic_scrolling*(self: ptr ScrolledWindow00): gboolean {.
    importc: "gtk_scrolled_window_get_kinetic_scrolling", libprag.}

proc getKineticScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc kineticScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_max_content_height*(self: ptr ScrolledWindow00): int32 {.
    importc: "gtk_scrolled_window_get_max_content_height", libprag.}

proc getMaxContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc maxContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_max_content_width*(self: ptr ScrolledWindow00): int32 {.
    importc: "gtk_scrolled_window_get_max_content_width", libprag.}

proc getMaxContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc maxContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_min_content_height*(self: ptr ScrolledWindow00): int32 {.
    importc: "gtk_scrolled_window_get_min_content_height", libprag.}

proc getMinContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc minContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_min_content_width*(self: ptr ScrolledWindow00): int32 {.
    importc: "gtk_scrolled_window_get_min_content_width", libprag.}

proc getMinContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc minContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_overlay_scrolling*(self: ptr ScrolledWindow00): gboolean {.
    importc: "gtk_scrolled_window_get_overlay_scrolling", libprag.}

proc getOverlayScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc overlayScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_placement*(self: ptr ScrolledWindow00): CornerType {.
    importc: "gtk_scrolled_window_get_placement", libprag.}

proc getPlacement*(self: ScrolledWindow): CornerType =
  gtk_scrolled_window_get_placement(cast[ptr ScrolledWindow00](self.impl))

proc placement*(self: ScrolledWindow): CornerType =
  gtk_scrolled_window_get_placement(cast[ptr ScrolledWindow00](self.impl))

proc gtk_scrolled_window_get_propagate_natural_height*(self: ptr ScrolledWindow00): gboolean {.
    importc: "gtk_scrolled_window_get_propagate_natural_height", libprag.}

proc getPropagateNaturalHeight*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl)))

proc propagateNaturalHeight*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_propagate_natural_width*(self: ptr ScrolledWindow00): gboolean {.
    importc: "gtk_scrolled_window_get_propagate_natural_width", libprag.}

proc getPropagateNaturalWidth*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl)))

proc propagateNaturalWidth*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_shadow_type*(self: ptr ScrolledWindow00): ShadowType {.
    importc: "gtk_scrolled_window_get_shadow_type", libprag.}

proc getShadowType*(self: ScrolledWindow): ShadowType =
  gtk_scrolled_window_get_shadow_type(cast[ptr ScrolledWindow00](self.impl))

proc shadowType*(self: ScrolledWindow): ShadowType =
  gtk_scrolled_window_get_shadow_type(cast[ptr ScrolledWindow00](self.impl))

proc gtk_scrolled_window_get_vadjustment*(self: ptr ScrolledWindow00): ptr Adjustment00 {.
    importc: "gtk_scrolled_window_get_vadjustment", libprag.}

proc getVadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_vadjustment(cast[ptr ScrolledWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_vadjustment(cast[ptr ScrolledWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_vscrollbar*(self: ptr ScrolledWindow00): ptr Widget00 {.
    importc: "gtk_scrolled_window_get_vscrollbar", libprag.}

proc getVscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_vscrollbar(cast[ptr ScrolledWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_vscrollbar(cast[ptr ScrolledWindow00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_set_capture_button_press*(self: ptr ScrolledWindow00; captureButtonPress: gboolean) {.
    importc: "gtk_scrolled_window_set_capture_button_press", libprag.}

proc setCaptureButtonPress*(self: ScrolledWindow; captureButtonPress: bool) =
  gtk_scrolled_window_set_capture_button_press(cast[ptr ScrolledWindow00](self.impl), gboolean(captureButtonPress))

proc `captureButtonPress=`*(self: ScrolledWindow; captureButtonPress: bool) =
  gtk_scrolled_window_set_capture_button_press(cast[ptr ScrolledWindow00](self.impl), gboolean(captureButtonPress))

proc gtk_scrolled_window_set_hadjustment*(self: ptr ScrolledWindow00; hadjustment: ptr Adjustment00) {.
    importc: "gtk_scrolled_window_set_hadjustment", libprag.}

proc setHadjustment*(self: ScrolledWindow; hadjustment: Adjustment) =
  gtk_scrolled_window_set_hadjustment(cast[ptr ScrolledWindow00](self.impl), cast[ptr Adjustment00](hadjustment.impl))

proc `hadjustment=`*(self: ScrolledWindow; hadjustment: Adjustment) =
  gtk_scrolled_window_set_hadjustment(cast[ptr ScrolledWindow00](self.impl), cast[ptr Adjustment00](hadjustment.impl))

proc gtk_scrolled_window_set_kinetic_scrolling*(self: ptr ScrolledWindow00; kineticScrolling: gboolean) {.
    importc: "gtk_scrolled_window_set_kinetic_scrolling", libprag.}

proc setKineticScrolling*(self: ScrolledWindow; kineticScrolling: bool) =
  gtk_scrolled_window_set_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(kineticScrolling))

proc `kineticScrolling=`*(self: ScrolledWindow; kineticScrolling: bool) =
  gtk_scrolled_window_set_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(kineticScrolling))

proc gtk_scrolled_window_set_max_content_height*(self: ptr ScrolledWindow00; height: int32) {.
    importc: "gtk_scrolled_window_set_max_content_height", libprag.}

proc setMaxContentHeight*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_max_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc `maxContentHeight=`*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_max_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc gtk_scrolled_window_set_max_content_width*(self: ptr ScrolledWindow00; width: int32) {.
    importc: "gtk_scrolled_window_set_max_content_width", libprag.}

proc setMaxContentWidth*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_max_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc `maxContentWidth=`*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_max_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc gtk_scrolled_window_set_min_content_height*(self: ptr ScrolledWindow00; height: int32) {.
    importc: "gtk_scrolled_window_set_min_content_height", libprag.}

proc setMinContentHeight*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_min_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc `minContentHeight=`*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_min_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc gtk_scrolled_window_set_min_content_width*(self: ptr ScrolledWindow00; width: int32) {.
    importc: "gtk_scrolled_window_set_min_content_width", libprag.}

proc setMinContentWidth*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_min_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc `minContentWidth=`*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_min_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc gtk_scrolled_window_set_overlay_scrolling*(self: ptr ScrolledWindow00; overlayScrolling: gboolean) {.
    importc: "gtk_scrolled_window_set_overlay_scrolling", libprag.}

proc setOverlayScrolling*(self: ScrolledWindow; overlayScrolling: bool) =
  gtk_scrolled_window_set_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(overlayScrolling))

proc `overlayScrolling=`*(self: ScrolledWindow; overlayScrolling: bool) =
  gtk_scrolled_window_set_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(overlayScrolling))

proc gtk_scrolled_window_set_placement*(self: ptr ScrolledWindow00; windowPlacement: CornerType) {.
    importc: "gtk_scrolled_window_set_placement", libprag.}

proc setPlacement*(self: ScrolledWindow; windowPlacement: CornerType) =
  gtk_scrolled_window_set_placement(cast[ptr ScrolledWindow00](self.impl), windowPlacement)

proc `placement=`*(self: ScrolledWindow; windowPlacement: CornerType) =
  gtk_scrolled_window_set_placement(cast[ptr ScrolledWindow00](self.impl), windowPlacement)

proc gtk_scrolled_window_set_propagate_natural_height*(self: ptr ScrolledWindow00; propagate: gboolean) {.
    importc: "gtk_scrolled_window_set_propagate_natural_height", libprag.}

proc setPropagateNaturalHeight*(self: ScrolledWindow; propagate: bool) =
  gtk_scrolled_window_set_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc `propagateNaturalHeight=`*(self: ScrolledWindow; propagate: bool) =
  gtk_scrolled_window_set_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc gtk_scrolled_window_set_propagate_natural_width*(self: ptr ScrolledWindow00; propagate: gboolean) {.
    importc: "gtk_scrolled_window_set_propagate_natural_width", libprag.}

proc setPropagateNaturalWidth*(self: ScrolledWindow; propagate: bool) =
  gtk_scrolled_window_set_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc `propagateNaturalWidth=`*(self: ScrolledWindow; propagate: bool) =
  gtk_scrolled_window_set_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc gtk_scrolled_window_set_shadow_type*(self: ptr ScrolledWindow00; `type`: ShadowType) {.
    importc: "gtk_scrolled_window_set_shadow_type", libprag.}

proc setShadowType*(self: ScrolledWindow; `type`: ShadowType) =
  gtk_scrolled_window_set_shadow_type(cast[ptr ScrolledWindow00](self.impl), `type`)

proc `shadowType=`*(self: ScrolledWindow; `type`: ShadowType) =
  gtk_scrolled_window_set_shadow_type(cast[ptr ScrolledWindow00](self.impl), `type`)

proc gtk_scrolled_window_set_vadjustment*(self: ptr ScrolledWindow00; vadjustment: ptr Adjustment00) {.
    importc: "gtk_scrolled_window_set_vadjustment", libprag.}

proc setVadjustment*(self: ScrolledWindow; vadjustment: Adjustment) =
  gtk_scrolled_window_set_vadjustment(cast[ptr ScrolledWindow00](self.impl), cast[ptr Adjustment00](vadjustment.impl))

proc `vadjustment=`*(self: ScrolledWindow; vadjustment: Adjustment) =
  gtk_scrolled_window_set_vadjustment(cast[ptr ScrolledWindow00](self.impl), cast[ptr Adjustment00](vadjustment.impl))

proc gtk_scrolled_window_unset_placement*(self: ptr ScrolledWindow00) {.
    importc: "gtk_scrolled_window_unset_placement", libprag.}

proc unsetPlacement*(self: ScrolledWindow) =
  gtk_scrolled_window_unset_placement(cast[ptr ScrolledWindow00](self.impl))

type
  PlacesSidebar* = ref object of ScrolledWindow
  PlacesSidebar00* = object of ScrolledWindow00

proc scDragActionAsk*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; actions: int32; xdata: pointer): int32 {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-action-ask", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragActionRequested*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; context: gdk.DragContext00; destFile: gio.File00; 
    sourceFileList: ptr pointer; xdata: pointer): int32 {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-action-requested", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDragPerformDrop*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; destFile: gio.File00; sourceFileList: ptr pointer; 
    action: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "drag-perform-drop", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMount*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; mountOperation: gio.MountOperation00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "mount", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scOpenLocation*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; location: gio.File00; openFlags: PlacesOpenFlags; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "open-location", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopulatePopup*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; container: Widget00; selectedItem: gio.File00; selectedVolume: gio.Volume00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scShowConnectToServer*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "show-connect-to-server", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scShowEnterLocation*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "show-enter-location", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scShowErrorMessage*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; primary: cstring; secondary: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "show-error-message", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scShowOtherLocations*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "show-other-locations", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scShowOtherLocationsWithFlags*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; openFlags: PlacesOpenFlags; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "show-other-locations-with-flags", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUnmount*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; mountOperation: gio.MountOperation00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "unmount", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_places_sidebar_new*(): ptr PlacesSidebar00 {.
    importc: "gtk_places_sidebar_new", libprag.}

proc newPlacesSidebar*(): PlacesSidebar =
  new(result, finalizeGObject)
  result.impl = gtk_places_sidebar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPlacesSidebar*[T](result: var T) =
  assert(result is PlacesSidebar)
  new(result, finalizeGObject)
  result.impl = gtk_places_sidebar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_places_sidebar_add_shortcut*(self: ptr PlacesSidebar00; location: ptr gio.File00) {.
    importc: "gtk_places_sidebar_add_shortcut", libprag.}

proc addShortcut*(self: PlacesSidebar; location: gio.File) =
  gtk_places_sidebar_add_shortcut(cast[ptr PlacesSidebar00](self.impl), cast[ptr gio.File00](location.impl))

proc gtk_places_sidebar_get_local_only*(self: ptr PlacesSidebar00): gboolean {.
    importc: "gtk_places_sidebar_get_local_only", libprag.}

proc getLocalOnly*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_local_only(cast[ptr PlacesSidebar00](self.impl)))

proc localOnly*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_local_only(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_location*(self: ptr PlacesSidebar00): ptr gio.File00 {.
    importc: "gtk_places_sidebar_get_location", libprag.}

proc getLocation*(self: PlacesSidebar): gio.File =
  new(result)
  result.impl = gtk_places_sidebar_get_location(cast[ptr PlacesSidebar00](self.impl))

proc location*(self: PlacesSidebar): gio.File =
  new(result)
  result.impl = gtk_places_sidebar_get_location(cast[ptr PlacesSidebar00](self.impl))

proc gtk_places_sidebar_get_nth_bookmark*(self: ptr PlacesSidebar00; n: int32): ptr gio.File00 {.
    importc: "gtk_places_sidebar_get_nth_bookmark", libprag.}

proc getNthBookmark*(self: PlacesSidebar; n: int): gio.File =
  new(result)
  result.impl = gtk_places_sidebar_get_nth_bookmark(cast[ptr PlacesSidebar00](self.impl), int32(n))

proc nthBookmark*(self: PlacesSidebar; n: int): gio.File =
  new(result)
  result.impl = gtk_places_sidebar_get_nth_bookmark(cast[ptr PlacesSidebar00](self.impl), int32(n))

proc gtk_places_sidebar_get_open_flags*(self: ptr PlacesSidebar00): PlacesOpenFlags {.
    importc: "gtk_places_sidebar_get_open_flags", libprag.}

proc getOpenFlags*(self: PlacesSidebar): PlacesOpenFlags =
  gtk_places_sidebar_get_open_flags(cast[ptr PlacesSidebar00](self.impl))

proc openFlags*(self: PlacesSidebar): PlacesOpenFlags =
  gtk_places_sidebar_get_open_flags(cast[ptr PlacesSidebar00](self.impl))

proc gtk_places_sidebar_get_show_connect_to_server*(self: ptr PlacesSidebar00): gboolean {.
    importc: "gtk_places_sidebar_get_show_connect_to_server", libprag.}

proc getShowConnectToServer*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_connect_to_server(cast[ptr PlacesSidebar00](self.impl)))

proc showConnectToServer*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_connect_to_server(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_desktop*(self: ptr PlacesSidebar00): gboolean {.
    importc: "gtk_places_sidebar_get_show_desktop", libprag.}

proc getShowDesktop*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_desktop(cast[ptr PlacesSidebar00](self.impl)))

proc showDesktop*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_desktop(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_enter_location*(self: ptr PlacesSidebar00): gboolean {.
    importc: "gtk_places_sidebar_get_show_enter_location", libprag.}

proc getShowEnterLocation*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_enter_location(cast[ptr PlacesSidebar00](self.impl)))

proc showEnterLocation*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_enter_location(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_other_locations*(self: ptr PlacesSidebar00): gboolean {.
    importc: "gtk_places_sidebar_get_show_other_locations", libprag.}

proc getShowOtherLocations*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_other_locations(cast[ptr PlacesSidebar00](self.impl)))

proc showOtherLocations*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_other_locations(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_recent*(self: ptr PlacesSidebar00): gboolean {.
    importc: "gtk_places_sidebar_get_show_recent", libprag.}

proc getShowRecent*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_recent(cast[ptr PlacesSidebar00](self.impl)))

proc showRecent*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_recent(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_trash*(self: ptr PlacesSidebar00): gboolean {.
    importc: "gtk_places_sidebar_get_show_trash", libprag.}

proc getShowTrash*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_trash(cast[ptr PlacesSidebar00](self.impl)))

proc showTrash*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_trash(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_list_shortcuts*(self: ptr PlacesSidebar00): ptr pointer {.
    importc: "gtk_places_sidebar_list_shortcuts", libprag.}

proc listShortcuts*(self: PlacesSidebar): ptr pointer =
  gtk_places_sidebar_list_shortcuts(cast[ptr PlacesSidebar00](self.impl))

proc gtk_places_sidebar_remove_shortcut*(self: ptr PlacesSidebar00; location: ptr gio.File00) {.
    importc: "gtk_places_sidebar_remove_shortcut", libprag.}

proc removeShortcut*(self: PlacesSidebar; location: gio.File) =
  gtk_places_sidebar_remove_shortcut(cast[ptr PlacesSidebar00](self.impl), cast[ptr gio.File00](location.impl))

proc gtk_places_sidebar_set_drop_targets_visible*(self: ptr PlacesSidebar00; visible: gboolean; context: ptr gdk.DragContext00) {.
    importc: "gtk_places_sidebar_set_drop_targets_visible", libprag.}

proc setDropTargetsVisible*(self: PlacesSidebar; visible: bool; context: gdk.DragContext) =
  gtk_places_sidebar_set_drop_targets_visible(cast[ptr PlacesSidebar00](self.impl), gboolean(visible), cast[ptr gdk.DragContext00](context.impl))

proc gtk_places_sidebar_set_local_only*(self: ptr PlacesSidebar00; localOnly: gboolean) {.
    importc: "gtk_places_sidebar_set_local_only", libprag.}

proc setLocalOnly*(self: PlacesSidebar; localOnly: bool) =
  gtk_places_sidebar_set_local_only(cast[ptr PlacesSidebar00](self.impl), gboolean(localOnly))

proc `localOnly=`*(self: PlacesSidebar; localOnly: bool) =
  gtk_places_sidebar_set_local_only(cast[ptr PlacesSidebar00](self.impl), gboolean(localOnly))

proc gtk_places_sidebar_set_location*(self: ptr PlacesSidebar00; location: ptr gio.File00) {.
    importc: "gtk_places_sidebar_set_location", libprag.}

proc setLocation*(self: PlacesSidebar; location: gio.File) =
  gtk_places_sidebar_set_location(cast[ptr PlacesSidebar00](self.impl), cast[ptr gio.File00](location.impl))

proc `location=`*(self: PlacesSidebar; location: gio.File) =
  gtk_places_sidebar_set_location(cast[ptr PlacesSidebar00](self.impl), cast[ptr gio.File00](location.impl))

proc gtk_places_sidebar_set_open_flags*(self: ptr PlacesSidebar00; flags: PlacesOpenFlags) {.
    importc: "gtk_places_sidebar_set_open_flags", libprag.}

proc setOpenFlags*(self: PlacesSidebar; flags: PlacesOpenFlags) =
  gtk_places_sidebar_set_open_flags(cast[ptr PlacesSidebar00](self.impl), flags)

proc `openFlags=`*(self: PlacesSidebar; flags: PlacesOpenFlags) =
  gtk_places_sidebar_set_open_flags(cast[ptr PlacesSidebar00](self.impl), flags)

proc gtk_places_sidebar_set_show_connect_to_server*(self: ptr PlacesSidebar00; showConnectToServer: gboolean) {.
    importc: "gtk_places_sidebar_set_show_connect_to_server", libprag.}

proc setShowConnectToServer*(self: PlacesSidebar; showConnectToServer: bool) =
  gtk_places_sidebar_set_show_connect_to_server(cast[ptr PlacesSidebar00](self.impl), gboolean(showConnectToServer))

proc `showConnectToServer=`*(self: PlacesSidebar; showConnectToServer: bool) =
  gtk_places_sidebar_set_show_connect_to_server(cast[ptr PlacesSidebar00](self.impl), gboolean(showConnectToServer))

proc gtk_places_sidebar_set_show_desktop*(self: ptr PlacesSidebar00; showDesktop: gboolean) {.
    importc: "gtk_places_sidebar_set_show_desktop", libprag.}

proc setShowDesktop*(self: PlacesSidebar; showDesktop: bool) =
  gtk_places_sidebar_set_show_desktop(cast[ptr PlacesSidebar00](self.impl), gboolean(showDesktop))

proc `showDesktop=`*(self: PlacesSidebar; showDesktop: bool) =
  gtk_places_sidebar_set_show_desktop(cast[ptr PlacesSidebar00](self.impl), gboolean(showDesktop))

proc gtk_places_sidebar_set_show_enter_location*(self: ptr PlacesSidebar00; showEnterLocation: gboolean) {.
    importc: "gtk_places_sidebar_set_show_enter_location", libprag.}

proc setShowEnterLocation*(self: PlacesSidebar; showEnterLocation: bool) =
  gtk_places_sidebar_set_show_enter_location(cast[ptr PlacesSidebar00](self.impl), gboolean(showEnterLocation))

proc `showEnterLocation=`*(self: PlacesSidebar; showEnterLocation: bool) =
  gtk_places_sidebar_set_show_enter_location(cast[ptr PlacesSidebar00](self.impl), gboolean(showEnterLocation))

proc gtk_places_sidebar_set_show_other_locations*(self: ptr PlacesSidebar00; showOtherLocations: gboolean) {.
    importc: "gtk_places_sidebar_set_show_other_locations", libprag.}

proc setShowOtherLocations*(self: PlacesSidebar; showOtherLocations: bool) =
  gtk_places_sidebar_set_show_other_locations(cast[ptr PlacesSidebar00](self.impl), gboolean(showOtherLocations))

proc `showOtherLocations=`*(self: PlacesSidebar; showOtherLocations: bool) =
  gtk_places_sidebar_set_show_other_locations(cast[ptr PlacesSidebar00](self.impl), gboolean(showOtherLocations))

proc gtk_places_sidebar_set_show_recent*(self: ptr PlacesSidebar00; showRecent: gboolean) {.
    importc: "gtk_places_sidebar_set_show_recent", libprag.}

proc setShowRecent*(self: PlacesSidebar; showRecent: bool) =
  gtk_places_sidebar_set_show_recent(cast[ptr PlacesSidebar00](self.impl), gboolean(showRecent))

proc `showRecent=`*(self: PlacesSidebar; showRecent: bool) =
  gtk_places_sidebar_set_show_recent(cast[ptr PlacesSidebar00](self.impl), gboolean(showRecent))

proc gtk_places_sidebar_set_show_trash*(self: ptr PlacesSidebar00; showTrash: gboolean) {.
    importc: "gtk_places_sidebar_set_show_trash", libprag.}

proc setShowTrash*(self: PlacesSidebar; showTrash: bool) =
  gtk_places_sidebar_set_show_trash(cast[ptr PlacesSidebar00](self.impl), gboolean(showTrash))

proc `showTrash=`*(self: PlacesSidebar; showTrash: bool) =
  gtk_places_sidebar_set_show_trash(cast[ptr PlacesSidebar00](self.impl), gboolean(showTrash))

type
  PolicyType* {.size: sizeof(cint), pure.} = enum
    always = 0
    automatic = 1
    never = 2
    external = 3

proc gtk_scrolled_window_get_policy*(self: ptr ScrolledWindow00; hscrollbarPolicy: var PolicyType; 
    vscrollbarPolicy: var PolicyType) {.
    importc: "gtk_scrolled_window_get_policy", libprag.}

proc getPolicy*(self: ScrolledWindow; hscrollbarPolicy: var PolicyType; 
    vscrollbarPolicy: var PolicyType) =
  gtk_scrolled_window_get_policy(cast[ptr ScrolledWindow00](self.impl), hscrollbarPolicy, vscrollbarPolicy)

proc policy*(self: ScrolledWindow; hscrollbarPolicy: var PolicyType; 
    vscrollbarPolicy: var PolicyType) =
  gtk_scrolled_window_get_policy(cast[ptr ScrolledWindow00](self.impl), hscrollbarPolicy, vscrollbarPolicy)

proc gtk_scrolled_window_set_policy*(self: ptr ScrolledWindow00; hscrollbarPolicy: PolicyType; 
    vscrollbarPolicy: PolicyType) {.
    importc: "gtk_scrolled_window_set_policy", libprag.}

proc setPolicy*(self: ScrolledWindow; hscrollbarPolicy: PolicyType; 
    vscrollbarPolicy: PolicyType) =
  gtk_scrolled_window_set_policy(cast[ptr ScrolledWindow00](self.impl), hscrollbarPolicy, vscrollbarPolicy)

type
  PlacesSidebarClass00* {.pure.} = object
  PlacesSidebarClass* = ref object
    impl*: ptr PlacesSidebarClass00

type
  PlugPrivate00* {.pure.} = object
  PlugPrivate* = ref object
    impl*: ptr PlugPrivate00

type
  Plug* = ref object of Window
  Plug00* = object of Window00
    priv5: ptr PlugPrivate00

proc scEmbedded*(self: Plug;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "embedded", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_plug_new*(socketId: uint64): ptr Plug00 {.
    importc: "gtk_plug_new", libprag.}

proc newPlug*(socketId: uint64): Plug =
  new(result, finalizeGObject)
  result.impl = gtk_plug_new(socketId)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPlug*[T](result: var T; socketId: uint64) =
  assert(result is Plug)
  new(result, finalizeGObject)
  result.impl = gtk_plug_new(socketId)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_plug_new_for_display*(display: ptr gdk.Display00; socketId: uint64): ptr Plug00 {.
    importc: "gtk_plug_new_for_display", libprag.}

proc newPlugForDisplay*(display: gdk.Display; socketId: uint64): Plug =
  new(result, finalizeGObject)
  result.impl = gtk_plug_new_for_display(cast[ptr gdk.Display00](display.impl), socketId)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPlugForDisplay*[T](result: var T; display: gdk.Display; socketId: uint64) =
  assert(result is Plug)
  new(result, finalizeGObject)
  result.impl = gtk_plug_new_for_display(cast[ptr gdk.Display00](display.impl), socketId)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_plug_construct*(self: ptr Plug00; socketId: uint64) {.
    importc: "gtk_plug_construct", libprag.}

proc construct*(self: Plug; socketId: uint64) =
  gtk_plug_construct(cast[ptr Plug00](self.impl), socketId)

proc gtk_plug_construct_for_display*(self: ptr Plug00; display: ptr gdk.Display00; socketId: uint64) {.
    importc: "gtk_plug_construct_for_display", libprag.}

proc constructForDisplay*(self: Plug; display: gdk.Display; socketId: uint64) =
  gtk_plug_construct_for_display(cast[ptr Plug00](self.impl), cast[ptr gdk.Display00](display.impl), socketId)

proc gtk_plug_get_embedded*(self: ptr Plug00): gboolean {.
    importc: "gtk_plug_get_embedded", libprag.}

proc getEmbedded*(self: Plug): bool =
  toBool(gtk_plug_get_embedded(cast[ptr Plug00](self.impl)))

proc embedded*(self: Plug): bool =
  toBool(gtk_plug_get_embedded(cast[ptr Plug00](self.impl)))

proc gtk_plug_get_id*(self: ptr Plug00): uint64 {.
    importc: "gtk_plug_get_id", libprag.}

proc getId*(self: Plug): uint64 =
  gtk_plug_get_id(cast[ptr Plug00](self.impl))

proc id*(self: Plug): uint64 =
  gtk_plug_get_id(cast[ptr Plug00](self.impl))

proc gtk_plug_get_socket_window*(self: ptr Plug00): ptr gdk.Window00 {.
    importc: "gtk_plug_get_socket_window", libprag.}

proc getSocketWindow*(self: Plug): gdk.Window =
  let gobj = gtk_plug_get_socket_window(cast[ptr Plug00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc socketWindow*(self: Plug): gdk.Window =
  let gobj = gtk_plug_get_socket_window(cast[ptr Plug00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  PlugClass00* {.pure.} = object
    parentClass*: WindowClass00
    embedded*: proc(plug: ptr Plug00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  PlugClass* = ref object
    impl*: ptr PlugClass00

type
  PopoverAccessible* = ref object of ContainerAccessible
  PopoverAccessible00* = object of ContainerAccessible00

type
  PopoverAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  PopoverAccessibleClass* = ref object
    impl*: ptr PopoverAccessibleClass00

type
  PopoverClass00* {.pure.} = object
    parentClass*: BinClass00
    closed*: proc(popover: ptr Popover00) {.cdecl.}
    reserved*: array[10, pointer]
  PopoverClass* = ref object
    impl*: ptr PopoverClass00

type
  PopoverMenu* = ref object of Popover
  PopoverMenu00* = object of Popover00

proc gtk_popover_menu_new*(): ptr PopoverMenu00 {.
    importc: "gtk_popover_menu_new", libprag.}

proc newPopoverMenu*(): PopoverMenu =
  new(result, finalizeGObject)
  result.impl = gtk_popover_menu_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopoverMenu*[T](result: var T) =
  assert(result is PopoverMenu)
  new(result, finalizeGObject)
  result.impl = gtk_popover_menu_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_menu_open_submenu*(self: ptr PopoverMenu00; name: cstring) {.
    importc: "gtk_popover_menu_open_submenu", libprag.}

proc openSubmenu*(self: PopoverMenu; name: string) =
  gtk_popover_menu_open_submenu(cast[ptr PopoverMenu00](self.impl), cstring(name))

type
  PopoverMenuClass00* {.pure.} = object
    parentClass*: PopoverClass00
    reserved*: array[10, pointer]
  PopoverMenuClass* = ref object
    impl*: ptr PopoverMenuClass00

type
  PrintContext* = ref object of gobject.Object
  PrintContext00* = object of gobject.Object00

proc gtk_print_context_create_pango_context*(self: ptr PrintContext00): ptr pango.Context00 {.
    importc: "gtk_print_context_create_pango_context", libprag.}

proc createPangoContext*(self: PrintContext): pango.Context =
  let gobj = gtk_print_context_create_pango_context(cast[ptr PrintContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Context](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_create_pango_layout*(self: ptr PrintContext00): ptr pango.Layout00 {.
    importc: "gtk_print_context_create_pango_layout", libprag.}

proc createPangoLayout*(self: PrintContext): pango.Layout =
  let gobj = gtk_print_context_create_pango_layout(cast[ptr PrintContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.Layout](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_get_cairo_context*(self: ptr PrintContext00): ptr cairo.Context00 {.
    importc: "gtk_print_context_get_cairo_context", libprag.}

proc getCairoContext*(self: PrintContext): cairo.Context =
  new(result)
  result.impl = gtk_print_context_get_cairo_context(cast[ptr PrintContext00](self.impl))

proc cairoContext*(self: PrintContext): cairo.Context =
  new(result)
  result.impl = gtk_print_context_get_cairo_context(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_dpi_x*(self: ptr PrintContext00): cdouble {.
    importc: "gtk_print_context_get_dpi_x", libprag.}

proc getDpiX*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_x(cast[ptr PrintContext00](self.impl))

proc dpiX*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_x(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_dpi_y*(self: ptr PrintContext00): cdouble {.
    importc: "gtk_print_context_get_dpi_y", libprag.}

proc getDpiY*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_y(cast[ptr PrintContext00](self.impl))

proc dpiY*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_y(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_hard_margins*(self: ptr PrintContext00; top: var cdouble; bottom: var cdouble; 
    left: var cdouble; right: var cdouble): gboolean {.
    importc: "gtk_print_context_get_hard_margins", libprag.}

proc getHardMargins*(self: PrintContext; top: var cdouble; bottom: var cdouble; 
    left: var cdouble; right: var cdouble): bool =
  toBool(gtk_print_context_get_hard_margins(cast[ptr PrintContext00](self.impl), top, bottom, left, right))

proc hardMargins*(self: PrintContext; top: var cdouble; bottom: var cdouble; 
    left: var cdouble; right: var cdouble): bool =
  toBool(gtk_print_context_get_hard_margins(cast[ptr PrintContext00](self.impl), top, bottom, left, right))

proc gtk_print_context_get_height*(self: ptr PrintContext00): cdouble {.
    importc: "gtk_print_context_get_height", libprag.}

proc getHeight*(self: PrintContext): cdouble =
  gtk_print_context_get_height(cast[ptr PrintContext00](self.impl))

proc height*(self: PrintContext): cdouble =
  gtk_print_context_get_height(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_page_setup*(self: ptr PrintContext00): ptr PageSetup00 {.
    importc: "gtk_print_context_get_page_setup", libprag.}

proc getPageSetup*(self: PrintContext): PageSetup =
  let gobj = gtk_print_context_get_page_setup(cast[ptr PrintContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[PageSetup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pageSetup*(self: PrintContext): PageSetup =
  let gobj = gtk_print_context_get_page_setup(cast[ptr PrintContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[PageSetup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_get_pango_fontmap*(self: ptr PrintContext00): ptr pango.FontMap00 {.
    importc: "gtk_print_context_get_pango_fontmap", libprag.}

proc getPangoFontmap*(self: PrintContext): pango.FontMap =
  let gobj = gtk_print_context_get_pango_fontmap(cast[ptr PrintContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontMap](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pangoFontmap*(self: PrintContext): pango.FontMap =
  let gobj = gtk_print_context_get_pango_fontmap(cast[ptr PrintContext00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[pango.FontMap](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_get_width*(self: ptr PrintContext00): cdouble {.
    importc: "gtk_print_context_get_width", libprag.}

proc getWidth*(self: PrintContext): cdouble =
  gtk_print_context_get_width(cast[ptr PrintContext00](self.impl))

proc width*(self: PrintContext): cdouble =
  gtk_print_context_get_width(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_set_cairo_context*(self: ptr PrintContext00; cr: ptr cairo.Context00; 
    dpiX: cdouble; dpiY: cdouble) {.
    importc: "gtk_print_context_set_cairo_context", libprag.}

proc setCairoContext*(self: PrintContext; cr: cairo.Context; dpiX: cdouble; 
    dpiY: cdouble) =
  gtk_print_context_set_cairo_context(cast[ptr PrintContext00](self.impl), cast[ptr cairo.Context00](cr.impl), dpiX, dpiY)

type
  PrintDuplex* {.size: sizeof(cint), pure.} = enum
    simplex = 0
    horizontal = 1
    vertical = 2

type
  PrintError* {.size: sizeof(cint), pure.} = enum
    general = 0
    internalError = 1
    nomem = 2
    invalidFile = 3

proc gtk_print_error_quark*(): uint32 {.
    importc: "gtk_print_error_quark", libprag.}

type
  PrintOperationPrivate00* {.pure.} = object
  PrintOperationPrivate* = ref object
    impl*: ptr PrintOperationPrivate00

type
  PrintOperationResult* {.size: sizeof(cint), pure.} = enum
    error = 0
    apply = 1
    cancel = 2
    inProgress = 3

type
  PrintOperationPreview00* {.pure.} = object
  PrintOperationPreview* = ref object
    impl*: ptr PrintOperationPreview00

proc gtk_print_operation_preview_end_preview*(self: ptr PrintOperationPreview00) {.
    importc: "gtk_print_operation_preview_end_preview", libprag.}

proc endPreview*(self: PrintOperationPreview) =
  gtk_print_operation_preview_end_preview(cast[ptr PrintOperationPreview00](self.impl))

proc gtk_print_operation_preview_is_selected*(self: ptr PrintOperationPreview00; pageNr: int32): gboolean {.
    importc: "gtk_print_operation_preview_is_selected", libprag.}

proc isSelected*(self: PrintOperationPreview; pageNr: int): bool =
  toBool(gtk_print_operation_preview_is_selected(cast[ptr PrintOperationPreview00](self.impl), int32(pageNr)))

proc gtk_print_operation_preview_render_page*(self: ptr PrintOperationPreview00; pageNr: int32) {.
    importc: "gtk_print_operation_preview_render_page", libprag.}

proc renderPage*(self: PrintOperationPreview; pageNr: int) =
  gtk_print_operation_preview_render_page(cast[ptr PrintOperationPreview00](self.impl), int32(pageNr))

type
  PrintSettings* = ref object of gobject.Object
  PrintSettings00* = object of gobject.Object00

proc gtk_print_settings_new*(): ptr PrintSettings00 {.
    importc: "gtk_print_settings_new", libprag.}

proc newPrintSettings*(): PrintSettings =
  new(result, finalizeGObject)
  result.impl = gtk_print_settings_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettings*[T](result: var T) =
  assert(result is PrintSettings)
  new(result, finalizeGObject)
  result.impl = gtk_print_settings_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_new_from_file*(fileName: ucstring): ptr PrintSettings00 {.
    importc: "gtk_print_settings_new_from_file", libprag.}

proc newPrintSettingsFromFile*(fileName: ucstring): PrintSettings =
  new(result, finalizeGObject)
  result.impl = gtk_print_settings_new_from_file(fileName)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettingsFromFile*[T](result: var T; fileName: ucstring) =
  assert(result is PrintSettings)
  new(result, finalizeGObject)
  result.impl = gtk_print_settings_new_from_file(fileName)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_new_from_gvariant*(variant: ptr glib.Variant00): ptr PrintSettings00 {.
    importc: "gtk_print_settings_new_from_gvariant", libprag.}

proc newPrintSettingsFromGvariant*(variant: glib.Variant): PrintSettings =
  new(result, finalizeGObject)
  result.impl = gtk_print_settings_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettingsFromGvariant*[T](result: var T; variant: glib.Variant) =
  assert(result is PrintSettings)
  new(result, finalizeGObject)
  result.impl = gtk_print_settings_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_new_from_key_file*(keyFile: ptr glib.KeyFile00; groupName: cstring): ptr PrintSettings00 {.
    importc: "gtk_print_settings_new_from_key_file", libprag.}

proc newPrintSettingsFromKeyFile*(keyFile: glib.KeyFile; groupName: string): PrintSettings =
  new(result, finalizeGObject)
  result.impl = gtk_print_settings_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettingsFromKeyFile*[T](result: var T; keyFile: glib.KeyFile; groupName: string) =
  assert(result is PrintSettings)
  new(result, finalizeGObject)
  result.impl = gtk_print_settings_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_copy*(self: ptr PrintSettings00): ptr PrintSettings00 {.
    importc: "gtk_print_settings_copy", libprag.}

proc copy*(self: PrintSettings): PrintSettings =
  let gobj = gtk_print_settings_copy(cast[ptr PrintSettings00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[PrintSettings](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_get*(self: ptr PrintSettings00; key: cstring): cstring {.
    importc: "gtk_print_settings_get", libprag.}

proc get*(self: PrintSettings; key: string): string =
  let resul0 = gtk_print_settings_get(cast[ptr PrintSettings00](self.impl), cstring(key))
  result = $resul0

proc gtk_print_settings_get_bool*(self: ptr PrintSettings00; key: cstring): gboolean {.
    importc: "gtk_print_settings_get_bool", libprag.}

proc getBool*(self: PrintSettings; key: string): bool =
  toBool(gtk_print_settings_get_bool(cast[ptr PrintSettings00](self.impl), cstring(key)))

proc bool*(self: PrintSettings; key: string): bool =
  toBool(gtk_print_settings_get_bool(cast[ptr PrintSettings00](self.impl), cstring(key)))

proc gtk_print_settings_get_collate*(self: ptr PrintSettings00): gboolean {.
    importc: "gtk_print_settings_get_collate", libprag.}

proc getCollate*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_collate(cast[ptr PrintSettings00](self.impl)))

proc collate*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_collate(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_default_source*(self: ptr PrintSettings00): cstring {.
    importc: "gtk_print_settings_get_default_source", libprag.}

proc getDefaultSource*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_default_source(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc defaultSource*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_default_source(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc gtk_print_settings_get_dither*(self: ptr PrintSettings00): cstring {.
    importc: "gtk_print_settings_get_dither", libprag.}

proc getDither*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_dither(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc dither*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_dither(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc gtk_print_settings_get_double*(self: ptr PrintSettings00; key: cstring): cdouble {.
    importc: "gtk_print_settings_get_double", libprag.}

proc getDouble*(self: PrintSettings; key: string): cdouble =
  gtk_print_settings_get_double(cast[ptr PrintSettings00](self.impl), cstring(key))

proc double*(self: PrintSettings; key: string): cdouble =
  gtk_print_settings_get_double(cast[ptr PrintSettings00](self.impl), cstring(key))

proc gtk_print_settings_get_double_with_default*(self: ptr PrintSettings00; key: cstring; def: cdouble): cdouble {.
    importc: "gtk_print_settings_get_double_with_default", libprag.}

proc getDoubleWithDefault*(self: PrintSettings; key: string; def: cdouble): cdouble =
  gtk_print_settings_get_double_with_default(cast[ptr PrintSettings00](self.impl), cstring(key), def)

proc doubleWithDefault*(self: PrintSettings; key: string; def: cdouble): cdouble =
  gtk_print_settings_get_double_with_default(cast[ptr PrintSettings00](self.impl), cstring(key), def)

proc gtk_print_settings_get_duplex*(self: ptr PrintSettings00): PrintDuplex {.
    importc: "gtk_print_settings_get_duplex", libprag.}

proc getDuplex*(self: PrintSettings): PrintDuplex =
  gtk_print_settings_get_duplex(cast[ptr PrintSettings00](self.impl))

proc duplex*(self: PrintSettings): PrintDuplex =
  gtk_print_settings_get_duplex(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_finishings*(self: ptr PrintSettings00): cstring {.
    importc: "gtk_print_settings_get_finishings", libprag.}

proc getFinishings*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_finishings(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc finishings*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_finishings(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc gtk_print_settings_get_int*(self: ptr PrintSettings00; key: cstring): int32 {.
    importc: "gtk_print_settings_get_int", libprag.}

proc getInt*(self: PrintSettings; key: string): int =
  int(gtk_print_settings_get_int(cast[ptr PrintSettings00](self.impl), cstring(key)))

proc gtk_print_settings_get_int_with_default*(self: ptr PrintSettings00; key: cstring; def: int32): int32 {.
    importc: "gtk_print_settings_get_int_with_default", libprag.}

proc getIntWithDefault*(self: PrintSettings; key: string; def: int): int =
  int(gtk_print_settings_get_int_with_default(cast[ptr PrintSettings00](self.impl), cstring(key), int32(def)))

proc intWithDefault*(self: PrintSettings; key: string; def: int): int =
  int(gtk_print_settings_get_int_with_default(cast[ptr PrintSettings00](self.impl), cstring(key), int32(def)))

proc gtk_print_settings_get_length*(self: ptr PrintSettings00; key: cstring; unit: Unit): cdouble {.
    importc: "gtk_print_settings_get_length", libprag.}

proc getLength*(self: PrintSettings; key: string; unit: Unit): cdouble =
  gtk_print_settings_get_length(cast[ptr PrintSettings00](self.impl), cstring(key), unit)

proc length*(self: PrintSettings; key: string; unit: Unit): cdouble =
  gtk_print_settings_get_length(cast[ptr PrintSettings00](self.impl), cstring(key), unit)

proc gtk_print_settings_get_media_type*(self: ptr PrintSettings00): cstring {.
    importc: "gtk_print_settings_get_media_type", libprag.}

proc getMediaType*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_media_type(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc mediaType*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_media_type(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc gtk_print_settings_get_n_copies*(self: ptr PrintSettings00): int32 {.
    importc: "gtk_print_settings_get_n_copies", libprag.}

proc getNCopies*(self: PrintSettings): int =
  int(gtk_print_settings_get_n_copies(cast[ptr PrintSettings00](self.impl)))

proc nCopies*(self: PrintSettings): int =
  int(gtk_print_settings_get_n_copies(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_number_up*(self: ptr PrintSettings00): int32 {.
    importc: "gtk_print_settings_get_number_up", libprag.}

proc getNumberUp*(self: PrintSettings): int =
  int(gtk_print_settings_get_number_up(cast[ptr PrintSettings00](self.impl)))

proc numberUp*(self: PrintSettings): int =
  int(gtk_print_settings_get_number_up(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_number_up_layout*(self: ptr PrintSettings00): NumberUpLayout {.
    importc: "gtk_print_settings_get_number_up_layout", libprag.}

proc getNumberUpLayout*(self: PrintSettings): NumberUpLayout =
  gtk_print_settings_get_number_up_layout(cast[ptr PrintSettings00](self.impl))

proc numberUpLayout*(self: PrintSettings): NumberUpLayout =
  gtk_print_settings_get_number_up_layout(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_orientation*(self: ptr PrintSettings00): PageOrientation {.
    importc: "gtk_print_settings_get_orientation", libprag.}

proc getOrientation*(self: PrintSettings): PageOrientation =
  gtk_print_settings_get_orientation(cast[ptr PrintSettings00](self.impl))

proc orientation*(self: PrintSettings): PageOrientation =
  gtk_print_settings_get_orientation(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_output_bin*(self: ptr PrintSettings00): cstring {.
    importc: "gtk_print_settings_get_output_bin", libprag.}

proc getOutputBin*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_output_bin(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc outputBin*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_output_bin(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc gtk_print_settings_get_page_ranges*(self: ptr PrintSettings00; numRanges: var int32): PageRange00Array {.
    importc: "gtk_print_settings_get_page_ranges", libprag.}

proc getPageRanges*(self: PrintSettings; numRanges: var int): PageRange00Array =
  var numRanges_00 = int32(numRanges)
  result = gtk_print_settings_get_page_ranges(cast[ptr PrintSettings00](self.impl), numRanges_00)
  numRanges = int(numRanges_00)

proc pageRanges*(self: PrintSettings; numRanges: var int): PageRange00Array =
  var numRanges_00 = int32(numRanges)
  result = gtk_print_settings_get_page_ranges(cast[ptr PrintSettings00](self.impl), numRanges_00)
  numRanges = int(numRanges_00)

proc gtk_print_settings_get_page_set*(self: ptr PrintSettings00): PageSet {.
    importc: "gtk_print_settings_get_page_set", libprag.}

proc getPageSet*(self: PrintSettings): PageSet =
  gtk_print_settings_get_page_set(cast[ptr PrintSettings00](self.impl))

proc pageSet*(self: PrintSettings): PageSet =
  gtk_print_settings_get_page_set(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_paper_height*(self: ptr PrintSettings00; unit: Unit): cdouble {.
    importc: "gtk_print_settings_get_paper_height", libprag.}

proc getPaperHeight*(self: PrintSettings; unit: Unit): cdouble =
  gtk_print_settings_get_paper_height(cast[ptr PrintSettings00](self.impl), unit)

proc paperHeight*(self: PrintSettings; unit: Unit): cdouble =
  gtk_print_settings_get_paper_height(cast[ptr PrintSettings00](self.impl), unit)

proc gtk_print_settings_get_paper_size*(self: ptr PrintSettings00): ptr PaperSize00 {.
    importc: "gtk_print_settings_get_paper_size", libprag.}

proc getPaperSize*(self: PrintSettings): PaperSize =
  new(result)
  result.impl = gtk_print_settings_get_paper_size(cast[ptr PrintSettings00](self.impl))

proc paperSize*(self: PrintSettings): PaperSize =
  new(result)
  result.impl = gtk_print_settings_get_paper_size(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_paper_width*(self: ptr PrintSettings00; unit: Unit): cdouble {.
    importc: "gtk_print_settings_get_paper_width", libprag.}

proc getPaperWidth*(self: PrintSettings; unit: Unit): cdouble =
  gtk_print_settings_get_paper_width(cast[ptr PrintSettings00](self.impl), unit)

proc paperWidth*(self: PrintSettings; unit: Unit): cdouble =
  gtk_print_settings_get_paper_width(cast[ptr PrintSettings00](self.impl), unit)

proc gtk_print_settings_get_printer*(self: ptr PrintSettings00): cstring {.
    importc: "gtk_print_settings_get_printer", libprag.}

proc getPrinter*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_printer(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc printer*(self: PrintSettings): string =
  let resul0 = gtk_print_settings_get_printer(cast[ptr PrintSettings00](self.impl))
  result = $resul0

proc gtk_print_settings_get_printer_lpi*(self: ptr PrintSettings00): cdouble {.
    importc: "gtk_print_settings_get_printer_lpi", libprag.}

proc getPrinterLpi*(self: PrintSettings): cdouble =
  gtk_print_settings_get_printer_lpi(cast[ptr PrintSettings00](self.impl))

proc printerLpi*(self: PrintSettings): cdouble =
  gtk_print_settings_get_printer_lpi(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_resolution*(self: ptr PrintSettings00): int32 {.
    importc: "gtk_print_settings_get_resolution", libprag.}

proc getResolution*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution(cast[ptr PrintSettings00](self.impl)))

proc resolution*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_resolution_x*(self: ptr PrintSettings00): int32 {.
    importc: "gtk_print_settings_get_resolution_x", libprag.}

proc getResolutionX*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_x(cast[ptr PrintSettings00](self.impl)))

proc resolutionX*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_x(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_resolution_y*(self: ptr PrintSettings00): int32 {.
    importc: "gtk_print_settings_get_resolution_y", libprag.}

proc getResolutionY*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_y(cast[ptr PrintSettings00](self.impl)))

proc resolutionY*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_y(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_reverse*(self: ptr PrintSettings00): gboolean {.
    importc: "gtk_print_settings_get_reverse", libprag.}

proc getReverse*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_reverse(cast[ptr PrintSettings00](self.impl)))

proc reverse*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_reverse(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_scale*(self: ptr PrintSettings00): cdouble {.
    importc: "gtk_print_settings_get_scale", libprag.}

proc getScale*(self: PrintSettings): cdouble =
  gtk_print_settings_get_scale(cast[ptr PrintSettings00](self.impl))

proc scale*(self: PrintSettings): cdouble =
  gtk_print_settings_get_scale(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_use_color*(self: ptr PrintSettings00): gboolean {.
    importc: "gtk_print_settings_get_use_color", libprag.}

proc getUseColor*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_use_color(cast[ptr PrintSettings00](self.impl)))

proc useColor*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_use_color(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_has_key*(self: ptr PrintSettings00; key: cstring): gboolean {.
    importc: "gtk_print_settings_has_key", libprag.}

proc hasKey*(self: PrintSettings; key: string): bool =
  toBool(gtk_print_settings_has_key(cast[ptr PrintSettings00](self.impl), cstring(key)))

proc gtk_print_settings_load_file*(self: ptr PrintSettings00; fileName: ucstring): gboolean {.
    importc: "gtk_print_settings_load_file", libprag.}

proc loadFile*(self: PrintSettings; fileName: ucstring): bool =
  toBool(gtk_print_settings_load_file(cast[ptr PrintSettings00](self.impl), fileName))

proc gtk_print_settings_load_key_file*(self: ptr PrintSettings00; keyFile: ptr glib.KeyFile00; 
    groupName: cstring): gboolean {.
    importc: "gtk_print_settings_load_key_file", libprag.}

proc loadKeyFile*(self: PrintSettings; keyFile: glib.KeyFile; groupName: string): bool =
  toBool(gtk_print_settings_load_key_file(cast[ptr PrintSettings00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName)))

proc gtk_print_settings_set*(self: ptr PrintSettings00; key: cstring; value: cstring) {.
    importc: "gtk_print_settings_set", libprag.}

proc set*(self: PrintSettings; key: string; value: string) =
  gtk_print_settings_set(cast[ptr PrintSettings00](self.impl), cstring(key), cstring(value))

proc gtk_print_settings_set_bool*(self: ptr PrintSettings00; key: cstring; value: gboolean) {.
    importc: "gtk_print_settings_set_bool", libprag.}

proc setBool*(self: PrintSettings; key: string; value: bool) =
  gtk_print_settings_set_bool(cast[ptr PrintSettings00](self.impl), cstring(key), gboolean(value))

proc gtk_print_settings_set_collate*(self: ptr PrintSettings00; collate: gboolean) {.
    importc: "gtk_print_settings_set_collate", libprag.}

proc setCollate*(self: PrintSettings; collate: bool) =
  gtk_print_settings_set_collate(cast[ptr PrintSettings00](self.impl), gboolean(collate))

proc `collate=`*(self: PrintSettings; collate: bool) =
  gtk_print_settings_set_collate(cast[ptr PrintSettings00](self.impl), gboolean(collate))

proc gtk_print_settings_set_default_source*(self: ptr PrintSettings00; defaultSource: cstring) {.
    importc: "gtk_print_settings_set_default_source", libprag.}

proc setDefaultSource*(self: PrintSettings; defaultSource: string) =
  gtk_print_settings_set_default_source(cast[ptr PrintSettings00](self.impl), cstring(defaultSource))

proc `defaultSource=`*(self: PrintSettings; defaultSource: string) =
  gtk_print_settings_set_default_source(cast[ptr PrintSettings00](self.impl), cstring(defaultSource))

proc gtk_print_settings_set_dither*(self: ptr PrintSettings00; dither: cstring) {.
    importc: "gtk_print_settings_set_dither", libprag.}

proc setDither*(self: PrintSettings; dither: string) =
  gtk_print_settings_set_dither(cast[ptr PrintSettings00](self.impl), cstring(dither))

proc `dither=`*(self: PrintSettings; dither: string) =
  gtk_print_settings_set_dither(cast[ptr PrintSettings00](self.impl), cstring(dither))

proc gtk_print_settings_set_double*(self: ptr PrintSettings00; key: cstring; value: cdouble) {.
    importc: "gtk_print_settings_set_double", libprag.}

proc setDouble*(self: PrintSettings; key: string; value: cdouble) =
  gtk_print_settings_set_double(cast[ptr PrintSettings00](self.impl), cstring(key), value)

proc gtk_print_settings_set_duplex*(self: ptr PrintSettings00; duplex: PrintDuplex) {.
    importc: "gtk_print_settings_set_duplex", libprag.}

proc setDuplex*(self: PrintSettings; duplex: PrintDuplex) =
  gtk_print_settings_set_duplex(cast[ptr PrintSettings00](self.impl), duplex)

proc `duplex=`*(self: PrintSettings; duplex: PrintDuplex) =
  gtk_print_settings_set_duplex(cast[ptr PrintSettings00](self.impl), duplex)

proc gtk_print_settings_set_finishings*(self: ptr PrintSettings00; finishings: cstring) {.
    importc: "gtk_print_settings_set_finishings", libprag.}

proc setFinishings*(self: PrintSettings; finishings: string) =
  gtk_print_settings_set_finishings(cast[ptr PrintSettings00](self.impl), cstring(finishings))

proc `finishings=`*(self: PrintSettings; finishings: string) =
  gtk_print_settings_set_finishings(cast[ptr PrintSettings00](self.impl), cstring(finishings))

proc gtk_print_settings_set_int*(self: ptr PrintSettings00; key: cstring; value: int32) {.
    importc: "gtk_print_settings_set_int", libprag.}

proc setInt*(self: PrintSettings; key: string; value: int) =
  gtk_print_settings_set_int(cast[ptr PrintSettings00](self.impl), cstring(key), int32(value))

proc gtk_print_settings_set_length*(self: ptr PrintSettings00; key: cstring; value: cdouble; 
    unit: Unit) {.
    importc: "gtk_print_settings_set_length", libprag.}

proc setLength*(self: PrintSettings; key: string; value: cdouble; 
    unit: Unit) =
  gtk_print_settings_set_length(cast[ptr PrintSettings00](self.impl), cstring(key), value, unit)

proc gtk_print_settings_set_media_type*(self: ptr PrintSettings00; mediaType: cstring) {.
    importc: "gtk_print_settings_set_media_type", libprag.}

proc setMediaType*(self: PrintSettings; mediaType: string) =
  gtk_print_settings_set_media_type(cast[ptr PrintSettings00](self.impl), cstring(mediaType))

proc `mediaType=`*(self: PrintSettings; mediaType: string) =
  gtk_print_settings_set_media_type(cast[ptr PrintSettings00](self.impl), cstring(mediaType))

proc gtk_print_settings_set_n_copies*(self: ptr PrintSettings00; numCopies: int32) {.
    importc: "gtk_print_settings_set_n_copies", libprag.}

proc setNCopies*(self: PrintSettings; numCopies: int) =
  gtk_print_settings_set_n_copies(cast[ptr PrintSettings00](self.impl), int32(numCopies))

proc `nCopies=`*(self: PrintSettings; numCopies: int) =
  gtk_print_settings_set_n_copies(cast[ptr PrintSettings00](self.impl), int32(numCopies))

proc gtk_print_settings_set_number_up*(self: ptr PrintSettings00; numberUp: int32) {.
    importc: "gtk_print_settings_set_number_up", libprag.}

proc setNumberUp*(self: PrintSettings; numberUp: int) =
  gtk_print_settings_set_number_up(cast[ptr PrintSettings00](self.impl), int32(numberUp))

proc `numberUp=`*(self: PrintSettings; numberUp: int) =
  gtk_print_settings_set_number_up(cast[ptr PrintSettings00](self.impl), int32(numberUp))

proc gtk_print_settings_set_number_up_layout*(self: ptr PrintSettings00; numberUpLayout: NumberUpLayout) {.
    importc: "gtk_print_settings_set_number_up_layout", libprag.}

proc setNumberUpLayout*(self: PrintSettings; numberUpLayout: NumberUpLayout) =
  gtk_print_settings_set_number_up_layout(cast[ptr PrintSettings00](self.impl), numberUpLayout)

proc `numberUpLayout=`*(self: PrintSettings; numberUpLayout: NumberUpLayout) =
  gtk_print_settings_set_number_up_layout(cast[ptr PrintSettings00](self.impl), numberUpLayout)

proc gtk_print_settings_set_orientation*(self: ptr PrintSettings00; orientation: PageOrientation) {.
    importc: "gtk_print_settings_set_orientation", libprag.}

proc setOrientation*(self: PrintSettings; orientation: PageOrientation) =
  gtk_print_settings_set_orientation(cast[ptr PrintSettings00](self.impl), orientation)

proc `orientation=`*(self: PrintSettings; orientation: PageOrientation) =
  gtk_print_settings_set_orientation(cast[ptr PrintSettings00](self.impl), orientation)

proc gtk_print_settings_set_output_bin*(self: ptr PrintSettings00; outputBin: cstring) {.
    importc: "gtk_print_settings_set_output_bin", libprag.}

proc setOutputBin*(self: PrintSettings; outputBin: string) =
  gtk_print_settings_set_output_bin(cast[ptr PrintSettings00](self.impl), cstring(outputBin))

proc `outputBin=`*(self: PrintSettings; outputBin: string) =
  gtk_print_settings_set_output_bin(cast[ptr PrintSettings00](self.impl), cstring(outputBin))

proc gtk_print_settings_set_page_ranges*(self: ptr PrintSettings00; pageRanges: PageRange00Array; 
    numRanges: int32) {.
    importc: "gtk_print_settings_set_page_ranges", libprag.}

proc setPageRanges*(self: PrintSettings; pageRanges: PageRange00Array; 
    numRanges: int) =
  gtk_print_settings_set_page_ranges(cast[ptr PrintSettings00](self.impl), pageRanges, int32(numRanges))

proc gtk_print_settings_set_page_set*(self: ptr PrintSettings00; pageSet: PageSet) {.
    importc: "gtk_print_settings_set_page_set", libprag.}

proc setPageSet*(self: PrintSettings; pageSet: PageSet) =
  gtk_print_settings_set_page_set(cast[ptr PrintSettings00](self.impl), pageSet)

proc `pageSet=`*(self: PrintSettings; pageSet: PageSet) =
  gtk_print_settings_set_page_set(cast[ptr PrintSettings00](self.impl), pageSet)

proc gtk_print_settings_set_paper_height*(self: ptr PrintSettings00; height: cdouble; unit: Unit) {.
    importc: "gtk_print_settings_set_paper_height", libprag.}

proc setPaperHeight*(self: PrintSettings; height: cdouble; unit: Unit) =
  gtk_print_settings_set_paper_height(cast[ptr PrintSettings00](self.impl), height, unit)

proc gtk_print_settings_set_paper_size*(self: ptr PrintSettings00; paperSize: ptr PaperSize00) {.
    importc: "gtk_print_settings_set_paper_size", libprag.}

proc setPaperSize*(self: PrintSettings; paperSize: PaperSize) =
  gtk_print_settings_set_paper_size(cast[ptr PrintSettings00](self.impl), cast[ptr PaperSize00](paperSize.impl))

proc `paperSize=`*(self: PrintSettings; paperSize: PaperSize) =
  gtk_print_settings_set_paper_size(cast[ptr PrintSettings00](self.impl), cast[ptr PaperSize00](paperSize.impl))

proc gtk_print_settings_set_paper_width*(self: ptr PrintSettings00; width: cdouble; unit: Unit) {.
    importc: "gtk_print_settings_set_paper_width", libprag.}

proc setPaperWidth*(self: PrintSettings; width: cdouble; unit: Unit) =
  gtk_print_settings_set_paper_width(cast[ptr PrintSettings00](self.impl), width, unit)

proc gtk_print_settings_set_printer*(self: ptr PrintSettings00; printer: cstring) {.
    importc: "gtk_print_settings_set_printer", libprag.}

proc setPrinter*(self: PrintSettings; printer: string) =
  gtk_print_settings_set_printer(cast[ptr PrintSettings00](self.impl), cstring(printer))

proc `printer=`*(self: PrintSettings; printer: string) =
  gtk_print_settings_set_printer(cast[ptr PrintSettings00](self.impl), cstring(printer))

proc gtk_print_settings_set_printer_lpi*(self: ptr PrintSettings00; lpi: cdouble) {.
    importc: "gtk_print_settings_set_printer_lpi", libprag.}

proc setPrinterLpi*(self: PrintSettings; lpi: cdouble) =
  gtk_print_settings_set_printer_lpi(cast[ptr PrintSettings00](self.impl), lpi)

proc `printerLpi=`*(self: PrintSettings; lpi: cdouble) =
  gtk_print_settings_set_printer_lpi(cast[ptr PrintSettings00](self.impl), lpi)

proc gtk_print_settings_set_resolution*(self: ptr PrintSettings00; resolution: int32) {.
    importc: "gtk_print_settings_set_resolution", libprag.}

proc setResolution*(self: PrintSettings; resolution: int) =
  gtk_print_settings_set_resolution(cast[ptr PrintSettings00](self.impl), int32(resolution))

proc `resolution=`*(self: PrintSettings; resolution: int) =
  gtk_print_settings_set_resolution(cast[ptr PrintSettings00](self.impl), int32(resolution))

proc gtk_print_settings_set_resolution_xy*(self: ptr PrintSettings00; resolutionX: int32; resolutionY: int32) {.
    importc: "gtk_print_settings_set_resolution_xy", libprag.}

proc setResolutionXy*(self: PrintSettings; resolutionX: int; resolutionY: int) =
  gtk_print_settings_set_resolution_xy(cast[ptr PrintSettings00](self.impl), int32(resolutionX), int32(resolutionY))

proc gtk_print_settings_set_reverse*(self: ptr PrintSettings00; reverse: gboolean) {.
    importc: "gtk_print_settings_set_reverse", libprag.}

proc setReverse*(self: PrintSettings; reverse: bool) =
  gtk_print_settings_set_reverse(cast[ptr PrintSettings00](self.impl), gboolean(reverse))

proc `reverse=`*(self: PrintSettings; reverse: bool) =
  gtk_print_settings_set_reverse(cast[ptr PrintSettings00](self.impl), gboolean(reverse))

proc gtk_print_settings_set_scale*(self: ptr PrintSettings00; scale: cdouble) {.
    importc: "gtk_print_settings_set_scale", libprag.}

proc setScale*(self: PrintSettings; scale: cdouble) =
  gtk_print_settings_set_scale(cast[ptr PrintSettings00](self.impl), scale)

proc `scale=`*(self: PrintSettings; scale: cdouble) =
  gtk_print_settings_set_scale(cast[ptr PrintSettings00](self.impl), scale)

proc gtk_print_settings_set_use_color*(self: ptr PrintSettings00; useColor: gboolean) {.
    importc: "gtk_print_settings_set_use_color", libprag.}

proc setUseColor*(self: PrintSettings; useColor: bool) =
  gtk_print_settings_set_use_color(cast[ptr PrintSettings00](self.impl), gboolean(useColor))

proc `useColor=`*(self: PrintSettings; useColor: bool) =
  gtk_print_settings_set_use_color(cast[ptr PrintSettings00](self.impl), gboolean(useColor))

proc gtk_print_settings_to_file*(self: ptr PrintSettings00; fileName: ucstring): gboolean {.
    importc: "gtk_print_settings_to_file", libprag.}

proc toFile*(self: PrintSettings; fileName: ucstring): bool =
  toBool(gtk_print_settings_to_file(cast[ptr PrintSettings00](self.impl), fileName))

proc gtk_print_settings_to_gvariant*(self: ptr PrintSettings00): ptr glib.Variant00 {.
    importc: "gtk_print_settings_to_gvariant", libprag.}

proc toGvariant*(self: PrintSettings): glib.Variant =
  new(result)
  result.impl = gtk_print_settings_to_gvariant(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_to_key_file*(self: ptr PrintSettings00; keyFile: ptr glib.KeyFile00; 
    groupName: cstring) {.
    importc: "gtk_print_settings_to_key_file", libprag.}

proc toKeyFile*(self: PrintSettings; keyFile: glib.KeyFile; groupName: string) =
  gtk_print_settings_to_key_file(cast[ptr PrintSettings00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), cstring(groupName))

proc gtk_print_settings_unset*(self: ptr PrintSettings00; key: cstring) {.
    importc: "gtk_print_settings_unset", libprag.}

proc unset*(self: PrintSettings; key: string) =
  gtk_print_settings_unset(cast[ptr PrintSettings00](self.impl), cstring(key))

type
  PrintOperation* = ref object of gobject.Object
  PrintOperation00* = object of gobject.Object00
    priv1: ptr PrintOperationPrivate00

proc scBeginPrint*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; context: PrintContext00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "begin-print", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCreateCustomWidget*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; xdata: pointer): gobject.Object00 {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "create-custom-widget", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCustomWidgetApply*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; widget: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "custom-widget-apply", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDone*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; resu: PrintOperationResult; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "done", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDrawPage*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; context: PrintContext00; pageNr: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "draw-page", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scEndPrint*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; context: PrintContext00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "end-print", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPaginate*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; context: PrintContext00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "paginate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPreview*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; preview: PrintOperationPreview00; context: PrintContext00; 
    parent: Window00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "preview", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRequestPageSetup*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; context: PrintContext00; pageNr: int32; setup: PageSetup00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "request-page-setup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStatusChanged*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "status-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUpdateCustomWidget*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; widget: Widget00; setup: PageSetup00; settings: PrintSettings00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "update-custom-widget", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_print_operation_new*(): ptr PrintOperation00 {.
    importc: "gtk_print_operation_new", libprag.}

proc newPrintOperation*(): PrintOperation =
  new(result, finalizeGObject)
  result.impl = gtk_print_operation_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintOperation*[T](result: var T) =
  assert(result is PrintOperation)
  new(result, finalizeGObject)
  result.impl = gtk_print_operation_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_operation_cancel*(self: ptr PrintOperation00) {.
    importc: "gtk_print_operation_cancel", libprag.}

proc cancel*(self: PrintOperation) =
  gtk_print_operation_cancel(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_draw_page_finish*(self: ptr PrintOperation00) {.
    importc: "gtk_print_operation_draw_page_finish", libprag.}

proc drawPageFinish*(self: PrintOperation) =
  gtk_print_operation_draw_page_finish(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_get_default_page_setup*(self: ptr PrintOperation00): ptr PageSetup00 {.
    importc: "gtk_print_operation_get_default_page_setup", libprag.}

proc getDefaultPageSetup*(self: PrintOperation): PageSetup =
  let gobj = gtk_print_operation_get_default_page_setup(cast[ptr PrintOperation00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[PageSetup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultPageSetup*(self: PrintOperation): PageSetup =
  let gobj = gtk_print_operation_get_default_page_setup(cast[ptr PrintOperation00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[PageSetup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_operation_get_embed_page_setup*(self: ptr PrintOperation00): gboolean {.
    importc: "gtk_print_operation_get_embed_page_setup", libprag.}

proc getEmbedPageSetup*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_embed_page_setup(cast[ptr PrintOperation00](self.impl)))

proc embedPageSetup*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_embed_page_setup(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_get_error*(self: ptr PrintOperation00) {.
    importc: "gtk_print_operation_get_error", libprag.}

proc getError*(self: PrintOperation) =
  gtk_print_operation_get_error(cast[ptr PrintOperation00](self.impl))

proc error*(self: PrintOperation) =
  gtk_print_operation_get_error(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_get_has_selection*(self: ptr PrintOperation00): gboolean {.
    importc: "gtk_print_operation_get_has_selection", libprag.}

proc getHasSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_has_selection(cast[ptr PrintOperation00](self.impl)))

proc hasSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_has_selection(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_get_n_pages_to_print*(self: ptr PrintOperation00): int32 {.
    importc: "gtk_print_operation_get_n_pages_to_print", libprag.}

proc getNPagesToPrint*(self: PrintOperation): int =
  int(gtk_print_operation_get_n_pages_to_print(cast[ptr PrintOperation00](self.impl)))

proc nPagesToPrint*(self: PrintOperation): int =
  int(gtk_print_operation_get_n_pages_to_print(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_get_print_settings*(self: ptr PrintOperation00): ptr PrintSettings00 {.
    importc: "gtk_print_operation_get_print_settings", libprag.}

proc getPrintSettings*(self: PrintOperation): PrintSettings =
  let gobj = gtk_print_operation_get_print_settings(cast[ptr PrintOperation00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[PrintSettings](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc printSettings*(self: PrintOperation): PrintSettings =
  let gobj = gtk_print_operation_get_print_settings(cast[ptr PrintOperation00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[PrintSettings](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_operation_get_status_string*(self: ptr PrintOperation00): cstring {.
    importc: "gtk_print_operation_get_status_string", libprag.}

proc getStatusString*(self: PrintOperation): string =
  let resul0 = gtk_print_operation_get_status_string(cast[ptr PrintOperation00](self.impl))
  result = $resul0

proc statusString*(self: PrintOperation): string =
  let resul0 = gtk_print_operation_get_status_string(cast[ptr PrintOperation00](self.impl))
  result = $resul0

proc gtk_print_operation_get_support_selection*(self: ptr PrintOperation00): gboolean {.
    importc: "gtk_print_operation_get_support_selection", libprag.}

proc getSupportSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_support_selection(cast[ptr PrintOperation00](self.impl)))

proc supportSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_support_selection(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_is_finished*(self: ptr PrintOperation00): gboolean {.
    importc: "gtk_print_operation_is_finished", libprag.}

proc isFinished*(self: PrintOperation): bool =
  toBool(gtk_print_operation_is_finished(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_set_allow_async*(self: ptr PrintOperation00; allowAsync: gboolean) {.
    importc: "gtk_print_operation_set_allow_async", libprag.}

proc setAllowAsync*(self: PrintOperation; allowAsync: bool) =
  gtk_print_operation_set_allow_async(cast[ptr PrintOperation00](self.impl), gboolean(allowAsync))

proc `allowAsync=`*(self: PrintOperation; allowAsync: bool) =
  gtk_print_operation_set_allow_async(cast[ptr PrintOperation00](self.impl), gboolean(allowAsync))

proc gtk_print_operation_set_current_page*(self: ptr PrintOperation00; currentPage: int32) {.
    importc: "gtk_print_operation_set_current_page", libprag.}

proc setCurrentPage*(self: PrintOperation; currentPage: int) =
  gtk_print_operation_set_current_page(cast[ptr PrintOperation00](self.impl), int32(currentPage))

proc `currentPage=`*(self: PrintOperation; currentPage: int) =
  gtk_print_operation_set_current_page(cast[ptr PrintOperation00](self.impl), int32(currentPage))

proc gtk_print_operation_set_custom_tab_label*(self: ptr PrintOperation00; label: cstring) {.
    importc: "gtk_print_operation_set_custom_tab_label", libprag.}

proc setCustomTabLabel*(self: PrintOperation; label: string) =
  gtk_print_operation_set_custom_tab_label(cast[ptr PrintOperation00](self.impl), cstring(label))

proc `customTabLabel=`*(self: PrintOperation; label: string) =
  gtk_print_operation_set_custom_tab_label(cast[ptr PrintOperation00](self.impl), cstring(label))

proc gtk_print_operation_set_default_page_setup*(self: ptr PrintOperation00; defaultPageSetup: ptr PageSetup00) {.
    importc: "gtk_print_operation_set_default_page_setup", libprag.}

proc setDefaultPageSetup*(self: PrintOperation; defaultPageSetup: PageSetup) =
  gtk_print_operation_set_default_page_setup(cast[ptr PrintOperation00](self.impl), cast[ptr PageSetup00](defaultPageSetup.impl))

proc `defaultPageSetup=`*(self: PrintOperation; defaultPageSetup: PageSetup) =
  gtk_print_operation_set_default_page_setup(cast[ptr PrintOperation00](self.impl), cast[ptr PageSetup00](defaultPageSetup.impl))

proc gtk_print_operation_set_defer_drawing*(self: ptr PrintOperation00) {.
    importc: "gtk_print_operation_set_defer_drawing", libprag.}

proc setDeferDrawing*(self: PrintOperation) =
  gtk_print_operation_set_defer_drawing(cast[ptr PrintOperation00](self.impl))

proc `deferDrawing=`*(self: PrintOperation) =
  gtk_print_operation_set_defer_drawing(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_set_embed_page_setup*(self: ptr PrintOperation00; embed: gboolean) {.
    importc: "gtk_print_operation_set_embed_page_setup", libprag.}

proc setEmbedPageSetup*(self: PrintOperation; embed: bool) =
  gtk_print_operation_set_embed_page_setup(cast[ptr PrintOperation00](self.impl), gboolean(embed))

proc `embedPageSetup=`*(self: PrintOperation; embed: bool) =
  gtk_print_operation_set_embed_page_setup(cast[ptr PrintOperation00](self.impl), gboolean(embed))

proc gtk_print_operation_set_export_filename*(self: ptr PrintOperation00; filename: ucstring) {.
    importc: "gtk_print_operation_set_export_filename", libprag.}

proc setExportFilename*(self: PrintOperation; filename: ucstring) =
  gtk_print_operation_set_export_filename(cast[ptr PrintOperation00](self.impl), filename)

proc `exportFilename=`*(self: PrintOperation; filename: ucstring) =
  gtk_print_operation_set_export_filename(cast[ptr PrintOperation00](self.impl), filename)

proc gtk_print_operation_set_has_selection*(self: ptr PrintOperation00; hasSelection: gboolean) {.
    importc: "gtk_print_operation_set_has_selection", libprag.}

proc setHasSelection*(self: PrintOperation; hasSelection: bool) =
  gtk_print_operation_set_has_selection(cast[ptr PrintOperation00](self.impl), gboolean(hasSelection))

proc `hasSelection=`*(self: PrintOperation; hasSelection: bool) =
  gtk_print_operation_set_has_selection(cast[ptr PrintOperation00](self.impl), gboolean(hasSelection))

proc gtk_print_operation_set_job_name*(self: ptr PrintOperation00; jobName: cstring) {.
    importc: "gtk_print_operation_set_job_name", libprag.}

proc setJobName*(self: PrintOperation; jobName: string) =
  gtk_print_operation_set_job_name(cast[ptr PrintOperation00](self.impl), cstring(jobName))

proc `jobName=`*(self: PrintOperation; jobName: string) =
  gtk_print_operation_set_job_name(cast[ptr PrintOperation00](self.impl), cstring(jobName))

proc gtk_print_operation_set_n_pages*(self: ptr PrintOperation00; nPages: int32) {.
    importc: "gtk_print_operation_set_n_pages", libprag.}

proc setNPages*(self: PrintOperation; nPages: int) =
  gtk_print_operation_set_n_pages(cast[ptr PrintOperation00](self.impl), int32(nPages))

proc `nPages=`*(self: PrintOperation; nPages: int) =
  gtk_print_operation_set_n_pages(cast[ptr PrintOperation00](self.impl), int32(nPages))

proc gtk_print_operation_set_print_settings*(self: ptr PrintOperation00; printSettings: ptr PrintSettings00) {.
    importc: "gtk_print_operation_set_print_settings", libprag.}

proc setPrintSettings*(self: PrintOperation; printSettings: PrintSettings) =
  gtk_print_operation_set_print_settings(cast[ptr PrintOperation00](self.impl), cast[ptr PrintSettings00](printSettings.impl))

proc `printSettings=`*(self: PrintOperation; printSettings: PrintSettings) =
  gtk_print_operation_set_print_settings(cast[ptr PrintOperation00](self.impl), cast[ptr PrintSettings00](printSettings.impl))

proc gtk_print_operation_set_show_progress*(self: ptr PrintOperation00; showProgress: gboolean) {.
    importc: "gtk_print_operation_set_show_progress", libprag.}

proc setShowProgress*(self: PrintOperation; showProgress: bool) =
  gtk_print_operation_set_show_progress(cast[ptr PrintOperation00](self.impl), gboolean(showProgress))

proc `showProgress=`*(self: PrintOperation; showProgress: bool) =
  gtk_print_operation_set_show_progress(cast[ptr PrintOperation00](self.impl), gboolean(showProgress))

proc gtk_print_operation_set_support_selection*(self: ptr PrintOperation00; supportSelection: gboolean) {.
    importc: "gtk_print_operation_set_support_selection", libprag.}

proc setSupportSelection*(self: PrintOperation; supportSelection: bool) =
  gtk_print_operation_set_support_selection(cast[ptr PrintOperation00](self.impl), gboolean(supportSelection))

proc `supportSelection=`*(self: PrintOperation; supportSelection: bool) =
  gtk_print_operation_set_support_selection(cast[ptr PrintOperation00](self.impl), gboolean(supportSelection))

proc gtk_print_operation_set_track_print_status*(self: ptr PrintOperation00; trackStatus: gboolean) {.
    importc: "gtk_print_operation_set_track_print_status", libprag.}

proc setTrackPrintStatus*(self: PrintOperation; trackStatus: bool) =
  gtk_print_operation_set_track_print_status(cast[ptr PrintOperation00](self.impl), gboolean(trackStatus))

proc `trackPrintStatus=`*(self: PrintOperation; trackStatus: bool) =
  gtk_print_operation_set_track_print_status(cast[ptr PrintOperation00](self.impl), gboolean(trackStatus))

proc gtk_print_operation_set_unit*(self: ptr PrintOperation00; unit: Unit) {.
    importc: "gtk_print_operation_set_unit", libprag.}

proc setUnit*(self: PrintOperation; unit: Unit) =
  gtk_print_operation_set_unit(cast[ptr PrintOperation00](self.impl), unit)

proc `unit=`*(self: PrintOperation; unit: Unit) =
  gtk_print_operation_set_unit(cast[ptr PrintOperation00](self.impl), unit)

proc gtk_print_operation_set_use_full_page*(self: ptr PrintOperation00; fullPage: gboolean) {.
    importc: "gtk_print_operation_set_use_full_page", libprag.}

proc setUseFullPage*(self: PrintOperation; fullPage: bool) =
  gtk_print_operation_set_use_full_page(cast[ptr PrintOperation00](self.impl), gboolean(fullPage))

proc `useFullPage=`*(self: PrintOperation; fullPage: bool) =
  gtk_print_operation_set_use_full_page(cast[ptr PrintOperation00](self.impl), gboolean(fullPage))

type
  PrintPages* {.size: sizeof(cint), pure.} = enum
    all = 0
    current = 1
    ranges = 2
    selection = 3

proc gtk_print_settings_get_print_pages*(self: ptr PrintSettings00): PrintPages {.
    importc: "gtk_print_settings_get_print_pages", libprag.}

proc getPrintPages*(self: PrintSettings): PrintPages =
  gtk_print_settings_get_print_pages(cast[ptr PrintSettings00](self.impl))

proc printPages*(self: PrintSettings): PrintPages =
  gtk_print_settings_get_print_pages(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_set_print_pages*(self: ptr PrintSettings00; pages: PrintPages) {.
    importc: "gtk_print_settings_set_print_pages", libprag.}

proc setPrintPages*(self: PrintSettings; pages: PrintPages) =
  gtk_print_settings_set_print_pages(cast[ptr PrintSettings00](self.impl), pages)

proc `printPages=`*(self: PrintSettings; pages: PrintPages) =
  gtk_print_settings_set_print_pages(cast[ptr PrintSettings00](self.impl), pages)

type
  PrintQuality* {.size: sizeof(cint), pure.} = enum
    low = 0
    normal = 1
    high = 2
    draft = 3

proc gtk_print_settings_get_quality*(self: ptr PrintSettings00): PrintQuality {.
    importc: "gtk_print_settings_get_quality", libprag.}

proc getQuality*(self: PrintSettings): PrintQuality =
  gtk_print_settings_get_quality(cast[ptr PrintSettings00](self.impl))

proc quality*(self: PrintSettings): PrintQuality =
  gtk_print_settings_get_quality(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_set_quality*(self: ptr PrintSettings00; quality: PrintQuality) {.
    importc: "gtk_print_settings_set_quality", libprag.}

proc setQuality*(self: PrintSettings; quality: PrintQuality) =
  gtk_print_settings_set_quality(cast[ptr PrintSettings00](self.impl), quality)

proc `quality=`*(self: PrintSettings; quality: PrintQuality) =
  gtk_print_settings_set_quality(cast[ptr PrintSettings00](self.impl), quality)

type
  PrintStatus* {.size: sizeof(cint), pure.} = enum
    initial = 0
    preparing = 1
    generatingData = 2
    sendingData = 3
    pending = 4
    pendingIssue = 5
    printing = 6
    finished = 7
    finishedAborted = 8

proc gtk_print_operation_get_status*(self: ptr PrintOperation00): PrintStatus {.
    importc: "gtk_print_operation_get_status", libprag.}

proc getStatus*(self: PrintOperation): PrintStatus =
  gtk_print_operation_get_status(cast[ptr PrintOperation00](self.impl))

proc status*(self: PrintOperation): PrintStatus =
  gtk_print_operation_get_status(cast[ptr PrintOperation00](self.impl))

type
  PrintOperationAction* {.size: sizeof(cint), pure.} = enum
    printDialog = 0
    print = 1
    preview = 2
    `export` = 3

proc gtk_print_operation_run*(self: ptr PrintOperation00; action: PrintOperationAction; 
    parent: ptr Window00): PrintOperationResult {.
    importc: "gtk_print_operation_run", libprag.}

proc run*(self: PrintOperation; action: PrintOperationAction; 
    parent: Window): PrintOperationResult =
  gtk_print_operation_run(cast[ptr PrintOperation00](self.impl), action, cast[ptr Window00](parent.impl))

type
  PrintOperationClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    done*: proc(operation: ptr PrintOperation00; resu: PrintOperationResult) {.cdecl.}
    beginPrint*: proc(operation: ptr PrintOperation00; context: ptr PrintContext00) {.cdecl.}
    paginate*: proc(operation: ptr PrintOperation00; context: ptr PrintContext00): gboolean {.cdecl.}
    requestPageSetup*: proc(operation: ptr PrintOperation00; context: ptr PrintContext00; 
    pageNr: int32; setup: ptr PageSetup00) {.cdecl.}
    drawPage*: proc(operation: ptr PrintOperation00; context: ptr PrintContext00; 
    pageNr: int32) {.cdecl.}
    endPrint*: proc(operation: ptr PrintOperation00; context: ptr PrintContext00) {.cdecl.}
    statusChanged*: proc(operation: ptr PrintOperation00) {.cdecl.}
    createCustomWidget*: pointer
    customWidgetApply*: proc(operation: ptr PrintOperation00; widget: ptr Widget00) {.cdecl.}
    preview*: proc(operation: ptr PrintOperation00; preview: ptr PrintOperationPreview00; 
    context: ptr PrintContext00; parent: ptr Window00): gboolean {.cdecl.}
    updateCustomWidget*: proc(operation: ptr PrintOperation00; widget: ptr Widget00; 
    setup: ptr PageSetup00; settings: ptr PrintSettings00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  PrintOperationClass* = ref object
    impl*: ptr PrintOperationClass00

type
  PrintOperationPreviewIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    ready*: proc(preview: ptr PrintOperationPreview00; context: ptr PrintContext00) {.cdecl.}
    gotPageSize*: proc(preview: ptr PrintOperationPreview00; context: ptr PrintContext00; 
    pageSetup: ptr PageSetup00) {.cdecl.}
    renderPage*: proc(preview: ptr PrintOperationPreview00; pageNr: int32) {.cdecl.}
    isSelected*: proc(preview: ptr PrintOperationPreview00; pageNr: int32): gboolean {.cdecl.}
    endPreview*: proc(preview: ptr PrintOperationPreview00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  PrintOperationPreviewIface* = ref object
    impl*: ptr PrintOperationPreviewIface00

type
  PrintSettingsFunc* = proc (key: cstring; value: cstring; userData: pointer) {.cdecl.}

proc gtk_print_settings_foreach*(self: ptr PrintSettings00; `func`: PrintSettingsFunc; 
    userData: pointer) {.
    importc: "gtk_print_settings_foreach", libprag.}

proc foreach*(self: PrintSettings; `func`: PrintSettingsFunc; userData: pointer) =
  gtk_print_settings_foreach(cast[ptr PrintSettings00](self.impl), `func`, userData)

type
  ProgressBarPrivate00* {.pure.} = object
  ProgressBarPrivate* = ref object
    impl*: ptr ProgressBarPrivate00

type
  ProgressBar* = ref object of Widget
  ProgressBar00* = object of Widget00
    priv2: ptr ProgressBarPrivate00

proc gtk_progress_bar_new*(): ptr ProgressBar00 {.
    importc: "gtk_progress_bar_new", libprag.}

proc newProgressBar*(): ProgressBar =
  new(result, finalizeGObject)
  result.impl = gtk_progress_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initProgressBar*[T](result: var T) =
  assert(result is ProgressBar)
  new(result, finalizeGObject)
  result.impl = gtk_progress_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_progress_bar_get_ellipsize*(self: ptr ProgressBar00): pango.EllipsizeMode {.
    importc: "gtk_progress_bar_get_ellipsize", libprag.}

proc getEllipsize*(self: ProgressBar): pango.EllipsizeMode =
  gtk_progress_bar_get_ellipsize(cast[ptr ProgressBar00](self.impl))

proc ellipsize*(self: ProgressBar): pango.EllipsizeMode =
  gtk_progress_bar_get_ellipsize(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_get_fraction*(self: ptr ProgressBar00): cdouble {.
    importc: "gtk_progress_bar_get_fraction", libprag.}

proc getFraction*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_fraction(cast[ptr ProgressBar00](self.impl))

proc fraction*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_fraction(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_get_inverted*(self: ptr ProgressBar00): gboolean {.
    importc: "gtk_progress_bar_get_inverted", libprag.}

proc getInverted*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_inverted(cast[ptr ProgressBar00](self.impl)))

proc inverted*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_inverted(cast[ptr ProgressBar00](self.impl)))

proc gtk_progress_bar_get_pulse_step*(self: ptr ProgressBar00): cdouble {.
    importc: "gtk_progress_bar_get_pulse_step", libprag.}

proc getPulseStep*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_pulse_step(cast[ptr ProgressBar00](self.impl))

proc pulseStep*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_pulse_step(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_get_show_text*(self: ptr ProgressBar00): gboolean {.
    importc: "gtk_progress_bar_get_show_text", libprag.}

proc getShowText*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_show_text(cast[ptr ProgressBar00](self.impl)))

proc showText*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_show_text(cast[ptr ProgressBar00](self.impl)))

proc gtk_progress_bar_get_text*(self: ptr ProgressBar00): cstring {.
    importc: "gtk_progress_bar_get_text", libprag.}

proc getText*(self: ProgressBar): string =
  let resul0 = gtk_progress_bar_get_text(cast[ptr ProgressBar00](self.impl))
  result = $resul0

proc text*(self: ProgressBar): string =
  let resul0 = gtk_progress_bar_get_text(cast[ptr ProgressBar00](self.impl))
  result = $resul0

proc gtk_progress_bar_pulse*(self: ptr ProgressBar00) {.
    importc: "gtk_progress_bar_pulse", libprag.}

proc pulse*(self: ProgressBar) =
  gtk_progress_bar_pulse(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_set_ellipsize*(self: ptr ProgressBar00; mode: pango.EllipsizeMode) {.
    importc: "gtk_progress_bar_set_ellipsize", libprag.}

proc setEllipsize*(self: ProgressBar; mode: pango.EllipsizeMode) =
  gtk_progress_bar_set_ellipsize(cast[ptr ProgressBar00](self.impl), mode)

proc `ellipsize=`*(self: ProgressBar; mode: pango.EllipsizeMode) =
  gtk_progress_bar_set_ellipsize(cast[ptr ProgressBar00](self.impl), mode)

proc gtk_progress_bar_set_fraction*(self: ptr ProgressBar00; fraction: cdouble) {.
    importc: "gtk_progress_bar_set_fraction", libprag.}

proc setFraction*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_fraction(cast[ptr ProgressBar00](self.impl), fraction)

proc `fraction=`*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_fraction(cast[ptr ProgressBar00](self.impl), fraction)

proc gtk_progress_bar_set_inverted*(self: ptr ProgressBar00; inverted: gboolean) {.
    importc: "gtk_progress_bar_set_inverted", libprag.}

proc setInverted*(self: ProgressBar; inverted: bool) =
  gtk_progress_bar_set_inverted(cast[ptr ProgressBar00](self.impl), gboolean(inverted))

proc `inverted=`*(self: ProgressBar; inverted: bool) =
  gtk_progress_bar_set_inverted(cast[ptr ProgressBar00](self.impl), gboolean(inverted))

proc gtk_progress_bar_set_pulse_step*(self: ptr ProgressBar00; fraction: cdouble) {.
    importc: "gtk_progress_bar_set_pulse_step", libprag.}

proc setPulseStep*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_pulse_step(cast[ptr ProgressBar00](self.impl), fraction)

proc `pulseStep=`*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_pulse_step(cast[ptr ProgressBar00](self.impl), fraction)

proc gtk_progress_bar_set_show_text*(self: ptr ProgressBar00; showText: gboolean) {.
    importc: "gtk_progress_bar_set_show_text", libprag.}

proc setShowText*(self: ProgressBar; showText: bool) =
  gtk_progress_bar_set_show_text(cast[ptr ProgressBar00](self.impl), gboolean(showText))

proc `showText=`*(self: ProgressBar; showText: bool) =
  gtk_progress_bar_set_show_text(cast[ptr ProgressBar00](self.impl), gboolean(showText))

proc gtk_progress_bar_set_text*(self: ptr ProgressBar00; text: cstring) {.
    importc: "gtk_progress_bar_set_text", libprag.}

proc setText*(self: ProgressBar; text: string) =
  gtk_progress_bar_set_text(cast[ptr ProgressBar00](self.impl), cstring(text))

proc `text=`*(self: ProgressBar; text: string) =
  gtk_progress_bar_set_text(cast[ptr ProgressBar00](self.impl), cstring(text))

type
  ProgressBarAccessiblePrivate00* {.pure.} = object
  ProgressBarAccessiblePrivate* = ref object
    impl*: ptr ProgressBarAccessiblePrivate00

type
  ProgressBarAccessible* = ref object of WidgetAccessible
  ProgressBarAccessible00* = object of WidgetAccessible00
    priv3: ptr ProgressBarAccessiblePrivate00

type
  ProgressBarAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
  ProgressBarAccessibleClass* = ref object
    impl*: ptr ProgressBarAccessibleClass00

type
  ProgressBarClass00* {.pure.} = object
    parentClass*: WidgetClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ProgressBarClass* = ref object
    impl*: ptr ProgressBarClass00

type
  ToggleActionPrivate00* {.pure.} = object
  ToggleActionPrivate* = ref object
    impl*: ptr ToggleActionPrivate00

type
  ToggleAction* = ref object of Action
  ToggleAction00* = object of Action00
    privateData2: ptr ToggleActionPrivate00

proc scToggled*(self: ToggleAction;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_toggle_action_new*(name: cstring; label: cstring; tooltip: cstring; stockId: cstring): ptr ToggleAction00 {.
    importc: "gtk_toggle_action_new", libprag.}

proc newToggleAction*(name: string; label: string; tooltip: string; stockId: string): ToggleAction =
  new(result, finalizeGObject)
  result.impl = gtk_toggle_action_new(cstring(name), cstring(label), cstring(tooltip), cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleAction*[T](result: var T; name: string; label: string; tooltip: string; stockId: string) =
  assert(result is ToggleAction)
  new(result, finalizeGObject)
  result.impl = gtk_toggle_action_new(cstring(name), cstring(label), cstring(tooltip), cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_action_get_active*(self: ptr ToggleAction00): gboolean {.
    importc: "gtk_toggle_action_get_active", libprag.}

proc getActive*(self: ToggleAction): bool =
  toBool(gtk_toggle_action_get_active(cast[ptr ToggleAction00](self.impl)))

proc active*(self: ToggleAction): bool =
  toBool(gtk_toggle_action_get_active(cast[ptr ToggleAction00](self.impl)))

proc gtk_toggle_action_get_draw_as_radio*(self: ptr ToggleAction00): gboolean {.
    importc: "gtk_toggle_action_get_draw_as_radio", libprag.}

proc getDrawAsRadio*(self: ToggleAction): bool =
  toBool(gtk_toggle_action_get_draw_as_radio(cast[ptr ToggleAction00](self.impl)))

proc drawAsRadio*(self: ToggleAction): bool =
  toBool(gtk_toggle_action_get_draw_as_radio(cast[ptr ToggleAction00](self.impl)))

proc gtk_toggle_action_set_active*(self: ptr ToggleAction00; isActive: gboolean) {.
    importc: "gtk_toggle_action_set_active", libprag.}

proc setActive*(self: ToggleAction; isActive: bool) =
  gtk_toggle_action_set_active(cast[ptr ToggleAction00](self.impl), gboolean(isActive))

proc `active=`*(self: ToggleAction; isActive: bool) =
  gtk_toggle_action_set_active(cast[ptr ToggleAction00](self.impl), gboolean(isActive))

proc gtk_toggle_action_set_draw_as_radio*(self: ptr ToggleAction00; drawAsRadio: gboolean) {.
    importc: "gtk_toggle_action_set_draw_as_radio", libprag.}

proc setDrawAsRadio*(self: ToggleAction; drawAsRadio: bool) =
  gtk_toggle_action_set_draw_as_radio(cast[ptr ToggleAction00](self.impl), gboolean(drawAsRadio))

proc `drawAsRadio=`*(self: ToggleAction; drawAsRadio: bool) =
  gtk_toggle_action_set_draw_as_radio(cast[ptr ToggleAction00](self.impl), gboolean(drawAsRadio))

proc gtk_toggle_action_toggled*(self: ptr ToggleAction00) {.
    importc: "gtk_toggle_action_toggled", libprag.}

proc toggled*(self: ToggleAction) =
  gtk_toggle_action_toggled(cast[ptr ToggleAction00](self.impl))

type
  RadioActionPrivate00* {.pure.} = object
  RadioActionPrivate* = ref object
    impl*: ptr RadioActionPrivate00

type
  RadioAction* = ref object of ToggleAction
  RadioAction00* = object of ToggleAction00
    privateData3: ptr RadioActionPrivate00

proc scChanged*(self: RadioAction;  p: proc (self: ptr gobject.Object00; current: RadioAction00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_radio_action_new*(name: cstring; label: cstring; tooltip: cstring; stockId: cstring; 
    value: int32): ptr RadioAction00 {.
    importc: "gtk_radio_action_new", libprag.}

proc newRadioAction*(name: string; label: string; tooltip: string; stockId: string; 
    value: int): RadioAction =
  new(result, finalizeGObject)
  result.impl = gtk_radio_action_new(cstring(name), cstring(label), cstring(tooltip), cstring(stockId), int32(value))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioAction*[T](result: var T; name: string; label: string; tooltip: string; stockId: string; 
    value: int) =
  assert(result is RadioAction)
  new(result, finalizeGObject)
  result.impl = gtk_radio_action_new(cstring(name), cstring(label), cstring(tooltip), cstring(stockId), int32(value))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_action_get_current_value*(self: ptr RadioAction00): int32 {.
    importc: "gtk_radio_action_get_current_value", libprag.}

proc getCurrentValue*(self: RadioAction): int =
  int(gtk_radio_action_get_current_value(cast[ptr RadioAction00](self.impl)))

proc currentValue*(self: RadioAction): int =
  int(gtk_radio_action_get_current_value(cast[ptr RadioAction00](self.impl)))

proc gtk_radio_action_get_group*(self: ptr RadioAction00): ptr pointer {.
    importc: "gtk_radio_action_get_group", libprag.}

proc getGroup*(self: RadioAction): ptr pointer =
  gtk_radio_action_get_group(cast[ptr RadioAction00](self.impl))

proc group*(self: RadioAction): ptr pointer =
  gtk_radio_action_get_group(cast[ptr RadioAction00](self.impl))

proc gtk_radio_action_join_group*(self: ptr RadioAction00; groupSource: ptr RadioAction00) {.
    importc: "gtk_radio_action_join_group", libprag.}

proc joinGroup*(self: RadioAction; groupSource: RadioAction) =
  gtk_radio_action_join_group(cast[ptr RadioAction00](self.impl), cast[ptr RadioAction00](groupSource.impl))

proc gtk_radio_action_set_current_value*(self: ptr RadioAction00; currentValue: int32) {.
    importc: "gtk_radio_action_set_current_value", libprag.}

proc setCurrentValue*(self: RadioAction; currentValue: int) =
  gtk_radio_action_set_current_value(cast[ptr RadioAction00](self.impl), int32(currentValue))

proc `currentValue=`*(self: RadioAction; currentValue: int) =
  gtk_radio_action_set_current_value(cast[ptr RadioAction00](self.impl), int32(currentValue))

proc gtk_radio_action_set_group*(self: ptr RadioAction00; group: ptr pointer) {.
    importc: "gtk_radio_action_set_group", libprag.}

proc setGroup*(self: RadioAction; group: ptr pointer) =
  gtk_radio_action_set_group(cast[ptr RadioAction00](self.impl), group)

proc `group=`*(self: RadioAction; group: ptr pointer) =
  gtk_radio_action_set_group(cast[ptr RadioAction00](self.impl), group)

type
  ToggleActionClass00* {.pure.} = object
    parentClass*: ActionClass00
    toggled*: proc(action: ptr ToggleAction00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ToggleActionClass* = ref object
    impl*: ptr ToggleActionClass00

type
  RadioActionClass00* {.pure.} = object
    parentClass*: ToggleActionClass00
    changed*: proc(action: ptr RadioAction00; current: ptr RadioAction00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  RadioActionClass* = ref object
    impl*: ptr RadioActionClass00

type
  RadioActionEntry00* {.pure.} = object
    name*: cstring
    stockId*: cstring
    label*: cstring
    accelerator*: cstring
    tooltip*: cstring
    value*: int32
  RadioActionEntry* = ref object
    impl*: ptr RadioActionEntry00

type
  RadioButtonPrivate00* {.pure.} = object
  RadioButtonPrivate* = ref object
    impl*: ptr RadioButtonPrivate00

type
  RadioButton* = ref object of CheckButton
  RadioButton00* = object of CheckButton00
    priv7: ptr RadioButtonPrivate00

proc scGroupChanged*(self: RadioButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "group-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_radio_button_new*(group: ptr pointer): ptr RadioButton00 {.
    importc: "gtk_radio_button_new", libprag.}

proc newRadioButton*(group: ptr pointer): RadioButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new(group)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButton*[T](result: var T; group: ptr pointer) =
  assert(result is RadioButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new(group)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_from_widget*(radioGroupMember: ptr RadioButton00): ptr RadioButton00 {.
    importc: "gtk_radio_button_new_from_widget", libprag.}

proc newRadioButtonFromWidget*(radioGroupMember: RadioButton): RadioButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_from_widget(cast[ptr RadioButton00](radioGroupMember.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonFromWidget*[T](result: var T; radioGroupMember: RadioButton) =
  assert(result is RadioButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_from_widget(cast[ptr RadioButton00](radioGroupMember.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_with_label*(group: ptr pointer; label: cstring): ptr RadioButton00 {.
    importc: "gtk_radio_button_new_with_label", libprag.}

proc newRadioButtonWithLabel*(group: ptr pointer; label: string): RadioButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_with_label(group, cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonWithLabel*[T](result: var T; group: ptr pointer; label: string) =
  assert(result is RadioButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_with_label(group, cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_with_label_from_widget*(radioGroupMember: ptr RadioButton00; label: cstring): ptr RadioButton00 {.
    importc: "gtk_radio_button_new_with_label_from_widget", libprag.}

proc newRadioButtonWithLabelFromWidget*(radioGroupMember: RadioButton; label: string): RadioButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_with_label_from_widget(cast[ptr RadioButton00](radioGroupMember.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonWithLabelFromWidget*[T](result: var T; radioGroupMember: RadioButton; label: string) =
  assert(result is RadioButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_with_label_from_widget(cast[ptr RadioButton00](radioGroupMember.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_with_mnemonic*(group: ptr pointer; label: cstring): ptr RadioButton00 {.
    importc: "gtk_radio_button_new_with_mnemonic", libprag.}

proc newRadioButtonWithMnemonic*(group: ptr pointer; label: string): RadioButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_with_mnemonic(group, cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonWithMnemonic*[T](result: var T; group: ptr pointer; label: string) =
  assert(result is RadioButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_with_mnemonic(group, cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_with_mnemonic_from_widget*(radioGroupMember: ptr RadioButton00; label: cstring): ptr RadioButton00 {.
    importc: "gtk_radio_button_new_with_mnemonic_from_widget", libprag.}

proc newRadioButtonWithMnemonicFromWidget*(radioGroupMember: RadioButton; label: string): RadioButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_with_mnemonic_from_widget(cast[ptr RadioButton00](radioGroupMember.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonWithMnemonicFromWidget*[T](result: var T; radioGroupMember: RadioButton; label: string) =
  assert(result is RadioButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_button_new_with_mnemonic_from_widget(cast[ptr RadioButton00](radioGroupMember.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_get_group*(self: ptr RadioButton00): ptr pointer {.
    importc: "gtk_radio_button_get_group", libprag.}

proc getGroup*(self: RadioButton): ptr pointer =
  gtk_radio_button_get_group(cast[ptr RadioButton00](self.impl))

proc group*(self: RadioButton): ptr pointer =
  gtk_radio_button_get_group(cast[ptr RadioButton00](self.impl))

proc gtk_radio_button_join_group*(self: ptr RadioButton00; groupSource: ptr RadioButton00) {.
    importc: "gtk_radio_button_join_group", libprag.}

proc joinGroup*(self: RadioButton; groupSource: RadioButton) =
  gtk_radio_button_join_group(cast[ptr RadioButton00](self.impl), cast[ptr RadioButton00](groupSource.impl))

proc gtk_radio_button_set_group*(self: ptr RadioButton00; group: ptr pointer) {.
    importc: "gtk_radio_button_set_group", libprag.}

proc setGroup*(self: RadioButton; group: ptr pointer) =
  gtk_radio_button_set_group(cast[ptr RadioButton00](self.impl), group)

proc `group=`*(self: RadioButton; group: ptr pointer) =
  gtk_radio_button_set_group(cast[ptr RadioButton00](self.impl), group)

type
  RadioButtonAccessiblePrivate00* {.pure.} = object
  RadioButtonAccessiblePrivate* = ref object
    impl*: ptr RadioButtonAccessiblePrivate00

type
  RadioButtonAccessible* = ref object of ToggleButtonAccessible
  RadioButtonAccessible00* = object of ToggleButtonAccessible00
    priv6: ptr RadioButtonAccessiblePrivate00

type
  RadioButtonAccessibleClass00* {.pure.} = object
    parentClass*: ToggleButtonAccessibleClass00
  RadioButtonAccessibleClass* = ref object
    impl*: ptr RadioButtonAccessibleClass00

type
  RadioButtonClass00* {.pure.} = object
    parentClass*: CheckButtonClass00
    groupChanged*: proc(radioButton: ptr RadioButton00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  RadioButtonClass* = ref object
    impl*: ptr RadioButtonClass00

type
  RadioMenuItemPrivate00* {.pure.} = object
  RadioMenuItemPrivate* = ref object
    impl*: ptr RadioMenuItemPrivate00

type
  RadioMenuItem* = ref object of CheckMenuItem
  RadioMenuItem00* = object of CheckMenuItem00
    priv6: ptr RadioMenuItemPrivate00

proc scGroupChanged*(self: RadioMenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "group-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_radio_menu_item_new*(group: ptr pointer): ptr RadioMenuItem00 {.
    importc: "gtk_radio_menu_item_new", libprag.}

proc newRadioMenuItem*(group: ptr pointer): RadioMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new(group)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItem*[T](result: var T; group: ptr pointer) =
  assert(result is RadioMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new(group)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_from_widget*(group: ptr RadioMenuItem00): ptr RadioMenuItem00 {.
    importc: "gtk_radio_menu_item_new_from_widget", libprag.}

proc newRadioMenuItemFromWidget*(group: RadioMenuItem): RadioMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_from_widget(cast[ptr RadioMenuItem00](group.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemFromWidget*[T](result: var T; group: RadioMenuItem) =
  assert(result is RadioMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_from_widget(cast[ptr RadioMenuItem00](group.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_with_label*(group: ptr pointer; label: cstring): ptr RadioMenuItem00 {.
    importc: "gtk_radio_menu_item_new_with_label", libprag.}

proc newRadioMenuItemWithLabel*(group: ptr pointer; label: string): RadioMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_with_label(group, cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemWithLabel*[T](result: var T; group: ptr pointer; label: string) =
  assert(result is RadioMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_with_label(group, cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_with_label_from_widget*(group: ptr RadioMenuItem00; label: cstring): ptr RadioMenuItem00 {.
    importc: "gtk_radio_menu_item_new_with_label_from_widget", libprag.}

proc newRadioMenuItemWithLabelFromWidget*(group: RadioMenuItem; label: string): RadioMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_with_label_from_widget(cast[ptr RadioMenuItem00](group.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemWithLabelFromWidget*[T](result: var T; group: RadioMenuItem; label: string) =
  assert(result is RadioMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_with_label_from_widget(cast[ptr RadioMenuItem00](group.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_with_mnemonic*(group: ptr pointer; label: cstring): ptr RadioMenuItem00 {.
    importc: "gtk_radio_menu_item_new_with_mnemonic", libprag.}

proc newRadioMenuItemWithMnemonic*(group: ptr pointer; label: string): RadioMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_with_mnemonic(group, cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemWithMnemonic*[T](result: var T; group: ptr pointer; label: string) =
  assert(result is RadioMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_with_mnemonic(group, cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_with_mnemonic_from_widget*(group: ptr RadioMenuItem00; label: cstring): ptr RadioMenuItem00 {.
    importc: "gtk_radio_menu_item_new_with_mnemonic_from_widget", libprag.}

proc newRadioMenuItemWithMnemonicFromWidget*(group: RadioMenuItem; label: string): RadioMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_with_mnemonic_from_widget(cast[ptr RadioMenuItem00](group.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemWithMnemonicFromWidget*[T](result: var T; group: RadioMenuItem; label: string) =
  assert(result is RadioMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_radio_menu_item_new_with_mnemonic_from_widget(cast[ptr RadioMenuItem00](group.impl), cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_get_group*(self: ptr RadioMenuItem00): ptr pointer {.
    importc: "gtk_radio_menu_item_get_group", libprag.}

proc getGroup*(self: RadioMenuItem): ptr pointer =
  gtk_radio_menu_item_get_group(cast[ptr RadioMenuItem00](self.impl))

proc group*(self: RadioMenuItem): ptr pointer =
  gtk_radio_menu_item_get_group(cast[ptr RadioMenuItem00](self.impl))

proc gtk_radio_menu_item_join_group*(self: ptr RadioMenuItem00; groupSource: ptr RadioMenuItem00) {.
    importc: "gtk_radio_menu_item_join_group", libprag.}

proc joinGroup*(self: RadioMenuItem; groupSource: RadioMenuItem) =
  gtk_radio_menu_item_join_group(cast[ptr RadioMenuItem00](self.impl), cast[ptr RadioMenuItem00](groupSource.impl))

proc gtk_radio_menu_item_set_group*(self: ptr RadioMenuItem00; group: ptr pointer) {.
    importc: "gtk_radio_menu_item_set_group", libprag.}

proc setGroup*(self: RadioMenuItem; group: ptr pointer) =
  gtk_radio_menu_item_set_group(cast[ptr RadioMenuItem00](self.impl), group)

proc `group=`*(self: RadioMenuItem; group: ptr pointer) =
  gtk_radio_menu_item_set_group(cast[ptr RadioMenuItem00](self.impl), group)

type
  RadioMenuItemAccessiblePrivate00* {.pure.} = object
  RadioMenuItemAccessiblePrivate* = ref object
    impl*: ptr RadioMenuItemAccessiblePrivate00

type
  RadioMenuItemAccessible* = ref object of CheckMenuItemAccessible
  RadioMenuItemAccessible00* = object of CheckMenuItemAccessible00
    priv6: ptr RadioMenuItemAccessiblePrivate00

type
  RadioMenuItemAccessibleClass00* {.pure.} = object
    parentClass*: CheckMenuItemAccessibleClass00
  RadioMenuItemAccessibleClass* = ref object
    impl*: ptr RadioMenuItemAccessibleClass00

type
  RadioMenuItemClass00* {.pure.} = object
    parentClass*: CheckMenuItemClass00
    groupChanged*: proc(radioMenuItem: ptr RadioMenuItem00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  RadioMenuItemClass* = ref object
    impl*: ptr RadioMenuItemClass00

type
  ToggleToolButtonPrivate00* {.pure.} = object
  ToggleToolButtonPrivate* = ref object
    impl*: ptr ToggleToolButtonPrivate00

type
  ToggleToolButton* = ref object of ToolButton
  ToggleToolButton00* = object of ToolButton00
    priv6: ptr ToggleToolButtonPrivate00

proc scToggled*(self: ToggleToolButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_toggle_tool_button_new*(): ptr ToggleToolButton00 {.
    importc: "gtk_toggle_tool_button_new", libprag.}

proc newToggleToolButton*(): ToggleToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_toggle_tool_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleToolButton*[T](result: var T) =
  assert(result is ToggleToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_toggle_tool_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_tool_button_new_from_stock*(stockId: cstring): ptr ToggleToolButton00 {.
    importc: "gtk_toggle_tool_button_new_from_stock", libprag.}

proc newToggleToolButtonFromStock*(stockId: string): ToggleToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_toggle_tool_button_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleToolButtonFromStock*[T](result: var T; stockId: string) =
  assert(result is ToggleToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_toggle_tool_button_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_tool_button_get_active*(self: ptr ToggleToolButton00): gboolean {.
    importc: "gtk_toggle_tool_button_get_active", libprag.}

proc getActive*(self: ToggleToolButton): bool =
  toBool(gtk_toggle_tool_button_get_active(cast[ptr ToggleToolButton00](self.impl)))

proc active*(self: ToggleToolButton): bool =
  toBool(gtk_toggle_tool_button_get_active(cast[ptr ToggleToolButton00](self.impl)))

proc gtk_toggle_tool_button_set_active*(self: ptr ToggleToolButton00; isActive: gboolean) {.
    importc: "gtk_toggle_tool_button_set_active", libprag.}

proc setActive*(self: ToggleToolButton; isActive: bool) =
  gtk_toggle_tool_button_set_active(cast[ptr ToggleToolButton00](self.impl), gboolean(isActive))

proc `active=`*(self: ToggleToolButton; isActive: bool) =
  gtk_toggle_tool_button_set_active(cast[ptr ToggleToolButton00](self.impl), gboolean(isActive))

type
  RadioToolButton* = ref object of ToggleToolButton
  RadioToolButton00* = object of ToggleToolButton00

proc gtk_radio_tool_button_new*(group: ptr pointer): ptr RadioToolButton00 {.
    importc: "gtk_radio_tool_button_new", libprag.}

proc newRadioToolButton*(group: ptr pointer): RadioToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_tool_button_new(group)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioToolButton*[T](result: var T; group: ptr pointer) =
  assert(result is RadioToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_tool_button_new(group)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_tool_button_new_from_stock*(group: ptr pointer; stockId: cstring): ptr RadioToolButton00 {.
    importc: "gtk_radio_tool_button_new_from_stock", libprag.}

proc newRadioToolButtonFromStock*(group: ptr pointer; stockId: string): RadioToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_tool_button_new_from_stock(group, cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioToolButtonFromStock*[T](result: var T; group: ptr pointer; stockId: string) =
  assert(result is RadioToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_tool_button_new_from_stock(group, cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_tool_button_new_from_widget*(group: ptr RadioToolButton00): ptr RadioToolButton00 {.
    importc: "gtk_radio_tool_button_new_from_widget", libprag.}

proc newRadioToolButtonFromWidget*(group: RadioToolButton): RadioToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_tool_button_new_from_widget(cast[ptr RadioToolButton00](group.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioToolButtonFromWidget*[T](result: var T; group: RadioToolButton) =
  assert(result is RadioToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_tool_button_new_from_widget(cast[ptr RadioToolButton00](group.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_tool_button_new_with_stock_from_widget*(group: ptr RadioToolButton00; stockId: cstring): ptr RadioToolButton00 {.
    importc: "gtk_radio_tool_button_new_with_stock_from_widget", libprag.}

proc newRadioToolButtonWithStockFromWidget*(group: RadioToolButton; stockId: string): RadioToolButton =
  new(result, finalizeGObject)
  result.impl = gtk_radio_tool_button_new_with_stock_from_widget(cast[ptr RadioToolButton00](group.impl), cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioToolButtonWithStockFromWidget*[T](result: var T; group: RadioToolButton; stockId: string) =
  assert(result is RadioToolButton)
  new(result, finalizeGObject)
  result.impl = gtk_radio_tool_button_new_with_stock_from_widget(cast[ptr RadioToolButton00](group.impl), cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_tool_button_get_group*(self: ptr RadioToolButton00): ptr pointer {.
    importc: "gtk_radio_tool_button_get_group", libprag.}

proc getGroup*(self: RadioToolButton): ptr pointer =
  gtk_radio_tool_button_get_group(cast[ptr RadioToolButton00](self.impl))

proc group*(self: RadioToolButton): ptr pointer =
  gtk_radio_tool_button_get_group(cast[ptr RadioToolButton00](self.impl))

proc gtk_radio_tool_button_set_group*(self: ptr RadioToolButton00; group: ptr pointer) {.
    importc: "gtk_radio_tool_button_set_group", libprag.}

proc setGroup*(self: RadioToolButton; group: ptr pointer) =
  gtk_radio_tool_button_set_group(cast[ptr RadioToolButton00](self.impl), group)

proc `group=`*(self: RadioToolButton; group: ptr pointer) =
  gtk_radio_tool_button_set_group(cast[ptr RadioToolButton00](self.impl), group)

type
  ToggleToolButtonClass00* {.pure.} = object
    parentClass*: ToolButtonClass00
    toggled*: proc(button: ptr ToggleToolButton00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ToggleToolButtonClass* = ref object
    impl*: ptr ToggleToolButtonClass00

type
  RadioToolButtonClass00* {.pure.} = object
    parentClass*: ToggleToolButtonClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  RadioToolButtonClass* = ref object
    impl*: ptr RadioToolButtonClass00

type
  RangeAccessiblePrivate00* {.pure.} = object
  RangeAccessiblePrivate* = ref object
    impl*: ptr RangeAccessiblePrivate00

type
  RangeAccessible* = ref object of WidgetAccessible
  RangeAccessible00* = object of WidgetAccessible00
    priv3: ptr RangeAccessiblePrivate00

type
  RangeAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
  RangeAccessibleClass* = ref object
    impl*: ptr RangeAccessibleClass00

type
  RcContext00* {.pure.} = object
  RcContext* = ref object
    impl*: ptr RcContext00

type
  RcProperty00* {.pure.} = object
    typeName*: uint32
    propertyName*: uint32
    origin*: cstring
    value*: gobject.Value00
  RcProperty* = ref object
    impl*: ptr RcProperty00

proc gtk_rc_property_parse_border*(pspec: ptr gobject.ParamSpec00; gstring: ptr glib.String00; 
    propertyValue: ptr gobject.Value00): gboolean {.
    importc: "gtk_rc_property_parse_border", libprag.}

proc parseBorder*(pspec: gobject.ParamSpec; gstring: glib.String; propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_border(cast[ptr gobject.ParamSpec00](pspec.impl), cast[ptr glib.String00](gstring.impl), cast[ptr gobject.Value00](propertyValue.impl)))

proc gtk_rc_property_parse_color*(pspec: ptr gobject.ParamSpec00; gstring: ptr glib.String00; 
    propertyValue: ptr gobject.Value00): gboolean {.
    importc: "gtk_rc_property_parse_color", libprag.}

proc parseColor*(pspec: gobject.ParamSpec; gstring: glib.String; propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_color(cast[ptr gobject.ParamSpec00](pspec.impl), cast[ptr glib.String00](gstring.impl), cast[ptr gobject.Value00](propertyValue.impl)))

proc gtk_rc_property_parse_enum*(pspec: ptr gobject.ParamSpec00; gstring: ptr glib.String00; 
    propertyValue: ptr gobject.Value00): gboolean {.
    importc: "gtk_rc_property_parse_enum", libprag.}

proc parseEnum*(pspec: gobject.ParamSpec; gstring: glib.String; propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_enum(cast[ptr gobject.ParamSpec00](pspec.impl), cast[ptr glib.String00](gstring.impl), cast[ptr gobject.Value00](propertyValue.impl)))

proc gtk_rc_property_parse_flags*(pspec: ptr gobject.ParamSpec00; gstring: ptr glib.String00; 
    propertyValue: ptr gobject.Value00): gboolean {.
    importc: "gtk_rc_property_parse_flags", libprag.}

proc parseFlags*(pspec: gobject.ParamSpec; gstring: glib.String; propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_flags(cast[ptr gobject.ParamSpec00](pspec.impl), cast[ptr glib.String00](gstring.impl), cast[ptr gobject.Value00](propertyValue.impl)))

proc gtk_rc_property_parse_requisition*(pspec: ptr gobject.ParamSpec00; gstring: ptr glib.String00; 
    propertyValue: ptr gobject.Value00): gboolean {.
    importc: "gtk_rc_property_parse_requisition", libprag.}

proc parseRequisition*(pspec: gobject.ParamSpec; gstring: glib.String; propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_requisition(cast[ptr gobject.ParamSpec00](pspec.impl), cast[ptr glib.String00](gstring.impl), cast[ptr gobject.Value00](propertyValue.impl)))

type
  RcPropertyParser* = proc (pspec: ptr gobject.ParamSpec00; rcString: ptr glib.String00; 
    propertyValue: ptr gobject.Value00): gboolean {.cdecl.}

proc gtk_settings_install_property_parser*(pspec: ptr gobject.ParamSpec00; parser: RcPropertyParser) {.
    importc: "gtk_settings_install_property_parser", libprag.}

proc installPropertyParser*(pspec: gobject.ParamSpec; parser: RcPropertyParser) =
  gtk_settings_install_property_parser(cast[ptr gobject.ParamSpec00](pspec.impl), parser)

type
  RcStyleClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    createRcStyle*: pointer
    parse*: proc(rcStyle: ptr RcStyle00; settings: ptr Settings00; 
    scanner: ptr glib.Scanner00): uint32 {.cdecl.}
    merge*: proc(dest: ptr RcStyle00; src: ptr RcStyle00) {.cdecl.}
    createStyle*: pointer
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  RcStyleClass* = ref object
    impl*: ptr RcStyleClass00

type
  RcTokenType* {.size: sizeof(cint), pure.} = enum
    invalid = 270
    `include` = 271
    normal = 272
    active = 273
    prelight = 274
    selected = 275
    insensitive = 276
    fg = 277
    bg = 278
    text = 279
    base = 280
    xthickness = 281
    ythickness = 282
    font = 283
    fontset = 284
    fontName = 285
    bgPixmap = 286
    pixmapPath = 287
    style = 288
    binding = 289
    `bind` = 290
    widget = 291
    widgetClass = 292
    class = 293
    lowest = 294
    gtk = 295
    application = 296
    theme = 297
    rc = 298
    highest = 299
    engine = 300
    modulePath = 301
    imModulePath = 302
    imModuleFile = 303
    stock = 304
    ltr = 305
    rtl = 306
    color = 307
    unbind = 308
    last = 309

type
  RecentActionPrivate00* {.pure.} = object
  RecentActionPrivate* = ref object
    impl*: ptr RecentActionPrivate00

type
  RecentAction* = ref object of Action
  RecentAction00* = object of Action00
    priv2: ptr RecentActionPrivate00

proc gtk_recent_action_new*(name: cstring; label: cstring; tooltip: cstring; stockId: cstring): ptr RecentAction00 {.
    importc: "gtk_recent_action_new", libprag.}

proc newRecentAction*(name: string; label: string; tooltip: string; stockId: string): RecentAction =
  new(result, finalizeGObject)
  result.impl = gtk_recent_action_new(cstring(name), cstring(label), cstring(tooltip), cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentAction*[T](result: var T; name: string; label: string; tooltip: string; stockId: string) =
  assert(result is RecentAction)
  new(result, finalizeGObject)
  result.impl = gtk_recent_action_new(cstring(name), cstring(label), cstring(tooltip), cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_action_get_show_numbers*(self: ptr RecentAction00): gboolean {.
    importc: "gtk_recent_action_get_show_numbers", libprag.}

proc getShowNumbers*(self: RecentAction): bool =
  toBool(gtk_recent_action_get_show_numbers(cast[ptr RecentAction00](self.impl)))

proc showNumbers*(self: RecentAction): bool =
  toBool(gtk_recent_action_get_show_numbers(cast[ptr RecentAction00](self.impl)))

proc gtk_recent_action_set_show_numbers*(self: ptr RecentAction00; showNumbers: gboolean) {.
    importc: "gtk_recent_action_set_show_numbers", libprag.}

proc setShowNumbers*(self: RecentAction; showNumbers: bool) =
  gtk_recent_action_set_show_numbers(cast[ptr RecentAction00](self.impl), gboolean(showNumbers))

proc `showNumbers=`*(self: RecentAction; showNumbers: bool) =
  gtk_recent_action_set_show_numbers(cast[ptr RecentAction00](self.impl), gboolean(showNumbers))

type
  RecentManagerPrivate00* {.pure.} = object
  RecentManagerPrivate* = ref object
    impl*: ptr RecentManagerPrivate00

type
  RecentManager* = ref object of gobject.Object
  RecentManager00* = object of gobject.Object00
    priv1: ptr RecentManagerPrivate00

proc scChanged*(self: RecentManager;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_recent_manager_new*(): ptr RecentManager00 {.
    importc: "gtk_recent_manager_new", libprag.}

proc newRecentManager*(): RecentManager =
  new(result, finalizeGObject)
  result.impl = gtk_recent_manager_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentManager*[T](result: var T) =
  assert(result is RecentManager)
  new(result, finalizeGObject)
  result.impl = gtk_recent_manager_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_manager_get_default*(): ptr RecentManager00 {.
    importc: "gtk_recent_manager_get_default", libprag.}

proc getDefault*(): RecentManager =
  let gobj = gtk_recent_manager_get_default()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[RecentManager](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc default*(): RecentManager =
  let gobj = gtk_recent_manager_get_default()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[RecentManager](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_manager_add_item*(self: ptr RecentManager00; uri: cstring): gboolean {.
    importc: "gtk_recent_manager_add_item", libprag.}

proc addItem*(self: RecentManager; uri: string): bool =
  toBool(gtk_recent_manager_add_item(cast[ptr RecentManager00](self.impl), cstring(uri)))

proc gtk_recent_manager_get_items*(self: ptr RecentManager00): ptr pointer {.
    importc: "gtk_recent_manager_get_items", libprag.}

proc getItems*(self: RecentManager): ptr pointer =
  gtk_recent_manager_get_items(cast[ptr RecentManager00](self.impl))

proc items*(self: RecentManager): ptr pointer =
  gtk_recent_manager_get_items(cast[ptr RecentManager00](self.impl))

proc gtk_recent_manager_has_item*(self: ptr RecentManager00; uri: cstring): gboolean {.
    importc: "gtk_recent_manager_has_item", libprag.}

proc hasItem*(self: RecentManager; uri: string): bool =
  toBool(gtk_recent_manager_has_item(cast[ptr RecentManager00](self.impl), cstring(uri)))

proc gtk_recent_manager_move_item*(self: ptr RecentManager00; uri: cstring; newUri: cstring): gboolean {.
    importc: "gtk_recent_manager_move_item", libprag.}

proc moveItem*(self: RecentManager; uri: string; newUri: string): bool =
  toBool(gtk_recent_manager_move_item(cast[ptr RecentManager00](self.impl), cstring(uri), cstring(newUri)))

proc gtk_recent_manager_purge_items*(self: ptr RecentManager00): int32 {.
    importc: "gtk_recent_manager_purge_items", libprag.}

proc purgeItems*(self: RecentManager): int =
  int(gtk_recent_manager_purge_items(cast[ptr RecentManager00](self.impl)))

proc gtk_recent_manager_remove_item*(self: ptr RecentManager00; uri: cstring): gboolean {.
    importc: "gtk_recent_manager_remove_item", libprag.}

proc removeItem*(self: RecentManager; uri: string): bool =
  toBool(gtk_recent_manager_remove_item(cast[ptr RecentManager00](self.impl), cstring(uri)))

proc gtk_recent_action_new_for_manager*(name: cstring; label: cstring; tooltip: cstring; stockId: cstring; 
    manager: ptr RecentManager00): ptr RecentAction00 {.
    importc: "gtk_recent_action_new_for_manager", libprag.}

proc newRecentActionForManager*(name: string; label: string; tooltip: string; stockId: string; 
    manager: RecentManager): RecentAction =
  new(result, finalizeGObject)
  result.impl = gtk_recent_action_new_for_manager(cstring(name), cstring(label), cstring(tooltip), cstring(stockId), cast[ptr RecentManager00](manager.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentActionForManager*[T](result: var T; name: string; label: string; tooltip: string; stockId: string; 
    manager: RecentManager) =
  assert(result is RecentAction)
  new(result, finalizeGObject)
  result.impl = gtk_recent_action_new_for_manager(cstring(name), cstring(label), cstring(tooltip), cstring(stockId), cast[ptr RecentManager00](manager.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  RecentData00* {.pure.} = object
    displayName*: cstring
    description*: cstring
    mimeType*: cstring
    appName*: cstring
    appExec*: cstring
    groups*: cstringArray
    isPrivate*: gboolean
  RecentData* = ref object
    impl*: ptr RecentData00

proc gtk_recent_manager_add_full*(self: ptr RecentManager00; uri: cstring; recentData: ptr RecentData00): gboolean {.
    importc: "gtk_recent_manager_add_full", libprag.}

proc addFull*(self: RecentManager; uri: string; recentData: RecentData): bool =
  toBool(gtk_recent_manager_add_full(cast[ptr RecentManager00](self.impl), cstring(uri), cast[ptr RecentData00](recentData.impl)))

type
  RecentInfo00* {.pure.} = object
  RecentInfo* = ref object
    impl*: ptr RecentInfo00

proc gtk_recent_info_create_app_info*(self: ptr RecentInfo00; appName: cstring): ptr gio.AppInfo00 {.
    importc: "gtk_recent_info_create_app_info", libprag.}

proc createAppInfo*(self: RecentInfo; appName: string): gio.AppInfo =
  new(result)
  result.impl = gtk_recent_info_create_app_info(cast[ptr RecentInfo00](self.impl), cstring(appName))

proc gtk_recent_info_exists*(self: ptr RecentInfo00): gboolean {.
    importc: "gtk_recent_info_exists", libprag.}

proc exists*(self: RecentInfo): bool =
  toBool(gtk_recent_info_exists(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_get_added*(self: ptr RecentInfo00): int64 {.
    importc: "gtk_recent_info_get_added", libprag.}

proc getAdded*(self: RecentInfo): int64 =
  gtk_recent_info_get_added(cast[ptr RecentInfo00](self.impl))

proc added*(self: RecentInfo): int64 =
  gtk_recent_info_get_added(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_age*(self: ptr RecentInfo00): int32 {.
    importc: "gtk_recent_info_get_age", libprag.}

proc getAge*(self: RecentInfo): int =
  int(gtk_recent_info_get_age(cast[ptr RecentInfo00](self.impl)))

proc age*(self: RecentInfo): int =
  int(gtk_recent_info_get_age(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_get_application_info*(self: ptr RecentInfo00; appName: cstring; appExec: var cstring; 
    count: var uint32; time: var int64): gboolean {.
    importc: "gtk_recent_info_get_application_info", libprag.}

proc getApplicationInfo*(self: RecentInfo; appName: string; appExec: var string; 
    count: var int; time: var int64): bool =
  var count_00 = uint32(count)
  var appExec_00 = cstring(appExec)
  result = toBool(gtk_recent_info_get_application_info(cast[ptr RecentInfo00](self.impl), cstring(appName), appExec_00, count_00, time))
  count = int(count_00)
  appExec = $(appExec_00)

proc applicationInfo*(self: RecentInfo; appName: string; appExec: var string; 
    count: var int; time: var int64): bool =
  var count_00 = uint32(count)
  var appExec_00 = cstring(appExec)
  result = toBool(gtk_recent_info_get_application_info(cast[ptr RecentInfo00](self.impl), cstring(appName), appExec_00, count_00, time))
  count = int(count_00)
  appExec = $(appExec_00)

proc gtk_recent_info_get_applications*(self: ptr RecentInfo00; length: var uint64): cstringArray {.
    importc: "gtk_recent_info_get_applications", libprag.}

proc getApplications*(self: RecentInfo; length: var uint64): cstringArray =
  gtk_recent_info_get_applications(cast[ptr RecentInfo00](self.impl), length)

proc applications*(self: RecentInfo; length: var uint64): cstringArray =
  gtk_recent_info_get_applications(cast[ptr RecentInfo00](self.impl), length)

proc gtk_recent_info_get_description*(self: ptr RecentInfo00): cstring {.
    importc: "gtk_recent_info_get_description", libprag.}

proc getDescription*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_description(cast[ptr RecentInfo00](self.impl))
  result = $resul0

proc description*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_description(cast[ptr RecentInfo00](self.impl))
  result = $resul0

proc gtk_recent_info_get_display_name*(self: ptr RecentInfo00): cstring {.
    importc: "gtk_recent_info_get_display_name", libprag.}

proc getDisplayName*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_display_name(cast[ptr RecentInfo00](self.impl))
  result = $resul0

proc displayName*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_display_name(cast[ptr RecentInfo00](self.impl))
  result = $resul0

proc gtk_recent_info_get_gicon*(self: ptr RecentInfo00): ptr gio.Icon00 {.
    importc: "gtk_recent_info_get_gicon", libprag.}

proc getGicon*(self: RecentInfo): gio.Icon =
  new(result)
  result.impl = gtk_recent_info_get_gicon(cast[ptr RecentInfo00](self.impl))

proc gicon*(self: RecentInfo): gio.Icon =
  new(result)
  result.impl = gtk_recent_info_get_gicon(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_groups*(self: ptr RecentInfo00; length: var uint64): cstringArray {.
    importc: "gtk_recent_info_get_groups", libprag.}

proc getGroups*(self: RecentInfo; length: var uint64): cstringArray =
  gtk_recent_info_get_groups(cast[ptr RecentInfo00](self.impl), length)

proc groups*(self: RecentInfo; length: var uint64): cstringArray =
  gtk_recent_info_get_groups(cast[ptr RecentInfo00](self.impl), length)

proc gtk_recent_info_get_icon*(self: ptr RecentInfo00; size: int32): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_recent_info_get_icon", libprag.}

proc getIcon*(self: RecentInfo; size: int): gdkpixbuf.Pixbuf =
  let gobj = gtk_recent_info_get_icon(cast[ptr RecentInfo00](self.impl), int32(size))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc icon*(self: RecentInfo; size: int): gdkpixbuf.Pixbuf =
  let gobj = gtk_recent_info_get_icon(cast[ptr RecentInfo00](self.impl), int32(size))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_info_get_mime_type*(self: ptr RecentInfo00): cstring {.
    importc: "gtk_recent_info_get_mime_type", libprag.}

proc getMimeType*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_mime_type(cast[ptr RecentInfo00](self.impl))
  result = $resul0

proc mimeType*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_mime_type(cast[ptr RecentInfo00](self.impl))
  result = $resul0

proc gtk_recent_info_get_modified*(self: ptr RecentInfo00): int64 {.
    importc: "gtk_recent_info_get_modified", libprag.}

proc getModified*(self: RecentInfo): int64 =
  gtk_recent_info_get_modified(cast[ptr RecentInfo00](self.impl))

proc modified*(self: RecentInfo): int64 =
  gtk_recent_info_get_modified(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_private_hint*(self: ptr RecentInfo00): gboolean {.
    importc: "gtk_recent_info_get_private_hint", libprag.}

proc getPrivateHint*(self: RecentInfo): bool =
  toBool(gtk_recent_info_get_private_hint(cast[ptr RecentInfo00](self.impl)))

proc privateHint*(self: RecentInfo): bool =
  toBool(gtk_recent_info_get_private_hint(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_get_short_name*(self: ptr RecentInfo00): cstring {.
    importc: "gtk_recent_info_get_short_name", libprag.}

proc getShortName*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_short_name(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc shortName*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_short_name(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_recent_info_get_uri*(self: ptr RecentInfo00): cstring {.
    importc: "gtk_recent_info_get_uri", libprag.}

proc getUri*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_uri(cast[ptr RecentInfo00](self.impl))
  result = $resul0

proc uri*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_uri(cast[ptr RecentInfo00](self.impl))
  result = $resul0

proc gtk_recent_info_get_uri_display*(self: ptr RecentInfo00): cstring {.
    importc: "gtk_recent_info_get_uri_display", libprag.}

proc getUriDisplay*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_uri_display(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc uriDisplay*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_uri_display(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_recent_info_get_visited*(self: ptr RecentInfo00): int64 {.
    importc: "gtk_recent_info_get_visited", libprag.}

proc getVisited*(self: RecentInfo): int64 =
  gtk_recent_info_get_visited(cast[ptr RecentInfo00](self.impl))

proc visited*(self: RecentInfo): int64 =
  gtk_recent_info_get_visited(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_has_application*(self: ptr RecentInfo00; appName: cstring): gboolean {.
    importc: "gtk_recent_info_has_application", libprag.}

proc hasApplication*(self: RecentInfo; appName: string): bool =
  toBool(gtk_recent_info_has_application(cast[ptr RecentInfo00](self.impl), cstring(appName)))

proc gtk_recent_info_has_group*(self: ptr RecentInfo00; groupName: cstring): gboolean {.
    importc: "gtk_recent_info_has_group", libprag.}

proc hasGroup*(self: RecentInfo; groupName: string): bool =
  toBool(gtk_recent_info_has_group(cast[ptr RecentInfo00](self.impl), cstring(groupName)))

proc gtk_recent_info_is_local*(self: ptr RecentInfo00): gboolean {.
    importc: "gtk_recent_info_is_local", libprag.}

proc isLocal*(self: RecentInfo): bool =
  toBool(gtk_recent_info_is_local(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_last_application*(self: ptr RecentInfo00): cstring {.
    importc: "gtk_recent_info_last_application", libprag.}

proc lastApplication*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_last_application(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_recent_info_match*(self: ptr RecentInfo00; infoB: ptr RecentInfo00): gboolean {.
    importc: "gtk_recent_info_match", libprag.}

proc match*(self: RecentInfo; infoB: RecentInfo): bool =
  toBool(gtk_recent_info_match(cast[ptr RecentInfo00](self.impl), cast[ptr RecentInfo00](infoB.impl)))

proc gtk_recent_info_ref*(self: ptr RecentInfo00): ptr RecentInfo00 {.
    importc: "gtk_recent_info_ref", libprag.}

proc `ref`*(self: RecentInfo): RecentInfo =
  new(result)
  result.impl = gtk_recent_info_ref(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_unref*(self: ptr RecentInfo00) {.
    importc: "gtk_recent_info_unref", libprag.}

proc unref*(self: RecentInfo) =
  gtk_recent_info_unref(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_manager_lookup_item*(self: ptr RecentManager00; uri: cstring): ptr RecentInfo00 {.
    importc: "gtk_recent_manager_lookup_item", libprag.}

proc lookupItem*(self: RecentManager; uri: string): RecentInfo =
  new(result)
  result.impl = gtk_recent_manager_lookup_item(cast[ptr RecentManager00](self.impl), cstring(uri))

type
  RecentActionClass00* {.pure.} = object
    parentClass*: ActionClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  RecentActionClass* = ref object
    impl*: ptr RecentActionClass00

type
  RecentChooser00* {.pure.} = object
  RecentChooser* = ref object
    impl*: ptr RecentChooser00

proc gtk_recent_chooser_get_current_item*(self: ptr RecentChooser00): ptr RecentInfo00 {.
    importc: "gtk_recent_chooser_get_current_item", libprag.}

proc getCurrentItem*(self: RecentChooser): RecentInfo =
  new(result)
  result.impl = gtk_recent_chooser_get_current_item(cast[ptr RecentChooser00](self.impl))

proc currentItem*(self: RecentChooser): RecentInfo =
  new(result)
  result.impl = gtk_recent_chooser_get_current_item(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_get_current_uri*(self: ptr RecentChooser00): cstring {.
    importc: "gtk_recent_chooser_get_current_uri", libprag.}

proc getCurrentUri*(self: RecentChooser): string =
  let resul0 = gtk_recent_chooser_get_current_uri(cast[ptr RecentChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc currentUri*(self: RecentChooser): string =
  let resul0 = gtk_recent_chooser_get_current_uri(cast[ptr RecentChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_recent_chooser_get_items*(self: ptr RecentChooser00): ptr pointer {.
    importc: "gtk_recent_chooser_get_items", libprag.}

proc getItems*(self: RecentChooser): ptr pointer =
  gtk_recent_chooser_get_items(cast[ptr RecentChooser00](self.impl))

proc items*(self: RecentChooser): ptr pointer =
  gtk_recent_chooser_get_items(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_get_limit*(self: ptr RecentChooser00): int32 {.
    importc: "gtk_recent_chooser_get_limit", libprag.}

proc getLimit*(self: RecentChooser): int =
  int(gtk_recent_chooser_get_limit(cast[ptr RecentChooser00](self.impl)))

proc limit*(self: RecentChooser): int =
  int(gtk_recent_chooser_get_limit(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_local_only*(self: ptr RecentChooser00): gboolean {.
    importc: "gtk_recent_chooser_get_local_only", libprag.}

proc getLocalOnly*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_local_only(cast[ptr RecentChooser00](self.impl)))

proc localOnly*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_local_only(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_select_multiple*(self: ptr RecentChooser00): gboolean {.
    importc: "gtk_recent_chooser_get_select_multiple", libprag.}

proc getSelectMultiple*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_select_multiple(cast[ptr RecentChooser00](self.impl)))

proc selectMultiple*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_select_multiple(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_show_icons*(self: ptr RecentChooser00): gboolean {.
    importc: "gtk_recent_chooser_get_show_icons", libprag.}

proc getShowIcons*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_show_icons(cast[ptr RecentChooser00](self.impl)))

proc showIcons*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_show_icons(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_show_not_found*(self: ptr RecentChooser00): gboolean {.
    importc: "gtk_recent_chooser_get_show_not_found", libprag.}

proc getShowNotFound*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_show_not_found(cast[ptr RecentChooser00](self.impl)))

proc showNotFound*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_show_not_found(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_show_private*(self: ptr RecentChooser00): gboolean {.
    importc: "gtk_recent_chooser_get_show_private", libprag.}

proc getShowPrivate*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_show_private(cast[ptr RecentChooser00](self.impl)))

proc showPrivate*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_show_private(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_show_tips*(self: ptr RecentChooser00): gboolean {.
    importc: "gtk_recent_chooser_get_show_tips", libprag.}

proc getShowTips*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_show_tips(cast[ptr RecentChooser00](self.impl)))

proc showTips*(self: RecentChooser): bool =
  toBool(gtk_recent_chooser_get_show_tips(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_uris*(self: ptr RecentChooser00; length: var uint64): cstringArray {.
    importc: "gtk_recent_chooser_get_uris", libprag.}

proc getUris*(self: RecentChooser; length: var uint64): cstringArray =
  gtk_recent_chooser_get_uris(cast[ptr RecentChooser00](self.impl), length)

proc uris*(self: RecentChooser; length: var uint64): cstringArray =
  gtk_recent_chooser_get_uris(cast[ptr RecentChooser00](self.impl), length)

proc gtk_recent_chooser_list_filters*(self: ptr RecentChooser00): ptr pointer {.
    importc: "gtk_recent_chooser_list_filters", libprag.}

proc listFilters*(self: RecentChooser): ptr pointer =
  gtk_recent_chooser_list_filters(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_select_all*(self: ptr RecentChooser00) {.
    importc: "gtk_recent_chooser_select_all", libprag.}

proc selectAll*(self: RecentChooser) =
  gtk_recent_chooser_select_all(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_select_uri*(self: ptr RecentChooser00; uri: cstring): gboolean {.
    importc: "gtk_recent_chooser_select_uri", libprag.}

proc selectUri*(self: RecentChooser; uri: string): bool =
  toBool(gtk_recent_chooser_select_uri(cast[ptr RecentChooser00](self.impl), cstring(uri)))

proc gtk_recent_chooser_set_current_uri*(self: ptr RecentChooser00; uri: cstring): gboolean {.
    importc: "gtk_recent_chooser_set_current_uri", libprag.}

proc setCurrentUri*(self: RecentChooser; uri: string): bool =
  toBool(gtk_recent_chooser_set_current_uri(cast[ptr RecentChooser00](self.impl), cstring(uri)))

proc `currentUri=`*(self: RecentChooser; uri: string): bool =
  toBool(gtk_recent_chooser_set_current_uri(cast[ptr RecentChooser00](self.impl), cstring(uri)))

proc gtk_recent_chooser_set_limit*(self: ptr RecentChooser00; limit: int32) {.
    importc: "gtk_recent_chooser_set_limit", libprag.}

proc setLimit*(self: RecentChooser; limit: int) =
  gtk_recent_chooser_set_limit(cast[ptr RecentChooser00](self.impl), int32(limit))

proc `limit=`*(self: RecentChooser; limit: int) =
  gtk_recent_chooser_set_limit(cast[ptr RecentChooser00](self.impl), int32(limit))

proc gtk_recent_chooser_set_local_only*(self: ptr RecentChooser00; localOnly: gboolean) {.
    importc: "gtk_recent_chooser_set_local_only", libprag.}

proc setLocalOnly*(self: RecentChooser; localOnly: bool) =
  gtk_recent_chooser_set_local_only(cast[ptr RecentChooser00](self.impl), gboolean(localOnly))

proc `localOnly=`*(self: RecentChooser; localOnly: bool) =
  gtk_recent_chooser_set_local_only(cast[ptr RecentChooser00](self.impl), gboolean(localOnly))

proc gtk_recent_chooser_set_select_multiple*(self: ptr RecentChooser00; selectMultiple: gboolean) {.
    importc: "gtk_recent_chooser_set_select_multiple", libprag.}

proc setSelectMultiple*(self: RecentChooser; selectMultiple: bool) =
  gtk_recent_chooser_set_select_multiple(cast[ptr RecentChooser00](self.impl), gboolean(selectMultiple))

proc `selectMultiple=`*(self: RecentChooser; selectMultiple: bool) =
  gtk_recent_chooser_set_select_multiple(cast[ptr RecentChooser00](self.impl), gboolean(selectMultiple))

proc gtk_recent_chooser_set_show_icons*(self: ptr RecentChooser00; showIcons: gboolean) {.
    importc: "gtk_recent_chooser_set_show_icons", libprag.}

proc setShowIcons*(self: RecentChooser; showIcons: bool) =
  gtk_recent_chooser_set_show_icons(cast[ptr RecentChooser00](self.impl), gboolean(showIcons))

proc `showIcons=`*(self: RecentChooser; showIcons: bool) =
  gtk_recent_chooser_set_show_icons(cast[ptr RecentChooser00](self.impl), gboolean(showIcons))

proc gtk_recent_chooser_set_show_not_found*(self: ptr RecentChooser00; showNotFound: gboolean) {.
    importc: "gtk_recent_chooser_set_show_not_found", libprag.}

proc setShowNotFound*(self: RecentChooser; showNotFound: bool) =
  gtk_recent_chooser_set_show_not_found(cast[ptr RecentChooser00](self.impl), gboolean(showNotFound))

proc `showNotFound=`*(self: RecentChooser; showNotFound: bool) =
  gtk_recent_chooser_set_show_not_found(cast[ptr RecentChooser00](self.impl), gboolean(showNotFound))

proc gtk_recent_chooser_set_show_private*(self: ptr RecentChooser00; showPrivate: gboolean) {.
    importc: "gtk_recent_chooser_set_show_private", libprag.}

proc setShowPrivate*(self: RecentChooser; showPrivate: bool) =
  gtk_recent_chooser_set_show_private(cast[ptr RecentChooser00](self.impl), gboolean(showPrivate))

proc `showPrivate=`*(self: RecentChooser; showPrivate: bool) =
  gtk_recent_chooser_set_show_private(cast[ptr RecentChooser00](self.impl), gboolean(showPrivate))

proc gtk_recent_chooser_set_show_tips*(self: ptr RecentChooser00; showTips: gboolean) {.
    importc: "gtk_recent_chooser_set_show_tips", libprag.}

proc setShowTips*(self: RecentChooser; showTips: bool) =
  gtk_recent_chooser_set_show_tips(cast[ptr RecentChooser00](self.impl), gboolean(showTips))

proc `showTips=`*(self: RecentChooser; showTips: bool) =
  gtk_recent_chooser_set_show_tips(cast[ptr RecentChooser00](self.impl), gboolean(showTips))

proc gtk_recent_chooser_unselect_all*(self: ptr RecentChooser00) {.
    importc: "gtk_recent_chooser_unselect_all", libprag.}

proc unselectAll*(self: RecentChooser) =
  gtk_recent_chooser_unselect_all(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_unselect_uri*(self: ptr RecentChooser00; uri: cstring) {.
    importc: "gtk_recent_chooser_unselect_uri", libprag.}

proc unselectUri*(self: RecentChooser; uri: string) =
  gtk_recent_chooser_unselect_uri(cast[ptr RecentChooser00](self.impl), cstring(uri))

type
  RecentFilter* = ref object of gobject.InitiallyUnowned
  RecentFilter00* = object of gobject.InitiallyUnowned00

proc gtk_recent_filter_new*(): ptr RecentFilter00 {.
    importc: "gtk_recent_filter_new", libprag.}

proc newRecentFilter*(): RecentFilter =
  new(result, finalizeGObject)
  result.impl = gtk_recent_filter_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentFilter*[T](result: var T) =
  assert(result is RecentFilter)
  new(result, finalizeGObject)
  result.impl = gtk_recent_filter_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_filter_add_age*(self: ptr RecentFilter00; days: int32) {.
    importc: "gtk_recent_filter_add_age", libprag.}

proc addAge*(self: RecentFilter; days: int) =
  gtk_recent_filter_add_age(cast[ptr RecentFilter00](self.impl), int32(days))

proc gtk_recent_filter_add_application*(self: ptr RecentFilter00; application: cstring) {.
    importc: "gtk_recent_filter_add_application", libprag.}

proc addApplication*(self: RecentFilter; application: string) =
  gtk_recent_filter_add_application(cast[ptr RecentFilter00](self.impl), cstring(application))

proc gtk_recent_filter_add_group*(self: ptr RecentFilter00; group: cstring) {.
    importc: "gtk_recent_filter_add_group", libprag.}

proc addGroup*(self: RecentFilter; group: string) =
  gtk_recent_filter_add_group(cast[ptr RecentFilter00](self.impl), cstring(group))

proc gtk_recent_filter_add_mime_type*(self: ptr RecentFilter00; mimeType: cstring) {.
    importc: "gtk_recent_filter_add_mime_type", libprag.}

proc addMimeType*(self: RecentFilter; mimeType: string) =
  gtk_recent_filter_add_mime_type(cast[ptr RecentFilter00](self.impl), cstring(mimeType))

proc gtk_recent_filter_add_pattern*(self: ptr RecentFilter00; pattern: cstring) {.
    importc: "gtk_recent_filter_add_pattern", libprag.}

proc addPattern*(self: RecentFilter; pattern: string) =
  gtk_recent_filter_add_pattern(cast[ptr RecentFilter00](self.impl), cstring(pattern))

proc gtk_recent_filter_add_pixbuf_formats*(self: ptr RecentFilter00) {.
    importc: "gtk_recent_filter_add_pixbuf_formats", libprag.}

proc addPixbufFormats*(self: RecentFilter) =
  gtk_recent_filter_add_pixbuf_formats(cast[ptr RecentFilter00](self.impl))

proc gtk_recent_filter_get_name*(self: ptr RecentFilter00): cstring {.
    importc: "gtk_recent_filter_get_name", libprag.}

proc getName*(self: RecentFilter): string =
  let resul0 = gtk_recent_filter_get_name(cast[ptr RecentFilter00](self.impl))
  result = $resul0

proc name*(self: RecentFilter): string =
  let resul0 = gtk_recent_filter_get_name(cast[ptr RecentFilter00](self.impl))
  result = $resul0

proc gtk_recent_filter_set_name*(self: ptr RecentFilter00; name: cstring) {.
    importc: "gtk_recent_filter_set_name", libprag.}

proc setName*(self: RecentFilter; name: string) =
  gtk_recent_filter_set_name(cast[ptr RecentFilter00](self.impl), cstring(name))

proc `name=`*(self: RecentFilter; name: string) =
  gtk_recent_filter_set_name(cast[ptr RecentFilter00](self.impl), cstring(name))

proc gtk_recent_chooser_add_filter*(self: ptr RecentChooser00; filter: ptr RecentFilter00) {.
    importc: "gtk_recent_chooser_add_filter", libprag.}

proc addFilter*(self: RecentChooser; filter: RecentFilter) =
  gtk_recent_chooser_add_filter(cast[ptr RecentChooser00](self.impl), cast[ptr RecentFilter00](filter.impl))

proc gtk_recent_chooser_get_filter*(self: ptr RecentChooser00): ptr RecentFilter00 {.
    importc: "gtk_recent_chooser_get_filter", libprag.}

proc getFilter*(self: RecentChooser): RecentFilter =
  let gobj = gtk_recent_chooser_get_filter(cast[ptr RecentChooser00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[RecentFilter](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc filter*(self: RecentChooser): RecentFilter =
  let gobj = gtk_recent_chooser_get_filter(cast[ptr RecentChooser00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[RecentFilter](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_chooser_remove_filter*(self: ptr RecentChooser00; filter: ptr RecentFilter00) {.
    importc: "gtk_recent_chooser_remove_filter", libprag.}

proc removeFilter*(self: RecentChooser; filter: RecentFilter) =
  gtk_recent_chooser_remove_filter(cast[ptr RecentChooser00](self.impl), cast[ptr RecentFilter00](filter.impl))

proc gtk_recent_chooser_set_filter*(self: ptr RecentChooser00; filter: ptr RecentFilter00) {.
    importc: "gtk_recent_chooser_set_filter", libprag.}

proc setFilter*(self: RecentChooser; filter: RecentFilter) =
  gtk_recent_chooser_set_filter(cast[ptr RecentChooser00](self.impl), cast[ptr RecentFilter00](filter.impl))

proc `filter=`*(self: RecentChooser; filter: RecentFilter) =
  gtk_recent_chooser_set_filter(cast[ptr RecentChooser00](self.impl), cast[ptr RecentFilter00](filter.impl))

type
  RecentFilterFlag* {.size: sizeof(cint), pure.} = enum
    uri = 1
    displayName = 2
    mimeType = 3
    application = 4
    group = 5
    age = 6

  RecentFilterFlags* {.size: sizeof(cint).} = set[RecentFilterFlag]

type
  RecentFilterInfo00* {.pure.} = object
    contains*: RecentFilterFlags
    uri*: cstring
    displayName*: cstring
    mimeType*: cstring
    applications*: cstringArray
    groups*: cstringArray
    age*: int32
  RecentFilterInfo* = ref object
    impl*: ptr RecentFilterInfo00

proc gtk_recent_filter_filter*(self: ptr RecentFilter00; filterInfo: ptr RecentFilterInfo00): gboolean {.
    importc: "gtk_recent_filter_filter", libprag.}

proc filter*(self: RecentFilter; filterInfo: RecentFilterInfo): bool =
  toBool(gtk_recent_filter_filter(cast[ptr RecentFilter00](self.impl), cast[ptr RecentFilterInfo00](filterInfo.impl)))

proc gtk_recent_filter_get_needed*(self: ptr RecentFilter00): RecentFilterFlags {.
    importc: "gtk_recent_filter_get_needed", libprag.}

proc getNeeded*(self: RecentFilter): RecentFilterFlags =
  gtk_recent_filter_get_needed(cast[ptr RecentFilter00](self.impl))

proc needed*(self: RecentFilter): RecentFilterFlags =
  gtk_recent_filter_get_needed(cast[ptr RecentFilter00](self.impl))

type
  RecentSortType* {.size: sizeof(cint), pure.} = enum
    none = 0
    mru = 1
    lru = 2
    custom = 3

proc gtk_recent_chooser_get_sort_type*(self: ptr RecentChooser00): RecentSortType {.
    importc: "gtk_recent_chooser_get_sort_type", libprag.}

proc getSortType*(self: RecentChooser): RecentSortType =
  gtk_recent_chooser_get_sort_type(cast[ptr RecentChooser00](self.impl))

proc sortType*(self: RecentChooser): RecentSortType =
  gtk_recent_chooser_get_sort_type(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_set_sort_type*(self: ptr RecentChooser00; sortType: RecentSortType) {.
    importc: "gtk_recent_chooser_set_sort_type", libprag.}

proc setSortType*(self: RecentChooser; sortType: RecentSortType) =
  gtk_recent_chooser_set_sort_type(cast[ptr RecentChooser00](self.impl), sortType)

proc `sortType=`*(self: RecentChooser; sortType: RecentSortType) =
  gtk_recent_chooser_set_sort_type(cast[ptr RecentChooser00](self.impl), sortType)

type
  RecentChooserDialogPrivate00* {.pure.} = object
  RecentChooserDialogPrivate* = ref object
    impl*: ptr RecentChooserDialogPrivate00

type
  RecentChooserDialog* = ref object of Dialog
  RecentChooserDialog00* = object of Dialog00
    priv6: ptr RecentChooserDialogPrivate00

type
  RecentChooserDialogClass00* {.pure.} = object
    parentClass*: DialogClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  RecentChooserDialogClass* = ref object
    impl*: ptr RecentChooserDialogClass00

type
  RecentChooserError* {.size: sizeof(cint), pure.} = enum
    notFound = 0
    invalidUri = 1

proc gtk_recent_chooser_error_quark*(): uint32 {.
    importc: "gtk_recent_chooser_error_quark", libprag.}

type
  RecentChooserMenuPrivate00* {.pure.} = object
  RecentChooserMenuPrivate* = ref object
    impl*: ptr RecentChooserMenuPrivate00

type
  RecentChooserMenu* = ref object of Menu
  RecentChooserMenu00* = object of Menu00
    priv5: ptr RecentChooserMenuPrivate00

proc gtk_recent_chooser_menu_new*(): ptr RecentChooserMenu00 {.
    importc: "gtk_recent_chooser_menu_new", libprag.}

proc newRecentChooserMenu*(): RecentChooserMenu =
  new(result, finalizeGObject)
  result.impl = gtk_recent_chooser_menu_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentChooserMenu*[T](result: var T) =
  assert(result is RecentChooserMenu)
  new(result, finalizeGObject)
  result.impl = gtk_recent_chooser_menu_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_chooser_menu_new_for_manager*(manager: ptr RecentManager00): ptr RecentChooserMenu00 {.
    importc: "gtk_recent_chooser_menu_new_for_manager", libprag.}

proc newRecentChooserMenuForManager*(manager: RecentManager): RecentChooserMenu =
  new(result, finalizeGObject)
  result.impl = gtk_recent_chooser_menu_new_for_manager(cast[ptr RecentManager00](manager.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentChooserMenuForManager*[T](result: var T; manager: RecentManager) =
  assert(result is RecentChooserMenu)
  new(result, finalizeGObject)
  result.impl = gtk_recent_chooser_menu_new_for_manager(cast[ptr RecentManager00](manager.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_chooser_menu_get_show_numbers*(self: ptr RecentChooserMenu00): gboolean {.
    importc: "gtk_recent_chooser_menu_get_show_numbers", libprag.}

proc getShowNumbers*(self: RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_menu_get_show_numbers(cast[ptr RecentChooserMenu00](self.impl)))

proc showNumbers*(self: RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_menu_get_show_numbers(cast[ptr RecentChooserMenu00](self.impl)))

proc gtk_recent_chooser_menu_set_show_numbers*(self: ptr RecentChooserMenu00; showNumbers: gboolean) {.
    importc: "gtk_recent_chooser_menu_set_show_numbers", libprag.}

proc setShowNumbers*(self: RecentChooserMenu; showNumbers: bool) =
  gtk_recent_chooser_menu_set_show_numbers(cast[ptr RecentChooserMenu00](self.impl), gboolean(showNumbers))

proc `showNumbers=`*(self: RecentChooserMenu; showNumbers: bool) =
  gtk_recent_chooser_menu_set_show_numbers(cast[ptr RecentChooserMenu00](self.impl), gboolean(showNumbers))

type
  RecentChooserMenuClass00* {.pure.} = object
    parentClass*: MenuClass00
    gtkRecent1*: proc() {.cdecl.}
    gtkRecent2*: proc() {.cdecl.}
    gtkRecent3*: proc() {.cdecl.}
    gtkRecent4*: proc() {.cdecl.}
  RecentChooserMenuClass* = ref object
    impl*: ptr RecentChooserMenuClass00

type
  RecentChooserWidgetPrivate00* {.pure.} = object
  RecentChooserWidgetPrivate* = ref object
    impl*: ptr RecentChooserWidgetPrivate00

type
  RecentChooserWidget* = ref object of Box
  RecentChooserWidget00* = object of Box00
    priv4: ptr RecentChooserWidgetPrivate00

proc gtk_recent_chooser_widget_new*(): ptr RecentChooserWidget00 {.
    importc: "gtk_recent_chooser_widget_new", libprag.}

proc newRecentChooserWidget*(): RecentChooserWidget =
  new(result, finalizeGObject)
  result.impl = gtk_recent_chooser_widget_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentChooserWidget*[T](result: var T) =
  assert(result is RecentChooserWidget)
  new(result, finalizeGObject)
  result.impl = gtk_recent_chooser_widget_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_chooser_widget_new_for_manager*(manager: ptr RecentManager00): ptr RecentChooserWidget00 {.
    importc: "gtk_recent_chooser_widget_new_for_manager", libprag.}

proc newRecentChooserWidgetForManager*(manager: RecentManager): RecentChooserWidget =
  new(result, finalizeGObject)
  result.impl = gtk_recent_chooser_widget_new_for_manager(cast[ptr RecentManager00](manager.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentChooserWidgetForManager*[T](result: var T; manager: RecentManager) =
  assert(result is RecentChooserWidget)
  new(result, finalizeGObject)
  result.impl = gtk_recent_chooser_widget_new_for_manager(cast[ptr RecentManager00](manager.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  RecentChooserWidgetClass00* {.pure.} = object
    parentClass*: BoxClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  RecentChooserWidgetClass* = ref object
    impl*: ptr RecentChooserWidgetClass00

type
  RecentFilterFunc* = proc (filterInfo: ptr RecentFilterInfo00; userData: pointer): gboolean {.cdecl.}

proc gtk_recent_filter_add_custom*(self: ptr RecentFilter00; needed: RecentFilterFlags; 
    `func`: RecentFilterFunc; data: pointer; dataDestroy: DestroyNotify) {.
    importc: "gtk_recent_filter_add_custom", libprag.}

proc addCustom*(self: RecentFilter; needed: RecentFilterFlags; `func`: RecentFilterFunc; 
    data: pointer; dataDestroy: DestroyNotify) =
  gtk_recent_filter_add_custom(cast[ptr RecentFilter00](self.impl), needed, `func`, data, dataDestroy)

type
  RecentManagerClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    changed*: proc(manager: ptr RecentManager00) {.cdecl.}
    gtkRecent1*: pointer
    gtkRecent2*: pointer
    gtkRecent3*: pointer
    gtkRecent4*: pointer
  RecentManagerClass* = ref object
    impl*: ptr RecentManagerClass00

type
  RecentManagerError* {.size: sizeof(cint), pure.} = enum
    notFound = 0
    invalidUri = 1
    invalidEncoding = 2
    notRegistered = 3
    read = 4
    write = 5
    unknown = 6

proc gtk_recent_manager_error_quark*(): uint32 {.
    importc: "gtk_recent_manager_error_quark", libprag.}

type
  RecentSortFunc* = proc (a: ptr RecentInfo00; b: ptr RecentInfo00; userData: pointer): int32 {.cdecl.}

type
  RecentChooserIface00* {.pure.} = object
    baseIface*: gobject.TypeInterface00
    setCurrentUri*: proc(chooser: ptr RecentChooser00; uri: cstring): gboolean {.cdecl.}
    getCurrentUri*: proc(chooser: ptr RecentChooser00): cstring {.cdecl.}
    selectUri*: proc(chooser: ptr RecentChooser00; uri: cstring): gboolean {.cdecl.}
    unselectUri*: proc(chooser: ptr RecentChooser00; uri: cstring) {.cdecl.}
    selectAll*: proc(chooser: ptr RecentChooser00) {.cdecl.}
    unselectAll*: proc(chooser: ptr RecentChooser00) {.cdecl.}
    getItems*: proc(chooser: ptr RecentChooser00): ptr pointer {.cdecl.}
    getRecentManager*: pointer
    addFilter*: proc(chooser: ptr RecentChooser00; filter: ptr RecentFilter00) {.cdecl.}
    removeFilter*: proc(chooser: ptr RecentChooser00; filter: ptr RecentFilter00) {.cdecl.}
    listFilters*: proc(chooser: ptr RecentChooser00): ptr pointer {.cdecl.}
    setSortFunc*: proc(chooser: ptr RecentChooser00; sortFunc: RecentSortFunc; 
    sortData: pointer; dataDestroy: DestroyNotify) {.cdecl.}
    itemActivated*: proc(chooser: ptr RecentChooser00) {.cdecl.}
    selectionChanged*: proc(chooser: ptr RecentChooser00) {.cdecl.}
  RecentChooserIface* = ref object
    impl*: ptr RecentChooserIface00

proc gtk_recent_chooser_set_sort_func*(self: ptr RecentChooser00; sortFunc: RecentSortFunc; 
    sortData: pointer; dataDestroy: DestroyNotify) {.
    importc: "gtk_recent_chooser_set_sort_func", libprag.}

proc setSortFunc*(self: RecentChooser; sortFunc: RecentSortFunc; sortData: pointer; 
    dataDestroy: DestroyNotify) =
  gtk_recent_chooser_set_sort_func(cast[ptr RecentChooser00](self.impl), sortFunc, sortData, dataDestroy)

type
  RequestedSize00* {.pure.} = object
    data*: pointer
    minimumSize*: int32
    naturalSize*: int32
  RequestedSize* = ref object
    impl*: ptr RequestedSize00

type
  ResponseType* {.size: sizeof(cint), pure.} = enum
    help = -11
    apply = -10
    no = -9
    yes = -8
    close = -7
    cancel = -6
    ok = -5
    deleteEvent = -4
    accept = -3
    reject = -2
    none = -1

type
  Revealer* = ref object of Bin
  Revealer00* = object of Bin00

proc gtk_revealer_new*(): ptr Revealer00 {.
    importc: "gtk_revealer_new", libprag.}

proc newRevealer*(): Revealer =
  new(result, finalizeGObject)
  result.impl = gtk_revealer_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRevealer*[T](result: var T) =
  assert(result is Revealer)
  new(result, finalizeGObject)
  result.impl = gtk_revealer_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_revealer_get_child_revealed*(self: ptr Revealer00): gboolean {.
    importc: "gtk_revealer_get_child_revealed", libprag.}

proc getChildRevealed*(self: Revealer): bool =
  toBool(gtk_revealer_get_child_revealed(cast[ptr Revealer00](self.impl)))

proc childRevealed*(self: Revealer): bool =
  toBool(gtk_revealer_get_child_revealed(cast[ptr Revealer00](self.impl)))

proc gtk_revealer_get_reveal_child*(self: ptr Revealer00): gboolean {.
    importc: "gtk_revealer_get_reveal_child", libprag.}

proc getRevealChild*(self: Revealer): bool =
  toBool(gtk_revealer_get_reveal_child(cast[ptr Revealer00](self.impl)))

proc revealChild*(self: Revealer): bool =
  toBool(gtk_revealer_get_reveal_child(cast[ptr Revealer00](self.impl)))

proc gtk_revealer_get_transition_duration*(self: ptr Revealer00): uint32 {.
    importc: "gtk_revealer_get_transition_duration", libprag.}

proc getTransitionDuration*(self: Revealer): int =
  int(gtk_revealer_get_transition_duration(cast[ptr Revealer00](self.impl)))

proc transitionDuration*(self: Revealer): int =
  int(gtk_revealer_get_transition_duration(cast[ptr Revealer00](self.impl)))

proc gtk_revealer_set_reveal_child*(self: ptr Revealer00; revealChild: gboolean) {.
    importc: "gtk_revealer_set_reveal_child", libprag.}

proc setRevealChild*(self: Revealer; revealChild: bool) =
  gtk_revealer_set_reveal_child(cast[ptr Revealer00](self.impl), gboolean(revealChild))

proc `revealChild=`*(self: Revealer; revealChild: bool) =
  gtk_revealer_set_reveal_child(cast[ptr Revealer00](self.impl), gboolean(revealChild))

proc gtk_revealer_set_transition_duration*(self: ptr Revealer00; duration: uint32) {.
    importc: "gtk_revealer_set_transition_duration", libprag.}

proc setTransitionDuration*(self: Revealer; duration: int) =
  gtk_revealer_set_transition_duration(cast[ptr Revealer00](self.impl), uint32(duration))

proc `transitionDuration=`*(self: Revealer; duration: int) =
  gtk_revealer_set_transition_duration(cast[ptr Revealer00](self.impl), uint32(duration))

type
  RevealerTransitionType* {.size: sizeof(cint), pure.} = enum
    none = 0
    crossfade = 1
    slideRight = 2
    slideLeft = 3
    slideUp = 4
    slideDown = 5

proc gtk_revealer_get_transition_type*(self: ptr Revealer00): RevealerTransitionType {.
    importc: "gtk_revealer_get_transition_type", libprag.}

proc getTransitionType*(self: Revealer): RevealerTransitionType =
  gtk_revealer_get_transition_type(cast[ptr Revealer00](self.impl))

proc transitionType*(self: Revealer): RevealerTransitionType =
  gtk_revealer_get_transition_type(cast[ptr Revealer00](self.impl))

proc gtk_revealer_set_transition_type*(self: ptr Revealer00; transition: RevealerTransitionType) {.
    importc: "gtk_revealer_set_transition_type", libprag.}

proc setTransitionType*(self: Revealer; transition: RevealerTransitionType) =
  gtk_revealer_set_transition_type(cast[ptr Revealer00](self.impl), transition)

proc `transitionType=`*(self: Revealer; transition: RevealerTransitionType) =
  gtk_revealer_set_transition_type(cast[ptr Revealer00](self.impl), transition)

type
  RevealerClass00* {.pure.} = object
    parentClass*: BinClass00
  RevealerClass* = ref object
    impl*: ptr RevealerClass00

const STOCK_ABOUT* = "gtk-about"

const STOCK_ADD* = "gtk-add"

const STOCK_APPLY* = "gtk-apply"

const STOCK_BOLD* = "gtk-bold"

const STOCK_CANCEL* = "gtk-cancel"

const STOCK_CAPS_LOCK_WARNING* = "gtk-caps-lock-warning"

const STOCK_CDROM* = "gtk-cdrom"

const STOCK_CLEAR* = "gtk-clear"

const STOCK_CLOSE* = "gtk-close"

const STOCK_COLOR_PICKER* = "gtk-color-picker"

const STOCK_CONNECT* = "gtk-connect"

const STOCK_CONVERT* = "gtk-convert"

const STOCK_COPY* = "gtk-copy"

const STOCK_CUT* = "gtk-cut"

const STOCK_DELETE* = "gtk-delete"

const STOCK_DIALOG_AUTHENTICATION* = "gtk-dialog-authentication"

const STOCK_DIALOG_ERROR* = "gtk-dialog-error"

const STOCK_DIALOG_INFO* = "gtk-dialog-info"

const STOCK_DIALOG_QUESTION* = "gtk-dialog-question"

const STOCK_DIALOG_WARNING* = "gtk-dialog-warning"

const STOCK_DIRECTORY* = "gtk-directory"

const STOCK_DISCARD* = "gtk-discard"

const STOCK_DISCONNECT* = "gtk-disconnect"

const STOCK_DND* = "gtk-dnd"

const STOCK_DND_MULTIPLE* = "gtk-dnd-multiple"

const STOCK_EDIT* = "gtk-edit"

const STOCK_EXECUTE* = "gtk-execute"

const STOCK_FILE* = "gtk-file"

const STOCK_FIND* = "gtk-find"

const STOCK_FIND_AND_REPLACE* = "gtk-find-and-replace"

const STOCK_FLOPPY* = "gtk-floppy"

const STOCK_FULLSCREEN* = "gtk-fullscreen"

const STOCK_GOTO_BOTTOM* = "gtk-goto-bottom"

const STOCK_GOTO_FIRST* = "gtk-goto-first"

const STOCK_GOTO_LAST* = "gtk-goto-last"

const STOCK_GOTO_TOP* = "gtk-goto-top"

const STOCK_GO_BACK* = "gtk-go-back"

const STOCK_GO_DOWN* = "gtk-go-down"

const STOCK_GO_FORWARD* = "gtk-go-forward"

const STOCK_GO_UP* = "gtk-go-up"

const STOCK_HARDDISK* = "gtk-harddisk"

const STOCK_HELP* = "gtk-help"

const STOCK_HOME* = "gtk-home"

const STOCK_INDENT* = "gtk-indent"

const STOCK_INDEX* = "gtk-index"

const STOCK_INFO* = "gtk-info"

const STOCK_ITALIC* = "gtk-italic"

const STOCK_JUMP_TO* = "gtk-jump-to"

const STOCK_JUSTIFY_CENTER* = "gtk-justify-center"

const STOCK_JUSTIFY_FILL* = "gtk-justify-fill"

const STOCK_JUSTIFY_LEFT* = "gtk-justify-left"

const STOCK_JUSTIFY_RIGHT* = "gtk-justify-right"

const STOCK_LEAVE_FULLSCREEN* = "gtk-leave-fullscreen"

const STOCK_MEDIA_FORWARD* = "gtk-media-forward"

const STOCK_MEDIA_NEXT* = "gtk-media-next"

const STOCK_MEDIA_PAUSE* = "gtk-media-pause"

const STOCK_MEDIA_PLAY* = "gtk-media-play"

const STOCK_MEDIA_PREVIOUS* = "gtk-media-previous"

const STOCK_MEDIA_RECORD* = "gtk-media-record"

const STOCK_MEDIA_REWIND* = "gtk-media-rewind"

const STOCK_MEDIA_STOP* = "gtk-media-stop"

const STOCK_MISSING_IMAGE* = "gtk-missing-image"

const STOCK_NETWORK* = "gtk-network"

const STOCK_NEW* = "gtk-new"

const STOCK_NO* = "gtk-no"

const STOCK_OK* = "gtk-ok"

const STOCK_OPEN* = "gtk-open"

const STOCK_ORIENTATION_LANDSCAPE* = "gtk-orientation-landscape"

const STOCK_ORIENTATION_PORTRAIT* = "gtk-orientation-portrait"

const STOCK_ORIENTATION_REVERSE_LANDSCAPE* = "gtk-orientation-reverse-landscape"

const STOCK_ORIENTATION_REVERSE_PORTRAIT* = "gtk-orientation-reverse-portrait"

const STOCK_PAGE_SETUP* = "gtk-page-setup"

const STOCK_PASTE* = "gtk-paste"

const STOCK_PREFERENCES* = "gtk-preferences"

const STOCK_PRINT* = "gtk-print"

const STOCK_PRINT_ERROR* = "gtk-print-error"

const STOCK_PRINT_PAUSED* = "gtk-print-paused"

const STOCK_PRINT_PREVIEW* = "gtk-print-preview"

const STOCK_PRINT_REPORT* = "gtk-print-report"

const STOCK_PRINT_WARNING* = "gtk-print-warning"

const STOCK_PROPERTIES* = "gtk-properties"

const STOCK_QUIT* = "gtk-quit"

const STOCK_REDO* = "gtk-redo"

const STOCK_REFRESH* = "gtk-refresh"

const STOCK_REMOVE* = "gtk-remove"

const STOCK_REVERT_TO_SAVED* = "gtk-revert-to-saved"

const STOCK_SAVE* = "gtk-save"

const STOCK_SAVE_AS* = "gtk-save-as"

const STOCK_SELECT_ALL* = "gtk-select-all"

const STOCK_SELECT_COLOR* = "gtk-select-color"

const STOCK_SELECT_FONT* = "gtk-select-font"

const STOCK_SORT_ASCENDING* = "gtk-sort-ascending"

const STOCK_SORT_DESCENDING* = "gtk-sort-descending"

const STOCK_SPELL_CHECK* = "gtk-spell-check"

const STOCK_STOP* = "gtk-stop"

const STOCK_STRIKETHROUGH* = "gtk-strikethrough"

const STOCK_UNDELETE* = "gtk-undelete"

const STOCK_UNDERLINE* = "gtk-underline"

const STOCK_UNDO* = "gtk-undo"

const STOCK_UNINDENT* = "gtk-unindent"

const STOCK_YES* = "gtk-yes"

const STOCK_ZOOM_100* = "gtk-zoom-100"

const STOCK_ZOOM_FIT* = "gtk-zoom-fit"

const STOCK_ZOOM_IN* = "gtk-zoom-in"

const STOCK_ZOOM_OUT* = "gtk-zoom-out"

const STYLE_CLASS_ACCELERATOR* = "accelerator"

const STYLE_CLASS_ARROW* = "arrow"

const STYLE_CLASS_BACKGROUND* = "background"

const STYLE_CLASS_BOTTOM* = "bottom"

const STYLE_CLASS_BUTTON* = "button"

const STYLE_CLASS_CALENDAR* = "calendar"

const STYLE_CLASS_CELL* = "cell"

const STYLE_CLASS_CHECK* = "check"

const STYLE_CLASS_COMBOBOX_ENTRY* = "combobox-entry"

const STYLE_CLASS_CONTEXT_MENU* = "context-menu"

const STYLE_CLASS_CSD* = "csd"

const STYLE_CLASS_CURSOR_HANDLE* = "cursor-handle"

const STYLE_CLASS_DEFAULT* = "default"

const STYLE_CLASS_DESTRUCTIVE_ACTION* = "destructive-action"

const STYLE_CLASS_DIM_LABEL* = "dim-label"

const STYLE_CLASS_DND* = "dnd"

const STYLE_CLASS_DOCK* = "dock"

const STYLE_CLASS_ENTRY* = "entry"

const STYLE_CLASS_ERROR* = "error"

const STYLE_CLASS_EXPANDER* = "expander"

const STYLE_CLASS_FLAT* = "flat"

const STYLE_CLASS_FRAME* = "frame"

const STYLE_CLASS_GRIP* = "grip"

const STYLE_CLASS_HEADER* = "header"

const STYLE_CLASS_HIGHLIGHT* = "highlight"

const STYLE_CLASS_HORIZONTAL* = "horizontal"

const STYLE_CLASS_IMAGE* = "image"

const STYLE_CLASS_INFO* = "info"

const STYLE_CLASS_INLINE_TOOLBAR* = "inline-toolbar"

const STYLE_CLASS_INSERTION_CURSOR* = "insertion-cursor"

const STYLE_CLASS_LABEL* = "label"

const STYLE_CLASS_LEFT* = "left"

const STYLE_CLASS_LEVEL_BAR* = "level-bar"

const STYLE_CLASS_LINKED* = "linked"

const STYLE_CLASS_LIST* = "list"

const STYLE_CLASS_LIST_ROW* = "list-row"

const STYLE_CLASS_MARK* = "mark"

const STYLE_CLASS_MENU* = "menu"

const STYLE_CLASS_MENUBAR* = "menubar"

const STYLE_CLASS_MENUITEM* = "menuitem"

const STYLE_CLASS_MESSAGE_DIALOG* = "message-dialog"

const STYLE_CLASS_MONOSPACE* = "monospace"

const STYLE_CLASS_NEEDS_ATTENTION* = "needs-attention"

const STYLE_CLASS_NOTEBOOK* = "notebook"

const STYLE_CLASS_OSD* = "osd"

const STYLE_CLASS_OVERSHOOT* = "overshoot"

const STYLE_CLASS_PANE_SEPARATOR* = "pane-separator"

const STYLE_CLASS_PAPER* = "paper"

const STYLE_CLASS_POPOVER* = "popover"

const STYLE_CLASS_POPUP* = "popup"

const STYLE_CLASS_PRIMARY_TOOLBAR* = "primary-toolbar"

const STYLE_CLASS_PROGRESSBAR* = "progressbar"

const STYLE_CLASS_PULSE* = "pulse"

const STYLE_CLASS_QUESTION* = "question"

const STYLE_CLASS_RADIO* = "radio"

const STYLE_CLASS_RAISED* = "raised"

const STYLE_CLASS_READ_ONLY* = "read-only"

const STYLE_CLASS_RIGHT* = "right"

const STYLE_CLASS_RUBBERBAND* = "rubberband"

const STYLE_CLASS_SCALE* = "scale"

const STYLE_CLASS_SCALE_HAS_MARKS_ABOVE* = "scale-has-marks-above"

const STYLE_CLASS_SCALE_HAS_MARKS_BELOW* = "scale-has-marks-below"

const STYLE_CLASS_SCROLLBAR* = "scrollbar"

const STYLE_CLASS_SCROLLBARS_JUNCTION* = "scrollbars-junction"

const STYLE_CLASS_SEPARATOR* = "separator"

const STYLE_CLASS_SIDEBAR* = "sidebar"

const STYLE_CLASS_SLIDER* = "slider"

const STYLE_CLASS_SPINBUTTON* = "spinbutton"

const STYLE_CLASS_SPINNER* = "spinner"

const STYLE_CLASS_STATUSBAR* = "statusbar"

const STYLE_CLASS_SUBTITLE* = "subtitle"

const STYLE_CLASS_SUGGESTED_ACTION* = "suggested-action"

const STYLE_CLASS_TITLE* = "title"

const STYLE_CLASS_TITLEBAR* = "titlebar"

const STYLE_CLASS_TOOLBAR* = "toolbar"

const STYLE_CLASS_TOOLTIP* = "tooltip"

const STYLE_CLASS_TOP* = "top"

const STYLE_CLASS_TOUCH_SELECTION* = "touch-selection"

const STYLE_CLASS_TROUGH* = "trough"

const STYLE_CLASS_UNDERSHOOT* = "undershoot"

const STYLE_CLASS_VERTICAL* = "vertical"

const STYLE_CLASS_VIEW* = "view"

const STYLE_CLASS_WARNING* = "warning"

const STYLE_CLASS_WIDE* = "wide"

const STYLE_PROPERTY_BACKGROUND_COLOR* = "background-color"

const STYLE_PROPERTY_BACKGROUND_IMAGE* = "background-image"

const STYLE_PROPERTY_BORDER_COLOR* = "border-color"

const STYLE_PROPERTY_BORDER_RADIUS* = "border-radius"

const STYLE_PROPERTY_BORDER_STYLE* = "border-style"

const STYLE_PROPERTY_BORDER_WIDTH* = "border-width"

const STYLE_PROPERTY_COLOR* = "color"

const STYLE_PROPERTY_FONT* = "font"

const STYLE_PROPERTY_MARGIN* = "margin"

const STYLE_PROPERTY_PADDING* = "padding"

const STYLE_PROVIDER_PRIORITY_APPLICATION* = 600'i32

const STYLE_PROVIDER_PRIORITY_FALLBACK* = 1'i32

const STYLE_PROVIDER_PRIORITY_SETTINGS* = 400'i32

const STYLE_PROVIDER_PRIORITY_THEME* = 200'i32

const STYLE_PROVIDER_PRIORITY_USER* = 800'i32

const STYLE_REGION_COLUMN* = "column"

const STYLE_REGION_COLUMN_HEADER* = "column-header"

const STYLE_REGION_ROW* = "row"

const STYLE_REGION_TAB* = "tab"

type
  ScaleAccessiblePrivate00* {.pure.} = object
  ScaleAccessiblePrivate* = ref object
    impl*: ptr ScaleAccessiblePrivate00

type
  ScaleAccessible* = ref object of RangeAccessible
  ScaleAccessible00* = object of RangeAccessible00
    priv4: ptr ScaleAccessiblePrivate00

type
  ScaleAccessibleClass00* {.pure.} = object
    parentClass*: RangeAccessibleClass00
  ScaleAccessibleClass* = ref object
    impl*: ptr ScaleAccessibleClass00

type
  ScaleButtonPrivate00* {.pure.} = object
  ScaleButtonPrivate* = ref object
    impl*: ptr ScaleButtonPrivate00

type
  ScaleButton* = ref object of Button
  ScaleButton00* = object of Button00
    priv5: ptr ScaleButtonPrivate00

proc scPopdown*(self: ScaleButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "popdown", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopup*(self: ScaleButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "popup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scValueChanged*(self: ScaleButton;  p: proc (self: ptr gobject.Object00; value: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_scale_button_new*(size: int32; min: cdouble; max: cdouble; step: cdouble; 
    icons: cstringArray): ptr ScaleButton00 {.
    importc: "gtk_scale_button_new", libprag.}

proc newScaleButton*(size: int; min: cdouble; max: cdouble; step: cdouble; 
    icons: cstringArray): ScaleButton =
  new(result, finalizeGObject)
  result.impl = gtk_scale_button_new(int32(size), min, max, step, icons)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScaleButton*[T](result: var T; size: int; min: cdouble; max: cdouble; step: cdouble; 
    icons: cstringArray) =
  assert(result is ScaleButton)
  new(result, finalizeGObject)
  result.impl = gtk_scale_button_new(int32(size), min, max, step, icons)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_adjustment*(self: ptr ScaleButton00): ptr Adjustment00 {.
    importc: "gtk_scale_button_get_adjustment", libprag.}

proc getAdjustment*(self: ScaleButton): Adjustment =
  let gobj = gtk_scale_button_get_adjustment(cast[ptr ScaleButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: ScaleButton): Adjustment =
  let gobj = gtk_scale_button_get_adjustment(cast[ptr ScaleButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_minus_button*(self: ptr ScaleButton00): ptr Button00 {.
    importc: "gtk_scale_button_get_minus_button", libprag.}

proc getMinusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_minus_button(cast[ptr ScaleButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Button](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc minusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_minus_button(cast[ptr ScaleButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Button](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_plus_button*(self: ptr ScaleButton00): ptr Button00 {.
    importc: "gtk_scale_button_get_plus_button", libprag.}

proc getPlusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_plus_button(cast[ptr ScaleButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Button](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc plusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_plus_button(cast[ptr ScaleButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Button](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_popup*(self: ptr ScaleButton00): ptr Widget00 {.
    importc: "gtk_scale_button_get_popup", libprag.}

proc getPopup*(self: ScaleButton): Widget =
  let gobj = gtk_scale_button_get_popup(cast[ptr ScaleButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popup*(self: ScaleButton): Widget =
  let gobj = gtk_scale_button_get_popup(cast[ptr ScaleButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_value*(self: ptr ScaleButton00): cdouble {.
    importc: "gtk_scale_button_get_value", libprag.}

proc getValue*(self: ScaleButton): cdouble =
  gtk_scale_button_get_value(cast[ptr ScaleButton00](self.impl))

proc value*(self: ScaleButton): cdouble =
  gtk_scale_button_get_value(cast[ptr ScaleButton00](self.impl))

proc gtk_scale_button_set_adjustment*(self: ptr ScaleButton00; adjustment: ptr Adjustment00) {.
    importc: "gtk_scale_button_set_adjustment", libprag.}

proc setAdjustment*(self: ScaleButton; adjustment: Adjustment) =
  gtk_scale_button_set_adjustment(cast[ptr ScaleButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: ScaleButton; adjustment: Adjustment) =
  gtk_scale_button_set_adjustment(cast[ptr ScaleButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_scale_button_set_icons*(self: ptr ScaleButton00; icons: cstringArray) {.
    importc: "gtk_scale_button_set_icons", libprag.}

proc setIcons*(self: ScaleButton; icons: cstringArray) =
  gtk_scale_button_set_icons(cast[ptr ScaleButton00](self.impl), icons)

proc `icons=`*(self: ScaleButton; icons: cstringArray) =
  gtk_scale_button_set_icons(cast[ptr ScaleButton00](self.impl), icons)

proc gtk_scale_button_set_value*(self: ptr ScaleButton00; value: cdouble) {.
    importc: "gtk_scale_button_set_value", libprag.}

proc setValue*(self: ScaleButton; value: cdouble) =
  gtk_scale_button_set_value(cast[ptr ScaleButton00](self.impl), value)

proc `value=`*(self: ScaleButton; value: cdouble) =
  gtk_scale_button_set_value(cast[ptr ScaleButton00](self.impl), value)

type
  ScaleButtonAccessiblePrivate00* {.pure.} = object
  ScaleButtonAccessiblePrivate* = ref object
    impl*: ptr ScaleButtonAccessiblePrivate00

type
  ScaleButtonAccessible* = ref object of ButtonAccessible
  ScaleButtonAccessible00* = object of ButtonAccessible00
    priv5: ptr ScaleButtonAccessiblePrivate00

type
  ScaleButtonAccessibleClass00* {.pure.} = object
    parentClass*: ButtonAccessibleClass00
  ScaleButtonAccessibleClass* = ref object
    impl*: ptr ScaleButtonAccessibleClass00

type
  ScaleButtonClass00* {.pure.} = object
    parentClass*: ButtonClass00
    valueChanged*: proc(button: ptr ScaleButton00; value: cdouble) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ScaleButtonClass* = ref object
    impl*: ptr ScaleButtonClass00

type
  ScrollStep* {.size: sizeof(cint), pure.} = enum
    steps = 0
    pages = 1
    ends = 2
    horizontalSteps = 3
    horizontalPages = 4
    horizontalEnds = 5

type
  Scrollable00* {.pure.} = object
  Scrollable* = ref object
    impl*: ptr Scrollable00

proc gtk_scrollable_get_border*(self: ptr Scrollable00; border: var Border00): gboolean {.
    importc: "gtk_scrollable_get_border", libprag.}

proc getBorder*(self: ptr Scrollable00; border: var Border00): gboolean {.
    importc: "gtk_scrollable_get_border", libprag.}

proc border*(self: ptr Scrollable00; border: var Border00): gboolean {.
    importc: "gtk_scrollable_get_border", libprag.}

proc gtk_scrollable_get_hadjustment*(self: ptr Scrollable00): ptr Adjustment00 {.
    importc: "gtk_scrollable_get_hadjustment", libprag.}

proc getHadjustment*(self: Scrollable): Adjustment =
  let gobj = gtk_scrollable_get_hadjustment(cast[ptr Scrollable00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: Scrollable): Adjustment =
  let gobj = gtk_scrollable_get_hadjustment(cast[ptr Scrollable00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrollable_get_vadjustment*(self: ptr Scrollable00): ptr Adjustment00 {.
    importc: "gtk_scrollable_get_vadjustment", libprag.}

proc getVadjustment*(self: Scrollable): Adjustment =
  let gobj = gtk_scrollable_get_vadjustment(cast[ptr Scrollable00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: Scrollable): Adjustment =
  let gobj = gtk_scrollable_get_vadjustment(cast[ptr Scrollable00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrollable_set_hadjustment*(self: ptr Scrollable00; hadjustment: ptr Adjustment00) {.
    importc: "gtk_scrollable_set_hadjustment", libprag.}

proc setHadjustment*(self: Scrollable; hadjustment: Adjustment) =
  gtk_scrollable_set_hadjustment(cast[ptr Scrollable00](self.impl), cast[ptr Adjustment00](hadjustment.impl))

proc `hadjustment=`*(self: Scrollable; hadjustment: Adjustment) =
  gtk_scrollable_set_hadjustment(cast[ptr Scrollable00](self.impl), cast[ptr Adjustment00](hadjustment.impl))

proc gtk_scrollable_set_vadjustment*(self: ptr Scrollable00; vadjustment: ptr Adjustment00) {.
    importc: "gtk_scrollable_set_vadjustment", libprag.}

proc setVadjustment*(self: Scrollable; vadjustment: Adjustment) =
  gtk_scrollable_set_vadjustment(cast[ptr Scrollable00](self.impl), cast[ptr Adjustment00](vadjustment.impl))

proc `vadjustment=`*(self: Scrollable; vadjustment: Adjustment) =
  gtk_scrollable_set_vadjustment(cast[ptr Scrollable00](self.impl), cast[ptr Adjustment00](vadjustment.impl))

type
  ScrollablePolicy* {.size: sizeof(cint), pure.} = enum
    minimum = 0
    natural = 1

proc gtk_scrollable_get_hscroll_policy*(self: ptr Scrollable00): ScrollablePolicy {.
    importc: "gtk_scrollable_get_hscroll_policy", libprag.}

proc getHscrollPolicy*(self: Scrollable): ScrollablePolicy =
  gtk_scrollable_get_hscroll_policy(cast[ptr Scrollable00](self.impl))

proc hscrollPolicy*(self: Scrollable): ScrollablePolicy =
  gtk_scrollable_get_hscroll_policy(cast[ptr Scrollable00](self.impl))

proc gtk_scrollable_get_vscroll_policy*(self: ptr Scrollable00): ScrollablePolicy {.
    importc: "gtk_scrollable_get_vscroll_policy", libprag.}

proc getVscrollPolicy*(self: Scrollable): ScrollablePolicy =
  gtk_scrollable_get_vscroll_policy(cast[ptr Scrollable00](self.impl))

proc vscrollPolicy*(self: Scrollable): ScrollablePolicy =
  gtk_scrollable_get_vscroll_policy(cast[ptr Scrollable00](self.impl))

proc gtk_scrollable_set_hscroll_policy*(self: ptr Scrollable00; policy: ScrollablePolicy) {.
    importc: "gtk_scrollable_set_hscroll_policy", libprag.}

proc setHscrollPolicy*(self: Scrollable; policy: ScrollablePolicy) =
  gtk_scrollable_set_hscroll_policy(cast[ptr Scrollable00](self.impl), policy)

proc `hscrollPolicy=`*(self: Scrollable; policy: ScrollablePolicy) =
  gtk_scrollable_set_hscroll_policy(cast[ptr Scrollable00](self.impl), policy)

proc gtk_scrollable_set_vscroll_policy*(self: ptr Scrollable00; policy: ScrollablePolicy) {.
    importc: "gtk_scrollable_set_vscroll_policy", libprag.}

proc setVscrollPolicy*(self: Scrollable; policy: ScrollablePolicy) =
  gtk_scrollable_set_vscroll_policy(cast[ptr Scrollable00](self.impl), policy)

proc `vscrollPolicy=`*(self: Scrollable; policy: ScrollablePolicy) =
  gtk_scrollable_set_vscroll_policy(cast[ptr Scrollable00](self.impl), policy)

type
  ScrollableInterface00* {.pure.} = object
    baseIface*: gobject.TypeInterface00
    getBorder*: proc(scrollable: ptr Scrollable00; border: var Border00): gboolean {.cdecl.}
  ScrollableInterface* = ref object
    impl*: ptr ScrollableInterface00

type
  ScrolledWindowAccessiblePrivate00* {.pure.} = object
  ScrolledWindowAccessiblePrivate* = ref object
    impl*: ptr ScrolledWindowAccessiblePrivate00

type
  ScrolledWindowAccessible* = ref object of ContainerAccessible
  ScrolledWindowAccessible00* = object of ContainerAccessible00
    priv4: ptr ScrolledWindowAccessiblePrivate00

type
  ScrolledWindowAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  ScrolledWindowAccessibleClass* = ref object
    impl*: ptr ScrolledWindowAccessibleClass00

type
  ScrolledWindowClass00* {.pure.} = object
    parentClass*: BinClass00
    scrollbarSpacing*: int32
    scrollChild*: proc(scrolledWindow: ptr ScrolledWindow00; scroll: ScrollType; 
    horizontal: gboolean): gboolean {.cdecl.}
    moveFocusOut*: proc(scrolledWindow: ptr ScrolledWindow00; direction: DirectionType) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ScrolledWindowClass* = ref object
    impl*: ptr ScrolledWindowClass00

type
  SearchBar* = ref object of Bin
  SearchBar00* = object of Bin00

proc gtk_search_bar_new*(): ptr SearchBar00 {.
    importc: "gtk_search_bar_new", libprag.}

proc newSearchBar*(): SearchBar =
  new(result, finalizeGObject)
  result.impl = gtk_search_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSearchBar*[T](result: var T) =
  assert(result is SearchBar)
  new(result, finalizeGObject)
  result.impl = gtk_search_bar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_search_bar_connect_entry*(self: ptr SearchBar00; entry: ptr Entry00) {.
    importc: "gtk_search_bar_connect_entry", libprag.}

proc connectEntry*(self: SearchBar; entry: Entry) =
  gtk_search_bar_connect_entry(cast[ptr SearchBar00](self.impl), cast[ptr Entry00](entry.impl))

proc gtk_search_bar_get_search_mode*(self: ptr SearchBar00): gboolean {.
    importc: "gtk_search_bar_get_search_mode", libprag.}

proc getSearchMode*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_search_mode(cast[ptr SearchBar00](self.impl)))

proc searchMode*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_search_mode(cast[ptr SearchBar00](self.impl)))

proc gtk_search_bar_get_show_close_button*(self: ptr SearchBar00): gboolean {.
    importc: "gtk_search_bar_get_show_close_button", libprag.}

proc getShowCloseButton*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_show_close_button(cast[ptr SearchBar00](self.impl)))

proc showCloseButton*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_show_close_button(cast[ptr SearchBar00](self.impl)))

proc gtk_search_bar_handle_event*(self: ptr SearchBar00; event: ptr gdk.Event00): gboolean {.
    importc: "gtk_search_bar_handle_event", libprag.}

proc handleEvent*(self: SearchBar; event: gdk.Event): bool =
  toBool(gtk_search_bar_handle_event(cast[ptr SearchBar00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_search_bar_set_search_mode*(self: ptr SearchBar00; searchMode: gboolean) {.
    importc: "gtk_search_bar_set_search_mode", libprag.}

proc setSearchMode*(self: SearchBar; searchMode: bool) =
  gtk_search_bar_set_search_mode(cast[ptr SearchBar00](self.impl), gboolean(searchMode))

proc `searchMode=`*(self: SearchBar; searchMode: bool) =
  gtk_search_bar_set_search_mode(cast[ptr SearchBar00](self.impl), gboolean(searchMode))

proc gtk_search_bar_set_show_close_button*(self: ptr SearchBar00; visible: gboolean) {.
    importc: "gtk_search_bar_set_show_close_button", libprag.}

proc setShowCloseButton*(self: SearchBar; visible: bool) =
  gtk_search_bar_set_show_close_button(cast[ptr SearchBar00](self.impl), gboolean(visible))

proc `showCloseButton=`*(self: SearchBar; visible: bool) =
  gtk_search_bar_set_show_close_button(cast[ptr SearchBar00](self.impl), gboolean(visible))

type
  SearchBarClass00* {.pure.} = object
    parentClass*: BinClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  SearchBarClass* = ref object
    impl*: ptr SearchBarClass00

type
  SearchEntry* = ref object of Entry
  SearchEntry00* = object of Entry00

proc scNextMatch*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "next-match", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPreviousMatch*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "previous-match", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSearchChanged*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "search-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStopSearch*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "stop-search", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_search_entry_new*(): ptr SearchEntry00 {.
    importc: "gtk_search_entry_new", libprag.}

proc newSearchEntry*(): SearchEntry =
  new(result, finalizeGObject)
  result.impl = gtk_search_entry_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSearchEntry*[T](result: var T) =
  assert(result is SearchEntry)
  new(result, finalizeGObject)
  result.impl = gtk_search_entry_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_search_entry_handle_event*(self: ptr SearchEntry00; event: ptr gdk.Event00): gboolean {.
    importc: "gtk_search_entry_handle_event", libprag.}

proc handleEvent*(self: SearchEntry; event: gdk.Event): bool =
  toBool(gtk_search_entry_handle_event(cast[ptr SearchEntry00](self.impl), cast[ptr gdk.Event00](event.impl)))

type
  SearchEntryClass00* {.pure.} = object
    parentClass*: EntryClass00
    searchChanged*: proc(entry: ptr SearchEntry00) {.cdecl.}
    nextMatch*: proc(entry: ptr SearchEntry00) {.cdecl.}
    previousMatch*: proc(entry: ptr SearchEntry00) {.cdecl.}
    stopSearch*: proc(entry: ptr SearchEntry00) {.cdecl.}
  SearchEntryClass* = ref object
    impl*: ptr SearchEntryClass00

type
  SeparatorMenuItem* = ref object of MenuItem
  SeparatorMenuItem00* = object of MenuItem00

proc gtk_separator_menu_item_new*(): ptr SeparatorMenuItem00 {.
    importc: "gtk_separator_menu_item_new", libprag.}

proc newSeparatorMenuItem*(): SeparatorMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_separator_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSeparatorMenuItem*[T](result: var T) =
  assert(result is SeparatorMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_separator_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SeparatorMenuItemClass00* {.pure.} = object
    parentClass*: MenuItemClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  SeparatorMenuItemClass* = ref object
    impl*: ptr SeparatorMenuItemClass00

type
  SeparatorToolItemPrivate00* {.pure.} = object
  SeparatorToolItemPrivate* = ref object
    impl*: ptr SeparatorToolItemPrivate00

type
  SeparatorToolItem* = ref object of ToolItem
  SeparatorToolItem00* = object of ToolItem00
    priv5: ptr SeparatorToolItemPrivate00

proc gtk_separator_tool_item_new*(): ptr SeparatorToolItem00 {.
    importc: "gtk_separator_tool_item_new", libprag.}

proc newSeparatorToolItem*(): SeparatorToolItem =
  new(result, finalizeGObject)
  result.impl = gtk_separator_tool_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSeparatorToolItem*[T](result: var T) =
  assert(result is SeparatorToolItem)
  new(result, finalizeGObject)
  result.impl = gtk_separator_tool_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_separator_tool_item_get_draw*(self: ptr SeparatorToolItem00): gboolean {.
    importc: "gtk_separator_tool_item_get_draw", libprag.}

proc getDraw*(self: SeparatorToolItem): bool =
  toBool(gtk_separator_tool_item_get_draw(cast[ptr SeparatorToolItem00](self.impl)))

proc draw*(self: SeparatorToolItem): bool =
  toBool(gtk_separator_tool_item_get_draw(cast[ptr SeparatorToolItem00](self.impl)))

proc gtk_separator_tool_item_set_draw*(self: ptr SeparatorToolItem00; draw: gboolean) {.
    importc: "gtk_separator_tool_item_set_draw", libprag.}

proc setDraw*(self: SeparatorToolItem; draw: bool) =
  gtk_separator_tool_item_set_draw(cast[ptr SeparatorToolItem00](self.impl), gboolean(draw))

proc `draw=`*(self: SeparatorToolItem; draw: bool) =
  gtk_separator_tool_item_set_draw(cast[ptr SeparatorToolItem00](self.impl), gboolean(draw))

type
  SeparatorToolItemClass00* {.pure.} = object
    parentClass*: ToolItemClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  SeparatorToolItemClass* = ref object
    impl*: ptr SeparatorToolItemClass00

type
  SettingsClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  SettingsClass* = ref object
    impl*: ptr SettingsClass00

type
  ShortcutLabel* = ref object of Box
  ShortcutLabel00* = object of Box00

proc gtk_shortcut_label_new*(accelerator: cstring): ptr ShortcutLabel00 {.
    importc: "gtk_shortcut_label_new", libprag.}

proc newShortcutLabel*(accelerator: string): ShortcutLabel =
  new(result, finalizeGObject)
  result.impl = gtk_shortcut_label_new(cstring(accelerator))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initShortcutLabel*[T](result: var T; accelerator: string) =
  assert(result is ShortcutLabel)
  new(result, finalizeGObject)
  result.impl = gtk_shortcut_label_new(cstring(accelerator))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_label_get_accelerator*(self: ptr ShortcutLabel00): cstring {.
    importc: "gtk_shortcut_label_get_accelerator", libprag.}

proc getAccelerator*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_accelerator(cast[ptr ShortcutLabel00](self.impl))
  result = $resul0

proc accelerator*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_accelerator(cast[ptr ShortcutLabel00](self.impl))
  result = $resul0

proc gtk_shortcut_label_get_disabled_text*(self: ptr ShortcutLabel00): cstring {.
    importc: "gtk_shortcut_label_get_disabled_text", libprag.}

proc getDisabledText*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_disabled_text(cast[ptr ShortcutLabel00](self.impl))
  result = $resul0

proc disabledText*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_disabled_text(cast[ptr ShortcutLabel00](self.impl))
  result = $resul0

proc gtk_shortcut_label_set_accelerator*(self: ptr ShortcutLabel00; accelerator: cstring) {.
    importc: "gtk_shortcut_label_set_accelerator", libprag.}

proc setAccelerator*(self: ShortcutLabel; accelerator: string) =
  gtk_shortcut_label_set_accelerator(cast[ptr ShortcutLabel00](self.impl), cstring(accelerator))

proc `accelerator=`*(self: ShortcutLabel; accelerator: string) =
  gtk_shortcut_label_set_accelerator(cast[ptr ShortcutLabel00](self.impl), cstring(accelerator))

proc gtk_shortcut_label_set_disabled_text*(self: ptr ShortcutLabel00; disabledText: cstring) {.
    importc: "gtk_shortcut_label_set_disabled_text", libprag.}

proc setDisabledText*(self: ShortcutLabel; disabledText: string) =
  gtk_shortcut_label_set_disabled_text(cast[ptr ShortcutLabel00](self.impl), cstring(disabledText))

proc `disabledText=`*(self: ShortcutLabel; disabledText: string) =
  gtk_shortcut_label_set_disabled_text(cast[ptr ShortcutLabel00](self.impl), cstring(disabledText))

type
  ShortcutLabelClass00* {.pure.} = object
  ShortcutLabelClass* = ref object
    impl*: ptr ShortcutLabelClass00

type
  ShortcutType* {.size: sizeof(cint), pure.} = enum
    accelerator = 0
    gesturePinch = 1
    gestureStretch = 2
    gestureRotateClockwise = 3
    gestureRotateCounterclockwise = 4
    gestureTwoFingerSwipeLeft = 5
    gestureTwoFingerSwipeRight = 6
    gesture = 7

type
  ShortcutsGroup* = ref object of Box
  ShortcutsGroup00* = object of Box00

type
  ShortcutsGroupClass00* {.pure.} = object
  ShortcutsGroupClass* = ref object
    impl*: ptr ShortcutsGroupClass00

type
  ShortcutsSection* = ref object of Box
  ShortcutsSection00* = object of Box00

proc scChangeCurrentPage*(self: ShortcutsSection;  p: proc (self: ptr gobject.Object00; `object`: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "change-current-page", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

type
  ShortcutsSectionClass00* {.pure.} = object
  ShortcutsSectionClass* = ref object
    impl*: ptr ShortcutsSectionClass00

type
  ShortcutsShortcut* = ref object of Box
  ShortcutsShortcut00* = object of Box00

type
  ShortcutsShortcutClass00* {.pure.} = object
  ShortcutsShortcutClass* = ref object
    impl*: ptr ShortcutsShortcutClass00

type
  ShortcutsWindowClass00* {.pure.} = object
    parentClass*: WindowClass00
    close*: proc(self: ptr ShortcutsWindow00) {.cdecl.}
    search*: proc(self: ptr ShortcutsWindow00) {.cdecl.}
  ShortcutsWindowClass* = ref object
    impl*: ptr ShortcutsWindowClass00

type
  SizeGroupClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  SizeGroupClass* = ref object
    impl*: ptr SizeGroupClass00

type
  SocketPrivate00* {.pure.} = object
  SocketPrivate* = ref object
    impl*: ptr SocketPrivate00

type
  Socket* = ref object of Container
  Socket00* = object of Container00
    priv3: ptr SocketPrivate00

proc scPlugAdded*(self: Socket;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "plug-added", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPlugRemoved*(self: Socket;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "plug-removed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_socket_new*(): ptr Socket00 {.
    importc: "gtk_socket_new", libprag.}

proc newSocket*(): Socket =
  new(result, finalizeGObject)
  result.impl = gtk_socket_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSocket*[T](result: var T) =
  assert(result is Socket)
  new(result, finalizeGObject)
  result.impl = gtk_socket_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_socket_add_id*(self: ptr Socket00; window: uint64) {.
    importc: "gtk_socket_add_id", libprag.}

proc addId*(self: Socket; window: uint64) =
  gtk_socket_add_id(cast[ptr Socket00](self.impl), window)

proc gtk_socket_get_id*(self: ptr Socket00): uint64 {.
    importc: "gtk_socket_get_id", libprag.}

proc getId*(self: Socket): uint64 =
  gtk_socket_get_id(cast[ptr Socket00](self.impl))

proc id*(self: Socket): uint64 =
  gtk_socket_get_id(cast[ptr Socket00](self.impl))

proc gtk_socket_get_plug_window*(self: ptr Socket00): ptr gdk.Window00 {.
    importc: "gtk_socket_get_plug_window", libprag.}

proc getPlugWindow*(self: Socket): gdk.Window =
  let gobj = gtk_socket_get_plug_window(cast[ptr Socket00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc plugWindow*(self: Socket): gdk.Window =
  let gobj = gtk_socket_get_plug_window(cast[ptr Socket00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SocketClass00* {.pure.} = object
    parentClass*: ContainerClass00
    plugAdded*: proc(socket: ptr Socket00) {.cdecl.}
    plugRemoved*: proc(socket: ptr Socket00): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  SocketClass* = ref object
    impl*: ptr SocketClass00

type
  SortType* {.size: sizeof(cint), pure.} = enum
    ascending = 0
    descending = 1

type
  SpinButtonPrivate00* {.pure.} = object
  SpinButtonPrivate* = ref object
    impl*: ptr SpinButtonPrivate00

type
  SpinButton* = ref object of Entry
  SpinButton00* = object of Entry00
    priv3: ptr SpinButtonPrivate00

proc scChangeValue*(self: SpinButton;  p: proc (self: ptr gobject.Object00; scroll: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "change-value", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scInput*(self: SpinButton;  p: proc (self: ptr gobject.Object00; newValue: var cdouble; xdata: pointer): int32 {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "input", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scOutput*(self: SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "output", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scValueChanged*(self: SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scWrapped*(self: SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "wrapped", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_spin_button_new*(adjustment: ptr Adjustment00; climbRate: cdouble; 
    digits: uint32): ptr SpinButton00 {.
    importc: "gtk_spin_button_new", libprag.}

proc newSpinButton*(adjustment: Adjustment; climbRate: cdouble; digits: int): SpinButton =
  new(result, finalizeGObject)
  result.impl = gtk_spin_button_new(cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSpinButton*[T](result: var T; adjustment: Adjustment; climbRate: cdouble; digits: int) =
  assert(result is SpinButton)
  new(result, finalizeGObject)
  result.impl = gtk_spin_button_new(cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spin_button_new_with_range*(min: cdouble; max: cdouble; step: cdouble): ptr SpinButton00 {.
    importc: "gtk_spin_button_new_with_range", libprag.}

proc newSpinButtonWithRange*(min: cdouble; max: cdouble; step: cdouble): SpinButton =
  new(result, finalizeGObject)
  result.impl = gtk_spin_button_new_with_range(min, max, step)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSpinButtonWithRange*[T](result: var T; min: cdouble; max: cdouble; step: cdouble) =
  assert(result is SpinButton)
  new(result, finalizeGObject)
  result.impl = gtk_spin_button_new_with_range(min, max, step)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spin_button_configure*(self: ptr SpinButton00; adjustment: ptr Adjustment00; 
    climbRate: cdouble; digits: uint32) {.
    importc: "gtk_spin_button_configure", libprag.}

proc configure*(self: SpinButton; adjustment: Adjustment; climbRate: cdouble; 
    digits: int) =
  gtk_spin_button_configure(cast[ptr SpinButton00](self.impl), cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))

proc gtk_spin_button_get_adjustment*(self: ptr SpinButton00): ptr Adjustment00 {.
    importc: "gtk_spin_button_get_adjustment", libprag.}

proc getAdjustment*(self: SpinButton): Adjustment =
  let gobj = gtk_spin_button_get_adjustment(cast[ptr SpinButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: SpinButton): Adjustment =
  let gobj = gtk_spin_button_get_adjustment(cast[ptr SpinButton00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spin_button_get_digits*(self: ptr SpinButton00): uint32 {.
    importc: "gtk_spin_button_get_digits", libprag.}

proc getDigits*(self: SpinButton): int =
  int(gtk_spin_button_get_digits(cast[ptr SpinButton00](self.impl)))

proc digits*(self: SpinButton): int =
  int(gtk_spin_button_get_digits(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_increments*(self: ptr SpinButton00; step: var cdouble; page: var cdouble) {.
    importc: "gtk_spin_button_get_increments", libprag.}

proc getIncrements*(self: SpinButton; step: var cdouble; page: var cdouble) =
  gtk_spin_button_get_increments(cast[ptr SpinButton00](self.impl), step, page)

proc increments*(self: SpinButton; step: var cdouble; page: var cdouble) =
  gtk_spin_button_get_increments(cast[ptr SpinButton00](self.impl), step, page)

proc gtk_spin_button_get_numeric*(self: ptr SpinButton00): gboolean {.
    importc: "gtk_spin_button_get_numeric", libprag.}

proc getNumeric*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_numeric(cast[ptr SpinButton00](self.impl)))

proc numeric*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_numeric(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_range*(self: ptr SpinButton00; min: var cdouble; max: var cdouble) {.
    importc: "gtk_spin_button_get_range", libprag.}

proc getRange*(self: SpinButton; min: var cdouble; max: var cdouble) =
  gtk_spin_button_get_range(cast[ptr SpinButton00](self.impl), min, max)

proc range*(self: SpinButton; min: var cdouble; max: var cdouble) =
  gtk_spin_button_get_range(cast[ptr SpinButton00](self.impl), min, max)

proc gtk_spin_button_get_snap_to_ticks*(self: ptr SpinButton00): gboolean {.
    importc: "gtk_spin_button_get_snap_to_ticks", libprag.}

proc getSnapToTicks*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_snap_to_ticks(cast[ptr SpinButton00](self.impl)))

proc snapToTicks*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_snap_to_ticks(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_value*(self: ptr SpinButton00): cdouble {.
    importc: "gtk_spin_button_get_value", libprag.}

proc getValue*(self: SpinButton): cdouble =
  gtk_spin_button_get_value(cast[ptr SpinButton00](self.impl))

proc value*(self: SpinButton): cdouble =
  gtk_spin_button_get_value(cast[ptr SpinButton00](self.impl))

proc gtk_spin_button_get_value_as_int*(self: ptr SpinButton00): int32 {.
    importc: "gtk_spin_button_get_value_as_int", libprag.}

proc getValueAsInt*(self: SpinButton): int =
  int(gtk_spin_button_get_value_as_int(cast[ptr SpinButton00](self.impl)))

proc valueAsInt*(self: SpinButton): int =
  int(gtk_spin_button_get_value_as_int(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_wrap*(self: ptr SpinButton00): gboolean {.
    importc: "gtk_spin_button_get_wrap", libprag.}

proc getWrap*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_wrap(cast[ptr SpinButton00](self.impl)))

proc wrap*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_wrap(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_set_adjustment*(self: ptr SpinButton00; adjustment: ptr Adjustment00) {.
    importc: "gtk_spin_button_set_adjustment", libprag.}

proc setAdjustment*(self: SpinButton; adjustment: Adjustment) =
  gtk_spin_button_set_adjustment(cast[ptr SpinButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: SpinButton; adjustment: Adjustment) =
  gtk_spin_button_set_adjustment(cast[ptr SpinButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_spin_button_set_digits*(self: ptr SpinButton00; digits: uint32) {.
    importc: "gtk_spin_button_set_digits", libprag.}

proc setDigits*(self: SpinButton; digits: int) =
  gtk_spin_button_set_digits(cast[ptr SpinButton00](self.impl), uint32(digits))

proc `digits=`*(self: SpinButton; digits: int) =
  gtk_spin_button_set_digits(cast[ptr SpinButton00](self.impl), uint32(digits))

proc gtk_spin_button_set_increments*(self: ptr SpinButton00; step: cdouble; page: cdouble) {.
    importc: "gtk_spin_button_set_increments", libprag.}

proc setIncrements*(self: SpinButton; step: cdouble; page: cdouble) =
  gtk_spin_button_set_increments(cast[ptr SpinButton00](self.impl), step, page)

proc gtk_spin_button_set_numeric*(self: ptr SpinButton00; numeric: gboolean) {.
    importc: "gtk_spin_button_set_numeric", libprag.}

proc setNumeric*(self: SpinButton; numeric: bool) =
  gtk_spin_button_set_numeric(cast[ptr SpinButton00](self.impl), gboolean(numeric))

proc `numeric=`*(self: SpinButton; numeric: bool) =
  gtk_spin_button_set_numeric(cast[ptr SpinButton00](self.impl), gboolean(numeric))

proc gtk_spin_button_set_range*(self: ptr SpinButton00; min: cdouble; max: cdouble) {.
    importc: "gtk_spin_button_set_range", libprag.}

proc setRange*(self: SpinButton; min: cdouble; max: cdouble) =
  gtk_spin_button_set_range(cast[ptr SpinButton00](self.impl), min, max)

proc gtk_spin_button_set_snap_to_ticks*(self: ptr SpinButton00; snapToTicks: gboolean) {.
    importc: "gtk_spin_button_set_snap_to_ticks", libprag.}

proc setSnapToTicks*(self: SpinButton; snapToTicks: bool) =
  gtk_spin_button_set_snap_to_ticks(cast[ptr SpinButton00](self.impl), gboolean(snapToTicks))

proc `snapToTicks=`*(self: SpinButton; snapToTicks: bool) =
  gtk_spin_button_set_snap_to_ticks(cast[ptr SpinButton00](self.impl), gboolean(snapToTicks))

proc gtk_spin_button_set_value*(self: ptr SpinButton00; value: cdouble) {.
    importc: "gtk_spin_button_set_value", libprag.}

proc setValue*(self: SpinButton; value: cdouble) =
  gtk_spin_button_set_value(cast[ptr SpinButton00](self.impl), value)

proc `value=`*(self: SpinButton; value: cdouble) =
  gtk_spin_button_set_value(cast[ptr SpinButton00](self.impl), value)

proc gtk_spin_button_set_wrap*(self: ptr SpinButton00; wrap: gboolean) {.
    importc: "gtk_spin_button_set_wrap", libprag.}

proc setWrap*(self: SpinButton; wrap: bool) =
  gtk_spin_button_set_wrap(cast[ptr SpinButton00](self.impl), gboolean(wrap))

proc `wrap=`*(self: SpinButton; wrap: bool) =
  gtk_spin_button_set_wrap(cast[ptr SpinButton00](self.impl), gboolean(wrap))

proc gtk_spin_button_update*(self: ptr SpinButton00) {.
    importc: "gtk_spin_button_update", libprag.}

proc update*(self: SpinButton) =
  gtk_spin_button_update(cast[ptr SpinButton00](self.impl))

type
  SpinButtonUpdatePolicy* {.size: sizeof(cint), pure.} = enum
    always = 0
    ifValid = 1

proc gtk_spin_button_get_update_policy*(self: ptr SpinButton00): SpinButtonUpdatePolicy {.
    importc: "gtk_spin_button_get_update_policy", libprag.}

proc getUpdatePolicy*(self: SpinButton): SpinButtonUpdatePolicy =
  gtk_spin_button_get_update_policy(cast[ptr SpinButton00](self.impl))

proc updatePolicy*(self: SpinButton): SpinButtonUpdatePolicy =
  gtk_spin_button_get_update_policy(cast[ptr SpinButton00](self.impl))

proc gtk_spin_button_set_update_policy*(self: ptr SpinButton00; policy: SpinButtonUpdatePolicy) {.
    importc: "gtk_spin_button_set_update_policy", libprag.}

proc setUpdatePolicy*(self: SpinButton; policy: SpinButtonUpdatePolicy) =
  gtk_spin_button_set_update_policy(cast[ptr SpinButton00](self.impl), policy)

proc `updatePolicy=`*(self: SpinButton; policy: SpinButtonUpdatePolicy) =
  gtk_spin_button_set_update_policy(cast[ptr SpinButton00](self.impl), policy)

type
  SpinType* {.size: sizeof(cint), pure.} = enum
    stepForward = 0
    stepBackward = 1
    pageForward = 2
    pageBackward = 3
    home = 4
    `end` = 5
    userDefined = 6

proc gtk_spin_button_spin*(self: ptr SpinButton00; direction: SpinType; increment: cdouble) {.
    importc: "gtk_spin_button_spin", libprag.}

proc spin*(self: SpinButton; direction: SpinType; increment: cdouble) =
  gtk_spin_button_spin(cast[ptr SpinButton00](self.impl), direction, increment)

type
  SpinButtonAccessiblePrivate00* {.pure.} = object
  SpinButtonAccessiblePrivate* = ref object
    impl*: ptr SpinButtonAccessiblePrivate00

type
  SpinButtonAccessible* = ref object of EntryAccessible
  SpinButtonAccessible00* = object of EntryAccessible00
    priv4: ptr SpinButtonAccessiblePrivate00

type
  SpinButtonAccessibleClass00* {.pure.} = object
    parentClass*: EntryAccessibleClass00
  SpinButtonAccessibleClass* = ref object
    impl*: ptr SpinButtonAccessibleClass00

type
  SpinButtonClass00* {.pure.} = object
    parentClass*: EntryClass00
    input*: proc(spinButton: ptr SpinButton00; newValue: ptr cdouble): int32 {.cdecl.}
    output*: proc(spinButton: ptr SpinButton00): int32 {.cdecl.}
    valueChanged*: proc(spinButton: ptr SpinButton00) {.cdecl.}
    changeValue*: proc(spinButton: ptr SpinButton00; scroll: ScrollType) {.cdecl.}
    wrapped*: proc(spinButton: ptr SpinButton00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  SpinButtonClass* = ref object
    impl*: ptr SpinButtonClass00

type
  SpinnerPrivate00* {.pure.} = object
  SpinnerPrivate* = ref object
    impl*: ptr SpinnerPrivate00

type
  Spinner* = ref object of Widget
  Spinner00* = object of Widget00
    priv2: ptr SpinnerPrivate00

proc gtk_spinner_new*(): ptr Spinner00 {.
    importc: "gtk_spinner_new", libprag.}

proc newSpinner*(): Spinner =
  new(result, finalizeGObject)
  result.impl = gtk_spinner_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSpinner*[T](result: var T) =
  assert(result is Spinner)
  new(result, finalizeGObject)
  result.impl = gtk_spinner_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spinner_start*(self: ptr Spinner00) {.
    importc: "gtk_spinner_start", libprag.}

proc start*(self: Spinner) =
  gtk_spinner_start(cast[ptr Spinner00](self.impl))

proc gtk_spinner_stop*(self: ptr Spinner00) {.
    importc: "gtk_spinner_stop", libprag.}

proc stop*(self: Spinner) =
  gtk_spinner_stop(cast[ptr Spinner00](self.impl))

type
  SpinnerAccessiblePrivate00* {.pure.} = object
  SpinnerAccessiblePrivate* = ref object
    impl*: ptr SpinnerAccessiblePrivate00

type
  SpinnerAccessible* = ref object of WidgetAccessible
  SpinnerAccessible00* = object of WidgetAccessible00
    priv3: ptr SpinnerAccessiblePrivate00

type
  SpinnerAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
  SpinnerAccessibleClass* = ref object
    impl*: ptr SpinnerAccessibleClass00

type
  SpinnerClass00* {.pure.} = object
    parentClass*: WidgetClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  SpinnerClass* = ref object
    impl*: ptr SpinnerClass00

type
  Stack* = ref object of Container
  Stack00* = object of Container00

proc gtk_stack_new*(): ptr Stack00 {.
    importc: "gtk_stack_new", libprag.}

proc newStack*(): Stack =
  new(result, finalizeGObject)
  result.impl = gtk_stack_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStack*[T](result: var T) =
  assert(result is Stack)
  new(result, finalizeGObject)
  result.impl = gtk_stack_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_add_named*(self: ptr Stack00; child: ptr Widget00; name: cstring) {.
    importc: "gtk_stack_add_named", libprag.}

proc addNamed*(self: Stack; child: Widget; name: string) =
  gtk_stack_add_named(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl), cstring(name))

proc gtk_stack_add_titled*(self: ptr Stack00; child: ptr Widget00; name: cstring; 
    title: cstring) {.
    importc: "gtk_stack_add_titled", libprag.}

proc addTitled*(self: Stack; child: Widget; name: string; title: string) =
  gtk_stack_add_titled(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl), cstring(name), cstring(title))

proc gtk_stack_get_child_by_name*(self: ptr Stack00; name: cstring): ptr Widget00 {.
    importc: "gtk_stack_get_child_by_name", libprag.}

proc getChildByName*(self: Stack; name: string): Widget =
  let gobj = gtk_stack_get_child_by_name(cast[ptr Stack00](self.impl), cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc childByName*(self: Stack; name: string): Widget =
  let gobj = gtk_stack_get_child_by_name(cast[ptr Stack00](self.impl), cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_get_hhomogeneous*(self: ptr Stack00): gboolean {.
    importc: "gtk_stack_get_hhomogeneous", libprag.}

proc getHhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_hhomogeneous(cast[ptr Stack00](self.impl)))

proc hhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_hhomogeneous(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_homogeneous*(self: ptr Stack00): gboolean {.
    importc: "gtk_stack_get_homogeneous", libprag.}

proc getHomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_homogeneous(cast[ptr Stack00](self.impl)))

proc homogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_homogeneous(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_interpolate_size*(self: ptr Stack00): gboolean {.
    importc: "gtk_stack_get_interpolate_size", libprag.}

proc getInterpolateSize*(self: Stack): bool =
  toBool(gtk_stack_get_interpolate_size(cast[ptr Stack00](self.impl)))

proc interpolateSize*(self: Stack): bool =
  toBool(gtk_stack_get_interpolate_size(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_transition_duration*(self: ptr Stack00): uint32 {.
    importc: "gtk_stack_get_transition_duration", libprag.}

proc getTransitionDuration*(self: Stack): int =
  int(gtk_stack_get_transition_duration(cast[ptr Stack00](self.impl)))

proc transitionDuration*(self: Stack): int =
  int(gtk_stack_get_transition_duration(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_transition_running*(self: ptr Stack00): gboolean {.
    importc: "gtk_stack_get_transition_running", libprag.}

proc getTransitionRunning*(self: Stack): bool =
  toBool(gtk_stack_get_transition_running(cast[ptr Stack00](self.impl)))

proc transitionRunning*(self: Stack): bool =
  toBool(gtk_stack_get_transition_running(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_vhomogeneous*(self: ptr Stack00): gboolean {.
    importc: "gtk_stack_get_vhomogeneous", libprag.}

proc getVhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_vhomogeneous(cast[ptr Stack00](self.impl)))

proc vhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_vhomogeneous(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_visible_child*(self: ptr Stack00): ptr Widget00 {.
    importc: "gtk_stack_get_visible_child", libprag.}

proc getVisibleChild*(self: Stack): Widget =
  let gobj = gtk_stack_get_visible_child(cast[ptr Stack00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc visibleChild*(self: Stack): Widget =
  let gobj = gtk_stack_get_visible_child(cast[ptr Stack00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_get_visible_child_name*(self: ptr Stack00): cstring {.
    importc: "gtk_stack_get_visible_child_name", libprag.}

proc getVisibleChildName*(self: Stack): string =
  let resul0 = gtk_stack_get_visible_child_name(cast[ptr Stack00](self.impl))
  result = $resul0

proc visibleChildName*(self: Stack): string =
  let resul0 = gtk_stack_get_visible_child_name(cast[ptr Stack00](self.impl))
  result = $resul0

proc gtk_stack_set_hhomogeneous*(self: ptr Stack00; hhomogeneous: gboolean) {.
    importc: "gtk_stack_set_hhomogeneous", libprag.}

proc setHhomogeneous*(self: Stack; hhomogeneous: bool) =
  gtk_stack_set_hhomogeneous(cast[ptr Stack00](self.impl), gboolean(hhomogeneous))

proc `hhomogeneous=`*(self: Stack; hhomogeneous: bool) =
  gtk_stack_set_hhomogeneous(cast[ptr Stack00](self.impl), gboolean(hhomogeneous))

proc gtk_stack_set_homogeneous*(self: ptr Stack00; homogeneous: gboolean) {.
    importc: "gtk_stack_set_homogeneous", libprag.}

proc setHomogeneous*(self: Stack; homogeneous: bool) =
  gtk_stack_set_homogeneous(cast[ptr Stack00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: Stack; homogeneous: bool) =
  gtk_stack_set_homogeneous(cast[ptr Stack00](self.impl), gboolean(homogeneous))

proc gtk_stack_set_interpolate_size*(self: ptr Stack00; interpolateSize: gboolean) {.
    importc: "gtk_stack_set_interpolate_size", libprag.}

proc setInterpolateSize*(self: Stack; interpolateSize: bool) =
  gtk_stack_set_interpolate_size(cast[ptr Stack00](self.impl), gboolean(interpolateSize))

proc `interpolateSize=`*(self: Stack; interpolateSize: bool) =
  gtk_stack_set_interpolate_size(cast[ptr Stack00](self.impl), gboolean(interpolateSize))

proc gtk_stack_set_transition_duration*(self: ptr Stack00; duration: uint32) {.
    importc: "gtk_stack_set_transition_duration", libprag.}

proc setTransitionDuration*(self: Stack; duration: int) =
  gtk_stack_set_transition_duration(cast[ptr Stack00](self.impl), uint32(duration))

proc `transitionDuration=`*(self: Stack; duration: int) =
  gtk_stack_set_transition_duration(cast[ptr Stack00](self.impl), uint32(duration))

proc gtk_stack_set_vhomogeneous*(self: ptr Stack00; vhomogeneous: gboolean) {.
    importc: "gtk_stack_set_vhomogeneous", libprag.}

proc setVhomogeneous*(self: Stack; vhomogeneous: bool) =
  gtk_stack_set_vhomogeneous(cast[ptr Stack00](self.impl), gboolean(vhomogeneous))

proc `vhomogeneous=`*(self: Stack; vhomogeneous: bool) =
  gtk_stack_set_vhomogeneous(cast[ptr Stack00](self.impl), gboolean(vhomogeneous))

proc gtk_stack_set_visible_child*(self: ptr Stack00; child: ptr Widget00) {.
    importc: "gtk_stack_set_visible_child", libprag.}

proc setVisibleChild*(self: Stack; child: Widget) =
  gtk_stack_set_visible_child(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl))

proc `visibleChild=`*(self: Stack; child: Widget) =
  gtk_stack_set_visible_child(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_stack_set_visible_child_name*(self: ptr Stack00; name: cstring) {.
    importc: "gtk_stack_set_visible_child_name", libprag.}

proc setVisibleChildName*(self: Stack; name: string) =
  gtk_stack_set_visible_child_name(cast[ptr Stack00](self.impl), cstring(name))

proc `visibleChildName=`*(self: Stack; name: string) =
  gtk_stack_set_visible_child_name(cast[ptr Stack00](self.impl), cstring(name))

type
  StackTransitionType* {.size: sizeof(cint), pure.} = enum
    none = 0
    crossfade = 1
    slideRight = 2
    slideLeft = 3
    slideUp = 4
    slideDown = 5
    slideLeftRight = 6
    slideUpDown = 7
    overUp = 8
    overDown = 9
    overLeft = 10
    overRight = 11
    underUp = 12
    underDown = 13
    underLeft = 14
    underRight = 15
    overUpDown = 16
    overDownUp = 17
    overLeftRight = 18
    overRightLeft = 19

proc gtk_stack_get_transition_type*(self: ptr Stack00): StackTransitionType {.
    importc: "gtk_stack_get_transition_type", libprag.}

proc getTransitionType*(self: Stack): StackTransitionType =
  gtk_stack_get_transition_type(cast[ptr Stack00](self.impl))

proc transitionType*(self: Stack): StackTransitionType =
  gtk_stack_get_transition_type(cast[ptr Stack00](self.impl))

proc gtk_stack_set_transition_type*(self: ptr Stack00; transition: StackTransitionType) {.
    importc: "gtk_stack_set_transition_type", libprag.}

proc setTransitionType*(self: Stack; transition: StackTransitionType) =
  gtk_stack_set_transition_type(cast[ptr Stack00](self.impl), transition)

proc `transitionType=`*(self: Stack; transition: StackTransitionType) =
  gtk_stack_set_transition_type(cast[ptr Stack00](self.impl), transition)

proc gtk_stack_set_visible_child_full*(self: ptr Stack00; name: cstring; transition: StackTransitionType) {.
    importc: "gtk_stack_set_visible_child_full", libprag.}

proc setVisibleChildFull*(self: Stack; name: string; transition: StackTransitionType) =
  gtk_stack_set_visible_child_full(cast[ptr Stack00](self.impl), cstring(name), transition)

type
  StackAccessible* = ref object of ContainerAccessible
  StackAccessible00* = object of ContainerAccessible00

type
  StackAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  StackAccessibleClass* = ref object
    impl*: ptr StackAccessibleClass00

type
  StackClass00* {.pure.} = object
    parentClass*: ContainerClass00
  StackClass* = ref object
    impl*: ptr StackClass00

type
  StackSidebar* = ref object of Bin
  StackSidebar00* = object of Bin00

proc gtk_stack_sidebar_new*(): ptr StackSidebar00 {.
    importc: "gtk_stack_sidebar_new", libprag.}

proc newStackSidebar*(): StackSidebar =
  new(result, finalizeGObject)
  result.impl = gtk_stack_sidebar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStackSidebar*[T](result: var T) =
  assert(result is StackSidebar)
  new(result, finalizeGObject)
  result.impl = gtk_stack_sidebar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_sidebar_get_stack*(self: ptr StackSidebar00): ptr Stack00 {.
    importc: "gtk_stack_sidebar_get_stack", libprag.}

proc getStack*(self: StackSidebar): Stack =
  let gobj = gtk_stack_sidebar_get_stack(cast[ptr StackSidebar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Stack](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc stack*(self: StackSidebar): Stack =
  let gobj = gtk_stack_sidebar_get_stack(cast[ptr StackSidebar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Stack](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_sidebar_set_stack*(self: ptr StackSidebar00; stack: ptr Stack00) {.
    importc: "gtk_stack_sidebar_set_stack", libprag.}

proc setStack*(self: StackSidebar; stack: Stack) =
  gtk_stack_sidebar_set_stack(cast[ptr StackSidebar00](self.impl), cast[ptr Stack00](stack.impl))

proc `stack=`*(self: StackSidebar; stack: Stack) =
  gtk_stack_sidebar_set_stack(cast[ptr StackSidebar00](self.impl), cast[ptr Stack00](stack.impl))

type
  StackSidebarClass00* {.pure.} = object
    parentClass*: BinClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  StackSidebarClass* = ref object
    impl*: ptr StackSidebarClass00

type
  StackSidebarPrivate00* {.pure.} = object
  StackSidebarPrivate* = ref object
    impl*: ptr StackSidebarPrivate00

type
  StackSwitcher* = ref object of Box
  StackSwitcher00* = object of Box00

proc gtk_stack_switcher_new*(): ptr StackSwitcher00 {.
    importc: "gtk_stack_switcher_new", libprag.}

proc newStackSwitcher*(): StackSwitcher =
  new(result, finalizeGObject)
  result.impl = gtk_stack_switcher_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStackSwitcher*[T](result: var T) =
  assert(result is StackSwitcher)
  new(result, finalizeGObject)
  result.impl = gtk_stack_switcher_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_switcher_get_stack*(self: ptr StackSwitcher00): ptr Stack00 {.
    importc: "gtk_stack_switcher_get_stack", libprag.}

proc getStack*(self: StackSwitcher): Stack =
  let gobj = gtk_stack_switcher_get_stack(cast[ptr StackSwitcher00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Stack](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc stack*(self: StackSwitcher): Stack =
  let gobj = gtk_stack_switcher_get_stack(cast[ptr StackSwitcher00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Stack](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_switcher_set_stack*(self: ptr StackSwitcher00; stack: ptr Stack00) {.
    importc: "gtk_stack_switcher_set_stack", libprag.}

proc setStack*(self: StackSwitcher; stack: Stack) =
  gtk_stack_switcher_set_stack(cast[ptr StackSwitcher00](self.impl), cast[ptr Stack00](stack.impl))

proc `stack=`*(self: StackSwitcher; stack: Stack) =
  gtk_stack_switcher_set_stack(cast[ptr StackSwitcher00](self.impl), cast[ptr Stack00](stack.impl))

type
  StackSwitcherClass00* {.pure.} = object
    parentClass*: BoxClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  StackSwitcherClass* = ref object
    impl*: ptr StackSwitcherClass00

type
  StatusIconPrivate00* {.pure.} = object
  StatusIconPrivate* = ref object
    impl*: ptr StatusIconPrivate00

type
  StatusIcon* = ref object of gobject.Object
  StatusIcon00* = object of gobject.Object00
    priv1: ptr StatusIconPrivate00

proc scActivate*(self: StatusIcon;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scButtonPressEvent*(self: StatusIcon;  p: proc (self: ptr gobject.Object00; event: gdk.EventButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "button-press-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scButtonReleaseEvent*(self: StatusIcon;  p: proc (self: ptr gobject.Object00; event: gdk.EventButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "button-release-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopupMenu*(self: StatusIcon;  p: proc (self: ptr gobject.Object00; button: uint32; activateTime: uint32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "popup-menu", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scQueryTooltip*(self: StatusIcon;  p: proc (self: ptr gobject.Object00; x: int32; y: int32; keyboardMode: gboolean; tooltip: Tooltip00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "query-tooltip", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scScrollEvent*(self: StatusIcon;  p: proc (self: ptr gobject.Object00; event: gdk.EventScroll00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "scroll-event", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSizeChanged*(self: StatusIcon;  p: proc (self: ptr gobject.Object00; size: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "size-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_status_icon_new*(): ptr StatusIcon00 {.
    importc: "gtk_status_icon_new", libprag.}

proc newStatusIcon*(): StatusIcon =
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIcon*[T](result: var T) =
  assert(result is StatusIcon)
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_file*(filename: ucstring): ptr StatusIcon00 {.
    importc: "gtk_status_icon_new_from_file", libprag.}

proc newStatusIconFromFile*(filename: ucstring): StatusIcon =
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_file(filename)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromFile*[T](result: var T; filename: ucstring) =
  assert(result is StatusIcon)
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_file(filename)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_gicon*(icon: ptr gio.Icon00): ptr StatusIcon00 {.
    importc: "gtk_status_icon_new_from_gicon", libprag.}

proc newStatusIconFromGicon*(icon: gio.Icon): StatusIcon =
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_gicon(cast[ptr gio.Icon00](icon.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromGicon*[T](result: var T; icon: gio.Icon) =
  assert(result is StatusIcon)
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_gicon(cast[ptr gio.Icon00](icon.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_icon_name*(iconName: cstring): ptr StatusIcon00 {.
    importc: "gtk_status_icon_new_from_icon_name", libprag.}

proc newStatusIconFromIconName*(iconName: string): StatusIcon =
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_icon_name(cstring(iconName))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromIconName*[T](result: var T; iconName: string) =
  assert(result is StatusIcon)
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_icon_name(cstring(iconName))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_pixbuf*(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr StatusIcon00 {.
    importc: "gtk_status_icon_new_from_pixbuf", libprag.}

proc newStatusIconFromPixbuf*(pixbuf: gdkpixbuf.Pixbuf): StatusIcon =
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf) =
  assert(result is StatusIcon)
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_stock*(stockId: cstring): ptr StatusIcon00 {.
    importc: "gtk_status_icon_new_from_stock", libprag.}

proc newStatusIconFromStock*(stockId: string): StatusIcon =
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromStock*[T](result: var T; stockId: string) =
  assert(result is StatusIcon)
  new(result, finalizeGObject)
  result.impl = gtk_status_icon_new_from_stock(cstring(stockId))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_position_menu*(menu: ptr Menu00; x: int32; y: int32; pushIn: var gboolean; 
    userData: ptr StatusIcon00) {.
    importc: "gtk_status_icon_position_menu", libprag.}

proc positionMenu*(menu: Menu; x: int; y: int; pushIn: var bool; userData: StatusIcon) =
  var pushIn_00 = gboolean(pushIn)
  gtk_status_icon_position_menu(cast[ptr Menu00](menu.impl), int32(x), int32(y), pushIn_00, cast[ptr StatusIcon00](userData.impl))
  pushIn = toBool(pushIn_00)

proc gtk_status_icon_get_geometry*(self: ptr StatusIcon00; screen: var ptr gdk.Screen00; 
    area: var gdk.Rectangle00; orientation: var Orientation): gboolean {.
    importc: "gtk_status_icon_get_geometry", libprag.}

proc getGeometry*(self: ptr StatusIcon00; screen: var ptr gdk.Screen00; 
    area: var gdk.Rectangle00; orientation: var Orientation): gboolean {.
    importc: "gtk_status_icon_get_geometry", libprag.}

proc geometry*(self: ptr StatusIcon00; screen: var ptr gdk.Screen00; 
    area: var gdk.Rectangle00; orientation: var Orientation): gboolean {.
    importc: "gtk_status_icon_get_geometry", libprag.}

proc gtk_status_icon_get_gicon*(self: ptr StatusIcon00): ptr gio.Icon00 {.
    importc: "gtk_status_icon_get_gicon", libprag.}

proc getGicon*(self: StatusIcon): gio.Icon =
  new(result)
  result.impl = gtk_status_icon_get_gicon(cast[ptr StatusIcon00](self.impl))

proc gicon*(self: StatusIcon): gio.Icon =
  new(result)
  result.impl = gtk_status_icon_get_gicon(cast[ptr StatusIcon00](self.impl))

proc gtk_status_icon_get_has_tooltip*(self: ptr StatusIcon00): gboolean {.
    importc: "gtk_status_icon_get_has_tooltip", libprag.}

proc getHasTooltip*(self: StatusIcon): bool =
  toBool(gtk_status_icon_get_has_tooltip(cast[ptr StatusIcon00](self.impl)))

proc hasTooltip*(self: StatusIcon): bool =
  toBool(gtk_status_icon_get_has_tooltip(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_get_icon_name*(self: ptr StatusIcon00): cstring {.
    importc: "gtk_status_icon_get_icon_name", libprag.}

proc getIconName*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_icon_name(cast[ptr StatusIcon00](self.impl))
  result = $resul0

proc iconName*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_icon_name(cast[ptr StatusIcon00](self.impl))
  result = $resul0

proc gtk_status_icon_get_pixbuf*(self: ptr StatusIcon00): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_status_icon_get_pixbuf", libprag.}

proc getPixbuf*(self: StatusIcon): gdkpixbuf.Pixbuf =
  let gobj = gtk_status_icon_get_pixbuf(cast[ptr StatusIcon00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: StatusIcon): gdkpixbuf.Pixbuf =
  let gobj = gtk_status_icon_get_pixbuf(cast[ptr StatusIcon00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_get_screen*(self: ptr StatusIcon00): ptr gdk.Screen00 {.
    importc: "gtk_status_icon_get_screen", libprag.}

proc getScreen*(self: StatusIcon): gdk.Screen =
  let gobj = gtk_status_icon_get_screen(cast[ptr StatusIcon00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: StatusIcon): gdk.Screen =
  let gobj = gtk_status_icon_get_screen(cast[ptr StatusIcon00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_get_size*(self: ptr StatusIcon00): int32 {.
    importc: "gtk_status_icon_get_size", libprag.}

proc getSize*(self: StatusIcon): int =
  int(gtk_status_icon_get_size(cast[ptr StatusIcon00](self.impl)))

proc size*(self: StatusIcon): int =
  int(gtk_status_icon_get_size(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_get_stock*(self: ptr StatusIcon00): cstring {.
    importc: "gtk_status_icon_get_stock", libprag.}

proc getStock*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_stock(cast[ptr StatusIcon00](self.impl))
  result = $resul0

proc stock*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_stock(cast[ptr StatusIcon00](self.impl))
  result = $resul0

proc gtk_status_icon_get_storage_type*(self: ptr StatusIcon00): ImageType {.
    importc: "gtk_status_icon_get_storage_type", libprag.}

proc getStorageType*(self: StatusIcon): ImageType =
  gtk_status_icon_get_storage_type(cast[ptr StatusIcon00](self.impl))

proc storageType*(self: StatusIcon): ImageType =
  gtk_status_icon_get_storage_type(cast[ptr StatusIcon00](self.impl))

proc gtk_status_icon_get_title*(self: ptr StatusIcon00): cstring {.
    importc: "gtk_status_icon_get_title", libprag.}

proc getTitle*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_title(cast[ptr StatusIcon00](self.impl))
  result = $resul0

proc title*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_title(cast[ptr StatusIcon00](self.impl))
  result = $resul0

proc gtk_status_icon_get_tooltip_markup*(self: ptr StatusIcon00): cstring {.
    importc: "gtk_status_icon_get_tooltip_markup", libprag.}

proc getTooltipMarkup*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_tooltip_markup(cast[ptr StatusIcon00](self.impl))
  result = $resul0
  cogfree(resul0)

proc tooltipMarkup*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_tooltip_markup(cast[ptr StatusIcon00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_status_icon_get_tooltip_text*(self: ptr StatusIcon00): cstring {.
    importc: "gtk_status_icon_get_tooltip_text", libprag.}

proc getTooltipText*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_tooltip_text(cast[ptr StatusIcon00](self.impl))
  result = $resul0
  cogfree(resul0)

proc tooltipText*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_tooltip_text(cast[ptr StatusIcon00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_status_icon_get_visible*(self: ptr StatusIcon00): gboolean {.
    importc: "gtk_status_icon_get_visible", libprag.}

proc getVisible*(self: StatusIcon): bool =
  toBool(gtk_status_icon_get_visible(cast[ptr StatusIcon00](self.impl)))

proc visible*(self: StatusIcon): bool =
  toBool(gtk_status_icon_get_visible(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_get_x11_window_id*(self: ptr StatusIcon00): uint32 {.
    importc: "gtk_status_icon_get_x11_window_id", libprag.}

proc getX11WindowId*(self: StatusIcon): int =
  int(gtk_status_icon_get_x11_window_id(cast[ptr StatusIcon00](self.impl)))

proc x11WindowId*(self: StatusIcon): int =
  int(gtk_status_icon_get_x11_window_id(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_is_embedded*(self: ptr StatusIcon00): gboolean {.
    importc: "gtk_status_icon_is_embedded", libprag.}

proc isEmbedded*(self: StatusIcon): bool =
  toBool(gtk_status_icon_is_embedded(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_set_from_file*(self: ptr StatusIcon00; filename: ucstring) {.
    importc: "gtk_status_icon_set_from_file", libprag.}

proc setFromFile*(self: StatusIcon; filename: ucstring) =
  gtk_status_icon_set_from_file(cast[ptr StatusIcon00](self.impl), filename)

proc `fromFile=`*(self: StatusIcon; filename: ucstring) =
  gtk_status_icon_set_from_file(cast[ptr StatusIcon00](self.impl), filename)

proc gtk_status_icon_set_from_gicon*(self: ptr StatusIcon00; icon: ptr gio.Icon00) {.
    importc: "gtk_status_icon_set_from_gicon", libprag.}

proc setFromGicon*(self: StatusIcon; icon: gio.Icon) =
  gtk_status_icon_set_from_gicon(cast[ptr StatusIcon00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc `fromGicon=`*(self: StatusIcon; icon: gio.Icon) =
  gtk_status_icon_set_from_gicon(cast[ptr StatusIcon00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc gtk_status_icon_set_from_icon_name*(self: ptr StatusIcon00; iconName: cstring) {.
    importc: "gtk_status_icon_set_from_icon_name", libprag.}

proc setFromIconName*(self: StatusIcon; iconName: string) =
  gtk_status_icon_set_from_icon_name(cast[ptr StatusIcon00](self.impl), cstring(iconName))

proc `fromIconName=`*(self: StatusIcon; iconName: string) =
  gtk_status_icon_set_from_icon_name(cast[ptr StatusIcon00](self.impl), cstring(iconName))

proc gtk_status_icon_set_from_pixbuf*(self: ptr StatusIcon00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc: "gtk_status_icon_set_from_pixbuf", libprag.}

proc setFromPixbuf*(self: StatusIcon; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_status_icon_set_from_pixbuf(cast[ptr StatusIcon00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `fromPixbuf=`*(self: StatusIcon; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_status_icon_set_from_pixbuf(cast[ptr StatusIcon00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_status_icon_set_from_stock*(self: ptr StatusIcon00; stockId: cstring) {.
    importc: "gtk_status_icon_set_from_stock", libprag.}

proc setFromStock*(self: StatusIcon; stockId: string) =
  gtk_status_icon_set_from_stock(cast[ptr StatusIcon00](self.impl), cstring(stockId))

proc `fromStock=`*(self: StatusIcon; stockId: string) =
  gtk_status_icon_set_from_stock(cast[ptr StatusIcon00](self.impl), cstring(stockId))

proc gtk_status_icon_set_has_tooltip*(self: ptr StatusIcon00; hasTooltip: gboolean) {.
    importc: "gtk_status_icon_set_has_tooltip", libprag.}

proc setHasTooltip*(self: StatusIcon; hasTooltip: bool) =
  gtk_status_icon_set_has_tooltip(cast[ptr StatusIcon00](self.impl), gboolean(hasTooltip))

proc `hasTooltip=`*(self: StatusIcon; hasTooltip: bool) =
  gtk_status_icon_set_has_tooltip(cast[ptr StatusIcon00](self.impl), gboolean(hasTooltip))

proc gtk_status_icon_set_name*(self: ptr StatusIcon00; name: cstring) {.
    importc: "gtk_status_icon_set_name", libprag.}

proc setName*(self: StatusIcon; name: string) =
  gtk_status_icon_set_name(cast[ptr StatusIcon00](self.impl), cstring(name))

proc `name=`*(self: StatusIcon; name: string) =
  gtk_status_icon_set_name(cast[ptr StatusIcon00](self.impl), cstring(name))

proc gtk_status_icon_set_screen*(self: ptr StatusIcon00; screen: ptr gdk.Screen00) {.
    importc: "gtk_status_icon_set_screen", libprag.}

proc setScreen*(self: StatusIcon; screen: gdk.Screen) =
  gtk_status_icon_set_screen(cast[ptr StatusIcon00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: StatusIcon; screen: gdk.Screen) =
  gtk_status_icon_set_screen(cast[ptr StatusIcon00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc gtk_status_icon_set_title*(self: ptr StatusIcon00; title: cstring) {.
    importc: "gtk_status_icon_set_title", libprag.}

proc setTitle*(self: StatusIcon; title: string) =
  gtk_status_icon_set_title(cast[ptr StatusIcon00](self.impl), cstring(title))

proc `title=`*(self: StatusIcon; title: string) =
  gtk_status_icon_set_title(cast[ptr StatusIcon00](self.impl), cstring(title))

proc gtk_status_icon_set_tooltip_markup*(self: ptr StatusIcon00; markup: cstring) {.
    importc: "gtk_status_icon_set_tooltip_markup", libprag.}

proc setTooltipMarkup*(self: StatusIcon; markup: string) =
  gtk_status_icon_set_tooltip_markup(cast[ptr StatusIcon00](self.impl), cstring(markup))

proc `tooltipMarkup=`*(self: StatusIcon; markup: string) =
  gtk_status_icon_set_tooltip_markup(cast[ptr StatusIcon00](self.impl), cstring(markup))

proc gtk_status_icon_set_tooltip_text*(self: ptr StatusIcon00; text: cstring) {.
    importc: "gtk_status_icon_set_tooltip_text", libprag.}

proc setTooltipText*(self: StatusIcon; text: string) =
  gtk_status_icon_set_tooltip_text(cast[ptr StatusIcon00](self.impl), cstring(text))

proc `tooltipText=`*(self: StatusIcon; text: string) =
  gtk_status_icon_set_tooltip_text(cast[ptr StatusIcon00](self.impl), cstring(text))

proc gtk_status_icon_set_visible*(self: ptr StatusIcon00; visible: gboolean) {.
    importc: "gtk_status_icon_set_visible", libprag.}

proc setVisible*(self: StatusIcon; visible: bool) =
  gtk_status_icon_set_visible(cast[ptr StatusIcon00](self.impl), gboolean(visible))

proc `visible=`*(self: StatusIcon; visible: bool) =
  gtk_status_icon_set_visible(cast[ptr StatusIcon00](self.impl), gboolean(visible))

type
  StatusIconClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    activate*: proc(statusIcon: ptr StatusIcon00) {.cdecl.}
    popupMenu*: proc(statusIcon: ptr StatusIcon00; button: uint32; activateTime: uint32) {.cdecl.}
    sizeChanged*: proc(statusIcon: ptr StatusIcon00; size: int32): gboolean {.cdecl.}
    buttonPressEvent*: proc(statusIcon: ptr StatusIcon00; event: ptr gdk.EventButton00): gboolean {.cdecl.}
    buttonReleaseEvent*: proc(statusIcon: ptr StatusIcon00; event: ptr gdk.EventButton00): gboolean {.cdecl.}
    scrollEvent*: proc(statusIcon: ptr StatusIcon00; event: ptr gdk.EventScroll00): gboolean {.cdecl.}
    queryTooltip*: proc(statusIcon: ptr StatusIcon00; x: int32; y: int32; 
    keyboardMode: gboolean; tooltip: ptr Tooltip00): gboolean {.cdecl.}
    GtkReserved1*: pointer
    GtkReserved2*: pointer
    GtkReserved3*: pointer
    GtkReserved4*: pointer
  StatusIconClass* = ref object
    impl*: ptr StatusIconClass00

type
  StatusbarPrivate00* {.pure.} = object
  StatusbarPrivate* = ref object
    impl*: ptr StatusbarPrivate00

type
  Statusbar* = ref object of Box
  Statusbar00* = object of Box00
    priv4: ptr StatusbarPrivate00

proc scTextPopped*(self: Statusbar;  p: proc (self: ptr gobject.Object00; contextId: uint32; text: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "text-popped", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scTextPushed*(self: Statusbar;  p: proc (self: ptr gobject.Object00; contextId: uint32; text: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "text-pushed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_statusbar_new*(): ptr Statusbar00 {.
    importc: "gtk_statusbar_new", libprag.}

proc newStatusbar*(): Statusbar =
  new(result, finalizeGObject)
  result.impl = gtk_statusbar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusbar*[T](result: var T) =
  assert(result is Statusbar)
  new(result, finalizeGObject)
  result.impl = gtk_statusbar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_statusbar_get_context_id*(self: ptr Statusbar00; contextDescription: cstring): uint32 {.
    importc: "gtk_statusbar_get_context_id", libprag.}

proc getContextId*(self: Statusbar; contextDescription: string): int =
  int(gtk_statusbar_get_context_id(cast[ptr Statusbar00](self.impl), cstring(contextDescription)))

proc contextId*(self: Statusbar; contextDescription: string): int =
  int(gtk_statusbar_get_context_id(cast[ptr Statusbar00](self.impl), cstring(contextDescription)))

proc gtk_statusbar_get_message_area*(self: ptr Statusbar00): ptr Box00 {.
    importc: "gtk_statusbar_get_message_area", libprag.}

proc getMessageArea*(self: Statusbar): Box =
  let gobj = gtk_statusbar_get_message_area(cast[ptr Statusbar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Box](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc messageArea*(self: Statusbar): Box =
  let gobj = gtk_statusbar_get_message_area(cast[ptr Statusbar00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Box](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_statusbar_pop*(self: ptr Statusbar00; contextId: uint32) {.
    importc: "gtk_statusbar_pop", libprag.}

proc pop*(self: Statusbar; contextId: int) =
  gtk_statusbar_pop(cast[ptr Statusbar00](self.impl), uint32(contextId))

proc gtk_statusbar_push*(self: ptr Statusbar00; contextId: uint32; text: cstring): uint32 {.
    importc: "gtk_statusbar_push", libprag.}

proc push*(self: Statusbar; contextId: int; text: string): int =
  int(gtk_statusbar_push(cast[ptr Statusbar00](self.impl), uint32(contextId), cstring(text)))

proc gtk_statusbar_remove*(self: ptr Statusbar00; contextId: uint32; messageId: uint32) {.
    importc: "gtk_statusbar_remove", libprag.}

proc remove*(self: Statusbar; contextId: int; messageId: int) =
  gtk_statusbar_remove(cast[ptr Statusbar00](self.impl), uint32(contextId), uint32(messageId))

proc gtk_statusbar_remove_all*(self: ptr Statusbar00; contextId: uint32) {.
    importc: "gtk_statusbar_remove_all", libprag.}

proc removeAll*(self: Statusbar; contextId: int) =
  gtk_statusbar_remove_all(cast[ptr Statusbar00](self.impl), uint32(contextId))

type
  StatusbarAccessiblePrivate00* {.pure.} = object
  StatusbarAccessiblePrivate* = ref object
    impl*: ptr StatusbarAccessiblePrivate00

type
  StatusbarAccessible* = ref object of ContainerAccessible
  StatusbarAccessible00* = object of ContainerAccessible00
    priv4: ptr StatusbarAccessiblePrivate00

type
  StatusbarAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  StatusbarAccessibleClass* = ref object
    impl*: ptr StatusbarAccessibleClass00

type
  StatusbarClass00* {.pure.} = object
    parentClass*: BoxClass00
    reserved*: pointer
    textPushed*: proc(statusbar: ptr Statusbar00; contextId: uint32; text: cstring) {.cdecl.}
    textPopped*: proc(statusbar: ptr Statusbar00; contextId: uint32; text: cstring) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  StatusbarClass* = ref object
    impl*: ptr StatusbarClass00

type
  StockItem00* {.pure.} = object
    stockId*: cstring
    label*: cstring
    modifier*: gdk.ModifierType
    keyval*: uint32
    translationDomain*: cstring
  StockItem* = ref object
    impl*: ptr StockItem00

proc gtk_stock_item_free*(self: ptr StockItem00) {.
    importc: "gtk_stock_item_free", libprag.}

proc free*(self: StockItem) =
  gtk_stock_item_free(cast[ptr StockItem00](self.impl))

type
  StyleClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    realize*: proc(style: ptr Style00) {.cdecl.}
    unrealize*: proc(style: ptr Style00) {.cdecl.}
    copy*: proc(style: ptr Style00; src: ptr Style00) {.cdecl.}
    clone*: pointer
    initFromRc*: proc(style: ptr Style00; rcStyle: ptr RcStyle00) {.cdecl.}
    setBackground*: proc(style: ptr Style00; window: ptr gdk.Window00; stateType: StateType) {.cdecl.}
    renderIcon*: proc(style: ptr Style00; source: ptr IconSource00; direction: TextDirection; 
    state: StateType; size: int32; widget: ptr Widget00; detail: cstring): ptr gdkpixbuf.Pixbuf00 {.cdecl.}
    drawHline*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; x1: int32; x2: int32; y: int32) {.cdecl.}
    drawVline*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; y1: int32; y2: int32; x: int32) {.cdecl.}
    drawShadow*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.cdecl.}
    drawArrow*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; arrowType: ArrowType; 
    fill: gboolean; x: int32; y: int32; width: int32; height: int32) {.cdecl.}
    drawDiamond*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.cdecl.}
    drawBox*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.cdecl.}
    drawFlatBox*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.cdecl.}
    drawCheck*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.cdecl.}
    drawOption*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.cdecl.}
    drawTab*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.cdecl.}
    drawShadowGap*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; gapSide: PositionType; gapX: int32; gapWidth: int32) {.cdecl.}
    drawBoxGap*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; gapSide: PositionType; gapX: int32; gapWidth: int32) {.cdecl.}
    drawExtension*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; gapSide: PositionType) {.cdecl.}
    drawFocus*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; x: int32; y: int32; width: int32; height: int32) {.cdecl.}
    drawSlider*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; orientation: Orientation) {.cdecl.}
    drawHandle*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; orientation: Orientation) {.cdecl.}
    drawExpander*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; x: int32; y: int32; expanderStyle: ExpanderStyle) {.cdecl.}
    drawLayout*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    useText: gboolean; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    layout: ptr pango.Layout00) {.cdecl.}
    drawResizeGrip*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; edge: gdk.WindowEdge; x: int32; y: int32; 
    width: int32; height: int32) {.cdecl.}
    drawSpinner*: proc(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; step: uint32; x: int32; y: int32; width: int32; 
    height: int32) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
    gtkReserved9*: pointer
    gtkReserved10*: pointer
    gtkReserved11*: pointer
  StyleClass* = ref object
    impl*: ptr StyleClass00

type
  StyleContextClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    changed*: proc(context: ptr StyleContext00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  StyleContextClass* = ref object
    impl*: ptr StyleContextClass00

type
  StylePropertiesClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  StylePropertiesClass* = ref object
    impl*: ptr StylePropertiesClass00

type
  StylePropertyParser* = proc (string: cstring; value: ptr gobject.Value00): gboolean {.cdecl.}

type
  StyleProviderIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    getStyle*: proc(provider: ptr StyleProvider00; path: ptr WidgetPath00): ptr StyleProperties00 {.cdecl.}
    getStyleProperty*: proc(provider: ptr StyleProvider00; path: ptr WidgetPath00; 
    state: StateFlags; pspec: ptr gobject.ParamSpec00; value: var gobject.Value00): gboolean {.cdecl.}
    getIconFactory*: proc(provider: ptr StyleProvider00; path: ptr WidgetPath00): ptr IconFactory00 {.cdecl.}
  StyleProviderIface* = ref object
    impl*: ptr StyleProviderIface00

type
  SwitchPrivate00* {.pure.} = object
  SwitchPrivate* = ref object
    impl*: ptr SwitchPrivate00

type
  Switch* = ref object of Widget
  Switch00* = object of Widget00
    priv2: ptr SwitchPrivate00

proc scActivate*(self: Switch;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStateSet*(self: Switch;  p: proc (self: ptr gobject.Object00; state: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "state-set", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_switch_new*(): ptr Switch00 {.
    importc: "gtk_switch_new", libprag.}

proc newSwitch*(): Switch =
  new(result, finalizeGObject)
  result.impl = gtk_switch_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSwitch*[T](result: var T) =
  assert(result is Switch)
  new(result, finalizeGObject)
  result.impl = gtk_switch_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_switch_get_active*(self: ptr Switch00): gboolean {.
    importc: "gtk_switch_get_active", libprag.}

proc getActive*(self: Switch): bool =
  toBool(gtk_switch_get_active(cast[ptr Switch00](self.impl)))

proc active*(self: Switch): bool =
  toBool(gtk_switch_get_active(cast[ptr Switch00](self.impl)))

proc gtk_switch_get_state*(self: ptr Switch00): gboolean {.
    importc: "gtk_switch_get_state", libprag.}

proc getState*(self: Switch): bool =
  toBool(gtk_switch_get_state(cast[ptr Switch00](self.impl)))

proc state*(self: Switch): bool =
  toBool(gtk_switch_get_state(cast[ptr Switch00](self.impl)))

proc gtk_switch_set_active*(self: ptr Switch00; isActive: gboolean) {.
    importc: "gtk_switch_set_active", libprag.}

proc setActive*(self: Switch; isActive: bool) =
  gtk_switch_set_active(cast[ptr Switch00](self.impl), gboolean(isActive))

proc `active=`*(self: Switch; isActive: bool) =
  gtk_switch_set_active(cast[ptr Switch00](self.impl), gboolean(isActive))

proc gtk_switch_set_state*(self: ptr Switch00; state: gboolean) {.
    importc: "gtk_switch_set_state", libprag.}

proc setState*(self: Switch; state: bool) =
  gtk_switch_set_state(cast[ptr Switch00](self.impl), gboolean(state))

proc `state=`*(self: Switch; state: bool) =
  gtk_switch_set_state(cast[ptr Switch00](self.impl), gboolean(state))

type
  SwitchAccessiblePrivate00* {.pure.} = object
  SwitchAccessiblePrivate* = ref object
    impl*: ptr SwitchAccessiblePrivate00

type
  SwitchAccessible* = ref object of WidgetAccessible
  SwitchAccessible00* = object of WidgetAccessible00
    priv3: ptr SwitchAccessiblePrivate00

type
  SwitchAccessibleClass00* {.pure.} = object
    parentClass*: WidgetAccessibleClass00
  SwitchAccessibleClass* = ref object
    impl*: ptr SwitchAccessibleClass00

type
  SwitchClass00* {.pure.} = object
    parentClass*: WidgetClass00
    activate*: proc(sw: ptr Switch00) {.cdecl.}
    stateSet*: proc(sw: ptr Switch00; state: gboolean): gboolean {.cdecl.}
    switchPadding_1*: pointer
    switchPadding_2*: pointer
    switchPadding_3*: pointer
    switchPadding_4*: pointer
    switchPadding_5*: pointer
  SwitchClass* = ref object
    impl*: ptr SwitchClass00

const TEXT_VIEW_PRIORITY_VALIDATE* = 5'i32

const TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID* = -1'i32

const TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID* = -2'i32

type
  TablePrivate00* {.pure.} = object
  TablePrivate* = ref object
    impl*: ptr TablePrivate00

type
  Table* = ref object of Container
  Table00* = object of Container00
    priv3: ptr TablePrivate00

proc gtk_table_new*(rows: uint32; columns: uint32; homogeneous: gboolean): ptr Table00 {.
    importc: "gtk_table_new", libprag.}

proc newTable*(rows: int; columns: int; homogeneous: bool): Table =
  new(result, finalizeGObject)
  result.impl = gtk_table_new(uint32(rows), uint32(columns), gboolean(homogeneous))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTable*[T](result: var T; rows: int; columns: int; homogeneous: bool) =
  assert(result is Table)
  new(result, finalizeGObject)
  result.impl = gtk_table_new(uint32(rows), uint32(columns), gboolean(homogeneous))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_table_attach*(self: ptr Table00; child: ptr Widget00; leftAttach: uint32; 
    rightAttach: uint32; topAttach: uint32; bottomAttach: uint32; xoptions: AttachOptions; 
    yoptions: AttachOptions; xpadding: uint32; ypadding: uint32) {.
    importc: "gtk_table_attach", libprag.}

proc attach*(self: Table; child: Widget; leftAttach: int; rightAttach: int; 
    topAttach: int; bottomAttach: int; xoptions: AttachOptions; yoptions: AttachOptions; 
    xpadding: int; ypadding: int) =
  gtk_table_attach(cast[ptr Table00](self.impl), cast[ptr Widget00](child.impl), uint32(leftAttach), uint32(rightAttach), uint32(topAttach), uint32(bottomAttach), xoptions, yoptions, uint32(xpadding), uint32(ypadding))

proc gtk_table_attach_defaults*(self: ptr Table00; widget: ptr Widget00; leftAttach: uint32; 
    rightAttach: uint32; topAttach: uint32; bottomAttach: uint32) {.
    importc: "gtk_table_attach_defaults", libprag.}

proc attachDefaults*(self: Table; widget: Widget; leftAttach: int; rightAttach: int; 
    topAttach: int; bottomAttach: int) =
  gtk_table_attach_defaults(cast[ptr Table00](self.impl), cast[ptr Widget00](widget.impl), uint32(leftAttach), uint32(rightAttach), uint32(topAttach), uint32(bottomAttach))

proc gtk_table_get_col_spacing*(self: ptr Table00; column: uint32): uint32 {.
    importc: "gtk_table_get_col_spacing", libprag.}

proc getColSpacing*(self: Table; column: int): int =
  int(gtk_table_get_col_spacing(cast[ptr Table00](self.impl), uint32(column)))

proc colSpacing*(self: Table; column: int): int =
  int(gtk_table_get_col_spacing(cast[ptr Table00](self.impl), uint32(column)))

proc gtk_table_get_default_col_spacing*(self: ptr Table00): uint32 {.
    importc: "gtk_table_get_default_col_spacing", libprag.}

proc getDefaultColSpacing*(self: Table): int =
  int(gtk_table_get_default_col_spacing(cast[ptr Table00](self.impl)))

proc defaultColSpacing*(self: Table): int =
  int(gtk_table_get_default_col_spacing(cast[ptr Table00](self.impl)))

proc gtk_table_get_default_row_spacing*(self: ptr Table00): uint32 {.
    importc: "gtk_table_get_default_row_spacing", libprag.}

proc getDefaultRowSpacing*(self: Table): int =
  int(gtk_table_get_default_row_spacing(cast[ptr Table00](self.impl)))

proc defaultRowSpacing*(self: Table): int =
  int(gtk_table_get_default_row_spacing(cast[ptr Table00](self.impl)))

proc gtk_table_get_homogeneous*(self: ptr Table00): gboolean {.
    importc: "gtk_table_get_homogeneous", libprag.}

proc getHomogeneous*(self: Table): bool =
  toBool(gtk_table_get_homogeneous(cast[ptr Table00](self.impl)))

proc homogeneous*(self: Table): bool =
  toBool(gtk_table_get_homogeneous(cast[ptr Table00](self.impl)))

proc gtk_table_get_row_spacing*(self: ptr Table00; row: uint32): uint32 {.
    importc: "gtk_table_get_row_spacing", libprag.}

proc getRowSpacing*(self: Table; row: int): int =
  int(gtk_table_get_row_spacing(cast[ptr Table00](self.impl), uint32(row)))

proc rowSpacing*(self: Table; row: int): int =
  int(gtk_table_get_row_spacing(cast[ptr Table00](self.impl), uint32(row)))

proc gtk_table_get_size*(self: ptr Table00; rows: var uint32; columns: var uint32) {.
    importc: "gtk_table_get_size", libprag.}

proc getSize*(self: Table; rows: var int; columns: var int) =
  var columns_00 = uint32(columns)
  var rows_00 = uint32(rows)
  gtk_table_get_size(cast[ptr Table00](self.impl), rows_00, columns_00)
  columns = int(columns_00)
  rows = int(rows_00)

proc size*(self: Table; rows: var int; columns: var int) =
  var columns_00 = uint32(columns)
  var rows_00 = uint32(rows)
  gtk_table_get_size(cast[ptr Table00](self.impl), rows_00, columns_00)
  columns = int(columns_00)
  rows = int(rows_00)

proc gtk_table_resize*(self: ptr Table00; rows: uint32; columns: uint32) {.
    importc: "gtk_table_resize", libprag.}

proc resize*(self: Table; rows: int; columns: int) =
  gtk_table_resize(cast[ptr Table00](self.impl), uint32(rows), uint32(columns))

proc gtk_table_set_col_spacing*(self: ptr Table00; column: uint32; spacing: uint32) {.
    importc: "gtk_table_set_col_spacing", libprag.}

proc setColSpacing*(self: Table; column: int; spacing: int) =
  gtk_table_set_col_spacing(cast[ptr Table00](self.impl), uint32(column), uint32(spacing))

proc gtk_table_set_col_spacings*(self: ptr Table00; spacing: uint32) {.
    importc: "gtk_table_set_col_spacings", libprag.}

proc setColSpacings*(self: Table; spacing: int) =
  gtk_table_set_col_spacings(cast[ptr Table00](self.impl), uint32(spacing))

proc `colSpacings=`*(self: Table; spacing: int) =
  gtk_table_set_col_spacings(cast[ptr Table00](self.impl), uint32(spacing))

proc gtk_table_set_homogeneous*(self: ptr Table00; homogeneous: gboolean) {.
    importc: "gtk_table_set_homogeneous", libprag.}

proc setHomogeneous*(self: Table; homogeneous: bool) =
  gtk_table_set_homogeneous(cast[ptr Table00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: Table; homogeneous: bool) =
  gtk_table_set_homogeneous(cast[ptr Table00](self.impl), gboolean(homogeneous))

proc gtk_table_set_row_spacing*(self: ptr Table00; row: uint32; spacing: uint32) {.
    importc: "gtk_table_set_row_spacing", libprag.}

proc setRowSpacing*(self: Table; row: int; spacing: int) =
  gtk_table_set_row_spacing(cast[ptr Table00](self.impl), uint32(row), uint32(spacing))

proc gtk_table_set_row_spacings*(self: ptr Table00; spacing: uint32) {.
    importc: "gtk_table_set_row_spacings", libprag.}

proc setRowSpacings*(self: Table; spacing: int) =
  gtk_table_set_row_spacings(cast[ptr Table00](self.impl), uint32(spacing))

proc `rowSpacings=`*(self: Table; spacing: int) =
  gtk_table_set_row_spacings(cast[ptr Table00](self.impl), uint32(spacing))

type
  TableChild00* {.pure.} = object
    widget*: ptr Widget00
    leftAttach*: uint16
    rightAttach*: uint16
    topAttach*: uint16
    bottomAttach*: uint16
    xpadding*: uint16
    ypadding*: uint16
    xexpand*: uint32
    yexpand*: uint32
    xshrink*: uint32
    yshrink*: uint32
    xfill*: uint32
    yfill*: uint32
  TableChild* = ref object
    impl*: ptr TableChild00

type
  TableClass00* {.pure.} = object
    parentClass*: ContainerClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TableClass* = ref object
    impl*: ptr TableClass00

type
  TableRowCol00* {.pure.} = object
    requisition*: uint16
    allocation*: uint16
    spacing*: uint16
    needExpand*: uint32
    needShrink*: uint32
    expand*: uint32
    shrink*: uint32
    empty*: uint32
  TableRowCol* = ref object
    impl*: ptr TableRowCol00

type
  TargetFlag* {.size: sizeof(cint), pure.} = enum
    sameApp = 1
    sameWidget = 2
    otherApp = 3
    otherWidget = 4

  TargetFlags* {.size: sizeof(cint).} = set[TargetFlag]

type
  TargetPair00* {.pure.} = object
    target*: ptr gdk.Atom00
    flags*: uint32
    info*: uint32
  TargetPair* = ref object
    impl*: ptr TargetPair00

type
  TearoffMenuItemPrivate00* {.pure.} = object
  TearoffMenuItemPrivate* = ref object
    impl*: ptr TearoffMenuItemPrivate00

type
  TearoffMenuItem* = ref object of MenuItem
  TearoffMenuItem00* = object of MenuItem00
    priv5: ptr TearoffMenuItemPrivate00

proc gtk_tearoff_menu_item_new*(): ptr TearoffMenuItem00 {.
    importc: "gtk_tearoff_menu_item_new", libprag.}

proc newTearoffMenuItem*(): TearoffMenuItem =
  new(result, finalizeGObject)
  result.impl = gtk_tearoff_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTearoffMenuItem*[T](result: var T) =
  assert(result is TearoffMenuItem)
  new(result, finalizeGObject)
  result.impl = gtk_tearoff_menu_item_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TearoffMenuItemClass00* {.pure.} = object
    parentClass*: MenuItemClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TearoffMenuItemClass* = ref object
    impl*: ptr TearoffMenuItemClass00

type
  TextBTree00* {.pure.} = object
  TextBTree* = ref object
    impl*: ptr TextBTree00

type
  TextBufferClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    insertText*: proc(buffer: ptr TextBuffer00; pos: ptr TextIter00; newText: cstring; 
    newTextLength: int32) {.cdecl.}
    insertPixbuf*: proc(buffer: ptr TextBuffer00; iter: ptr TextIter00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.cdecl.}
    insertChildAnchor*: proc(buffer: ptr TextBuffer00; iter: ptr TextIter00; anchor: ptr TextChildAnchor00) {.cdecl.}
    deleteRange*: proc(buffer: ptr TextBuffer00; start: ptr TextIter00; `end`: ptr TextIter00) {.cdecl.}
    changed*: proc(buffer: ptr TextBuffer00) {.cdecl.}
    modifiedChanged*: proc(buffer: ptr TextBuffer00) {.cdecl.}
    markSet*: proc(buffer: ptr TextBuffer00; location: ptr TextIter00; 
    mark: ptr TextMark00) {.cdecl.}
    markDeleted*: proc(buffer: ptr TextBuffer00; mark: ptr TextMark00) {.cdecl.}
    applyTag*: proc(buffer: ptr TextBuffer00; tag: ptr TextTag00; start: ptr TextIter00; 
    `end`: ptr TextIter00) {.cdecl.}
    removeTag*: proc(buffer: ptr TextBuffer00; tag: ptr TextTag00; start: ptr TextIter00; 
    `end`: ptr TextIter00) {.cdecl.}
    beginUserAction*: proc(buffer: ptr TextBuffer00) {.cdecl.}
    endUserAction*: proc(buffer: ptr TextBuffer00) {.cdecl.}
    pasteDone*: proc(buffer: ptr TextBuffer00; clipboard: ptr Clipboard00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TextBufferClass* = ref object
    impl*: ptr TextBufferClass00

type
  TextBufferDeserializeFunc* = proc (registerBuffer: ptr TextBuffer00; contentBuffer: ptr TextBuffer00; 
    iter: ptr TextIter00; data: uint8Array; length: uint64; createTags: gboolean; 
    userData: pointer): gboolean {.cdecl.}

proc gtk_text_buffer_register_deserialize_format*(self: ptr TextBuffer00; mimeType: cstring; function: TextBufferDeserializeFunc; 
    userData: pointer; userDataDestroy: DestroyNotify): ptr gdk.Atom00 {.
    importc: "gtk_text_buffer_register_deserialize_format", libprag.}

proc registerDeserializeFormat*(self: TextBuffer; mimeType: string; function: TextBufferDeserializeFunc; 
    userData: pointer; userDataDestroy: DestroyNotify): gdk.Atom =
  new(result)
  result.impl = gtk_text_buffer_register_deserialize_format(cast[ptr TextBuffer00](self.impl), cstring(mimeType), function, userData, userDataDestroy)

type
  TextBufferSerializeFunc* = proc (registerBuffer: ptr TextBuffer00; contentBuffer: ptr TextBuffer00; 
    start: ptr TextIter00; `end`: ptr TextIter00; length: ptr uint64; userData: pointer): ptr uint8 {.cdecl.}

proc gtk_text_buffer_register_serialize_format*(self: ptr TextBuffer00; mimeType: cstring; function: TextBufferSerializeFunc; 
    userData: pointer; userDataDestroy: DestroyNotify): ptr gdk.Atom00 {.
    importc: "gtk_text_buffer_register_serialize_format", libprag.}

proc registerSerializeFormat*(self: TextBuffer; mimeType: string; function: TextBufferSerializeFunc; 
    userData: pointer; userDataDestroy: DestroyNotify): gdk.Atom =
  new(result)
  result.impl = gtk_text_buffer_register_serialize_format(cast[ptr TextBuffer00](self.impl), cstring(mimeType), function, userData, userDataDestroy)

type
  TextBufferTargetInfo* {.size: sizeof(cint), pure.} = enum
    text = -3
    richText = -2
    bufferContents = -1

type
  TextCellAccessiblePrivate00* {.pure.} = object
  TextCellAccessiblePrivate* = ref object
    impl*: ptr TextCellAccessiblePrivate00

type
  TextCellAccessible* = ref object of RendererCellAccessible
  TextCellAccessible00* = object of RendererCellAccessible00
    priv4: ptr TextCellAccessiblePrivate00

type
  TextCellAccessibleClass00* {.pure.} = object
    parentClass*: RendererCellAccessibleClass00
  TextCellAccessibleClass* = ref object
    impl*: ptr TextCellAccessibleClass00

type
  TextCharPredicate* = proc (ch: gunichar; userData: pointer): gboolean {.cdecl.}

proc gtk_text_iter_backward_find_char*(self: ptr TextIter00; pred: TextCharPredicate; userData: pointer; 
    limit: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_backward_find_char", libprag.}

proc backwardFindChar*(self: TextIter; pred: TextCharPredicate; userData: pointer; 
    limit: TextIter): bool =
  toBool(gtk_text_iter_backward_find_char(cast[ptr TextIter00](self.impl), pred, userData, cast[ptr TextIter00](limit.impl)))

proc gtk_text_iter_forward_find_char*(self: ptr TextIter00; pred: TextCharPredicate; userData: pointer; 
    limit: ptr TextIter00): gboolean {.
    importc: "gtk_text_iter_forward_find_char", libprag.}

proc forwardFindChar*(self: TextIter; pred: TextCharPredicate; userData: pointer; 
    limit: TextIter): bool =
  toBool(gtk_text_iter_forward_find_char(cast[ptr TextIter00](self.impl), pred, userData, cast[ptr TextIter00](limit.impl)))

type
  TextChildAnchorClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TextChildAnchorClass* = ref object
    impl*: ptr TextChildAnchorClass00

type
  TextExtendSelection* {.size: sizeof(cint), pure.} = enum
    word = 0
    line = 1

type
  TextMarkClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TextMarkClass* = ref object
    impl*: ptr TextMarkClass00

type
  TextTagClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    event*: proc(tag: ptr TextTag00; eventObject: ptr gobject.Object00; 
    event: ptr gdk.Event00; iter: ptr TextIter00): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TextTagClass* = ref object
    impl*: ptr TextTagClass00

type
  TextTagTableClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    tagChanged*: proc(table: ptr TextTagTable00; tag: ptr TextTag00; sizeChanged: gboolean) {.cdecl.}
    tagAdded*: proc(table: ptr TextTagTable00; tag: ptr TextTag00) {.cdecl.}
    tagRemoved*: proc(table: ptr TextTagTable00; tag: ptr TextTag00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TextTagTableClass* = ref object
    impl*: ptr TextTagTableClass00

type
  TextTagTableForeach* = proc (tag: ptr TextTag00; data: pointer) {.cdecl.}

proc gtk_text_tag_table_foreach*(self: ptr TextTagTable00; `func`: TextTagTableForeach; 
    data: pointer) {.
    importc: "gtk_text_tag_table_foreach", libprag.}

proc foreach*(self: TextTagTable; `func`: TextTagTableForeach; data: pointer) =
  gtk_text_tag_table_foreach(cast[ptr TextTagTable00](self.impl), `func`, data)

type
  TextViewPrivate00* {.pure.} = object
  TextViewPrivate* = ref object
    impl*: ptr TextViewPrivate00

type
  TextView* = ref object of Container
  TextView00* = object of Container00
    priv3: ptr TextViewPrivate00

proc scBackspace*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "backspace", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCopyClipboard*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "copy-clipboard", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCutClipboard*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cut-clipboard", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDeleteFromCursor*(self: TextView;  p: proc (self: ptr gobject.Object00; `type`: DeleteType; count: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "delete-from-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scExtendSelection*(self: TextView;  p: proc (self: ptr gobject.Object00; granularity: TextExtendSelection; location: TextIter00; 
    start: TextIter00; `end`: TextIter00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "extend-selection", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scInsertAtCursor*(self: TextView;  p: proc (self: ptr gobject.Object00; string: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "insert-at-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveCursor*(self: TextView;  p: proc (self: ptr gobject.Object00; step: MovementStep; count: int32; extendSelection: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveViewport*(self: TextView;  p: proc (self: ptr gobject.Object00; step: ScrollStep; count: int32; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-viewport", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPasteClipboard*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "paste-clipboard", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopulatePopup*(self: TextView;  p: proc (self: ptr gobject.Object00; popup: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPreeditChanged*(self: TextView;  p: proc (self: ptr gobject.Object00; preedit: cstring; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "preedit-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectAll*(self: TextView;  p: proc (self: ptr gobject.Object00; select: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSetAnchor*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "set-anchor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleCursorVisible*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-cursor-visible", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleOverwrite*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-overwrite", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_text_view_new*(): ptr TextView00 {.
    importc: "gtk_text_view_new", libprag.}

proc newTextView*(): TextView =
  new(result, finalizeGObject)
  result.impl = gtk_text_view_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextView*[T](result: var T) =
  assert(result is TextView)
  new(result, finalizeGObject)
  result.impl = gtk_text_view_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_new_with_buffer*(buffer: ptr TextBuffer00): ptr TextView00 {.
    importc: "gtk_text_view_new_with_buffer", libprag.}

proc newTextViewWithBuffer*(buffer: TextBuffer): TextView =
  new(result, finalizeGObject)
  result.impl = gtk_text_view_new_with_buffer(cast[ptr TextBuffer00](buffer.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextViewWithBuffer*[T](result: var T; buffer: TextBuffer) =
  assert(result is TextView)
  new(result, finalizeGObject)
  result.impl = gtk_text_view_new_with_buffer(cast[ptr TextBuffer00](buffer.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_add_child_at_anchor*(self: ptr TextView00; child: ptr Widget00; anchor: ptr TextChildAnchor00) {.
    importc: "gtk_text_view_add_child_at_anchor", libprag.}

proc addChildAtAnchor*(self: TextView; child: Widget; anchor: TextChildAnchor) =
  gtk_text_view_add_child_at_anchor(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl), cast[ptr TextChildAnchor00](anchor.impl))

proc gtk_text_view_backward_display_line*(self: ptr TextView00; iter: ptr TextIter00): gboolean {.
    importc: "gtk_text_view_backward_display_line", libprag.}

proc backwardDisplayLine*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_backward_display_line(cast[ptr TextView00](self.impl), cast[ptr TextIter00](iter.impl)))

proc gtk_text_view_backward_display_line_start*(self: ptr TextView00; iter: ptr TextIter00): gboolean {.
    importc: "gtk_text_view_backward_display_line_start", libprag.}

proc backwardDisplayLineStart*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_backward_display_line_start(cast[ptr TextView00](self.impl), cast[ptr TextIter00](iter.impl)))

proc gtk_text_view_forward_display_line*(self: ptr TextView00; iter: ptr TextIter00): gboolean {.
    importc: "gtk_text_view_forward_display_line", libprag.}

proc forwardDisplayLine*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_forward_display_line(cast[ptr TextView00](self.impl), cast[ptr TextIter00](iter.impl)))

proc gtk_text_view_forward_display_line_end*(self: ptr TextView00; iter: ptr TextIter00): gboolean {.
    importc: "gtk_text_view_forward_display_line_end", libprag.}

proc forwardDisplayLineEnd*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_forward_display_line_end(cast[ptr TextView00](self.impl), cast[ptr TextIter00](iter.impl)))

proc gtk_text_view_get_accepts_tab*(self: ptr TextView00): gboolean {.
    importc: "gtk_text_view_get_accepts_tab", libprag.}

proc getAcceptsTab*(self: TextView): bool =
  toBool(gtk_text_view_get_accepts_tab(cast[ptr TextView00](self.impl)))

proc acceptsTab*(self: TextView): bool =
  toBool(gtk_text_view_get_accepts_tab(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_bottom_margin*(self: ptr TextView00): int32 {.
    importc: "gtk_text_view_get_bottom_margin", libprag.}

proc getBottomMargin*(self: TextView): int =
  int(gtk_text_view_get_bottom_margin(cast[ptr TextView00](self.impl)))

proc bottomMargin*(self: TextView): int =
  int(gtk_text_view_get_bottom_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_buffer*(self: ptr TextView00): ptr TextBuffer00 {.
    importc: "gtk_text_view_get_buffer", libprag.}

proc getBuffer*(self: TextView): TextBuffer =
  let gobj = gtk_text_view_get_buffer(cast[ptr TextView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextBuffer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: TextView): TextBuffer =
  let gobj = gtk_text_view_get_buffer(cast[ptr TextView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TextBuffer](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_cursor_locations*(self: ptr TextView00; iter: ptr TextIter00; strong: var gdk.Rectangle00; 
    weak: var gdk.Rectangle00) {.
    importc: "gtk_text_view_get_cursor_locations", libprag.}

proc getCursorLocations*(self: ptr TextView00; iter: ptr TextIter00; strong: var gdk.Rectangle00; 
    weak: var gdk.Rectangle00) {.
    importc: "gtk_text_view_get_cursor_locations", libprag.}

proc cursorLocations*(self: ptr TextView00; iter: ptr TextIter00; strong: var gdk.Rectangle00; 
    weak: var gdk.Rectangle00) {.
    importc: "gtk_text_view_get_cursor_locations", libprag.}

proc gtk_text_view_get_cursor_visible*(self: ptr TextView00): gboolean {.
    importc: "gtk_text_view_get_cursor_visible", libprag.}

proc getCursorVisible*(self: TextView): bool =
  toBool(gtk_text_view_get_cursor_visible(cast[ptr TextView00](self.impl)))

proc cursorVisible*(self: TextView): bool =
  toBool(gtk_text_view_get_cursor_visible(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_default_attributes*(self: ptr TextView00): ptr TextAttributes00 {.
    importc: "gtk_text_view_get_default_attributes", libprag.}

proc getDefaultAttributes*(self: TextView): TextAttributes =
  new(result)
  result.impl = gtk_text_view_get_default_attributes(cast[ptr TextView00](self.impl))

proc defaultAttributes*(self: TextView): TextAttributes =
  new(result)
  result.impl = gtk_text_view_get_default_attributes(cast[ptr TextView00](self.impl))

proc gtk_text_view_get_editable*(self: ptr TextView00): gboolean {.
    importc: "gtk_text_view_get_editable", libprag.}

proc getEditable*(self: TextView): bool =
  toBool(gtk_text_view_get_editable(cast[ptr TextView00](self.impl)))

proc editable*(self: TextView): bool =
  toBool(gtk_text_view_get_editable(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_hadjustment*(self: ptr TextView00): ptr Adjustment00 {.
    importc: "gtk_text_view_get_hadjustment", libprag.}

proc getHadjustment*(self: TextView): Adjustment =
  let gobj = gtk_text_view_get_hadjustment(cast[ptr TextView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: TextView): Adjustment =
  let gobj = gtk_text_view_get_hadjustment(cast[ptr TextView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_indent*(self: ptr TextView00): int32 {.
    importc: "gtk_text_view_get_indent", libprag.}

proc getIndent*(self: TextView): int =
  int(gtk_text_view_get_indent(cast[ptr TextView00](self.impl)))

proc indent*(self: TextView): int =
  int(gtk_text_view_get_indent(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_input_hints*(self: ptr TextView00): InputHints {.
    importc: "gtk_text_view_get_input_hints", libprag.}

proc getInputHints*(self: TextView): InputHints =
  gtk_text_view_get_input_hints(cast[ptr TextView00](self.impl))

proc inputHints*(self: TextView): InputHints =
  gtk_text_view_get_input_hints(cast[ptr TextView00](self.impl))

proc gtk_text_view_get_input_purpose*(self: ptr TextView00): InputPurpose {.
    importc: "gtk_text_view_get_input_purpose", libprag.}

proc getInputPurpose*(self: TextView): InputPurpose =
  gtk_text_view_get_input_purpose(cast[ptr TextView00](self.impl))

proc inputPurpose*(self: TextView): InputPurpose =
  gtk_text_view_get_input_purpose(cast[ptr TextView00](self.impl))

proc gtk_text_view_get_iter_at_location*(self: ptr TextView00; iter: var TextIter00; x: int32; 
    y: int32): gboolean {.
    importc: "gtk_text_view_get_iter_at_location", libprag.}

proc getIterAtLocation*(self: ptr TextView00; iter: var TextIter00; x: int32; 
    y: int32): gboolean {.
    importc: "gtk_text_view_get_iter_at_location", libprag.}

proc iterAtLocation*(self: ptr TextView00; iter: var TextIter00; x: int32; 
    y: int32): gboolean {.
    importc: "gtk_text_view_get_iter_at_location", libprag.}

proc gtk_text_view_get_iter_at_position*(self: ptr TextView00; iter: var TextIter00; trailing: var int32; 
    x: int32; y: int32): gboolean {.
    importc: "gtk_text_view_get_iter_at_position", libprag.}

proc getIterAtPosition*(self: ptr TextView00; iter: var TextIter00; trailing: var int32; 
    x: int32; y: int32): gboolean {.
    importc: "gtk_text_view_get_iter_at_position", libprag.}

proc iterAtPosition*(self: ptr TextView00; iter: var TextIter00; trailing: var int32; 
    x: int32; y: int32): gboolean {.
    importc: "gtk_text_view_get_iter_at_position", libprag.}

proc gtk_text_view_get_iter_location*(self: ptr TextView00; iter: ptr TextIter00; location: var gdk.Rectangle00) {.
    importc: "gtk_text_view_get_iter_location", libprag.}

proc getIterLocation*(self: ptr TextView00; iter: ptr TextIter00; location: var gdk.Rectangle00) {.
    importc: "gtk_text_view_get_iter_location", libprag.}

proc iterLocation*(self: ptr TextView00; iter: ptr TextIter00; location: var gdk.Rectangle00) {.
    importc: "gtk_text_view_get_iter_location", libprag.}

proc gtk_text_view_get_justification*(self: ptr TextView00): Justification {.
    importc: "gtk_text_view_get_justification", libprag.}

proc getJustification*(self: TextView): Justification =
  gtk_text_view_get_justification(cast[ptr TextView00](self.impl))

proc justification*(self: TextView): Justification =
  gtk_text_view_get_justification(cast[ptr TextView00](self.impl))

proc gtk_text_view_get_left_margin*(self: ptr TextView00): int32 {.
    importc: "gtk_text_view_get_left_margin", libprag.}

proc getLeftMargin*(self: TextView): int =
  int(gtk_text_view_get_left_margin(cast[ptr TextView00](self.impl)))

proc leftMargin*(self: TextView): int =
  int(gtk_text_view_get_left_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_line_at_y*(self: ptr TextView00; targetIter: var TextIter00; 
    y: int32; lineTop: var int32) {.
    importc: "gtk_text_view_get_line_at_y", libprag.}

proc getLineAtY*(self: ptr TextView00; targetIter: var TextIter00; 
    y: int32; lineTop: var int32) {.
    importc: "gtk_text_view_get_line_at_y", libprag.}

proc lineAtY*(self: ptr TextView00; targetIter: var TextIter00; 
    y: int32; lineTop: var int32) {.
    importc: "gtk_text_view_get_line_at_y", libprag.}

proc gtk_text_view_get_line_yrange*(self: ptr TextView00; iter: ptr TextIter00; y: var int32; 
    height: var int32) {.
    importc: "gtk_text_view_get_line_yrange", libprag.}

proc getLineYrange*(self: TextView; iter: TextIter; y: var int; height: var int) =
  var height_00 = int32(height)
  var y_00 = int32(y)
  gtk_text_view_get_line_yrange(cast[ptr TextView00](self.impl), cast[ptr TextIter00](iter.impl), y_00, height_00)
  height = int(height_00)
  y = int(y_00)

proc lineYrange*(self: TextView; iter: TextIter; y: var int; height: var int) =
  var height_00 = int32(height)
  var y_00 = int32(y)
  gtk_text_view_get_line_yrange(cast[ptr TextView00](self.impl), cast[ptr TextIter00](iter.impl), y_00, height_00)
  height = int(height_00)
  y = int(y_00)

proc gtk_text_view_get_monospace*(self: ptr TextView00): gboolean {.
    importc: "gtk_text_view_get_monospace", libprag.}

proc getMonospace*(self: TextView): bool =
  toBool(gtk_text_view_get_monospace(cast[ptr TextView00](self.impl)))

proc monospace*(self: TextView): bool =
  toBool(gtk_text_view_get_monospace(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_overwrite*(self: ptr TextView00): gboolean {.
    importc: "gtk_text_view_get_overwrite", libprag.}

proc getOverwrite*(self: TextView): bool =
  toBool(gtk_text_view_get_overwrite(cast[ptr TextView00](self.impl)))

proc overwrite*(self: TextView): bool =
  toBool(gtk_text_view_get_overwrite(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_pixels_above_lines*(self: ptr TextView00): int32 {.
    importc: "gtk_text_view_get_pixels_above_lines", libprag.}

proc getPixelsAboveLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_above_lines(cast[ptr TextView00](self.impl)))

proc pixelsAboveLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_above_lines(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_pixels_below_lines*(self: ptr TextView00): int32 {.
    importc: "gtk_text_view_get_pixels_below_lines", libprag.}

proc getPixelsBelowLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_below_lines(cast[ptr TextView00](self.impl)))

proc pixelsBelowLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_below_lines(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_pixels_inside_wrap*(self: ptr TextView00): int32 {.
    importc: "gtk_text_view_get_pixels_inside_wrap", libprag.}

proc getPixelsInsideWrap*(self: TextView): int =
  int(gtk_text_view_get_pixels_inside_wrap(cast[ptr TextView00](self.impl)))

proc pixelsInsideWrap*(self: TextView): int =
  int(gtk_text_view_get_pixels_inside_wrap(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_right_margin*(self: ptr TextView00): int32 {.
    importc: "gtk_text_view_get_right_margin", libprag.}

proc getRightMargin*(self: TextView): int =
  int(gtk_text_view_get_right_margin(cast[ptr TextView00](self.impl)))

proc rightMargin*(self: TextView): int =
  int(gtk_text_view_get_right_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_tabs*(self: ptr TextView00): ptr pango.TabArray00 {.
    importc: "gtk_text_view_get_tabs", libprag.}

proc getTabs*(self: TextView): pango.TabArray =
  new(result)
  result.impl = gtk_text_view_get_tabs(cast[ptr TextView00](self.impl))

proc tabs*(self: TextView): pango.TabArray =
  new(result)
  result.impl = gtk_text_view_get_tabs(cast[ptr TextView00](self.impl))

proc gtk_text_view_get_top_margin*(self: ptr TextView00): int32 {.
    importc: "gtk_text_view_get_top_margin", libprag.}

proc getTopMargin*(self: TextView): int =
  int(gtk_text_view_get_top_margin(cast[ptr TextView00](self.impl)))

proc topMargin*(self: TextView): int =
  int(gtk_text_view_get_top_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_vadjustment*(self: ptr TextView00): ptr Adjustment00 {.
    importc: "gtk_text_view_get_vadjustment", libprag.}

proc getVadjustment*(self: TextView): Adjustment =
  let gobj = gtk_text_view_get_vadjustment(cast[ptr TextView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: TextView): Adjustment =
  let gobj = gtk_text_view_get_vadjustment(cast[ptr TextView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_visible_rect*(self: ptr TextView00; visibleRect: var gdk.Rectangle00) {.
    importc: "gtk_text_view_get_visible_rect", libprag.}

proc getVisibleRect*(self: ptr TextView00; visibleRect: var gdk.Rectangle00) {.
    importc: "gtk_text_view_get_visible_rect", libprag.}

proc visibleRect*(self: ptr TextView00; visibleRect: var gdk.Rectangle00) {.
    importc: "gtk_text_view_get_visible_rect", libprag.}

proc gtk_text_view_get_wrap_mode*(self: ptr TextView00): WrapMode {.
    importc: "gtk_text_view_get_wrap_mode", libprag.}

proc getWrapMode*(self: TextView): WrapMode =
  gtk_text_view_get_wrap_mode(cast[ptr TextView00](self.impl))

proc wrapMode*(self: TextView): WrapMode =
  gtk_text_view_get_wrap_mode(cast[ptr TextView00](self.impl))

proc gtk_text_view_im_context_filter_keypress*(self: ptr TextView00; event: ptr gdk.EventKey00): gboolean {.
    importc: "gtk_text_view_im_context_filter_keypress", libprag.}

proc imContextFilterKeypress*(self: TextView; event: gdk.EventKey): bool =
  toBool(gtk_text_view_im_context_filter_keypress(cast[ptr TextView00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_text_view_move_child*(self: ptr TextView00; child: ptr Widget00; xpos: int32; 
    ypos: int32) {.
    importc: "gtk_text_view_move_child", libprag.}

proc moveChild*(self: TextView; child: Widget; xpos: int; ypos: int) =
  gtk_text_view_move_child(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl), int32(xpos), int32(ypos))

proc gtk_text_view_move_mark_onscreen*(self: ptr TextView00; mark: ptr TextMark00): gboolean {.
    importc: "gtk_text_view_move_mark_onscreen", libprag.}

proc moveMarkOnscreen*(self: TextView; mark: TextMark): bool =
  toBool(gtk_text_view_move_mark_onscreen(cast[ptr TextView00](self.impl), cast[ptr TextMark00](mark.impl)))

proc gtk_text_view_move_visually*(self: ptr TextView00; iter: ptr TextIter00; count: int32): gboolean {.
    importc: "gtk_text_view_move_visually", libprag.}

proc moveVisually*(self: TextView; iter: TextIter; count: int): bool =
  toBool(gtk_text_view_move_visually(cast[ptr TextView00](self.impl), cast[ptr TextIter00](iter.impl), int32(count)))

proc gtk_text_view_place_cursor_onscreen*(self: ptr TextView00): gboolean {.
    importc: "gtk_text_view_place_cursor_onscreen", libprag.}

proc placeCursorOnscreen*(self: TextView): bool =
  toBool(gtk_text_view_place_cursor_onscreen(cast[ptr TextView00](self.impl)))

proc gtk_text_view_reset_cursor_blink*(self: ptr TextView00) {.
    importc: "gtk_text_view_reset_cursor_blink", libprag.}

proc resetCursorBlink*(self: TextView) =
  gtk_text_view_reset_cursor_blink(cast[ptr TextView00](self.impl))

proc gtk_text_view_reset_im_context*(self: ptr TextView00) {.
    importc: "gtk_text_view_reset_im_context", libprag.}

proc resetImContext*(self: TextView) =
  gtk_text_view_reset_im_context(cast[ptr TextView00](self.impl))

proc gtk_text_view_scroll_mark_onscreen*(self: ptr TextView00; mark: ptr TextMark00) {.
    importc: "gtk_text_view_scroll_mark_onscreen", libprag.}

proc scrollMarkOnscreen*(self: TextView; mark: TextMark) =
  gtk_text_view_scroll_mark_onscreen(cast[ptr TextView00](self.impl), cast[ptr TextMark00](mark.impl))

proc gtk_text_view_scroll_to_iter*(self: ptr TextView00; iter: ptr TextIter00; withinMargin: cdouble; 
    useAlign: gboolean; xalign: cdouble; yalign: cdouble): gboolean {.
    importc: "gtk_text_view_scroll_to_iter", libprag.}

proc scrollToIter*(self: TextView; iter: TextIter; withinMargin: cdouble; 
    useAlign: bool; xalign: cdouble; yalign: cdouble): bool =
  toBool(gtk_text_view_scroll_to_iter(cast[ptr TextView00](self.impl), cast[ptr TextIter00](iter.impl), withinMargin, gboolean(useAlign), xalign, yalign))

proc gtk_text_view_scroll_to_mark*(self: ptr TextView00; mark: ptr TextMark00; withinMargin: cdouble; 
    useAlign: gboolean; xalign: cdouble; yalign: cdouble) {.
    importc: "gtk_text_view_scroll_to_mark", libprag.}

proc scrollToMark*(self: TextView; mark: TextMark; withinMargin: cdouble; 
    useAlign: bool; xalign: cdouble; yalign: cdouble) =
  gtk_text_view_scroll_to_mark(cast[ptr TextView00](self.impl), cast[ptr TextMark00](mark.impl), withinMargin, gboolean(useAlign), xalign, yalign)

proc gtk_text_view_set_accepts_tab*(self: ptr TextView00; acceptsTab: gboolean) {.
    importc: "gtk_text_view_set_accepts_tab", libprag.}

proc setAcceptsTab*(self: TextView; acceptsTab: bool) =
  gtk_text_view_set_accepts_tab(cast[ptr TextView00](self.impl), gboolean(acceptsTab))

proc `acceptsTab=`*(self: TextView; acceptsTab: bool) =
  gtk_text_view_set_accepts_tab(cast[ptr TextView00](self.impl), gboolean(acceptsTab))

proc gtk_text_view_set_bottom_margin*(self: ptr TextView00; bottomMargin: int32) {.
    importc: "gtk_text_view_set_bottom_margin", libprag.}

proc setBottomMargin*(self: TextView; bottomMargin: int) =
  gtk_text_view_set_bottom_margin(cast[ptr TextView00](self.impl), int32(bottomMargin))

proc `bottomMargin=`*(self: TextView; bottomMargin: int) =
  gtk_text_view_set_bottom_margin(cast[ptr TextView00](self.impl), int32(bottomMargin))

proc gtk_text_view_set_buffer*(self: ptr TextView00; buffer: ptr TextBuffer00) {.
    importc: "gtk_text_view_set_buffer", libprag.}

proc setBuffer*(self: TextView; buffer: TextBuffer) =
  gtk_text_view_set_buffer(cast[ptr TextView00](self.impl), cast[ptr TextBuffer00](buffer.impl))

proc `buffer=`*(self: TextView; buffer: TextBuffer) =
  gtk_text_view_set_buffer(cast[ptr TextView00](self.impl), cast[ptr TextBuffer00](buffer.impl))

proc gtk_text_view_set_cursor_visible*(self: ptr TextView00; setting: gboolean) {.
    importc: "gtk_text_view_set_cursor_visible", libprag.}

proc setCursorVisible*(self: TextView; setting: bool) =
  gtk_text_view_set_cursor_visible(cast[ptr TextView00](self.impl), gboolean(setting))

proc `cursorVisible=`*(self: TextView; setting: bool) =
  gtk_text_view_set_cursor_visible(cast[ptr TextView00](self.impl), gboolean(setting))

proc gtk_text_view_set_editable*(self: ptr TextView00; setting: gboolean) {.
    importc: "gtk_text_view_set_editable", libprag.}

proc setEditable*(self: TextView; setting: bool) =
  gtk_text_view_set_editable(cast[ptr TextView00](self.impl), gboolean(setting))

proc `editable=`*(self: TextView; setting: bool) =
  gtk_text_view_set_editable(cast[ptr TextView00](self.impl), gboolean(setting))

proc gtk_text_view_set_indent*(self: ptr TextView00; indent: int32) {.
    importc: "gtk_text_view_set_indent", libprag.}

proc setIndent*(self: TextView; indent: int) =
  gtk_text_view_set_indent(cast[ptr TextView00](self.impl), int32(indent))

proc `indent=`*(self: TextView; indent: int) =
  gtk_text_view_set_indent(cast[ptr TextView00](self.impl), int32(indent))

proc gtk_text_view_set_input_hints*(self: ptr TextView00; hints: InputHints) {.
    importc: "gtk_text_view_set_input_hints", libprag.}

proc setInputHints*(self: TextView; hints: InputHints) =
  gtk_text_view_set_input_hints(cast[ptr TextView00](self.impl), hints)

proc `inputHints=`*(self: TextView; hints: InputHints) =
  gtk_text_view_set_input_hints(cast[ptr TextView00](self.impl), hints)

proc gtk_text_view_set_input_purpose*(self: ptr TextView00; purpose: InputPurpose) {.
    importc: "gtk_text_view_set_input_purpose", libprag.}

proc setInputPurpose*(self: TextView; purpose: InputPurpose) =
  gtk_text_view_set_input_purpose(cast[ptr TextView00](self.impl), purpose)

proc `inputPurpose=`*(self: TextView; purpose: InputPurpose) =
  gtk_text_view_set_input_purpose(cast[ptr TextView00](self.impl), purpose)

proc gtk_text_view_set_justification*(self: ptr TextView00; justification: Justification) {.
    importc: "gtk_text_view_set_justification", libprag.}

proc setJustification*(self: TextView; justification: Justification) =
  gtk_text_view_set_justification(cast[ptr TextView00](self.impl), justification)

proc `justification=`*(self: TextView; justification: Justification) =
  gtk_text_view_set_justification(cast[ptr TextView00](self.impl), justification)

proc gtk_text_view_set_left_margin*(self: ptr TextView00; leftMargin: int32) {.
    importc: "gtk_text_view_set_left_margin", libprag.}

proc setLeftMargin*(self: TextView; leftMargin: int) =
  gtk_text_view_set_left_margin(cast[ptr TextView00](self.impl), int32(leftMargin))

proc `leftMargin=`*(self: TextView; leftMargin: int) =
  gtk_text_view_set_left_margin(cast[ptr TextView00](self.impl), int32(leftMargin))

proc gtk_text_view_set_monospace*(self: ptr TextView00; monospace: gboolean) {.
    importc: "gtk_text_view_set_monospace", libprag.}

proc setMonospace*(self: TextView; monospace: bool) =
  gtk_text_view_set_monospace(cast[ptr TextView00](self.impl), gboolean(monospace))

proc `monospace=`*(self: TextView; monospace: bool) =
  gtk_text_view_set_monospace(cast[ptr TextView00](self.impl), gboolean(monospace))

proc gtk_text_view_set_overwrite*(self: ptr TextView00; overwrite: gboolean) {.
    importc: "gtk_text_view_set_overwrite", libprag.}

proc setOverwrite*(self: TextView; overwrite: bool) =
  gtk_text_view_set_overwrite(cast[ptr TextView00](self.impl), gboolean(overwrite))

proc `overwrite=`*(self: TextView; overwrite: bool) =
  gtk_text_view_set_overwrite(cast[ptr TextView00](self.impl), gboolean(overwrite))

proc gtk_text_view_set_pixels_above_lines*(self: ptr TextView00; pixelsAboveLines: int32) {.
    importc: "gtk_text_view_set_pixels_above_lines", libprag.}

proc setPixelsAboveLines*(self: TextView; pixelsAboveLines: int) =
  gtk_text_view_set_pixels_above_lines(cast[ptr TextView00](self.impl), int32(pixelsAboveLines))

proc `pixelsAboveLines=`*(self: TextView; pixelsAboveLines: int) =
  gtk_text_view_set_pixels_above_lines(cast[ptr TextView00](self.impl), int32(pixelsAboveLines))

proc gtk_text_view_set_pixels_below_lines*(self: ptr TextView00; pixelsBelowLines: int32) {.
    importc: "gtk_text_view_set_pixels_below_lines", libprag.}

proc setPixelsBelowLines*(self: TextView; pixelsBelowLines: int) =
  gtk_text_view_set_pixels_below_lines(cast[ptr TextView00](self.impl), int32(pixelsBelowLines))

proc `pixelsBelowLines=`*(self: TextView; pixelsBelowLines: int) =
  gtk_text_view_set_pixels_below_lines(cast[ptr TextView00](self.impl), int32(pixelsBelowLines))

proc gtk_text_view_set_pixels_inside_wrap*(self: ptr TextView00; pixelsInsideWrap: int32) {.
    importc: "gtk_text_view_set_pixels_inside_wrap", libprag.}

proc setPixelsInsideWrap*(self: TextView; pixelsInsideWrap: int) =
  gtk_text_view_set_pixels_inside_wrap(cast[ptr TextView00](self.impl), int32(pixelsInsideWrap))

proc `pixelsInsideWrap=`*(self: TextView; pixelsInsideWrap: int) =
  gtk_text_view_set_pixels_inside_wrap(cast[ptr TextView00](self.impl), int32(pixelsInsideWrap))

proc gtk_text_view_set_right_margin*(self: ptr TextView00; rightMargin: int32) {.
    importc: "gtk_text_view_set_right_margin", libprag.}

proc setRightMargin*(self: TextView; rightMargin: int) =
  gtk_text_view_set_right_margin(cast[ptr TextView00](self.impl), int32(rightMargin))

proc `rightMargin=`*(self: TextView; rightMargin: int) =
  gtk_text_view_set_right_margin(cast[ptr TextView00](self.impl), int32(rightMargin))

proc gtk_text_view_set_tabs*(self: ptr TextView00; tabs: ptr pango.TabArray00) {.
    importc: "gtk_text_view_set_tabs", libprag.}

proc setTabs*(self: TextView; tabs: pango.TabArray) =
  gtk_text_view_set_tabs(cast[ptr TextView00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc `tabs=`*(self: TextView; tabs: pango.TabArray) =
  gtk_text_view_set_tabs(cast[ptr TextView00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc gtk_text_view_set_top_margin*(self: ptr TextView00; topMargin: int32) {.
    importc: "gtk_text_view_set_top_margin", libprag.}

proc setTopMargin*(self: TextView; topMargin: int) =
  gtk_text_view_set_top_margin(cast[ptr TextView00](self.impl), int32(topMargin))

proc `topMargin=`*(self: TextView; topMargin: int) =
  gtk_text_view_set_top_margin(cast[ptr TextView00](self.impl), int32(topMargin))

proc gtk_text_view_set_wrap_mode*(self: ptr TextView00; wrapMode: WrapMode) {.
    importc: "gtk_text_view_set_wrap_mode", libprag.}

proc setWrapMode*(self: TextView; wrapMode: WrapMode) =
  gtk_text_view_set_wrap_mode(cast[ptr TextView00](self.impl), wrapMode)

proc `wrapMode=`*(self: TextView; wrapMode: WrapMode) =
  gtk_text_view_set_wrap_mode(cast[ptr TextView00](self.impl), wrapMode)

proc gtk_text_view_starts_display_line*(self: ptr TextView00; iter: ptr TextIter00): gboolean {.
    importc: "gtk_text_view_starts_display_line", libprag.}

proc startsDisplayLine*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_starts_display_line(cast[ptr TextView00](self.impl), cast[ptr TextIter00](iter.impl)))

type
  TextWindowType* {.size: sizeof(cint), pure.} = enum
    private = 0
    widget = 1
    text = 2
    left = 3
    right = 4
    top = 5
    bottom = 6

proc gtk_text_view_add_child_in_window*(self: ptr TextView00; child: ptr Widget00; whichWindow: TextWindowType; 
    xpos: int32; ypos: int32) {.
    importc: "gtk_text_view_add_child_in_window", libprag.}

proc addChildInWindow*(self: TextView; child: Widget; whichWindow: TextWindowType; 
    xpos: int; ypos: int) =
  gtk_text_view_add_child_in_window(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl), whichWindow, int32(xpos), int32(ypos))

proc gtk_text_view_buffer_to_window_coords*(self: ptr TextView00; win: TextWindowType; bufferX: int32; 
    bufferY: int32; windowX: var int32; windowY: var int32) {.
    importc: "gtk_text_view_buffer_to_window_coords", libprag.}

proc bufferToWindowCoords*(self: TextView; win: TextWindowType; bufferX: int; 
    bufferY: int; windowX: var int; windowY: var int) =
  var windowY_00 = int32(windowY)
  var windowX_00 = int32(windowX)
  gtk_text_view_buffer_to_window_coords(cast[ptr TextView00](self.impl), win, int32(bufferX), int32(bufferY), windowX_00, windowY_00)
  windowY = int(windowY_00)
  windowX = int(windowX_00)

proc gtk_text_view_get_border_window_size*(self: ptr TextView00; `type`: TextWindowType): int32 {.
    importc: "gtk_text_view_get_border_window_size", libprag.}

proc getBorderWindowSize*(self: TextView; `type`: TextWindowType): int =
  int(gtk_text_view_get_border_window_size(cast[ptr TextView00](self.impl), `type`))

proc borderWindowSize*(self: TextView; `type`: TextWindowType): int =
  int(gtk_text_view_get_border_window_size(cast[ptr TextView00](self.impl), `type`))

proc gtk_text_view_get_window*(self: ptr TextView00; win: TextWindowType): ptr gdk.Window00 {.
    importc: "gtk_text_view_get_window", libprag.}

proc getWindow*(self: TextView; win: TextWindowType): gdk.Window =
  let gobj = gtk_text_view_get_window(cast[ptr TextView00](self.impl), win)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc window*(self: TextView; win: TextWindowType): gdk.Window =
  let gobj = gtk_text_view_get_window(cast[ptr TextView00](self.impl), win)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_window_type*(self: ptr TextView00; window: ptr gdk.Window00): TextWindowType {.
    importc: "gtk_text_view_get_window_type", libprag.}

proc getWindowType*(self: TextView; window: gdk.Window): TextWindowType =
  gtk_text_view_get_window_type(cast[ptr TextView00](self.impl), cast[ptr gdk.Window00](window.impl))

proc windowType*(self: TextView; window: gdk.Window): TextWindowType =
  gtk_text_view_get_window_type(cast[ptr TextView00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_text_view_set_border_window_size*(self: ptr TextView00; `type`: TextWindowType; size: int32) {.
    importc: "gtk_text_view_set_border_window_size", libprag.}

proc setBorderWindowSize*(self: TextView; `type`: TextWindowType; size: int) =
  gtk_text_view_set_border_window_size(cast[ptr TextView00](self.impl), `type`, int32(size))

proc gtk_text_view_window_to_buffer_coords*(self: ptr TextView00; win: TextWindowType; windowX: int32; 
    windowY: int32; bufferX: var int32; bufferY: var int32) {.
    importc: "gtk_text_view_window_to_buffer_coords", libprag.}

proc windowToBufferCoords*(self: TextView; win: TextWindowType; windowX: int; 
    windowY: int; bufferX: var int; bufferY: var int) =
  var bufferY_00 = int32(bufferY)
  var bufferX_00 = int32(bufferX)
  gtk_text_view_window_to_buffer_coords(cast[ptr TextView00](self.impl), win, int32(windowX), int32(windowY), bufferX_00, bufferY_00)
  bufferY = int(bufferY_00)
  bufferX = int(bufferX_00)

type
  TextViewAccessiblePrivate00* {.pure.} = object
  TextViewAccessiblePrivate* = ref object
    impl*: ptr TextViewAccessiblePrivate00

type
  TextViewAccessible* = ref object of ContainerAccessible
  TextViewAccessible00* = object of ContainerAccessible00
    priv4: ptr TextViewAccessiblePrivate00

type
  TextViewAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  TextViewAccessibleClass* = ref object
    impl*: ptr TextViewAccessibleClass00

type
  TextViewLayer* {.size: sizeof(cint), pure.} = enum
    below = 0
    above = 1
    belowText = 2
    aboveText = 3

type
  TextViewClass00* {.pure.} = object
    parentClass*: ContainerClass00
    populatePopup*: proc(textView: ptr TextView00; popup: ptr Widget00) {.cdecl.}
    moveCursor*: proc(textView: ptr TextView00; step: MovementStep; count: int32; 
    extendSelection: gboolean) {.cdecl.}
    setAnchor*: proc(textView: ptr TextView00) {.cdecl.}
    insertAtCursor*: proc(textView: ptr TextView00; str: cstring) {.cdecl.}
    deleteFromCursor*: proc(textView: ptr TextView00; `type`: DeleteType; count: int32) {.cdecl.}
    backspace*: proc(textView: ptr TextView00) {.cdecl.}
    cutClipboard*: proc(textView: ptr TextView00) {.cdecl.}
    copyClipboard*: proc(textView: ptr TextView00) {.cdecl.}
    pasteClipboard*: proc(textView: ptr TextView00) {.cdecl.}
    toggleOverwrite*: proc(textView: ptr TextView00) {.cdecl.}
    createBuffer*: pointer
    drawLayer*: proc(textView: ptr TextView00; layer: TextViewLayer; cr: ptr cairo.Context00) {.cdecl.}
    extendSelection*: proc(textView: ptr TextView00; granularity: TextExtendSelection; 
    location: ptr TextIter00; start: ptr TextIter00; `end`: ptr TextIter00): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
  TextViewClass* = ref object
    impl*: ptr TextViewClass00

type
  ThemeEngine00* {.pure.} = object
  ThemeEngine* = ref object
    impl*: ptr ThemeEngine00

type
  ThemingEnginePrivate00* {.pure.} = object
  ThemingEnginePrivate* = ref object
    impl*: ptr ThemingEnginePrivate00

type
  ThemingEngine* = ref object of gobject.Object
  ThemingEngine00* = object of gobject.Object00
    priv1: ptr ThemingEnginePrivate00

proc gtk_theming_engine_load*(name: cstring): ptr ThemingEngine00 {.
    importc: "gtk_theming_engine_load", libprag.}

proc load*(name: string): ThemingEngine =
  let gobj = gtk_theming_engine_load(cstring(name))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ThemingEngine](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_theming_engine_get_background_color*(self: ptr ThemingEngine00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_theming_engine_get_background_color", libprag.}

proc getBackgroundColor*(self: ptr ThemingEngine00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_theming_engine_get_background_color", libprag.}

proc backgroundColor*(self: ptr ThemingEngine00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_theming_engine_get_background_color", libprag.}

proc gtk_theming_engine_get_border*(self: ptr ThemingEngine00; state: StateFlags; border: var Border00) {.
    importc: "gtk_theming_engine_get_border", libprag.}

proc getBorder*(self: ptr ThemingEngine00; state: StateFlags; border: var Border00) {.
    importc: "gtk_theming_engine_get_border", libprag.}

proc border*(self: ptr ThemingEngine00; state: StateFlags; border: var Border00) {.
    importc: "gtk_theming_engine_get_border", libprag.}

proc gtk_theming_engine_get_border_color*(self: ptr ThemingEngine00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_theming_engine_get_border_color", libprag.}

proc getBorderColor*(self: ptr ThemingEngine00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_theming_engine_get_border_color", libprag.}

proc borderColor*(self: ptr ThemingEngine00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_theming_engine_get_border_color", libprag.}

proc gtk_theming_engine_get_color*(self: ptr ThemingEngine00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_theming_engine_get_color", libprag.}

proc getColor*(self: ptr ThemingEngine00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_theming_engine_get_color", libprag.}

proc color*(self: ptr ThemingEngine00; state: StateFlags; color: var gdk.RGBA00) {.
    importc: "gtk_theming_engine_get_color", libprag.}

proc gtk_theming_engine_get_direction*(self: ptr ThemingEngine00): TextDirection {.
    importc: "gtk_theming_engine_get_direction", libprag.}

proc getDirection*(self: ThemingEngine): TextDirection =
  gtk_theming_engine_get_direction(cast[ptr ThemingEngine00](self.impl))

proc direction*(self: ThemingEngine): TextDirection =
  gtk_theming_engine_get_direction(cast[ptr ThemingEngine00](self.impl))

proc gtk_theming_engine_get_font*(self: ptr ThemingEngine00; state: StateFlags): ptr pango.FontDescription00 {.
    importc: "gtk_theming_engine_get_font", libprag.}

proc getFont*(self: ThemingEngine; state: StateFlags): pango.FontDescription =
  new(result)
  result.impl = gtk_theming_engine_get_font(cast[ptr ThemingEngine00](self.impl), state)

proc font*(self: ThemingEngine; state: StateFlags): pango.FontDescription =
  new(result)
  result.impl = gtk_theming_engine_get_font(cast[ptr ThemingEngine00](self.impl), state)

proc gtk_theming_engine_get_junction_sides*(self: ptr ThemingEngine00): JunctionSides {.
    importc: "gtk_theming_engine_get_junction_sides", libprag.}

proc getJunctionSides*(self: ThemingEngine): JunctionSides =
  gtk_theming_engine_get_junction_sides(cast[ptr ThemingEngine00](self.impl))

proc junctionSides*(self: ThemingEngine): JunctionSides =
  gtk_theming_engine_get_junction_sides(cast[ptr ThemingEngine00](self.impl))

proc gtk_theming_engine_get_margin*(self: ptr ThemingEngine00; state: StateFlags; margin: var Border00) {.
    importc: "gtk_theming_engine_get_margin", libprag.}

proc getMargin*(self: ptr ThemingEngine00; state: StateFlags; margin: var Border00) {.
    importc: "gtk_theming_engine_get_margin", libprag.}

proc margin*(self: ptr ThemingEngine00; state: StateFlags; margin: var Border00) {.
    importc: "gtk_theming_engine_get_margin", libprag.}

proc gtk_theming_engine_get_padding*(self: ptr ThemingEngine00; state: StateFlags; padding: var Border00) {.
    importc: "gtk_theming_engine_get_padding", libprag.}

proc getPadding*(self: ptr ThemingEngine00; state: StateFlags; padding: var Border00) {.
    importc: "gtk_theming_engine_get_padding", libprag.}

proc padding*(self: ptr ThemingEngine00; state: StateFlags; padding: var Border00) {.
    importc: "gtk_theming_engine_get_padding", libprag.}

proc gtk_theming_engine_get_path*(self: ptr ThemingEngine00): ptr WidgetPath00 {.
    importc: "gtk_theming_engine_get_path", libprag.}

proc getPath*(self: ThemingEngine): WidgetPath =
  new(result)
  result.impl = gtk_theming_engine_get_path(cast[ptr ThemingEngine00](self.impl))

proc path*(self: ThemingEngine): WidgetPath =
  new(result)
  result.impl = gtk_theming_engine_get_path(cast[ptr ThemingEngine00](self.impl))

proc gtk_theming_engine_get_property*(self: ptr ThemingEngine00; property: cstring; state: StateFlags; 
    value: var gobject.Value00) {.
    importc: "gtk_theming_engine_get_property", libprag.}

proc getProperty*(self: ptr ThemingEngine00; property: cstring; state: StateFlags; 
    value: var gobject.Value00) {.
    importc: "gtk_theming_engine_get_property", libprag.}

proc property*(self: ptr ThemingEngine00; property: cstring; state: StateFlags; 
    value: var gobject.Value00) {.
    importc: "gtk_theming_engine_get_property", libprag.}

proc gtk_theming_engine_get_screen*(self: ptr ThemingEngine00): ptr gdk.Screen00 {.
    importc: "gtk_theming_engine_get_screen", libprag.}

proc getScreen*(self: ThemingEngine): gdk.Screen =
  let gobj = gtk_theming_engine_get_screen(cast[ptr ThemingEngine00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: ThemingEngine): gdk.Screen =
  let gobj = gtk_theming_engine_get_screen(cast[ptr ThemingEngine00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Screen](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_theming_engine_get_state*(self: ptr ThemingEngine00): StateFlags {.
    importc: "gtk_theming_engine_get_state", libprag.}

proc getState*(self: ThemingEngine): StateFlags =
  gtk_theming_engine_get_state(cast[ptr ThemingEngine00](self.impl))

proc state*(self: ThemingEngine): StateFlags =
  gtk_theming_engine_get_state(cast[ptr ThemingEngine00](self.impl))

proc gtk_theming_engine_get_style_property*(self: ptr ThemingEngine00; propertyName: cstring; 
    value: var gobject.Value00) {.
    importc: "gtk_theming_engine_get_style_property", libprag.}

proc getStyleProperty*(self: ptr ThemingEngine00; propertyName: cstring; 
    value: var gobject.Value00) {.
    importc: "gtk_theming_engine_get_style_property", libprag.}

proc styleProperty*(self: ptr ThemingEngine00; propertyName: cstring; 
    value: var gobject.Value00) {.
    importc: "gtk_theming_engine_get_style_property", libprag.}

proc gtk_theming_engine_has_class*(self: ptr ThemingEngine00; styleClass: cstring): gboolean {.
    importc: "gtk_theming_engine_has_class", libprag.}

proc hasClass*(self: ThemingEngine; styleClass: string): bool =
  toBool(gtk_theming_engine_has_class(cast[ptr ThemingEngine00](self.impl), cstring(styleClass)))

proc gtk_theming_engine_has_region*(self: ptr ThemingEngine00; styleRegion: cstring; flags: var RegionFlags): gboolean {.
    importc: "gtk_theming_engine_has_region", libprag.}

proc hasRegion*(self: ThemingEngine; styleRegion: string; flags: var RegionFlags): bool =
  toBool(gtk_theming_engine_has_region(cast[ptr ThemingEngine00](self.impl), cstring(styleRegion), flags))

proc gtk_theming_engine_lookup_color*(self: ptr ThemingEngine00; colorName: cstring; color: var gdk.RGBA00): gboolean {.
    importc: "gtk_theming_engine_lookup_color", libprag.}

proc lookupColor*(self: ptr ThemingEngine00; colorName: cstring; color: var gdk.RGBA00): gboolean {.
    importc: "gtk_theming_engine_lookup_color", libprag.}

proc gtk_theming_engine_state_is_running*(self: ptr ThemingEngine00; state: StateType; progress: var cdouble): gboolean {.
    importc: "gtk_theming_engine_state_is_running", libprag.}

proc stateIsRunning*(self: ThemingEngine; state: StateType; progress: var cdouble): bool =
  toBool(gtk_theming_engine_state_is_running(cast[ptr ThemingEngine00](self.impl), state, progress))

type
  ThemingEngineClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    renderLine*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble) {.cdecl.}
    renderBackground*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.cdecl.}
    renderFrame*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.cdecl.}
    renderFrameGap*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType; xy0Gap: cdouble; 
    xy1Gap: cdouble) {.cdecl.}
    renderExtension*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType) {.cdecl.}
    renderCheck*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.cdecl.}
    renderOption*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.cdecl.}
    renderArrow*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    angle: cdouble; x: cdouble; y: cdouble; size: cdouble) {.cdecl.}
    renderExpander*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.cdecl.}
    renderFocus*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.cdecl.}
    renderLayout*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; layout: ptr pango.Layout00) {.cdecl.}
    renderSlider*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble; orientation: Orientation) {.cdecl.}
    renderHandle*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.cdecl.}
    renderActivity*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.cdecl.}
    renderIconPixbuf*: pointer
    renderIcon*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    pixbuf: ptr gdkpixbuf.Pixbuf00; x: cdouble; y: cdouble) {.cdecl.}
    renderIconSurface*: proc(engine: ptr ThemingEngine00; cr: ptr cairo.Context00; 
    surface: ptr cairo.Surface00; x: cdouble; y: cdouble) {.cdecl.}
    padding*: array[14, pointer]
  ThemingEngineClass* = ref object
    impl*: ptr ThemingEngineClass00

type
  TickCallback* = proc (widget: ptr Widget00; frameClock: ptr gdk.FrameClock00; 
    userData: pointer): gboolean {.cdecl.}

proc gtk_widget_add_tick_callback*(self: ptr Widget00; callback: TickCallback; userData: pointer; 
    notify: DestroyNotify): uint32 {.
    importc: "gtk_widget_add_tick_callback", libprag.}

proc addTickCallback*(self: Widget; callback: TickCallback; userData: pointer; 
    notify: DestroyNotify): int =
  int(gtk_widget_add_tick_callback(cast[ptr Widget00](self.impl), callback, userData, notify))

type
  ToggleActionEntry00* {.pure.} = object
    name*: cstring
    stockId*: cstring
    label*: cstring
    accelerator*: cstring
    tooltip*: cstring
    callback*: Callback
    isActive*: gboolean
  ToggleActionEntry* = ref object
    impl*: ptr ToggleActionEntry00

type
  ToolItemGroupPrivate00* {.pure.} = object
  ToolItemGroupPrivate* = ref object
    impl*: ptr ToolItemGroupPrivate00

type
  ToolItemGroup* = ref object of Container
  ToolItemGroup00* = object of Container00
    priv3: ptr ToolItemGroupPrivate00

proc gtk_tool_item_group_new*(label: cstring): ptr ToolItemGroup00 {.
    importc: "gtk_tool_item_group_new", libprag.}

proc newToolItemGroup*(label: string): ToolItemGroup =
  new(result, finalizeGObject)
  result.impl = gtk_tool_item_group_new(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolItemGroup*[T](result: var T; label: string) =
  assert(result is ToolItemGroup)
  new(result, finalizeGObject)
  result.impl = gtk_tool_item_group_new(cstring(label))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_group_get_collapsed*(self: ptr ToolItemGroup00): gboolean {.
    importc: "gtk_tool_item_group_get_collapsed", libprag.}

proc getCollapsed*(self: ToolItemGroup): bool =
  toBool(gtk_tool_item_group_get_collapsed(cast[ptr ToolItemGroup00](self.impl)))

proc collapsed*(self: ToolItemGroup): bool =
  toBool(gtk_tool_item_group_get_collapsed(cast[ptr ToolItemGroup00](self.impl)))

proc gtk_tool_item_group_get_drop_item*(self: ptr ToolItemGroup00; x: int32; y: int32): ptr ToolItem00 {.
    importc: "gtk_tool_item_group_get_drop_item", libprag.}

proc getDropItem*(self: ToolItemGroup; x: int; y: int): ToolItem =
  let gobj = gtk_tool_item_group_get_drop_item(cast[ptr ToolItemGroup00](self.impl), int32(x), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItem](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc dropItem*(self: ToolItemGroup; x: int; y: int): ToolItem =
  let gobj = gtk_tool_item_group_get_drop_item(cast[ptr ToolItemGroup00](self.impl), int32(x), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItem](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_group_get_ellipsize*(self: ptr ToolItemGroup00): pango.EllipsizeMode {.
    importc: "gtk_tool_item_group_get_ellipsize", libprag.}

proc getEllipsize*(self: ToolItemGroup): pango.EllipsizeMode =
  gtk_tool_item_group_get_ellipsize(cast[ptr ToolItemGroup00](self.impl))

proc ellipsize*(self: ToolItemGroup): pango.EllipsizeMode =
  gtk_tool_item_group_get_ellipsize(cast[ptr ToolItemGroup00](self.impl))

proc gtk_tool_item_group_get_header_relief*(self: ptr ToolItemGroup00): ReliefStyle {.
    importc: "gtk_tool_item_group_get_header_relief", libprag.}

proc getHeaderRelief*(self: ToolItemGroup): ReliefStyle =
  gtk_tool_item_group_get_header_relief(cast[ptr ToolItemGroup00](self.impl))

proc headerRelief*(self: ToolItemGroup): ReliefStyle =
  gtk_tool_item_group_get_header_relief(cast[ptr ToolItemGroup00](self.impl))

proc gtk_tool_item_group_get_item_position*(self: ptr ToolItemGroup00; item: ptr ToolItem00): int32 {.
    importc: "gtk_tool_item_group_get_item_position", libprag.}

proc getItemPosition*(self: ToolItemGroup; item: ToolItem): int =
  int(gtk_tool_item_group_get_item_position(cast[ptr ToolItemGroup00](self.impl), cast[ptr ToolItem00](item.impl)))

proc itemPosition*(self: ToolItemGroup; item: ToolItem): int =
  int(gtk_tool_item_group_get_item_position(cast[ptr ToolItemGroup00](self.impl), cast[ptr ToolItem00](item.impl)))

proc gtk_tool_item_group_get_label*(self: ptr ToolItemGroup00): cstring {.
    importc: "gtk_tool_item_group_get_label", libprag.}

proc getLabel*(self: ToolItemGroup): string =
  let resul0 = gtk_tool_item_group_get_label(cast[ptr ToolItemGroup00](self.impl))
  result = $resul0

proc label*(self: ToolItemGroup): string =
  let resul0 = gtk_tool_item_group_get_label(cast[ptr ToolItemGroup00](self.impl))
  result = $resul0

proc gtk_tool_item_group_get_label_widget*(self: ptr ToolItemGroup00): ptr Widget00 {.
    importc: "gtk_tool_item_group_get_label_widget", libprag.}

proc getLabelWidget*(self: ToolItemGroup): Widget =
  let gobj = gtk_tool_item_group_get_label_widget(cast[ptr ToolItemGroup00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: ToolItemGroup): Widget =
  let gobj = gtk_tool_item_group_get_label_widget(cast[ptr ToolItemGroup00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_group_get_n_items*(self: ptr ToolItemGroup00): uint32 {.
    importc: "gtk_tool_item_group_get_n_items", libprag.}

proc getNItems*(self: ToolItemGroup): int =
  int(gtk_tool_item_group_get_n_items(cast[ptr ToolItemGroup00](self.impl)))

proc nItems*(self: ToolItemGroup): int =
  int(gtk_tool_item_group_get_n_items(cast[ptr ToolItemGroup00](self.impl)))

proc gtk_tool_item_group_get_nth_item*(self: ptr ToolItemGroup00; index: uint32): ptr ToolItem00 {.
    importc: "gtk_tool_item_group_get_nth_item", libprag.}

proc getNthItem*(self: ToolItemGroup; index: int): ToolItem =
  let gobj = gtk_tool_item_group_get_nth_item(cast[ptr ToolItemGroup00](self.impl), uint32(index))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItem](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc nthItem*(self: ToolItemGroup; index: int): ToolItem =
  let gobj = gtk_tool_item_group_get_nth_item(cast[ptr ToolItemGroup00](self.impl), uint32(index))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItem](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_group_insert*(self: ptr ToolItemGroup00; item: ptr ToolItem00; position: int32) {.
    importc: "gtk_tool_item_group_insert", libprag.}

proc insert*(self: ToolItemGroup; item: ToolItem; position: int) =
  gtk_tool_item_group_insert(cast[ptr ToolItemGroup00](self.impl), cast[ptr ToolItem00](item.impl), int32(position))

proc gtk_tool_item_group_set_collapsed*(self: ptr ToolItemGroup00; collapsed: gboolean) {.
    importc: "gtk_tool_item_group_set_collapsed", libprag.}

proc setCollapsed*(self: ToolItemGroup; collapsed: bool) =
  gtk_tool_item_group_set_collapsed(cast[ptr ToolItemGroup00](self.impl), gboolean(collapsed))

proc `collapsed=`*(self: ToolItemGroup; collapsed: bool) =
  gtk_tool_item_group_set_collapsed(cast[ptr ToolItemGroup00](self.impl), gboolean(collapsed))

proc gtk_tool_item_group_set_ellipsize*(self: ptr ToolItemGroup00; ellipsize: pango.EllipsizeMode) {.
    importc: "gtk_tool_item_group_set_ellipsize", libprag.}

proc setEllipsize*(self: ToolItemGroup; ellipsize: pango.EllipsizeMode) =
  gtk_tool_item_group_set_ellipsize(cast[ptr ToolItemGroup00](self.impl), ellipsize)

proc `ellipsize=`*(self: ToolItemGroup; ellipsize: pango.EllipsizeMode) =
  gtk_tool_item_group_set_ellipsize(cast[ptr ToolItemGroup00](self.impl), ellipsize)

proc gtk_tool_item_group_set_header_relief*(self: ptr ToolItemGroup00; style: ReliefStyle) {.
    importc: "gtk_tool_item_group_set_header_relief", libprag.}

proc setHeaderRelief*(self: ToolItemGroup; style: ReliefStyle) =
  gtk_tool_item_group_set_header_relief(cast[ptr ToolItemGroup00](self.impl), style)

proc `headerRelief=`*(self: ToolItemGroup; style: ReliefStyle) =
  gtk_tool_item_group_set_header_relief(cast[ptr ToolItemGroup00](self.impl), style)

proc gtk_tool_item_group_set_item_position*(self: ptr ToolItemGroup00; item: ptr ToolItem00; position: int32) {.
    importc: "gtk_tool_item_group_set_item_position", libprag.}

proc setItemPosition*(self: ToolItemGroup; item: ToolItem; position: int) =
  gtk_tool_item_group_set_item_position(cast[ptr ToolItemGroup00](self.impl), cast[ptr ToolItem00](item.impl), int32(position))

proc gtk_tool_item_group_set_label*(self: ptr ToolItemGroup00; label: cstring) {.
    importc: "gtk_tool_item_group_set_label", libprag.}

proc setLabel*(self: ToolItemGroup; label: string) =
  gtk_tool_item_group_set_label(cast[ptr ToolItemGroup00](self.impl), cstring(label))

proc `label=`*(self: ToolItemGroup; label: string) =
  gtk_tool_item_group_set_label(cast[ptr ToolItemGroup00](self.impl), cstring(label))

proc gtk_tool_item_group_set_label_widget*(self: ptr ToolItemGroup00; labelWidget: ptr Widget00) {.
    importc: "gtk_tool_item_group_set_label_widget", libprag.}

proc setLabelWidget*(self: ToolItemGroup; labelWidget: Widget) =
  gtk_tool_item_group_set_label_widget(cast[ptr ToolItemGroup00](self.impl), cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: ToolItemGroup; labelWidget: Widget) =
  gtk_tool_item_group_set_label_widget(cast[ptr ToolItemGroup00](self.impl), cast[ptr Widget00](labelWidget.impl))

type
  ToolItemGroupClass00* {.pure.} = object
    parentClass*: ContainerClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ToolItemGroupClass* = ref object
    impl*: ptr ToolItemGroupClass00

type
  ToolPalettePrivate00* {.pure.} = object
  ToolPalettePrivate* = ref object
    impl*: ptr ToolPalettePrivate00

type
  ToolPalette* = ref object of Container
  ToolPalette00* = object of Container00
    priv3: ptr ToolPalettePrivate00

proc gtk_tool_palette_new*(): ptr ToolPalette00 {.
    importc: "gtk_tool_palette_new", libprag.}

proc newToolPalette*(): ToolPalette =
  new(result, finalizeGObject)
  result.impl = gtk_tool_palette_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolPalette*[T](result: var T) =
  assert(result is ToolPalette)
  new(result, finalizeGObject)
  result.impl = gtk_tool_palette_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_drag_target_group*(): ptr TargetEntry00 {.
    importc: "gtk_tool_palette_get_drag_target_group", libprag.}

proc getDragTargetGroup*(): TargetEntry =
  new(result)
  result.impl = gtk_tool_palette_get_drag_target_group()

proc dragTargetGroup*(): TargetEntry =
  new(result)
  result.impl = gtk_tool_palette_get_drag_target_group()

proc gtk_tool_palette_get_drag_target_item*(): ptr TargetEntry00 {.
    importc: "gtk_tool_palette_get_drag_target_item", libprag.}

proc getDragTargetItem*(): TargetEntry =
  new(result)
  result.impl = gtk_tool_palette_get_drag_target_item()

proc dragTargetItem*(): TargetEntry =
  new(result)
  result.impl = gtk_tool_palette_get_drag_target_item()

proc gtk_tool_palette_get_drag_item*(self: ptr ToolPalette00; selection: ptr SelectionData00): ptr Widget00 {.
    importc: "gtk_tool_palette_get_drag_item", libprag.}

proc getDragItem*(self: ToolPalette; selection: SelectionData): Widget =
  let gobj = gtk_tool_palette_get_drag_item(cast[ptr ToolPalette00](self.impl), cast[ptr SelectionData00](selection.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc dragItem*(self: ToolPalette; selection: SelectionData): Widget =
  let gobj = gtk_tool_palette_get_drag_item(cast[ptr ToolPalette00](self.impl), cast[ptr SelectionData00](selection.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_drop_group*(self: ptr ToolPalette00; x: int32; y: int32): ptr ToolItemGroup00 {.
    importc: "gtk_tool_palette_get_drop_group", libprag.}

proc getDropGroup*(self: ToolPalette; x: int; y: int): ToolItemGroup =
  let gobj = gtk_tool_palette_get_drop_group(cast[ptr ToolPalette00](self.impl), int32(x), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItemGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc dropGroup*(self: ToolPalette; x: int; y: int): ToolItemGroup =
  let gobj = gtk_tool_palette_get_drop_group(cast[ptr ToolPalette00](self.impl), int32(x), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItemGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_drop_item*(self: ptr ToolPalette00; x: int32; y: int32): ptr ToolItem00 {.
    importc: "gtk_tool_palette_get_drop_item", libprag.}

proc getDropItem*(self: ToolPalette; x: int; y: int): ToolItem =
  let gobj = gtk_tool_palette_get_drop_item(cast[ptr ToolPalette00](self.impl), int32(x), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItem](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc dropItem*(self: ToolPalette; x: int; y: int): ToolItem =
  let gobj = gtk_tool_palette_get_drop_item(cast[ptr ToolPalette00](self.impl), int32(x), int32(y))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItem](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_exclusive*(self: ptr ToolPalette00; group: ptr ToolItemGroup00): gboolean {.
    importc: "gtk_tool_palette_get_exclusive", libprag.}

proc getExclusive*(self: ToolPalette; group: ToolItemGroup): bool =
  toBool(gtk_tool_palette_get_exclusive(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl)))

proc exclusive*(self: ToolPalette; group: ToolItemGroup): bool =
  toBool(gtk_tool_palette_get_exclusive(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl)))

proc gtk_tool_palette_get_expand*(self: ptr ToolPalette00; group: ptr ToolItemGroup00): gboolean {.
    importc: "gtk_tool_palette_get_expand", libprag.}

proc getExpand*(self: ToolPalette; group: ToolItemGroup): bool =
  toBool(gtk_tool_palette_get_expand(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl)))

proc expand*(self: ToolPalette; group: ToolItemGroup): bool =
  toBool(gtk_tool_palette_get_expand(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl)))

proc gtk_tool_palette_get_group_position*(self: ptr ToolPalette00; group: ptr ToolItemGroup00): int32 {.
    importc: "gtk_tool_palette_get_group_position", libprag.}

proc getGroupPosition*(self: ToolPalette; group: ToolItemGroup): int =
  int(gtk_tool_palette_get_group_position(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl)))

proc groupPosition*(self: ToolPalette; group: ToolItemGroup): int =
  int(gtk_tool_palette_get_group_position(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl)))

proc gtk_tool_palette_get_hadjustment*(self: ptr ToolPalette00): ptr Adjustment00 {.
    importc: "gtk_tool_palette_get_hadjustment", libprag.}

proc getHadjustment*(self: ToolPalette): Adjustment =
  let gobj = gtk_tool_palette_get_hadjustment(cast[ptr ToolPalette00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: ToolPalette): Adjustment =
  let gobj = gtk_tool_palette_get_hadjustment(cast[ptr ToolPalette00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_icon_size*(self: ptr ToolPalette00): int32 {.
    importc: "gtk_tool_palette_get_icon_size", libprag.}

proc getIconSize*(self: ToolPalette): int =
  int(gtk_tool_palette_get_icon_size(cast[ptr ToolPalette00](self.impl)))

proc iconSize*(self: ToolPalette): int =
  int(gtk_tool_palette_get_icon_size(cast[ptr ToolPalette00](self.impl)))

proc gtk_tool_palette_get_style*(self: ptr ToolPalette00): ToolbarStyle {.
    importc: "gtk_tool_palette_get_style", libprag.}

proc getStyle*(self: ToolPalette): ToolbarStyle =
  gtk_tool_palette_get_style(cast[ptr ToolPalette00](self.impl))

proc style*(self: ToolPalette): ToolbarStyle =
  gtk_tool_palette_get_style(cast[ptr ToolPalette00](self.impl))

proc gtk_tool_palette_get_vadjustment*(self: ptr ToolPalette00): ptr Adjustment00 {.
    importc: "gtk_tool_palette_get_vadjustment", libprag.}

proc getVadjustment*(self: ToolPalette): Adjustment =
  let gobj = gtk_tool_palette_get_vadjustment(cast[ptr ToolPalette00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: ToolPalette): Adjustment =
  let gobj = gtk_tool_palette_get_vadjustment(cast[ptr ToolPalette00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_set_exclusive*(self: ptr ToolPalette00; group: ptr ToolItemGroup00; 
    exclusive: gboolean) {.
    importc: "gtk_tool_palette_set_exclusive", libprag.}

proc setExclusive*(self: ToolPalette; group: ToolItemGroup; exclusive: bool) =
  gtk_tool_palette_set_exclusive(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl), gboolean(exclusive))

proc gtk_tool_palette_set_expand*(self: ptr ToolPalette00; group: ptr ToolItemGroup00; 
    expand: gboolean) {.
    importc: "gtk_tool_palette_set_expand", libprag.}

proc setExpand*(self: ToolPalette; group: ToolItemGroup; expand: bool) =
  gtk_tool_palette_set_expand(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl), gboolean(expand))

proc gtk_tool_palette_set_group_position*(self: ptr ToolPalette00; group: ptr ToolItemGroup00; 
    position: int32) {.
    importc: "gtk_tool_palette_set_group_position", libprag.}

proc setGroupPosition*(self: ToolPalette; group: ToolItemGroup; position: int) =
  gtk_tool_palette_set_group_position(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl), int32(position))

proc gtk_tool_palette_set_icon_size*(self: ptr ToolPalette00; iconSize: int32) {.
    importc: "gtk_tool_palette_set_icon_size", libprag.}

proc setIconSize*(self: ToolPalette; iconSize: int) =
  gtk_tool_palette_set_icon_size(cast[ptr ToolPalette00](self.impl), int32(iconSize))

proc `iconSize=`*(self: ToolPalette; iconSize: int) =
  gtk_tool_palette_set_icon_size(cast[ptr ToolPalette00](self.impl), int32(iconSize))

proc gtk_tool_palette_set_style*(self: ptr ToolPalette00; style: ToolbarStyle) {.
    importc: "gtk_tool_palette_set_style", libprag.}

proc setStyle*(self: ToolPalette; style: ToolbarStyle) =
  gtk_tool_palette_set_style(cast[ptr ToolPalette00](self.impl), style)

proc `style=`*(self: ToolPalette; style: ToolbarStyle) =
  gtk_tool_palette_set_style(cast[ptr ToolPalette00](self.impl), style)

proc gtk_tool_palette_unset_icon_size*(self: ptr ToolPalette00) {.
    importc: "gtk_tool_palette_unset_icon_size", libprag.}

proc unsetIconSize*(self: ToolPalette) =
  gtk_tool_palette_unset_icon_size(cast[ptr ToolPalette00](self.impl))

proc gtk_tool_palette_unset_style*(self: ptr ToolPalette00) {.
    importc: "gtk_tool_palette_unset_style", libprag.}

proc unsetStyle*(self: ToolPalette) =
  gtk_tool_palette_unset_style(cast[ptr ToolPalette00](self.impl))

type
  ToolPaletteDragTargets* {.size: sizeof(cint), pure.} = enum
    items = 1
    groups = 2

proc gtk_tool_palette_add_drag_dest*(self: ptr ToolPalette00; widget: ptr Widget00; flags: DestDefaults; 
    targets: ToolPaletteDragTargets; actions: gdk.DragAction) {.
    importc: "gtk_tool_palette_add_drag_dest", libprag.}

proc addDragDest*(self: ToolPalette; widget: Widget; flags: DestDefaults; 
    targets: ToolPaletteDragTargets; actions: gdk.DragAction) =
  gtk_tool_palette_add_drag_dest(cast[ptr ToolPalette00](self.impl), cast[ptr Widget00](widget.impl), flags, targets, actions)

proc gtk_tool_palette_set_drag_source*(self: ptr ToolPalette00; targets: ToolPaletteDragTargets) {.
    importc: "gtk_tool_palette_set_drag_source", libprag.}

proc setDragSource*(self: ToolPalette; targets: ToolPaletteDragTargets) =
  gtk_tool_palette_set_drag_source(cast[ptr ToolPalette00](self.impl), targets)

proc `dragSource=`*(self: ToolPalette; targets: ToolPaletteDragTargets) =
  gtk_tool_palette_set_drag_source(cast[ptr ToolPalette00](self.impl), targets)

type
  ToolPaletteClass00* {.pure.} = object
    parentClass*: ContainerClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ToolPaletteClass* = ref object
    impl*: ptr ToolPaletteClass00

type
  ToolShell00* {.pure.} = object
  ToolShell* = ref object
    impl*: ptr ToolShell00

proc gtk_tool_shell_get_ellipsize_mode*(self: ptr ToolShell00): pango.EllipsizeMode {.
    importc: "gtk_tool_shell_get_ellipsize_mode", libprag.}

proc getEllipsizeMode*(self: ToolShell): pango.EllipsizeMode =
  gtk_tool_shell_get_ellipsize_mode(cast[ptr ToolShell00](self.impl))

proc ellipsizeMode*(self: ToolShell): pango.EllipsizeMode =
  gtk_tool_shell_get_ellipsize_mode(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_icon_size*(self: ptr ToolShell00): int32 {.
    importc: "gtk_tool_shell_get_icon_size", libprag.}

proc getIconSize*(self: ToolShell): int =
  int(gtk_tool_shell_get_icon_size(cast[ptr ToolShell00](self.impl)))

proc iconSize*(self: ToolShell): int =
  int(gtk_tool_shell_get_icon_size(cast[ptr ToolShell00](self.impl)))

proc gtk_tool_shell_get_orientation*(self: ptr ToolShell00): Orientation {.
    importc: "gtk_tool_shell_get_orientation", libprag.}

proc getOrientation*(self: ToolShell): Orientation =
  gtk_tool_shell_get_orientation(cast[ptr ToolShell00](self.impl))

proc orientation*(self: ToolShell): Orientation =
  gtk_tool_shell_get_orientation(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_relief_style*(self: ptr ToolShell00): ReliefStyle {.
    importc: "gtk_tool_shell_get_relief_style", libprag.}

proc getReliefStyle*(self: ToolShell): ReliefStyle =
  gtk_tool_shell_get_relief_style(cast[ptr ToolShell00](self.impl))

proc reliefStyle*(self: ToolShell): ReliefStyle =
  gtk_tool_shell_get_relief_style(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_style*(self: ptr ToolShell00): ToolbarStyle {.
    importc: "gtk_tool_shell_get_style", libprag.}

proc getStyle*(self: ToolShell): ToolbarStyle =
  gtk_tool_shell_get_style(cast[ptr ToolShell00](self.impl))

proc style*(self: ToolShell): ToolbarStyle =
  gtk_tool_shell_get_style(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_text_alignment*(self: ptr ToolShell00): cfloat {.
    importc: "gtk_tool_shell_get_text_alignment", libprag.}

proc getTextAlignment*(self: ToolShell): cfloat =
  gtk_tool_shell_get_text_alignment(cast[ptr ToolShell00](self.impl))

proc textAlignment*(self: ToolShell): cfloat =
  gtk_tool_shell_get_text_alignment(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_text_orientation*(self: ptr ToolShell00): Orientation {.
    importc: "gtk_tool_shell_get_text_orientation", libprag.}

proc getTextOrientation*(self: ToolShell): Orientation =
  gtk_tool_shell_get_text_orientation(cast[ptr ToolShell00](self.impl))

proc textOrientation*(self: ToolShell): Orientation =
  gtk_tool_shell_get_text_orientation(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_text_size_group*(self: ptr ToolShell00): ptr SizeGroup00 {.
    importc: "gtk_tool_shell_get_text_size_group", libprag.}

proc getTextSizeGroup*(self: ToolShell): SizeGroup =
  let gobj = gtk_tool_shell_get_text_size_group(cast[ptr ToolShell00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[SizeGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc textSizeGroup*(self: ToolShell): SizeGroup =
  let gobj = gtk_tool_shell_get_text_size_group(cast[ptr ToolShell00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[SizeGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_shell_rebuild_menu*(self: ptr ToolShell00) {.
    importc: "gtk_tool_shell_rebuild_menu", libprag.}

proc rebuildMenu*(self: ToolShell) =
  gtk_tool_shell_rebuild_menu(cast[ptr ToolShell00](self.impl))

type
  ToolShellIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    getIconSize*: proc(shell: ptr ToolShell00): IconSize {.cdecl.}
    getOrientation*: proc(shell: ptr ToolShell00): Orientation {.cdecl.}
    getStyle*: proc(shell: ptr ToolShell00): ToolbarStyle {.cdecl.}
    getReliefStyle*: proc(shell: ptr ToolShell00): ReliefStyle {.cdecl.}
    rebuildMenu*: proc(shell: ptr ToolShell00) {.cdecl.}
    getTextOrientation*: proc(shell: ptr ToolShell00): Orientation {.cdecl.}
    getTextAlignment*: proc(shell: ptr ToolShell00): cfloat {.cdecl.}
    getEllipsizeMode*: proc(shell: ptr ToolShell00): pango.EllipsizeMode {.cdecl.}
    getTextSizeGroup*: proc(shell: ptr ToolShell00): ptr SizeGroup00 {.cdecl.}
  ToolShellIface* = ref object
    impl*: ptr ToolShellIface00

type
  ToolbarPrivate00* {.pure.} = object
  ToolbarPrivate* = ref object
    impl*: ptr ToolbarPrivate00

type
  Toolbar* = ref object of Container
  Toolbar00* = object of Container00
    priv3: ptr ToolbarPrivate00

proc scFocusHomeOrEnd*(self: Toolbar;  p: proc (self: ptr gobject.Object00; focusHome: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "focus-home-or-end", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scOrientationChanged*(self: Toolbar;  p: proc (self: ptr gobject.Object00; orientation: Orientation; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "orientation-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPopupContextMenu*(self: Toolbar;  p: proc (self: ptr gobject.Object00; x: int32; y: int32; button: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "popup-context-menu", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStyleChanged*(self: Toolbar;  p: proc (self: ptr gobject.Object00; style: ToolbarStyle; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "style-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_toolbar_new*(): ptr Toolbar00 {.
    importc: "gtk_toolbar_new", libprag.}

proc newToolbar*(): Toolbar =
  new(result, finalizeGObject)
  result.impl = gtk_toolbar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolbar*[T](result: var T) =
  assert(result is Toolbar)
  new(result, finalizeGObject)
  result.impl = gtk_toolbar_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toolbar_get_drop_index*(self: ptr Toolbar00; x: int32; y: int32): int32 {.
    importc: "gtk_toolbar_get_drop_index", libprag.}

proc getDropIndex*(self: Toolbar; x: int; y: int): int =
  int(gtk_toolbar_get_drop_index(cast[ptr Toolbar00](self.impl), int32(x), int32(y)))

proc dropIndex*(self: Toolbar; x: int; y: int): int =
  int(gtk_toolbar_get_drop_index(cast[ptr Toolbar00](self.impl), int32(x), int32(y)))

proc gtk_toolbar_get_icon_size*(self: ptr Toolbar00): IconSize {.
    importc: "gtk_toolbar_get_icon_size", libprag.}

proc getIconSize*(self: Toolbar): IconSize =
  gtk_toolbar_get_icon_size(cast[ptr Toolbar00](self.impl))

proc iconSize*(self: Toolbar): IconSize =
  gtk_toolbar_get_icon_size(cast[ptr Toolbar00](self.impl))

proc gtk_toolbar_get_item_index*(self: ptr Toolbar00; item: ptr ToolItem00): int32 {.
    importc: "gtk_toolbar_get_item_index", libprag.}

proc getItemIndex*(self: Toolbar; item: ToolItem): int =
  int(gtk_toolbar_get_item_index(cast[ptr Toolbar00](self.impl), cast[ptr ToolItem00](item.impl)))

proc itemIndex*(self: Toolbar; item: ToolItem): int =
  int(gtk_toolbar_get_item_index(cast[ptr Toolbar00](self.impl), cast[ptr ToolItem00](item.impl)))

proc gtk_toolbar_get_n_items*(self: ptr Toolbar00): int32 {.
    importc: "gtk_toolbar_get_n_items", libprag.}

proc getNItems*(self: Toolbar): int =
  int(gtk_toolbar_get_n_items(cast[ptr Toolbar00](self.impl)))

proc nItems*(self: Toolbar): int =
  int(gtk_toolbar_get_n_items(cast[ptr Toolbar00](self.impl)))

proc gtk_toolbar_get_nth_item*(self: ptr Toolbar00; n: int32): ptr ToolItem00 {.
    importc: "gtk_toolbar_get_nth_item", libprag.}

proc getNthItem*(self: Toolbar; n: int): ToolItem =
  let gobj = gtk_toolbar_get_nth_item(cast[ptr Toolbar00](self.impl), int32(n))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItem](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc nthItem*(self: Toolbar; n: int): ToolItem =
  let gobj = gtk_toolbar_get_nth_item(cast[ptr Toolbar00](self.impl), int32(n))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[ToolItem](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toolbar_get_relief_style*(self: ptr Toolbar00): ReliefStyle {.
    importc: "gtk_toolbar_get_relief_style", libprag.}

proc getReliefStyle*(self: Toolbar): ReliefStyle =
  gtk_toolbar_get_relief_style(cast[ptr Toolbar00](self.impl))

proc reliefStyle*(self: Toolbar): ReliefStyle =
  gtk_toolbar_get_relief_style(cast[ptr Toolbar00](self.impl))

proc gtk_toolbar_get_show_arrow*(self: ptr Toolbar00): gboolean {.
    importc: "gtk_toolbar_get_show_arrow", libprag.}

proc getShowArrow*(self: Toolbar): bool =
  toBool(gtk_toolbar_get_show_arrow(cast[ptr Toolbar00](self.impl)))

proc showArrow*(self: Toolbar): bool =
  toBool(gtk_toolbar_get_show_arrow(cast[ptr Toolbar00](self.impl)))

proc gtk_toolbar_get_style*(self: ptr Toolbar00): ToolbarStyle {.
    importc: "gtk_toolbar_get_style", libprag.}

proc getStyle*(self: Toolbar): ToolbarStyle =
  gtk_toolbar_get_style(cast[ptr Toolbar00](self.impl))

proc style*(self: Toolbar): ToolbarStyle =
  gtk_toolbar_get_style(cast[ptr Toolbar00](self.impl))

proc gtk_toolbar_insert*(self: ptr Toolbar00; item: ptr ToolItem00; pos: int32) {.
    importc: "gtk_toolbar_insert", libprag.}

proc insert*(self: Toolbar; item: ToolItem; pos: int) =
  gtk_toolbar_insert(cast[ptr Toolbar00](self.impl), cast[ptr ToolItem00](item.impl), int32(pos))

proc gtk_toolbar_set_drop_highlight_item*(self: ptr Toolbar00; toolItem: ptr ToolItem00; index: int32) {.
    importc: "gtk_toolbar_set_drop_highlight_item", libprag.}

proc setDropHighlightItem*(self: Toolbar; toolItem: ToolItem; index: int) =
  gtk_toolbar_set_drop_highlight_item(cast[ptr Toolbar00](self.impl), cast[ptr ToolItem00](toolItem.impl), int32(index))

proc gtk_toolbar_set_icon_size*(self: ptr Toolbar00; iconSize: IconSize) {.
    importc: "gtk_toolbar_set_icon_size", libprag.}

proc setIconSize*(self: Toolbar; iconSize: IconSize) =
  gtk_toolbar_set_icon_size(cast[ptr Toolbar00](self.impl), iconSize)

proc `iconSize=`*(self: Toolbar; iconSize: IconSize) =
  gtk_toolbar_set_icon_size(cast[ptr Toolbar00](self.impl), iconSize)

proc gtk_toolbar_set_show_arrow*(self: ptr Toolbar00; showArrow: gboolean) {.
    importc: "gtk_toolbar_set_show_arrow", libprag.}

proc setShowArrow*(self: Toolbar; showArrow: bool) =
  gtk_toolbar_set_show_arrow(cast[ptr Toolbar00](self.impl), gboolean(showArrow))

proc `showArrow=`*(self: Toolbar; showArrow: bool) =
  gtk_toolbar_set_show_arrow(cast[ptr Toolbar00](self.impl), gboolean(showArrow))

proc gtk_toolbar_set_style*(self: ptr Toolbar00; style: ToolbarStyle) {.
    importc: "gtk_toolbar_set_style", libprag.}

proc setStyle*(self: Toolbar; style: ToolbarStyle) =
  gtk_toolbar_set_style(cast[ptr Toolbar00](self.impl), style)

proc `style=`*(self: Toolbar; style: ToolbarStyle) =
  gtk_toolbar_set_style(cast[ptr Toolbar00](self.impl), style)

proc gtk_toolbar_unset_icon_size*(self: ptr Toolbar00) {.
    importc: "gtk_toolbar_unset_icon_size", libprag.}

proc unsetIconSize*(self: Toolbar) =
  gtk_toolbar_unset_icon_size(cast[ptr Toolbar00](self.impl))

proc gtk_toolbar_unset_style*(self: ptr Toolbar00) {.
    importc: "gtk_toolbar_unset_style", libprag.}

proc unsetStyle*(self: Toolbar) =
  gtk_toolbar_unset_style(cast[ptr Toolbar00](self.impl))

type
  ToolbarClass00* {.pure.} = object
    parentClass*: ContainerClass00
    orientationChanged*: proc(toolbar: ptr Toolbar00; orientation: Orientation) {.cdecl.}
    styleChanged*: proc(toolbar: ptr Toolbar00; style: ToolbarStyle) {.cdecl.}
    popupContextMenu*: proc(toolbar: ptr Toolbar00; x: int32; y: int32; buttonNumber: int32): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ToolbarClass* = ref object
    impl*: ptr ToolbarClass00

type
  ToolbarSpaceStyle* {.size: sizeof(cint), pure.} = enum
    empty = 0
    line = 1

type
  ToplevelAccessiblePrivate00* {.pure.} = object
  ToplevelAccessiblePrivate* = ref object
    impl*: ptr ToplevelAccessiblePrivate00

type
  ToplevelAccessible* = ref object of atk.Object
  ToplevelAccessible00* = object of atk.Object00
    priv1: ptr ToplevelAccessiblePrivate00

proc gtk_toplevel_accessible_get_children*(self: ptr ToplevelAccessible00): ptr pointer {.
    importc: "gtk_toplevel_accessible_get_children", libprag.}

proc getChildren*(self: ToplevelAccessible): ptr pointer =
  gtk_toplevel_accessible_get_children(cast[ptr ToplevelAccessible00](self.impl))

proc children*(self: ToplevelAccessible): ptr pointer =
  gtk_toplevel_accessible_get_children(cast[ptr ToplevelAccessible00](self.impl))

type
  ToplevelAccessibleClass00* {.pure.} = object
    parentClass*: atk.ObjectClass00
  ToplevelAccessibleClass* = ref object
    impl*: ptr ToplevelAccessibleClass00

type
  TranslateFunc* = proc (path: cstring; funcData: pointer): cstring {.cdecl.}

proc gtk_action_group_set_translate_func*(self: ptr ActionGroup00; `func`: TranslateFunc; data: pointer; 
    notify: DestroyNotify) {.
    importc: "gtk_action_group_set_translate_func", libprag.}

proc setTranslateFunc*(self: ActionGroup; `func`: TranslateFunc; data: pointer; 
    notify: DestroyNotify) =
  gtk_action_group_set_translate_func(cast[ptr ActionGroup00](self.impl), `func`, data, notify)

type
  TreeViewColumnPrivate00* {.pure.} = object
  TreeViewColumnPrivate* = ref object
    impl*: ptr TreeViewColumnPrivate00

type
  TreeViewColumn* = ref object of gobject.InitiallyUnowned
  TreeViewColumn00* = object of gobject.InitiallyUnowned00
    priv1: ptr TreeViewColumnPrivate00

proc scClicked*(self: TreeViewColumn;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "clicked", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_tree_view_column_new*(): ptr TreeViewColumn00 {.
    importc: "gtk_tree_view_column_new", libprag.}

proc newTreeViewColumn*(): TreeViewColumn =
  new(result, finalizeGObject)
  result.impl = gtk_tree_view_column_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeViewColumn*[T](result: var T) =
  assert(result is TreeViewColumn)
  new(result, finalizeGObject)
  result.impl = gtk_tree_view_column_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_new_with_area*(area: ptr CellArea00): ptr TreeViewColumn00 {.
    importc: "gtk_tree_view_column_new_with_area", libprag.}

proc newTreeViewColumnWithArea*(area: CellArea): TreeViewColumn =
  new(result, finalizeGObject)
  result.impl = gtk_tree_view_column_new_with_area(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeViewColumnWithArea*[T](result: var T; area: CellArea) =
  assert(result is TreeViewColumn)
  new(result, finalizeGObject)
  result.impl = gtk_tree_view_column_new_with_area(cast[ptr CellArea00](area.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_add_attribute*(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00; 
    attribute: cstring; column: int32) {.
    importc: "gtk_tree_view_column_add_attribute", libprag.}

proc addAttribute*(self: TreeViewColumn; cellRenderer: CellRenderer; 
    attribute: string; column: int) =
  gtk_tree_view_column_add_attribute(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl), cstring(attribute), int32(column))

proc gtk_tree_view_column_cell_get_position*(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00; 
    xOffset: var int32; width: var int32): gboolean {.
    importc: "gtk_tree_view_column_cell_get_position", libprag.}

proc cellGetPosition*(self: TreeViewColumn; cellRenderer: CellRenderer; 
    xOffset: var int; width: var int): bool =
  var width_00 = int32(width)
  var xOffset_00 = int32(xOffset)
  result = toBool(gtk_tree_view_column_cell_get_position(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl), xOffset_00, width_00))
  width = int(width_00)
  xOffset = int(xOffset_00)

proc gtk_tree_view_column_cell_get_size*(self: ptr TreeViewColumn00; cellArea: ptr gdk.Rectangle00; 
    xOffset: var int32; yOffset: var int32; width: var int32; height: var int32) {.
    importc: "gtk_tree_view_column_cell_get_size", libprag.}

proc cellGetSize*(self: TreeViewColumn; cellArea: gdk.Rectangle; xOffset: var int; 
    yOffset: var int; width: var int; height: var int) =
  var height_00 = int32(height)
  var width_00 = int32(width)
  var yOffset_00 = int32(yOffset)
  var xOffset_00 = int32(xOffset)
  gtk_tree_view_column_cell_get_size(cast[ptr TreeViewColumn00](self.impl), cast[ptr gdk.Rectangle00](cellArea.impl), xOffset_00, yOffset_00, width_00, height_00)
  height = int(height_00)
  width = int(width_00)
  yOffset = int(yOffset_00)
  xOffset = int(xOffset_00)

proc gtk_tree_view_column_cell_is_visible*(self: ptr TreeViewColumn00): gboolean {.
    importc: "gtk_tree_view_column_cell_is_visible", libprag.}

proc cellIsVisible*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_cell_is_visible(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_cell_set_cell_data*(self: ptr TreeViewColumn00; treeModel: ptr TreeModel00; 
    iter: ptr TreeIter00; isExpander: gboolean; isExpanded: gboolean) {.
    importc: "gtk_tree_view_column_cell_set_cell_data", libprag.}

proc cellSetCellData*(self: TreeViewColumn; treeModel: TreeModel; iter: TreeIter; 
    isExpander: bool; isExpanded: bool) =
  gtk_tree_view_column_cell_set_cell_data(cast[ptr TreeViewColumn00](self.impl), cast[ptr TreeModel00](treeModel.impl), cast[ptr TreeIter00](iter.impl), gboolean(isExpander), gboolean(isExpanded))

proc gtk_tree_view_column_clear*(self: ptr TreeViewColumn00) {.
    importc: "gtk_tree_view_column_clear", libprag.}

proc clear*(self: TreeViewColumn) =
  gtk_tree_view_column_clear(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_clear_attributes*(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00) {.
    importc: "gtk_tree_view_column_clear_attributes", libprag.}

proc clearAttributes*(self: TreeViewColumn; cellRenderer: CellRenderer) =
  gtk_tree_view_column_clear_attributes(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl))

proc gtk_tree_view_column_clicked*(self: ptr TreeViewColumn00) {.
    importc: "gtk_tree_view_column_clicked", libprag.}

proc clicked*(self: TreeViewColumn) =
  gtk_tree_view_column_clicked(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_focus_cell*(self: ptr TreeViewColumn00; cell: ptr CellRenderer00) {.
    importc: "gtk_tree_view_column_focus_cell", libprag.}

proc focusCell*(self: TreeViewColumn; cell: CellRenderer) =
  gtk_tree_view_column_focus_cell(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cell.impl))

proc gtk_tree_view_column_get_alignment*(self: ptr TreeViewColumn00): cfloat {.
    importc: "gtk_tree_view_column_get_alignment", libprag.}

proc getAlignment*(self: TreeViewColumn): cfloat =
  gtk_tree_view_column_get_alignment(cast[ptr TreeViewColumn00](self.impl))

proc alignment*(self: TreeViewColumn): cfloat =
  gtk_tree_view_column_get_alignment(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_get_button*(self: ptr TreeViewColumn00): ptr Widget00 {.
    importc: "gtk_tree_view_column_get_button", libprag.}

proc getButton*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_button(cast[ptr TreeViewColumn00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc button*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_button(cast[ptr TreeViewColumn00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_get_clickable*(self: ptr TreeViewColumn00): gboolean {.
    importc: "gtk_tree_view_column_get_clickable", libprag.}

proc getClickable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_clickable(cast[ptr TreeViewColumn00](self.impl)))

proc clickable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_clickable(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_expand*(self: ptr TreeViewColumn00): gboolean {.
    importc: "gtk_tree_view_column_get_expand", libprag.}

proc getExpand*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_expand(cast[ptr TreeViewColumn00](self.impl)))

proc expand*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_expand(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_fixed_width*(self: ptr TreeViewColumn00): int32 {.
    importc: "gtk_tree_view_column_get_fixed_width", libprag.}

proc getFixedWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_fixed_width(cast[ptr TreeViewColumn00](self.impl)))

proc fixedWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_fixed_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_max_width*(self: ptr TreeViewColumn00): int32 {.
    importc: "gtk_tree_view_column_get_max_width", libprag.}

proc getMaxWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_max_width(cast[ptr TreeViewColumn00](self.impl)))

proc maxWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_max_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_min_width*(self: ptr TreeViewColumn00): int32 {.
    importc: "gtk_tree_view_column_get_min_width", libprag.}

proc getMinWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_min_width(cast[ptr TreeViewColumn00](self.impl)))

proc minWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_min_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_reorderable*(self: ptr TreeViewColumn00): gboolean {.
    importc: "gtk_tree_view_column_get_reorderable", libprag.}

proc getReorderable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_reorderable(cast[ptr TreeViewColumn00](self.impl)))

proc reorderable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_reorderable(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_resizable*(self: ptr TreeViewColumn00): gboolean {.
    importc: "gtk_tree_view_column_get_resizable", libprag.}

proc getResizable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_resizable(cast[ptr TreeViewColumn00](self.impl)))

proc resizable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_resizable(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_sort_column_id*(self: ptr TreeViewColumn00): int32 {.
    importc: "gtk_tree_view_column_get_sort_column_id", libprag.}

proc getSortColumnId*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_sort_column_id(cast[ptr TreeViewColumn00](self.impl)))

proc sortColumnId*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_sort_column_id(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_sort_indicator*(self: ptr TreeViewColumn00): gboolean {.
    importc: "gtk_tree_view_column_get_sort_indicator", libprag.}

proc getSortIndicator*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_sort_indicator(cast[ptr TreeViewColumn00](self.impl)))

proc sortIndicator*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_sort_indicator(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_sort_order*(self: ptr TreeViewColumn00): SortType {.
    importc: "gtk_tree_view_column_get_sort_order", libprag.}

proc getSortOrder*(self: TreeViewColumn): SortType =
  gtk_tree_view_column_get_sort_order(cast[ptr TreeViewColumn00](self.impl))

proc sortOrder*(self: TreeViewColumn): SortType =
  gtk_tree_view_column_get_sort_order(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_get_spacing*(self: ptr TreeViewColumn00): int32 {.
    importc: "gtk_tree_view_column_get_spacing", libprag.}

proc getSpacing*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_spacing(cast[ptr TreeViewColumn00](self.impl)))

proc spacing*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_spacing(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_title*(self: ptr TreeViewColumn00): cstring {.
    importc: "gtk_tree_view_column_get_title", libprag.}

proc getTitle*(self: TreeViewColumn): string =
  let resul0 = gtk_tree_view_column_get_title(cast[ptr TreeViewColumn00](self.impl))
  result = $resul0

proc title*(self: TreeViewColumn): string =
  let resul0 = gtk_tree_view_column_get_title(cast[ptr TreeViewColumn00](self.impl))
  result = $resul0

proc gtk_tree_view_column_get_tree_view*(self: ptr TreeViewColumn00): ptr Widget00 {.
    importc: "gtk_tree_view_column_get_tree_view", libprag.}

proc getTreeView*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_tree_view(cast[ptr TreeViewColumn00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc treeView*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_tree_view(cast[ptr TreeViewColumn00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_get_visible*(self: ptr TreeViewColumn00): gboolean {.
    importc: "gtk_tree_view_column_get_visible", libprag.}

proc getVisible*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_visible(cast[ptr TreeViewColumn00](self.impl)))

proc visible*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_visible(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_widget*(self: ptr TreeViewColumn00): ptr Widget00 {.
    importc: "gtk_tree_view_column_get_widget", libprag.}

proc getWidget*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_widget(cast[ptr TreeViewColumn00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_widget(cast[ptr TreeViewColumn00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_get_width*(self: ptr TreeViewColumn00): int32 {.
    importc: "gtk_tree_view_column_get_width", libprag.}

proc getWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_width(cast[ptr TreeViewColumn00](self.impl)))

proc width*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_x_offset*(self: ptr TreeViewColumn00): int32 {.
    importc: "gtk_tree_view_column_get_x_offset", libprag.}

proc getXOffset*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_x_offset(cast[ptr TreeViewColumn00](self.impl)))

proc xOffset*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_x_offset(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_pack_end*(self: ptr TreeViewColumn00; cell: ptr CellRenderer00; 
    expand: gboolean) {.
    importc: "gtk_tree_view_column_pack_end", libprag.}

proc packEnd*(self: TreeViewColumn; cell: CellRenderer; expand: bool) =
  gtk_tree_view_column_pack_end(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_tree_view_column_pack_start*(self: ptr TreeViewColumn00; cell: ptr CellRenderer00; 
    expand: gboolean) {.
    importc: "gtk_tree_view_column_pack_start", libprag.}

proc packStart*(self: TreeViewColumn; cell: CellRenderer; expand: bool) =
  gtk_tree_view_column_pack_start(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_tree_view_column_queue_resize*(self: ptr TreeViewColumn00) {.
    importc: "gtk_tree_view_column_queue_resize", libprag.}

proc queueResize*(self: TreeViewColumn) =
  gtk_tree_view_column_queue_resize(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_set_alignment*(self: ptr TreeViewColumn00; xalign: cfloat) {.
    importc: "gtk_tree_view_column_set_alignment", libprag.}

proc setAlignment*(self: TreeViewColumn; xalign: cfloat) =
  gtk_tree_view_column_set_alignment(cast[ptr TreeViewColumn00](self.impl), xalign)

proc `alignment=`*(self: TreeViewColumn; xalign: cfloat) =
  gtk_tree_view_column_set_alignment(cast[ptr TreeViewColumn00](self.impl), xalign)

proc gtk_tree_view_column_set_clickable*(self: ptr TreeViewColumn00; clickable: gboolean) {.
    importc: "gtk_tree_view_column_set_clickable", libprag.}

proc setClickable*(self: TreeViewColumn; clickable: bool) =
  gtk_tree_view_column_set_clickable(cast[ptr TreeViewColumn00](self.impl), gboolean(clickable))

proc `clickable=`*(self: TreeViewColumn; clickable: bool) =
  gtk_tree_view_column_set_clickable(cast[ptr TreeViewColumn00](self.impl), gboolean(clickable))

proc gtk_tree_view_column_set_expand*(self: ptr TreeViewColumn00; expand: gboolean) {.
    importc: "gtk_tree_view_column_set_expand", libprag.}

proc setExpand*(self: TreeViewColumn; expand: bool) =
  gtk_tree_view_column_set_expand(cast[ptr TreeViewColumn00](self.impl), gboolean(expand))

proc `expand=`*(self: TreeViewColumn; expand: bool) =
  gtk_tree_view_column_set_expand(cast[ptr TreeViewColumn00](self.impl), gboolean(expand))

proc gtk_tree_view_column_set_fixed_width*(self: ptr TreeViewColumn00; fixedWidth: int32) {.
    importc: "gtk_tree_view_column_set_fixed_width", libprag.}

proc setFixedWidth*(self: TreeViewColumn; fixedWidth: int) =
  gtk_tree_view_column_set_fixed_width(cast[ptr TreeViewColumn00](self.impl), int32(fixedWidth))

proc `fixedWidth=`*(self: TreeViewColumn; fixedWidth: int) =
  gtk_tree_view_column_set_fixed_width(cast[ptr TreeViewColumn00](self.impl), int32(fixedWidth))

proc gtk_tree_view_column_set_max_width*(self: ptr TreeViewColumn00; maxWidth: int32) {.
    importc: "gtk_tree_view_column_set_max_width", libprag.}

proc setMaxWidth*(self: TreeViewColumn; maxWidth: int) =
  gtk_tree_view_column_set_max_width(cast[ptr TreeViewColumn00](self.impl), int32(maxWidth))

proc `maxWidth=`*(self: TreeViewColumn; maxWidth: int) =
  gtk_tree_view_column_set_max_width(cast[ptr TreeViewColumn00](self.impl), int32(maxWidth))

proc gtk_tree_view_column_set_min_width*(self: ptr TreeViewColumn00; minWidth: int32) {.
    importc: "gtk_tree_view_column_set_min_width", libprag.}

proc setMinWidth*(self: TreeViewColumn; minWidth: int) =
  gtk_tree_view_column_set_min_width(cast[ptr TreeViewColumn00](self.impl), int32(minWidth))

proc `minWidth=`*(self: TreeViewColumn; minWidth: int) =
  gtk_tree_view_column_set_min_width(cast[ptr TreeViewColumn00](self.impl), int32(minWidth))

proc gtk_tree_view_column_set_reorderable*(self: ptr TreeViewColumn00; reorderable: gboolean) {.
    importc: "gtk_tree_view_column_set_reorderable", libprag.}

proc setReorderable*(self: TreeViewColumn; reorderable: bool) =
  gtk_tree_view_column_set_reorderable(cast[ptr TreeViewColumn00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: TreeViewColumn; reorderable: bool) =
  gtk_tree_view_column_set_reorderable(cast[ptr TreeViewColumn00](self.impl), gboolean(reorderable))

proc gtk_tree_view_column_set_resizable*(self: ptr TreeViewColumn00; resizable: gboolean) {.
    importc: "gtk_tree_view_column_set_resizable", libprag.}

proc setResizable*(self: TreeViewColumn; resizable: bool) =
  gtk_tree_view_column_set_resizable(cast[ptr TreeViewColumn00](self.impl), gboolean(resizable))

proc `resizable=`*(self: TreeViewColumn; resizable: bool) =
  gtk_tree_view_column_set_resizable(cast[ptr TreeViewColumn00](self.impl), gboolean(resizable))

proc gtk_tree_view_column_set_sort_column_id*(self: ptr TreeViewColumn00; sortColumnId: int32) {.
    importc: "gtk_tree_view_column_set_sort_column_id", libprag.}

proc setSortColumnId*(self: TreeViewColumn; sortColumnId: int) =
  gtk_tree_view_column_set_sort_column_id(cast[ptr TreeViewColumn00](self.impl), int32(sortColumnId))

proc `sortColumnId=`*(self: TreeViewColumn; sortColumnId: int) =
  gtk_tree_view_column_set_sort_column_id(cast[ptr TreeViewColumn00](self.impl), int32(sortColumnId))

proc gtk_tree_view_column_set_sort_indicator*(self: ptr TreeViewColumn00; setting: gboolean) {.
    importc: "gtk_tree_view_column_set_sort_indicator", libprag.}

proc setSortIndicator*(self: TreeViewColumn; setting: bool) =
  gtk_tree_view_column_set_sort_indicator(cast[ptr TreeViewColumn00](self.impl), gboolean(setting))

proc `sortIndicator=`*(self: TreeViewColumn; setting: bool) =
  gtk_tree_view_column_set_sort_indicator(cast[ptr TreeViewColumn00](self.impl), gboolean(setting))

proc gtk_tree_view_column_set_sort_order*(self: ptr TreeViewColumn00; order: SortType) {.
    importc: "gtk_tree_view_column_set_sort_order", libprag.}

proc setSortOrder*(self: TreeViewColumn; order: SortType) =
  gtk_tree_view_column_set_sort_order(cast[ptr TreeViewColumn00](self.impl), order)

proc `sortOrder=`*(self: TreeViewColumn; order: SortType) =
  gtk_tree_view_column_set_sort_order(cast[ptr TreeViewColumn00](self.impl), order)

proc gtk_tree_view_column_set_spacing*(self: ptr TreeViewColumn00; spacing: int32) {.
    importc: "gtk_tree_view_column_set_spacing", libprag.}

proc setSpacing*(self: TreeViewColumn; spacing: int) =
  gtk_tree_view_column_set_spacing(cast[ptr TreeViewColumn00](self.impl), int32(spacing))

proc `spacing=`*(self: TreeViewColumn; spacing: int) =
  gtk_tree_view_column_set_spacing(cast[ptr TreeViewColumn00](self.impl), int32(spacing))

proc gtk_tree_view_column_set_title*(self: ptr TreeViewColumn00; title: cstring) {.
    importc: "gtk_tree_view_column_set_title", libprag.}

proc setTitle*(self: TreeViewColumn; title: string) =
  gtk_tree_view_column_set_title(cast[ptr TreeViewColumn00](self.impl), cstring(title))

proc `title=`*(self: TreeViewColumn; title: string) =
  gtk_tree_view_column_set_title(cast[ptr TreeViewColumn00](self.impl), cstring(title))

proc gtk_tree_view_column_set_visible*(self: ptr TreeViewColumn00; visible: gboolean) {.
    importc: "gtk_tree_view_column_set_visible", libprag.}

proc setVisible*(self: TreeViewColumn; visible: bool) =
  gtk_tree_view_column_set_visible(cast[ptr TreeViewColumn00](self.impl), gboolean(visible))

proc `visible=`*(self: TreeViewColumn; visible: bool) =
  gtk_tree_view_column_set_visible(cast[ptr TreeViewColumn00](self.impl), gboolean(visible))

proc gtk_tree_view_column_set_widget*(self: ptr TreeViewColumn00; widget: ptr Widget00) {.
    importc: "gtk_tree_view_column_set_widget", libprag.}

proc setWidget*(self: TreeViewColumn; widget: Widget) =
  gtk_tree_view_column_set_widget(cast[ptr TreeViewColumn00](self.impl), cast[ptr Widget00](widget.impl))

proc `widget=`*(self: TreeViewColumn; widget: Widget) =
  gtk_tree_view_column_set_widget(cast[ptr TreeViewColumn00](self.impl), cast[ptr Widget00](widget.impl))

type
  TreeCellDataFunc* = proc (treeColumn: ptr TreeViewColumn00; cell: ptr CellRenderer00; 
    treeModel: ptr TreeModel00; iter: ptr TreeIter00; data: pointer) {.cdecl.}

proc gtk_tree_view_column_set_cell_data_func*(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00; 
    `func`: TreeCellDataFunc; funcData: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_view_column_set_cell_data_func", libprag.}

proc setCellDataFunc*(self: TreeViewColumn; cellRenderer: CellRenderer; 
    `func`: TreeCellDataFunc; funcData: pointer; destroy: DestroyNotify) =
  gtk_tree_view_column_set_cell_data_func(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl), `func`, funcData, destroy)

type
  TreeViewColumnSizing* {.size: sizeof(cint), pure.} = enum
    growOnly = 0
    autosize = 1
    fixed = 2

proc gtk_tree_view_column_get_sizing*(self: ptr TreeViewColumn00): TreeViewColumnSizing {.
    importc: "gtk_tree_view_column_get_sizing", libprag.}

proc getSizing*(self: TreeViewColumn): TreeViewColumnSizing =
  gtk_tree_view_column_get_sizing(cast[ptr TreeViewColumn00](self.impl))

proc sizing*(self: TreeViewColumn): TreeViewColumnSizing =
  gtk_tree_view_column_get_sizing(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_set_sizing*(self: ptr TreeViewColumn00; `type`: TreeViewColumnSizing) {.
    importc: "gtk_tree_view_column_set_sizing", libprag.}

proc setSizing*(self: TreeViewColumn; `type`: TreeViewColumnSizing) =
  gtk_tree_view_column_set_sizing(cast[ptr TreeViewColumn00](self.impl), `type`)

proc `sizing=`*(self: TreeViewColumn; `type`: TreeViewColumnSizing) =
  gtk_tree_view_column_set_sizing(cast[ptr TreeViewColumn00](self.impl), `type`)

type
  TreeViewPrivate00* {.pure.} = object
  TreeViewPrivate* = ref object
    impl*: ptr TreeViewPrivate00

type
  TreeView* = ref object of Container
  TreeView00* = object of Container00
    priv3: ptr TreeViewPrivate00

proc scColumnsChanged*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "columns-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scCursorChanged*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "cursor-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scExpandCollapseCursorRow*(self: TreeView;  p: proc (self: ptr gobject.Object00; `object`: gboolean; p0: gboolean; p1: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "expand-collapse-cursor-row", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scMoveCursor*(self: TreeView;  p: proc (self: ptr gobject.Object00; step: MovementStep; direction: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRowActivated*(self: TreeView;  p: proc (self: ptr gobject.Object00; path: TreePath00; column: TreeViewColumn00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "row-activated", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRowCollapsed*(self: TreeView;  p: proc (self: ptr gobject.Object00; iter: TreeIter00; path: TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "row-collapsed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scRowExpanded*(self: TreeView;  p: proc (self: ptr gobject.Object00; iter: TreeIter00; path: TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "row-expanded", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectAll*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectCursorParent*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select-cursor-parent", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scSelectCursorRow*(self: TreeView;  p: proc (self: ptr gobject.Object00; `object`: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "select-cursor-row", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scStartInteractiveSearch*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "start-interactive-search", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scTestCollapseRow*(self: TreeView;  p: proc (self: ptr gobject.Object00; iter: TreeIter00; path: TreePath00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "test-collapse-row", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scTestExpandRow*(self: TreeView;  p: proc (self: ptr gobject.Object00; iter: TreeIter00; path: TreePath00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "test-expand-row", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scToggleCursorRow*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "toggle-cursor-row", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scUnselectAll*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_tree_view_new*(): ptr TreeView00 {.
    importc: "gtk_tree_view_new", libprag.}

proc newTreeView*(): TreeView =
  new(result, finalizeGObject)
  result.impl = gtk_tree_view_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeView*[T](result: var T) =
  assert(result is TreeView)
  new(result, finalizeGObject)
  result.impl = gtk_tree_view_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_new_with_model*(model: ptr TreeModel00): ptr TreeView00 {.
    importc: "gtk_tree_view_new_with_model", libprag.}

proc newTreeViewWithModel*(model: TreeModel): TreeView =
  new(result, finalizeGObject)
  result.impl = gtk_tree_view_new_with_model(cast[ptr TreeModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeViewWithModel*[T](result: var T; model: TreeModel) =
  assert(result is TreeView)
  new(result, finalizeGObject)
  result.impl = gtk_tree_view_new_with_model(cast[ptr TreeModel00](model.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_append_column*(self: ptr TreeView00; column: ptr TreeViewColumn00): int32 {.
    importc: "gtk_tree_view_append_column", libprag.}

proc appendColumn*(self: TreeView; column: TreeViewColumn): int =
  int(gtk_tree_view_append_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl)))

proc gtk_tree_view_collapse_all*(self: ptr TreeView00) {.
    importc: "gtk_tree_view_collapse_all", libprag.}

proc collapseAll*(self: TreeView) =
  gtk_tree_view_collapse_all(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_collapse_row*(self: ptr TreeView00; path: ptr TreePath00): gboolean {.
    importc: "gtk_tree_view_collapse_row", libprag.}

proc collapseRow*(self: TreeView; path: TreePath): bool =
  toBool(gtk_tree_view_collapse_row(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_view_columns_autosize*(self: ptr TreeView00) {.
    importc: "gtk_tree_view_columns_autosize", libprag.}

proc columnsAutosize*(self: TreeView) =
  gtk_tree_view_columns_autosize(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_convert_bin_window_to_tree_coords*(self: ptr TreeView00; bx: int32; by: int32; tx: var int32; 
    ty: var int32) {.
    importc: "gtk_tree_view_convert_bin_window_to_tree_coords", libprag.}

proc convertBinWindowToTreeCoords*(self: TreeView; bx: int; by: int; tx: var int; ty: var int) =
  var tx_00 = int32(tx)
  var ty_00 = int32(ty)
  gtk_tree_view_convert_bin_window_to_tree_coords(cast[ptr TreeView00](self.impl), int32(bx), int32(by), tx_00, ty_00)
  tx = int(tx_00)
  ty = int(ty_00)

proc gtk_tree_view_convert_bin_window_to_widget_coords*(self: ptr TreeView00; bx: int32; by: int32; wx: var int32; 
    wy: var int32) {.
    importc: "gtk_tree_view_convert_bin_window_to_widget_coords", libprag.}

proc convertBinWindowToWidgetCoords*(self: TreeView; bx: int; by: int; wx: var int; wy: var int) =
  var wy_00 = int32(wy)
  var wx_00 = int32(wx)
  gtk_tree_view_convert_bin_window_to_widget_coords(cast[ptr TreeView00](self.impl), int32(bx), int32(by), wx_00, wy_00)
  wy = int(wy_00)
  wx = int(wx_00)

proc gtk_tree_view_convert_tree_to_bin_window_coords*(self: ptr TreeView00; tx: int32; ty: int32; bx: var int32; 
    by: var int32) {.
    importc: "gtk_tree_view_convert_tree_to_bin_window_coords", libprag.}

proc convertTreeToBinWindowCoords*(self: TreeView; tx: int; ty: int; bx: var int; by: var int) =
  var bx_00 = int32(bx)
  var by_00 = int32(by)
  gtk_tree_view_convert_tree_to_bin_window_coords(cast[ptr TreeView00](self.impl), int32(tx), int32(ty), bx_00, by_00)
  bx = int(bx_00)
  by = int(by_00)

proc gtk_tree_view_convert_tree_to_widget_coords*(self: ptr TreeView00; tx: int32; ty: int32; wx: var int32; 
    wy: var int32) {.
    importc: "gtk_tree_view_convert_tree_to_widget_coords", libprag.}

proc convertTreeToWidgetCoords*(self: TreeView; tx: int; ty: int; wx: var int; wy: var int) =
  var wy_00 = int32(wy)
  var wx_00 = int32(wx)
  gtk_tree_view_convert_tree_to_widget_coords(cast[ptr TreeView00](self.impl), int32(tx), int32(ty), wx_00, wy_00)
  wy = int(wy_00)
  wx = int(wx_00)

proc gtk_tree_view_convert_widget_to_bin_window_coords*(self: ptr TreeView00; wx: int32; wy: int32; bx: var int32; 
    by: var int32) {.
    importc: "gtk_tree_view_convert_widget_to_bin_window_coords", libprag.}

proc convertWidgetToBinWindowCoords*(self: TreeView; wx: int; wy: int; bx: var int; by: var int) =
  var bx_00 = int32(bx)
  var by_00 = int32(by)
  gtk_tree_view_convert_widget_to_bin_window_coords(cast[ptr TreeView00](self.impl), int32(wx), int32(wy), bx_00, by_00)
  bx = int(bx_00)
  by = int(by_00)

proc gtk_tree_view_convert_widget_to_tree_coords*(self: ptr TreeView00; wx: int32; wy: int32; tx: var int32; 
    ty: var int32) {.
    importc: "gtk_tree_view_convert_widget_to_tree_coords", libprag.}

proc convertWidgetToTreeCoords*(self: TreeView; wx: int; wy: int; tx: var int; ty: var int) =
  var tx_00 = int32(tx)
  var ty_00 = int32(ty)
  gtk_tree_view_convert_widget_to_tree_coords(cast[ptr TreeView00](self.impl), int32(wx), int32(wy), tx_00, ty_00)
  tx = int(tx_00)
  ty = int(ty_00)

proc gtk_tree_view_create_row_drag_icon*(self: ptr TreeView00; path: ptr TreePath00): ptr cairo.Surface00 {.
    importc: "gtk_tree_view_create_row_drag_icon", libprag.}

proc createRowDragIcon*(self: TreeView; path: TreePath): cairo.Surface =
  new(result)
  result.impl = gtk_tree_view_create_row_drag_icon(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_view_enable_model_drag_dest*(self: ptr TreeView00; targets: TargetEntry00Array; 
    nTargets: int32; actions: gdk.DragAction) {.
    importc: "gtk_tree_view_enable_model_drag_dest", libprag.}

proc enableModelDragDest*(self: TreeView; targets: TargetEntry00Array; nTargets: int; 
    actions: gdk.DragAction) =
  gtk_tree_view_enable_model_drag_dest(cast[ptr TreeView00](self.impl), targets, int32(nTargets), actions)

proc gtk_tree_view_enable_model_drag_source*(self: ptr TreeView00; startButtonMask: gdk.ModifierType; 
    targets: TargetEntry00Array; nTargets: int32; actions: gdk.DragAction) {.
    importc: "gtk_tree_view_enable_model_drag_source", libprag.}

proc enableModelDragSource*(self: TreeView; startButtonMask: gdk.ModifierType; 
    targets: TargetEntry00Array; nTargets: int; actions: gdk.DragAction) =
  gtk_tree_view_enable_model_drag_source(cast[ptr TreeView00](self.impl), startButtonMask, targets, int32(nTargets), actions)

proc gtk_tree_view_expand_all*(self: ptr TreeView00) {.
    importc: "gtk_tree_view_expand_all", libprag.}

proc expandAll*(self: TreeView) =
  gtk_tree_view_expand_all(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_expand_row*(self: ptr TreeView00; path: ptr TreePath00; openAll: gboolean): gboolean {.
    importc: "gtk_tree_view_expand_row", libprag.}

proc expandRow*(self: TreeView; path: TreePath; openAll: bool): bool =
  toBool(gtk_tree_view_expand_row(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), gboolean(openAll)))

proc gtk_tree_view_expand_to_path*(self: ptr TreeView00; path: ptr TreePath00) {.
    importc: "gtk_tree_view_expand_to_path", libprag.}

proc expandToPath*(self: TreeView; path: TreePath) =
  gtk_tree_view_expand_to_path(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_view_get_activate_on_single_click*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_activate_on_single_click", libprag.}

proc getActivateOnSingleClick*(self: TreeView): bool =
  toBool(gtk_tree_view_get_activate_on_single_click(cast[ptr TreeView00](self.impl)))

proc activateOnSingleClick*(self: TreeView): bool =
  toBool(gtk_tree_view_get_activate_on_single_click(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_background_area*(self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00; 
    rect: var gdk.Rectangle00) {.
    importc: "gtk_tree_view_get_background_area", libprag.}

proc getBackgroundArea*(self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00; 
    rect: var gdk.Rectangle00) {.
    importc: "gtk_tree_view_get_background_area", libprag.}

proc backgroundArea*(self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00; 
    rect: var gdk.Rectangle00) {.
    importc: "gtk_tree_view_get_background_area", libprag.}

proc gtk_tree_view_get_bin_window*(self: ptr TreeView00): ptr gdk.Window00 {.
    importc: "gtk_tree_view_get_bin_window", libprag.}

proc getBinWindow*(self: TreeView): gdk.Window =
  let gobj = gtk_tree_view_get_bin_window(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc binWindow*(self: TreeView): gdk.Window =
  let gobj = gtk_tree_view_get_bin_window(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_cell_area*(self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00; 
    rect: var gdk.Rectangle00) {.
    importc: "gtk_tree_view_get_cell_area", libprag.}

proc getCellArea*(self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00; 
    rect: var gdk.Rectangle00) {.
    importc: "gtk_tree_view_get_cell_area", libprag.}

proc cellArea*(self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00; 
    rect: var gdk.Rectangle00) {.
    importc: "gtk_tree_view_get_cell_area", libprag.}

proc gtk_tree_view_get_column*(self: ptr TreeView00; n: int32): ptr TreeViewColumn00 {.
    importc: "gtk_tree_view_get_column", libprag.}

proc getColumn*(self: TreeView; n: int): TreeViewColumn =
  let gobj = gtk_tree_view_get_column(cast[ptr TreeView00](self.impl), int32(n))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TreeViewColumn](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc column*(self: TreeView; n: int): TreeViewColumn =
  let gobj = gtk_tree_view_get_column(cast[ptr TreeView00](self.impl), int32(n))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TreeViewColumn](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_columns*(self: ptr TreeView00): ptr pointer {.
    importc: "gtk_tree_view_get_columns", libprag.}

proc getColumns*(self: TreeView): ptr pointer =
  gtk_tree_view_get_columns(cast[ptr TreeView00](self.impl))

proc columns*(self: TreeView): ptr pointer =
  gtk_tree_view_get_columns(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_get_cursor*(self: ptr TreeView00; path: var ptr TreePath00; focusColumn: var ptr TreeViewColumn00) {.
    importc: "gtk_tree_view_get_cursor", libprag.}

proc getCursor*(self: ptr TreeView00; path: var ptr TreePath00; focusColumn: var ptr TreeViewColumn00) {.
    importc: "gtk_tree_view_get_cursor", libprag.}

proc cursor*(self: ptr TreeView00; path: var ptr TreePath00; focusColumn: var ptr TreeViewColumn00) {.
    importc: "gtk_tree_view_get_cursor", libprag.}

proc gtk_tree_view_get_enable_search*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_enable_search", libprag.}

proc getEnableSearch*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_search(cast[ptr TreeView00](self.impl)))

proc enableSearch*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_search(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_enable_tree_lines*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_enable_tree_lines", libprag.}

proc getEnableTreeLines*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_tree_lines(cast[ptr TreeView00](self.impl)))

proc enableTreeLines*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_tree_lines(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_expander_column*(self: ptr TreeView00): ptr TreeViewColumn00 {.
    importc: "gtk_tree_view_get_expander_column", libprag.}

proc getExpanderColumn*(self: TreeView): TreeViewColumn =
  let gobj = gtk_tree_view_get_expander_column(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TreeViewColumn](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc expanderColumn*(self: TreeView): TreeViewColumn =
  let gobj = gtk_tree_view_get_expander_column(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TreeViewColumn](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_fixed_height_mode*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_fixed_height_mode", libprag.}

proc getFixedHeightMode*(self: TreeView): bool =
  toBool(gtk_tree_view_get_fixed_height_mode(cast[ptr TreeView00](self.impl)))

proc fixedHeightMode*(self: TreeView): bool =
  toBool(gtk_tree_view_get_fixed_height_mode(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_hadjustment*(self: ptr TreeView00): ptr Adjustment00 {.
    importc: "gtk_tree_view_get_hadjustment", libprag.}

proc getHadjustment*(self: TreeView): Adjustment =
  let gobj = gtk_tree_view_get_hadjustment(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: TreeView): Adjustment =
  let gobj = gtk_tree_view_get_hadjustment(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_headers_clickable*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_headers_clickable", libprag.}

proc getHeadersClickable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_clickable(cast[ptr TreeView00](self.impl)))

proc headersClickable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_clickable(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_headers_visible*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_headers_visible", libprag.}

proc getHeadersVisible*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_visible(cast[ptr TreeView00](self.impl)))

proc headersVisible*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_visible(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_hover_expand*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_hover_expand", libprag.}

proc getHoverExpand*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_expand(cast[ptr TreeView00](self.impl)))

proc hoverExpand*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_expand(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_hover_selection*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_hover_selection", libprag.}

proc getHoverSelection*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_selection(cast[ptr TreeView00](self.impl)))

proc hoverSelection*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_selection(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_level_indentation*(self: ptr TreeView00): int32 {.
    importc: "gtk_tree_view_get_level_indentation", libprag.}

proc getLevelIndentation*(self: TreeView): int =
  int(gtk_tree_view_get_level_indentation(cast[ptr TreeView00](self.impl)))

proc levelIndentation*(self: TreeView): int =
  int(gtk_tree_view_get_level_indentation(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_model*(self: ptr TreeView00): ptr TreeModel00 {.
    importc: "gtk_tree_view_get_model", libprag.}

proc getModel*(self: TreeView): TreeModel =
  new(result)
  result.impl = gtk_tree_view_get_model(cast[ptr TreeView00](self.impl))

proc model*(self: TreeView): TreeModel =
  new(result)
  result.impl = gtk_tree_view_get_model(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_get_n_columns*(self: ptr TreeView00): uint32 {.
    importc: "gtk_tree_view_get_n_columns", libprag.}

proc getNColumns*(self: TreeView): int =
  int(gtk_tree_view_get_n_columns(cast[ptr TreeView00](self.impl)))

proc nColumns*(self: TreeView): int =
  int(gtk_tree_view_get_n_columns(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_path_at_pos*(self: ptr TreeView00; x: int32; y: int32; path: var ptr TreePath00; 
    column: var ptr TreeViewColumn00; cellX: var int32; cellY: var int32): gboolean {.
    importc: "gtk_tree_view_get_path_at_pos", libprag.}

proc getPathAtPos*(self: ptr TreeView00; x: int32; y: int32; path: var ptr TreePath00; 
    column: var ptr TreeViewColumn00; cellX: var int32; cellY: var int32): gboolean {.
    importc: "gtk_tree_view_get_path_at_pos", libprag.}

proc pathAtPos*(self: ptr TreeView00; x: int32; y: int32; path: var ptr TreePath00; 
    column: var ptr TreeViewColumn00; cellX: var int32; cellY: var int32): gboolean {.
    importc: "gtk_tree_view_get_path_at_pos", libprag.}

proc gtk_tree_view_get_reorderable*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_reorderable", libprag.}

proc getReorderable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_reorderable(cast[ptr TreeView00](self.impl)))

proc reorderable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_reorderable(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_rubber_banding*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_rubber_banding", libprag.}

proc getRubberBanding*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rubber_banding(cast[ptr TreeView00](self.impl)))

proc rubberBanding*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rubber_banding(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_rules_hint*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_rules_hint", libprag.}

proc getRulesHint*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rules_hint(cast[ptr TreeView00](self.impl)))

proc rulesHint*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rules_hint(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_search_column*(self: ptr TreeView00): int32 {.
    importc: "gtk_tree_view_get_search_column", libprag.}

proc getSearchColumn*(self: TreeView): int =
  int(gtk_tree_view_get_search_column(cast[ptr TreeView00](self.impl)))

proc searchColumn*(self: TreeView): int =
  int(gtk_tree_view_get_search_column(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_search_entry*(self: ptr TreeView00): ptr Entry00 {.
    importc: "gtk_tree_view_get_search_entry", libprag.}

proc getSearchEntry*(self: TreeView): Entry =
  let gobj = gtk_tree_view_get_search_entry(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Entry](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc searchEntry*(self: TreeView): Entry =
  let gobj = gtk_tree_view_get_search_entry(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Entry](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_show_expanders*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_get_show_expanders", libprag.}

proc getShowExpanders*(self: TreeView): bool =
  toBool(gtk_tree_view_get_show_expanders(cast[ptr TreeView00](self.impl)))

proc showExpanders*(self: TreeView): bool =
  toBool(gtk_tree_view_get_show_expanders(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_tooltip_column*(self: ptr TreeView00): int32 {.
    importc: "gtk_tree_view_get_tooltip_column", libprag.}

proc getTooltipColumn*(self: TreeView): int =
  int(gtk_tree_view_get_tooltip_column(cast[ptr TreeView00](self.impl)))

proc tooltipColumn*(self: TreeView): int =
  int(gtk_tree_view_get_tooltip_column(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_tooltip_context*(self: ptr TreeView00; x: int32; y: int32; keyboardTip: gboolean; 
    model: var ptr TreeModel00; path: var ptr TreePath00; iter: var TreeIter00): gboolean {.
    importc: "gtk_tree_view_get_tooltip_context", libprag.}

proc getTooltipContext*(self: ptr TreeView00; x: int32; y: int32; keyboardTip: gboolean; 
    model: var ptr TreeModel00; path: var ptr TreePath00; iter: var TreeIter00): gboolean {.
    importc: "gtk_tree_view_get_tooltip_context", libprag.}

proc tooltipContext*(self: ptr TreeView00; x: int32; y: int32; keyboardTip: gboolean; 
    model: var ptr TreeModel00; path: var ptr TreePath00; iter: var TreeIter00): gboolean {.
    importc: "gtk_tree_view_get_tooltip_context", libprag.}

proc gtk_tree_view_get_vadjustment*(self: ptr TreeView00): ptr Adjustment00 {.
    importc: "gtk_tree_view_get_vadjustment", libprag.}

proc getVadjustment*(self: TreeView): Adjustment =
  let gobj = gtk_tree_view_get_vadjustment(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: TreeView): Adjustment =
  let gobj = gtk_tree_view_get_vadjustment(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_visible_range*(self: ptr TreeView00; startPath: var ptr TreePath00; 
    endPath: var ptr TreePath00): gboolean {.
    importc: "gtk_tree_view_get_visible_range", libprag.}

proc getVisibleRange*(self: ptr TreeView00; startPath: var ptr TreePath00; 
    endPath: var ptr TreePath00): gboolean {.
    importc: "gtk_tree_view_get_visible_range", libprag.}

proc visibleRange*(self: ptr TreeView00; startPath: var ptr TreePath00; 
    endPath: var ptr TreePath00): gboolean {.
    importc: "gtk_tree_view_get_visible_range", libprag.}

proc gtk_tree_view_get_visible_rect*(self: ptr TreeView00; visibleRect: var gdk.Rectangle00) {.
    importc: "gtk_tree_view_get_visible_rect", libprag.}

proc getVisibleRect*(self: ptr TreeView00; visibleRect: var gdk.Rectangle00) {.
    importc: "gtk_tree_view_get_visible_rect", libprag.}

proc visibleRect*(self: ptr TreeView00; visibleRect: var gdk.Rectangle00) {.
    importc: "gtk_tree_view_get_visible_rect", libprag.}

proc gtk_tree_view_insert_column*(self: ptr TreeView00; column: ptr TreeViewColumn00; 
    position: int32): int32 {.
    importc: "gtk_tree_view_insert_column", libprag.}

proc insertColumn*(self: TreeView; column: TreeViewColumn; position: int): int =
  int(gtk_tree_view_insert_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl), int32(position)))

proc gtk_tree_view_insert_column_with_data_func*(self: ptr TreeView00; position: int32; title: cstring; 
    cell: ptr CellRenderer00; `func`: TreeCellDataFunc; data: pointer; dnotify: DestroyNotify): int32 {.
    importc: "gtk_tree_view_insert_column_with_data_func", libprag.}

proc insertColumnWithDataFunc*(self: TreeView; position: int; title: string; cell: CellRenderer; 
    `func`: TreeCellDataFunc; data: pointer; dnotify: DestroyNotify): int =
  int(gtk_tree_view_insert_column_with_data_func(cast[ptr TreeView00](self.impl), int32(position), cstring(title), cast[ptr CellRenderer00](cell.impl), `func`, data, dnotify))

proc gtk_tree_view_is_blank_at_pos*(self: ptr TreeView00; x: int32; y: int32; path: var ptr TreePath00; 
    column: var ptr TreeViewColumn00; cellX: var int32; cellY: var int32): gboolean {.
    importc: "gtk_tree_view_is_blank_at_pos", libprag.}

proc isBlankAtPos*(self: ptr TreeView00; x: int32; y: int32; path: var ptr TreePath00; 
    column: var ptr TreeViewColumn00; cellX: var int32; cellY: var int32): gboolean {.
    importc: "gtk_tree_view_is_blank_at_pos", libprag.}

proc gtk_tree_view_is_rubber_banding_active*(self: ptr TreeView00): gboolean {.
    importc: "gtk_tree_view_is_rubber_banding_active", libprag.}

proc isRubberBandingActive*(self: TreeView): bool =
  toBool(gtk_tree_view_is_rubber_banding_active(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_move_column_after*(self: ptr TreeView00; column: ptr TreeViewColumn00; 
    baseColumn: ptr TreeViewColumn00) {.
    importc: "gtk_tree_view_move_column_after", libprag.}

proc moveColumnAfter*(self: TreeView; column: TreeViewColumn; baseColumn: TreeViewColumn) =
  gtk_tree_view_move_column_after(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl), cast[ptr TreeViewColumn00](baseColumn.impl))

proc gtk_tree_view_remove_column*(self: ptr TreeView00; column: ptr TreeViewColumn00): int32 {.
    importc: "gtk_tree_view_remove_column", libprag.}

proc removeColumn*(self: TreeView; column: TreeViewColumn): int =
  int(gtk_tree_view_remove_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl)))

proc gtk_tree_view_row_activated*(self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00) {.
    importc: "gtk_tree_view_row_activated", libprag.}

proc rowActivated*(self: TreeView; path: TreePath; column: TreeViewColumn) =
  gtk_tree_view_row_activated(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeViewColumn00](column.impl))

proc gtk_tree_view_row_expanded*(self: ptr TreeView00; path: ptr TreePath00): gboolean {.
    importc: "gtk_tree_view_row_expanded", libprag.}

proc rowExpanded*(self: TreeView; path: TreePath): bool =
  toBool(gtk_tree_view_row_expanded(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_view_scroll_to_cell*(self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00; 
    useAlign: gboolean; rowAlign: cfloat; colAlign: cfloat) {.
    importc: "gtk_tree_view_scroll_to_cell", libprag.}

proc scrollToCell*(self: TreeView; path: TreePath; column: TreeViewColumn; 
    useAlign: bool; rowAlign: cfloat; colAlign: cfloat) =
  gtk_tree_view_scroll_to_cell(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeViewColumn00](column.impl), gboolean(useAlign), rowAlign, colAlign)

proc gtk_tree_view_scroll_to_point*(self: ptr TreeView00; treeX: int32; treeY: int32) {.
    importc: "gtk_tree_view_scroll_to_point", libprag.}

proc scrollToPoint*(self: TreeView; treeX: int; treeY: int) =
  gtk_tree_view_scroll_to_point(cast[ptr TreeView00](self.impl), int32(treeX), int32(treeY))

proc gtk_tree_view_set_activate_on_single_click*(self: ptr TreeView00; single: gboolean) {.
    importc: "gtk_tree_view_set_activate_on_single_click", libprag.}

proc setActivateOnSingleClick*(self: TreeView; single: bool) =
  gtk_tree_view_set_activate_on_single_click(cast[ptr TreeView00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: TreeView; single: bool) =
  gtk_tree_view_set_activate_on_single_click(cast[ptr TreeView00](self.impl), gboolean(single))

proc gtk_tree_view_set_cursor*(self: ptr TreeView00; path: ptr TreePath00; focusColumn: ptr TreeViewColumn00; 
    startEditing: gboolean) {.
    importc: "gtk_tree_view_set_cursor", libprag.}

proc setCursor*(self: TreeView; path: TreePath; focusColumn: TreeViewColumn; 
    startEditing: bool) =
  gtk_tree_view_set_cursor(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeViewColumn00](focusColumn.impl), gboolean(startEditing))

proc gtk_tree_view_set_cursor_on_cell*(self: ptr TreeView00; path: ptr TreePath00; focusColumn: ptr TreeViewColumn00; 
    focusCell: ptr CellRenderer00; startEditing: gboolean) {.
    importc: "gtk_tree_view_set_cursor_on_cell", libprag.}

proc setCursorOnCell*(self: TreeView; path: TreePath; focusColumn: TreeViewColumn; 
    focusCell: CellRenderer; startEditing: bool) =
  gtk_tree_view_set_cursor_on_cell(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeViewColumn00](focusColumn.impl), cast[ptr CellRenderer00](focusCell.impl), gboolean(startEditing))

proc gtk_tree_view_set_enable_search*(self: ptr TreeView00; enableSearch: gboolean) {.
    importc: "gtk_tree_view_set_enable_search", libprag.}

proc setEnableSearch*(self: TreeView; enableSearch: bool) =
  gtk_tree_view_set_enable_search(cast[ptr TreeView00](self.impl), gboolean(enableSearch))

proc `enableSearch=`*(self: TreeView; enableSearch: bool) =
  gtk_tree_view_set_enable_search(cast[ptr TreeView00](self.impl), gboolean(enableSearch))

proc gtk_tree_view_set_enable_tree_lines*(self: ptr TreeView00; enabled: gboolean) {.
    importc: "gtk_tree_view_set_enable_tree_lines", libprag.}

proc setEnableTreeLines*(self: TreeView; enabled: bool) =
  gtk_tree_view_set_enable_tree_lines(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc `enableTreeLines=`*(self: TreeView; enabled: bool) =
  gtk_tree_view_set_enable_tree_lines(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc gtk_tree_view_set_expander_column*(self: ptr TreeView00; column: ptr TreeViewColumn00) {.
    importc: "gtk_tree_view_set_expander_column", libprag.}

proc setExpanderColumn*(self: TreeView; column: TreeViewColumn) =
  gtk_tree_view_set_expander_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl))

proc `expanderColumn=`*(self: TreeView; column: TreeViewColumn) =
  gtk_tree_view_set_expander_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl))

proc gtk_tree_view_set_fixed_height_mode*(self: ptr TreeView00; enable: gboolean) {.
    importc: "gtk_tree_view_set_fixed_height_mode", libprag.}

proc setFixedHeightMode*(self: TreeView; enable: bool) =
  gtk_tree_view_set_fixed_height_mode(cast[ptr TreeView00](self.impl), gboolean(enable))

proc `fixedHeightMode=`*(self: TreeView; enable: bool) =
  gtk_tree_view_set_fixed_height_mode(cast[ptr TreeView00](self.impl), gboolean(enable))

proc gtk_tree_view_set_hadjustment*(self: ptr TreeView00; adjustment: ptr Adjustment00) {.
    importc: "gtk_tree_view_set_hadjustment", libprag.}

proc setHadjustment*(self: TreeView; adjustment: Adjustment) =
  gtk_tree_view_set_hadjustment(cast[ptr TreeView00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `hadjustment=`*(self: TreeView; adjustment: Adjustment) =
  gtk_tree_view_set_hadjustment(cast[ptr TreeView00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_tree_view_set_headers_clickable*(self: ptr TreeView00; setting: gboolean) {.
    importc: "gtk_tree_view_set_headers_clickable", libprag.}

proc setHeadersClickable*(self: TreeView; setting: bool) =
  gtk_tree_view_set_headers_clickable(cast[ptr TreeView00](self.impl), gboolean(setting))

proc `headersClickable=`*(self: TreeView; setting: bool) =
  gtk_tree_view_set_headers_clickable(cast[ptr TreeView00](self.impl), gboolean(setting))

proc gtk_tree_view_set_headers_visible*(self: ptr TreeView00; headersVisible: gboolean) {.
    importc: "gtk_tree_view_set_headers_visible", libprag.}

proc setHeadersVisible*(self: TreeView; headersVisible: bool) =
  gtk_tree_view_set_headers_visible(cast[ptr TreeView00](self.impl), gboolean(headersVisible))

proc `headersVisible=`*(self: TreeView; headersVisible: bool) =
  gtk_tree_view_set_headers_visible(cast[ptr TreeView00](self.impl), gboolean(headersVisible))

proc gtk_tree_view_set_hover_expand*(self: ptr TreeView00; expand: gboolean) {.
    importc: "gtk_tree_view_set_hover_expand", libprag.}

proc setHoverExpand*(self: TreeView; expand: bool) =
  gtk_tree_view_set_hover_expand(cast[ptr TreeView00](self.impl), gboolean(expand))

proc `hoverExpand=`*(self: TreeView; expand: bool) =
  gtk_tree_view_set_hover_expand(cast[ptr TreeView00](self.impl), gboolean(expand))

proc gtk_tree_view_set_hover_selection*(self: ptr TreeView00; hover: gboolean) {.
    importc: "gtk_tree_view_set_hover_selection", libprag.}

proc setHoverSelection*(self: TreeView; hover: bool) =
  gtk_tree_view_set_hover_selection(cast[ptr TreeView00](self.impl), gboolean(hover))

proc `hoverSelection=`*(self: TreeView; hover: bool) =
  gtk_tree_view_set_hover_selection(cast[ptr TreeView00](self.impl), gboolean(hover))

proc gtk_tree_view_set_level_indentation*(self: ptr TreeView00; indentation: int32) {.
    importc: "gtk_tree_view_set_level_indentation", libprag.}

proc setLevelIndentation*(self: TreeView; indentation: int) =
  gtk_tree_view_set_level_indentation(cast[ptr TreeView00](self.impl), int32(indentation))

proc `levelIndentation=`*(self: TreeView; indentation: int) =
  gtk_tree_view_set_level_indentation(cast[ptr TreeView00](self.impl), int32(indentation))

proc gtk_tree_view_set_model*(self: ptr TreeView00; model: ptr TreeModel00) {.
    importc: "gtk_tree_view_set_model", libprag.}

proc setModel*(self: TreeView; model: TreeModel) =
  gtk_tree_view_set_model(cast[ptr TreeView00](self.impl), cast[ptr TreeModel00](model.impl))

proc `model=`*(self: TreeView; model: TreeModel) =
  gtk_tree_view_set_model(cast[ptr TreeView00](self.impl), cast[ptr TreeModel00](model.impl))

proc gtk_tree_view_set_reorderable*(self: ptr TreeView00; reorderable: gboolean) {.
    importc: "gtk_tree_view_set_reorderable", libprag.}

proc setReorderable*(self: TreeView; reorderable: bool) =
  gtk_tree_view_set_reorderable(cast[ptr TreeView00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: TreeView; reorderable: bool) =
  gtk_tree_view_set_reorderable(cast[ptr TreeView00](self.impl), gboolean(reorderable))

proc gtk_tree_view_set_rubber_banding*(self: ptr TreeView00; enable: gboolean) {.
    importc: "gtk_tree_view_set_rubber_banding", libprag.}

proc setRubberBanding*(self: TreeView; enable: bool) =
  gtk_tree_view_set_rubber_banding(cast[ptr TreeView00](self.impl), gboolean(enable))

proc `rubberBanding=`*(self: TreeView; enable: bool) =
  gtk_tree_view_set_rubber_banding(cast[ptr TreeView00](self.impl), gboolean(enable))

proc gtk_tree_view_set_rules_hint*(self: ptr TreeView00; setting: gboolean) {.
    importc: "gtk_tree_view_set_rules_hint", libprag.}

proc setRulesHint*(self: TreeView; setting: bool) =
  gtk_tree_view_set_rules_hint(cast[ptr TreeView00](self.impl), gboolean(setting))

proc `rulesHint=`*(self: TreeView; setting: bool) =
  gtk_tree_view_set_rules_hint(cast[ptr TreeView00](self.impl), gboolean(setting))

proc gtk_tree_view_set_search_column*(self: ptr TreeView00; column: int32) {.
    importc: "gtk_tree_view_set_search_column", libprag.}

proc setSearchColumn*(self: TreeView; column: int) =
  gtk_tree_view_set_search_column(cast[ptr TreeView00](self.impl), int32(column))

proc `searchColumn=`*(self: TreeView; column: int) =
  gtk_tree_view_set_search_column(cast[ptr TreeView00](self.impl), int32(column))

proc gtk_tree_view_set_search_entry*(self: ptr TreeView00; entry: ptr Entry00) {.
    importc: "gtk_tree_view_set_search_entry", libprag.}

proc setSearchEntry*(self: TreeView; entry: Entry) =
  gtk_tree_view_set_search_entry(cast[ptr TreeView00](self.impl), cast[ptr Entry00](entry.impl))

proc `searchEntry=`*(self: TreeView; entry: Entry) =
  gtk_tree_view_set_search_entry(cast[ptr TreeView00](self.impl), cast[ptr Entry00](entry.impl))

proc gtk_tree_view_set_show_expanders*(self: ptr TreeView00; enabled: gboolean) {.
    importc: "gtk_tree_view_set_show_expanders", libprag.}

proc setShowExpanders*(self: TreeView; enabled: bool) =
  gtk_tree_view_set_show_expanders(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc `showExpanders=`*(self: TreeView; enabled: bool) =
  gtk_tree_view_set_show_expanders(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc gtk_tree_view_set_tooltip_cell*(self: ptr TreeView00; tooltip: ptr Tooltip00; path: ptr TreePath00; 
    column: ptr TreeViewColumn00; cell: ptr CellRenderer00) {.
    importc: "gtk_tree_view_set_tooltip_cell", libprag.}

proc setTooltipCell*(self: TreeView; tooltip: Tooltip; path: TreePath; 
    column: TreeViewColumn; cell: CellRenderer) =
  gtk_tree_view_set_tooltip_cell(cast[ptr TreeView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeViewColumn00](column.impl), cast[ptr CellRenderer00](cell.impl))

proc gtk_tree_view_set_tooltip_column*(self: ptr TreeView00; column: int32) {.
    importc: "gtk_tree_view_set_tooltip_column", libprag.}

proc setTooltipColumn*(self: TreeView; column: int) =
  gtk_tree_view_set_tooltip_column(cast[ptr TreeView00](self.impl), int32(column))

proc `tooltipColumn=`*(self: TreeView; column: int) =
  gtk_tree_view_set_tooltip_column(cast[ptr TreeView00](self.impl), int32(column))

proc gtk_tree_view_set_tooltip_row*(self: ptr TreeView00; tooltip: ptr Tooltip00; path: ptr TreePath00) {.
    importc: "gtk_tree_view_set_tooltip_row", libprag.}

proc setTooltipRow*(self: TreeView; tooltip: Tooltip; path: TreePath) =
  gtk_tree_view_set_tooltip_row(cast[ptr TreeView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_view_set_vadjustment*(self: ptr TreeView00; adjustment: ptr Adjustment00) {.
    importc: "gtk_tree_view_set_vadjustment", libprag.}

proc setVadjustment*(self: TreeView; adjustment: Adjustment) =
  gtk_tree_view_set_vadjustment(cast[ptr TreeView00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `vadjustment=`*(self: TreeView; adjustment: Adjustment) =
  gtk_tree_view_set_vadjustment(cast[ptr TreeView00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_tree_view_unset_rows_drag_dest*(self: ptr TreeView00) {.
    importc: "gtk_tree_view_unset_rows_drag_dest", libprag.}

proc unsetRowsDragDest*(self: TreeView) =
  gtk_tree_view_unset_rows_drag_dest(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_unset_rows_drag_source*(self: ptr TreeView00) {.
    importc: "gtk_tree_view_unset_rows_drag_source", libprag.}

proc unsetRowsDragSource*(self: TreeView) =
  gtk_tree_view_unset_rows_drag_source(cast[ptr TreeView00](self.impl))

type
  TreeDestroyCountFunc* = proc (treeView: ptr TreeView00; path: ptr TreePath00; children: int32; 
    userData: pointer) {.cdecl.}

proc gtk_tree_view_set_destroy_count_func*(self: ptr TreeView00; `func`: TreeDestroyCountFunc; 
    data: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_view_set_destroy_count_func", libprag.}

proc setDestroyCountFunc*(self: TreeView; `func`: TreeDestroyCountFunc; data: pointer; 
    destroy: DestroyNotify) =
  gtk_tree_view_set_destroy_count_func(cast[ptr TreeView00](self.impl), `func`, data, destroy)

type
  TreeSelectionPrivate00* {.pure.} = object
  TreeSelectionPrivate* = ref object
    impl*: ptr TreeSelectionPrivate00

type
  TreeSelection* = ref object of gobject.Object
  TreeSelection00* = object of gobject.Object00
    priv1: ptr TreeSelectionPrivate00

proc scChanged*(self: TreeSelection;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_tree_selection_count_selected_rows*(self: ptr TreeSelection00): int32 {.
    importc: "gtk_tree_selection_count_selected_rows", libprag.}

proc countSelectedRows*(self: TreeSelection): int =
  int(gtk_tree_selection_count_selected_rows(cast[ptr TreeSelection00](self.impl)))

proc gtk_tree_selection_get_mode*(self: ptr TreeSelection00): SelectionMode {.
    importc: "gtk_tree_selection_get_mode", libprag.}

proc getMode*(self: TreeSelection): SelectionMode =
  gtk_tree_selection_get_mode(cast[ptr TreeSelection00](self.impl))

proc mode*(self: TreeSelection): SelectionMode =
  gtk_tree_selection_get_mode(cast[ptr TreeSelection00](self.impl))

proc gtk_tree_selection_get_selected*(self: ptr TreeSelection00; model: var ptr TreeModel00; 
    iter: var TreeIter00): gboolean {.
    importc: "gtk_tree_selection_get_selected", libprag.}

proc getSelected*(self: ptr TreeSelection00; model: var ptr TreeModel00; 
    iter: var TreeIter00): gboolean {.
    importc: "gtk_tree_selection_get_selected", libprag.}

proc selected*(self: ptr TreeSelection00; model: var ptr TreeModel00; 
    iter: var TreeIter00): gboolean {.
    importc: "gtk_tree_selection_get_selected", libprag.}

proc gtk_tree_selection_get_selected_rows*(self: ptr TreeSelection00; model: var ptr TreeModel00): ptr pointer {.
    importc: "gtk_tree_selection_get_selected_rows", libprag.}

proc getSelectedRows*(self: ptr TreeSelection00; model: var ptr TreeModel00): ptr pointer {.
    importc: "gtk_tree_selection_get_selected_rows", libprag.}

proc selectedRows*(self: ptr TreeSelection00; model: var ptr TreeModel00): ptr pointer {.
    importc: "gtk_tree_selection_get_selected_rows", libprag.}

proc gtk_tree_selection_get_tree_view*(self: ptr TreeSelection00): ptr TreeView00 {.
    importc: "gtk_tree_selection_get_tree_view", libprag.}

proc getTreeView*(self: TreeSelection): TreeView =
  let gobj = gtk_tree_selection_get_tree_view(cast[ptr TreeSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TreeView](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc treeView*(self: TreeSelection): TreeView =
  let gobj = gtk_tree_selection_get_tree_view(cast[ptr TreeSelection00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TreeView](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_selection_iter_is_selected*(self: ptr TreeSelection00; iter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_selection_iter_is_selected", libprag.}

proc iterIsSelected*(self: TreeSelection; iter: TreeIter): bool =
  toBool(gtk_tree_selection_iter_is_selected(cast[ptr TreeSelection00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_tree_selection_path_is_selected*(self: ptr TreeSelection00; path: ptr TreePath00): gboolean {.
    importc: "gtk_tree_selection_path_is_selected", libprag.}

proc pathIsSelected*(self: TreeSelection; path: TreePath): bool =
  toBool(gtk_tree_selection_path_is_selected(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_selection_select_all*(self: ptr TreeSelection00) {.
    importc: "gtk_tree_selection_select_all", libprag.}

proc selectAll*(self: TreeSelection) =
  gtk_tree_selection_select_all(cast[ptr TreeSelection00](self.impl))

proc gtk_tree_selection_select_iter*(self: ptr TreeSelection00; iter: ptr TreeIter00) {.
    importc: "gtk_tree_selection_select_iter", libprag.}

proc selectIter*(self: TreeSelection; iter: TreeIter) =
  gtk_tree_selection_select_iter(cast[ptr TreeSelection00](self.impl), cast[ptr TreeIter00](iter.impl))

proc gtk_tree_selection_select_path*(self: ptr TreeSelection00; path: ptr TreePath00) {.
    importc: "gtk_tree_selection_select_path", libprag.}

proc selectPath*(self: TreeSelection; path: TreePath) =
  gtk_tree_selection_select_path(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_selection_select_range*(self: ptr TreeSelection00; startPath: ptr TreePath00; 
    endPath: ptr TreePath00) {.
    importc: "gtk_tree_selection_select_range", libprag.}

proc selectRange*(self: TreeSelection; startPath: TreePath; endPath: TreePath) =
  gtk_tree_selection_select_range(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](startPath.impl), cast[ptr TreePath00](endPath.impl))

proc gtk_tree_selection_set_mode*(self: ptr TreeSelection00; `type`: SelectionMode) {.
    importc: "gtk_tree_selection_set_mode", libprag.}

proc setMode*(self: TreeSelection; `type`: SelectionMode) =
  gtk_tree_selection_set_mode(cast[ptr TreeSelection00](self.impl), `type`)

proc `mode=`*(self: TreeSelection; `type`: SelectionMode) =
  gtk_tree_selection_set_mode(cast[ptr TreeSelection00](self.impl), `type`)

proc gtk_tree_selection_unselect_all*(self: ptr TreeSelection00) {.
    importc: "gtk_tree_selection_unselect_all", libprag.}

proc unselectAll*(self: TreeSelection) =
  gtk_tree_selection_unselect_all(cast[ptr TreeSelection00](self.impl))

proc gtk_tree_selection_unselect_iter*(self: ptr TreeSelection00; iter: ptr TreeIter00) {.
    importc: "gtk_tree_selection_unselect_iter", libprag.}

proc unselectIter*(self: TreeSelection; iter: TreeIter) =
  gtk_tree_selection_unselect_iter(cast[ptr TreeSelection00](self.impl), cast[ptr TreeIter00](iter.impl))

proc gtk_tree_selection_unselect_path*(self: ptr TreeSelection00; path: ptr TreePath00) {.
    importc: "gtk_tree_selection_unselect_path", libprag.}

proc unselectPath*(self: TreeSelection; path: TreePath) =
  gtk_tree_selection_unselect_path(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_selection_unselect_range*(self: ptr TreeSelection00; startPath: ptr TreePath00; 
    endPath: ptr TreePath00) {.
    importc: "gtk_tree_selection_unselect_range", libprag.}

proc unselectRange*(self: TreeSelection; startPath: TreePath; endPath: TreePath) =
  gtk_tree_selection_unselect_range(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](startPath.impl), cast[ptr TreePath00](endPath.impl))

proc gtk_tree_view_get_selection*(self: ptr TreeView00): ptr TreeSelection00 {.
    importc: "gtk_tree_view_get_selection", libprag.}

proc getSelection*(self: TreeView): TreeSelection =
  let gobj = gtk_tree_view_get_selection(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TreeSelection](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selection*(self: TreeView): TreeSelection =
  let gobj = gtk_tree_view_get_selection(cast[ptr TreeView00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[TreeSelection](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TreeViewDropPosition* {.size: sizeof(cint), pure.} = enum
    before = 0
    after = 1
    intoOrBefore = 2
    intoOrAfter = 3

proc gtk_tree_view_get_dest_row_at_pos*(self: ptr TreeView00; dragX: int32; dragY: int32; 
    path: var ptr TreePath00; pos: var TreeViewDropPosition): gboolean {.
    importc: "gtk_tree_view_get_dest_row_at_pos", libprag.}

proc getDestRowAtPos*(self: ptr TreeView00; dragX: int32; dragY: int32; 
    path: var ptr TreePath00; pos: var TreeViewDropPosition): gboolean {.
    importc: "gtk_tree_view_get_dest_row_at_pos", libprag.}

proc destRowAtPos*(self: ptr TreeView00; dragX: int32; dragY: int32; 
    path: var ptr TreePath00; pos: var TreeViewDropPosition): gboolean {.
    importc: "gtk_tree_view_get_dest_row_at_pos", libprag.}

proc gtk_tree_view_get_drag_dest_row*(self: ptr TreeView00; path: var ptr TreePath00; pos: var TreeViewDropPosition) {.
    importc: "gtk_tree_view_get_drag_dest_row", libprag.}

proc getDragDestRow*(self: ptr TreeView00; path: var ptr TreePath00; pos: var TreeViewDropPosition) {.
    importc: "gtk_tree_view_get_drag_dest_row", libprag.}

proc dragDestRow*(self: ptr TreeView00; path: var ptr TreePath00; pos: var TreeViewDropPosition) {.
    importc: "gtk_tree_view_get_drag_dest_row", libprag.}

proc gtk_tree_view_set_drag_dest_row*(self: ptr TreeView00; path: ptr TreePath00; pos: TreeViewDropPosition) {.
    importc: "gtk_tree_view_set_drag_dest_row", libprag.}

proc setDragDestRow*(self: TreeView; path: TreePath; pos: TreeViewDropPosition) =
  gtk_tree_view_set_drag_dest_row(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), pos)

type
  TreeViewGridLines* {.size: sizeof(cint), pure.} = enum
    none = 0
    horizontal = 1
    vertical = 2
    both = 3

proc gtk_tree_view_get_grid_lines*(self: ptr TreeView00): TreeViewGridLines {.
    importc: "gtk_tree_view_get_grid_lines", libprag.}

proc getGridLines*(self: TreeView): TreeViewGridLines =
  gtk_tree_view_get_grid_lines(cast[ptr TreeView00](self.impl))

proc gridLines*(self: TreeView): TreeViewGridLines =
  gtk_tree_view_get_grid_lines(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_set_grid_lines*(self: ptr TreeView00; gridLines: TreeViewGridLines) {.
    importc: "gtk_tree_view_set_grid_lines", libprag.}

proc setGridLines*(self: TreeView; gridLines: TreeViewGridLines) =
  gtk_tree_view_set_grid_lines(cast[ptr TreeView00](self.impl), gridLines)

proc `gridLines=`*(self: TreeView; gridLines: TreeViewGridLines) =
  gtk_tree_view_set_grid_lines(cast[ptr TreeView00](self.impl), gridLines)

type
  TreeDragDest00* {.pure.} = object
  TreeDragDest* = ref object
    impl*: ptr TreeDragDest00

proc gtk_tree_drag_dest_drag_data_received*(self: ptr TreeDragDest00; dest: ptr TreePath00; selectionData: ptr SelectionData00): gboolean {.
    importc: "gtk_tree_drag_dest_drag_data_received", libprag.}

proc dragDataReceived*(self: TreeDragDest; dest: TreePath; selectionData: SelectionData): bool =
  toBool(gtk_tree_drag_dest_drag_data_received(cast[ptr TreeDragDest00](self.impl), cast[ptr TreePath00](dest.impl), cast[ptr SelectionData00](selectionData.impl)))

proc gtk_tree_drag_dest_row_drop_possible*(self: ptr TreeDragDest00; destPath: ptr TreePath00; 
    selectionData: ptr SelectionData00): gboolean {.
    importc: "gtk_tree_drag_dest_row_drop_possible", libprag.}

proc rowDropPossible*(self: TreeDragDest; destPath: TreePath; selectionData: SelectionData): bool =
  toBool(gtk_tree_drag_dest_row_drop_possible(cast[ptr TreeDragDest00](self.impl), cast[ptr TreePath00](destPath.impl), cast[ptr SelectionData00](selectionData.impl)))

type
  TreeDragDestIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    dragDataReceived*: proc(dragDest: ptr TreeDragDest00; dest: ptr TreePath00; 
    selectionData: ptr SelectionData00): gboolean {.cdecl.}
    rowDropPossible*: proc(dragDest: ptr TreeDragDest00; destPath: ptr TreePath00; 
    selectionData: ptr SelectionData00): gboolean {.cdecl.}
  TreeDragDestIface* = ref object
    impl*: ptr TreeDragDestIface00

type
  TreeDragSource00* {.pure.} = object
  TreeDragSource* = ref object
    impl*: ptr TreeDragSource00

proc gtk_tree_drag_source_drag_data_delete*(self: ptr TreeDragSource00; path: ptr TreePath00): gboolean {.
    importc: "gtk_tree_drag_source_drag_data_delete", libprag.}

proc dragDataDelete*(self: TreeDragSource; path: TreePath): bool =
  toBool(gtk_tree_drag_source_drag_data_delete(cast[ptr TreeDragSource00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_drag_source_drag_data_get*(self: ptr TreeDragSource00; path: ptr TreePath00; 
    selectionData: ptr SelectionData00): gboolean {.
    importc: "gtk_tree_drag_source_drag_data_get", libprag.}

proc dragDataGet*(self: TreeDragSource; path: TreePath; selectionData: SelectionData): bool =
  toBool(gtk_tree_drag_source_drag_data_get(cast[ptr TreeDragSource00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr SelectionData00](selectionData.impl)))

proc gtk_tree_drag_source_row_draggable*(self: ptr TreeDragSource00; path: ptr TreePath00): gboolean {.
    importc: "gtk_tree_drag_source_row_draggable", libprag.}

proc rowDraggable*(self: TreeDragSource; path: TreePath): bool =
  toBool(gtk_tree_drag_source_row_draggable(cast[ptr TreeDragSource00](self.impl), cast[ptr TreePath00](path.impl)))

type
  TreeDragSourceIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    rowDraggable*: proc(dragSource: ptr TreeDragSource00; path: ptr TreePath00): gboolean {.cdecl.}
    dragDataGet*: proc(dragSource: ptr TreeDragSource00; path: ptr TreePath00; 
    selectionData: ptr SelectionData00): gboolean {.cdecl.}
    dragDataDelete*: proc(dragSource: ptr TreeDragSource00; path: ptr TreePath00): gboolean {.cdecl.}
  TreeDragSourceIface* = ref object
    impl*: ptr TreeDragSourceIface00

type
  TreeIterCompareFunc* = proc (model: ptr TreeModel00; a: ptr TreeIter00; b: ptr TreeIter00; 
    userData: pointer): int32 {.cdecl.}

type
  TreeModelFilterPrivate00* {.pure.} = object
  TreeModelFilterPrivate* = ref object
    impl*: ptr TreeModelFilterPrivate00

type
  TreeModelFilter* = ref object of gobject.Object
  TreeModelFilter00* = object of gobject.Object00
    priv1: ptr TreeModelFilterPrivate00

proc gtk_tree_model_filter_clear_cache*(self: ptr TreeModelFilter00) {.
    importc: "gtk_tree_model_filter_clear_cache", libprag.}

proc clearCache*(self: TreeModelFilter) =
  gtk_tree_model_filter_clear_cache(cast[ptr TreeModelFilter00](self.impl))

proc gtk_tree_model_filter_convert_child_iter_to_iter*(self: ptr TreeModelFilter00; filterIter: var TreeIter00; 
    childIter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_filter_convert_child_iter_to_iter", libprag.}

proc convertChildIterToIter*(self: ptr TreeModelFilter00; filterIter: var TreeIter00; 
    childIter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_filter_convert_child_iter_to_iter", libprag.}

proc gtk_tree_model_filter_convert_child_path_to_path*(self: ptr TreeModelFilter00; childPath: ptr TreePath00): ptr TreePath00 {.
    importc: "gtk_tree_model_filter_convert_child_path_to_path", libprag.}

proc convertChildPathToPath*(self: TreeModelFilter; childPath: TreePath): TreePath =
  new(result)
  result.impl = gtk_tree_model_filter_convert_child_path_to_path(cast[ptr TreeModelFilter00](self.impl), cast[ptr TreePath00](childPath.impl))

proc gtk_tree_model_filter_convert_iter_to_child_iter*(self: ptr TreeModelFilter00; childIter: var TreeIter00; 
    filterIter: ptr TreeIter00) {.
    importc: "gtk_tree_model_filter_convert_iter_to_child_iter", libprag.}

proc convertIterToChildIter*(self: ptr TreeModelFilter00; childIter: var TreeIter00; 
    filterIter: ptr TreeIter00) {.
    importc: "gtk_tree_model_filter_convert_iter_to_child_iter", libprag.}

proc gtk_tree_model_filter_convert_path_to_child_path*(self: ptr TreeModelFilter00; filterPath: ptr TreePath00): ptr TreePath00 {.
    importc: "gtk_tree_model_filter_convert_path_to_child_path", libprag.}

proc convertPathToChildPath*(self: TreeModelFilter; filterPath: TreePath): TreePath =
  new(result)
  result.impl = gtk_tree_model_filter_convert_path_to_child_path(cast[ptr TreeModelFilter00](self.impl), cast[ptr TreePath00](filterPath.impl))

proc gtk_tree_model_filter_get_model*(self: ptr TreeModelFilter00): ptr TreeModel00 {.
    importc: "gtk_tree_model_filter_get_model", libprag.}

proc getModel*(self: TreeModelFilter): TreeModel =
  new(result)
  result.impl = gtk_tree_model_filter_get_model(cast[ptr TreeModelFilter00](self.impl))

proc model*(self: TreeModelFilter): TreeModel =
  new(result)
  result.impl = gtk_tree_model_filter_get_model(cast[ptr TreeModelFilter00](self.impl))

proc gtk_tree_model_filter_refilter*(self: ptr TreeModelFilter00) {.
    importc: "gtk_tree_model_filter_refilter", libprag.}

proc refilter*(self: TreeModelFilter) =
  gtk_tree_model_filter_refilter(cast[ptr TreeModelFilter00](self.impl))

proc gtk_tree_model_filter_set_visible_column*(self: ptr TreeModelFilter00; column: int32) {.
    importc: "gtk_tree_model_filter_set_visible_column", libprag.}

proc setVisibleColumn*(self: TreeModelFilter; column: int) =
  gtk_tree_model_filter_set_visible_column(cast[ptr TreeModelFilter00](self.impl), int32(column))

proc `visibleColumn=`*(self: TreeModelFilter; column: int) =
  gtk_tree_model_filter_set_visible_column(cast[ptr TreeModelFilter00](self.impl), int32(column))

type
  TreeModelFilterClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    visible*: proc(self: ptr TreeModelFilter00; childModel: ptr TreeModel00; 
    iter: ptr TreeIter00): gboolean {.cdecl.}
    modify*: proc(self: ptr TreeModelFilter00; childModel: ptr TreeModel00; 
    iter: ptr TreeIter00; value: ptr gobject.Value00; column: int32) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TreeModelFilterClass* = ref object
    impl*: ptr TreeModelFilterClass00

type
  TreeModelFilterModifyFunc* = proc (model: ptr TreeModel00; iter: ptr TreeIter00; value: var gobject.Value00; 
    column: int32; data: pointer) {.cdecl.}

proc gtk_tree_model_filter_set_modify_func*(self: ptr TreeModelFilter00; nColumns: int32; types: GTypeArray; 
    `func`: TreeModelFilterModifyFunc; data: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_model_filter_set_modify_func", libprag.}

proc setModifyFunc*(self: TreeModelFilter; nColumns: int; types: GTypeArray; 
    `func`: TreeModelFilterModifyFunc; data: pointer; destroy: DestroyNotify) =
  gtk_tree_model_filter_set_modify_func(cast[ptr TreeModelFilter00](self.impl), int32(nColumns), types, `func`, data, destroy)

type
  TreeModelFilterVisibleFunc* = proc (model: ptr TreeModel00; iter: ptr TreeIter00; data: pointer): gboolean {.cdecl.}

proc gtk_tree_model_filter_set_visible_func*(self: ptr TreeModelFilter00; `func`: TreeModelFilterVisibleFunc; 
    data: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_model_filter_set_visible_func", libprag.}

proc setVisibleFunc*(self: TreeModelFilter; `func`: TreeModelFilterVisibleFunc; 
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_model_filter_set_visible_func(cast[ptr TreeModelFilter00](self.impl), `func`, data, destroy)

type
  TreeModelForeachFunc* = proc (model: ptr TreeModel00; path: ptr TreePath00; iter: ptr TreeIter00; 
    data: pointer): gboolean {.cdecl.}

proc gtk_tree_model_foreach*(self: ptr TreeModel00; `func`: TreeModelForeachFunc; 
    userData: pointer) {.
    importc: "gtk_tree_model_foreach", libprag.}

proc foreach*(self: TreeModel; `func`: TreeModelForeachFunc; userData: pointer) =
  gtk_tree_model_foreach(cast[ptr TreeModel00](self.impl), `func`, userData)

type
  TreeModelIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    rowChanged*: proc(treeModel: ptr TreeModel00; path: ptr TreePath00; 
    iter: ptr TreeIter00) {.cdecl.}
    rowInserted*: proc(treeModel: ptr TreeModel00; path: ptr TreePath00; 
    iter: ptr TreeIter00) {.cdecl.}
    rowHasChildToggled*: proc(treeModel: ptr TreeModel00; path: ptr TreePath00; 
    iter: ptr TreeIter00) {.cdecl.}
    rowDeleted*: proc(treeModel: ptr TreeModel00; path: ptr TreePath00) {.cdecl.}
    rowsReordered*: proc(treeModel: ptr TreeModel00; path: ptr TreePath00; 
    iter: ptr TreeIter00; newOrder: ptr int32) {.cdecl.}
    getFlags*: proc(treeModel: ptr TreeModel00): TreeModelFlags {.cdecl.}
    getNColumns*: proc(treeModel: ptr TreeModel00): int32 {.cdecl.}
    getColumnType*: proc(treeModel: ptr TreeModel00; index: int32): GType {.cdecl.}
    getIter*: proc(treeModel: ptr TreeModel00; iter: var TreeIter00; 
    path: ptr TreePath00): gboolean {.cdecl.}
    getPath*: proc(treeModel: ptr TreeModel00; iter: ptr TreeIter00): ptr TreePath00 {.cdecl.}
    getValue*: proc(treeModel: ptr TreeModel00; iter: ptr TreeIter00; 
    column: int32; value: var gobject.Value00) {.cdecl.}
    iterNext*: proc(treeModel: ptr TreeModel00; iter: ptr TreeIter00): gboolean {.cdecl.}
    iterPrevious*: proc(treeModel: ptr TreeModel00; iter: ptr TreeIter00): gboolean {.cdecl.}
    iterChildren*: proc(treeModel: ptr TreeModel00; iter: var TreeIter00; 
    parent: ptr TreeIter00): gboolean {.cdecl.}
    iterHasChild*: proc(treeModel: ptr TreeModel00; iter: ptr TreeIter00): gboolean {.cdecl.}
    iterNChildren*: proc(treeModel: ptr TreeModel00; iter: ptr TreeIter00): int32 {.cdecl.}
    iterNthChild*: proc(treeModel: ptr TreeModel00; iter: var TreeIter00; 
    parent: ptr TreeIter00; n: int32): gboolean {.cdecl.}
    iterParent*: proc(treeModel: ptr TreeModel00; iter: var TreeIter00; 
    child: ptr TreeIter00): gboolean {.cdecl.}
    refNode*: proc(treeModel: ptr TreeModel00; iter: ptr TreeIter00) {.cdecl.}
    unrefNode*: proc(treeModel: ptr TreeModel00; iter: ptr TreeIter00) {.cdecl.}
  TreeModelIface* = ref object
    impl*: ptr TreeModelIface00

type
  TreeModelSortPrivate00* {.pure.} = object
  TreeModelSortPrivate* = ref object
    impl*: ptr TreeModelSortPrivate00

type
  TreeModelSort* = ref object of gobject.Object
  TreeModelSort00* = object of gobject.Object00
    priv1: ptr TreeModelSortPrivate00

proc gtk_tree_model_sort_clear_cache*(self: ptr TreeModelSort00) {.
    importc: "gtk_tree_model_sort_clear_cache", libprag.}

proc clearCache*(self: TreeModelSort) =
  gtk_tree_model_sort_clear_cache(cast[ptr TreeModelSort00](self.impl))

proc gtk_tree_model_sort_convert_child_iter_to_iter*(self: ptr TreeModelSort00; sortIter: var TreeIter00; 
    childIter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_sort_convert_child_iter_to_iter", libprag.}

proc convertChildIterToIter*(self: ptr TreeModelSort00; sortIter: var TreeIter00; 
    childIter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_sort_convert_child_iter_to_iter", libprag.}

proc gtk_tree_model_sort_convert_child_path_to_path*(self: ptr TreeModelSort00; childPath: ptr TreePath00): ptr TreePath00 {.
    importc: "gtk_tree_model_sort_convert_child_path_to_path", libprag.}

proc convertChildPathToPath*(self: TreeModelSort; childPath: TreePath): TreePath =
  new(result)
  result.impl = gtk_tree_model_sort_convert_child_path_to_path(cast[ptr TreeModelSort00](self.impl), cast[ptr TreePath00](childPath.impl))

proc gtk_tree_model_sort_convert_iter_to_child_iter*(self: ptr TreeModelSort00; childIter: var TreeIter00; 
    sortedIter: ptr TreeIter00) {.
    importc: "gtk_tree_model_sort_convert_iter_to_child_iter", libprag.}

proc convertIterToChildIter*(self: ptr TreeModelSort00; childIter: var TreeIter00; 
    sortedIter: ptr TreeIter00) {.
    importc: "gtk_tree_model_sort_convert_iter_to_child_iter", libprag.}

proc gtk_tree_model_sort_convert_path_to_child_path*(self: ptr TreeModelSort00; sortedPath: ptr TreePath00): ptr TreePath00 {.
    importc: "gtk_tree_model_sort_convert_path_to_child_path", libprag.}

proc convertPathToChildPath*(self: TreeModelSort; sortedPath: TreePath): TreePath =
  new(result)
  result.impl = gtk_tree_model_sort_convert_path_to_child_path(cast[ptr TreeModelSort00](self.impl), cast[ptr TreePath00](sortedPath.impl))

proc gtk_tree_model_sort_get_model*(self: ptr TreeModelSort00): ptr TreeModel00 {.
    importc: "gtk_tree_model_sort_get_model", libprag.}

proc getModel*(self: TreeModelSort): TreeModel =
  new(result)
  result.impl = gtk_tree_model_sort_get_model(cast[ptr TreeModelSort00](self.impl))

proc model*(self: TreeModelSort): TreeModel =
  new(result)
  result.impl = gtk_tree_model_sort_get_model(cast[ptr TreeModelSort00](self.impl))

proc gtk_tree_model_sort_iter_is_valid*(self: ptr TreeModelSort00; iter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_model_sort_iter_is_valid", libprag.}

proc iterIsValid*(self: TreeModelSort; iter: TreeIter): bool =
  toBool(gtk_tree_model_sort_iter_is_valid(cast[ptr TreeModelSort00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_tree_model_sort_reset_default_sort_func*(self: ptr TreeModelSort00) {.
    importc: "gtk_tree_model_sort_reset_default_sort_func", libprag.}

proc resetDefaultSortFunc*(self: TreeModelSort) =
  gtk_tree_model_sort_reset_default_sort_func(cast[ptr TreeModelSort00](self.impl))

type
  TreeModelSortClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TreeModelSortClass* = ref object
    impl*: ptr TreeModelSortClass00

type
  TreeRowReference00* {.pure.} = object
  TreeRowReference* = ref object
    impl*: ptr TreeRowReference00

proc gtk_tree_row_reference_new*(model: ptr TreeModel00; path: ptr TreePath00): ptr TreeRowReference00 {.
    importc: "gtk_tree_row_reference_new", libprag.}

proc newTreeRowReference*(model: TreeModel; path: TreePath): TreeRowReference =
  new(result)
  result.impl = gtk_tree_row_reference_new(cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc initTreeRowReference*[T](result: var T; model: TreeModel; path: TreePath) =
  assert(result is TreeRowReference)
  new(result)
  result.impl = gtk_tree_row_reference_new(cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_row_reference_new_proxy*(proxy: ptr gobject.Object00; model: ptr TreeModel00; 
    path: ptr TreePath00): ptr TreeRowReference00 {.
    importc: "gtk_tree_row_reference_new_proxy", libprag.}

proc newTreeRowReferenceProxy*(proxy: gobject.Object; model: TreeModel; path: TreePath): TreeRowReference =
  new(result)
  result.impl = gtk_tree_row_reference_new_proxy(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc initTreeRowReferenceProxy*[T](result: var T; proxy: gobject.Object; model: TreeModel; path: TreePath) =
  assert(result is TreeRowReference)
  new(result)
  result.impl = gtk_tree_row_reference_new_proxy(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_row_reference_copy*(self: ptr TreeRowReference00): ptr TreeRowReference00 {.
    importc: "gtk_tree_row_reference_copy", libprag.}

proc copy*(self: TreeRowReference): TreeRowReference =
  new(result)
  result.impl = gtk_tree_row_reference_copy(cast[ptr TreeRowReference00](self.impl))

proc gtk_tree_row_reference_free*(self: ptr TreeRowReference00) {.
    importc: "gtk_tree_row_reference_free", libprag.}

proc free*(self: TreeRowReference) =
  gtk_tree_row_reference_free(cast[ptr TreeRowReference00](self.impl))

proc gtk_tree_row_reference_get_model*(self: ptr TreeRowReference00): ptr TreeModel00 {.
    importc: "gtk_tree_row_reference_get_model", libprag.}

proc getModel*(self: TreeRowReference): TreeModel =
  new(result)
  result.impl = gtk_tree_row_reference_get_model(cast[ptr TreeRowReference00](self.impl))

proc model*(self: TreeRowReference): TreeModel =
  new(result)
  result.impl = gtk_tree_row_reference_get_model(cast[ptr TreeRowReference00](self.impl))

proc gtk_tree_row_reference_get_path*(self: ptr TreeRowReference00): ptr TreePath00 {.
    importc: "gtk_tree_row_reference_get_path", libprag.}

proc getPath*(self: TreeRowReference): TreePath =
  new(result)
  result.impl = gtk_tree_row_reference_get_path(cast[ptr TreeRowReference00](self.impl))

proc path*(self: TreeRowReference): TreePath =
  new(result)
  result.impl = gtk_tree_row_reference_get_path(cast[ptr TreeRowReference00](self.impl))

proc gtk_tree_row_reference_valid*(self: ptr TreeRowReference00): gboolean {.
    importc: "gtk_tree_row_reference_valid", libprag.}

proc valid*(self: TreeRowReference): bool =
  toBool(gtk_tree_row_reference_valid(cast[ptr TreeRowReference00](self.impl)))

proc gtk_tree_row_reference_deleted*(proxy: ptr gobject.Object00; path: ptr TreePath00) {.
    importc: "gtk_tree_row_reference_deleted", libprag.}

proc deleted*(proxy: gobject.Object; path: TreePath) =
  gtk_tree_row_reference_deleted(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_row_reference_inserted*(proxy: ptr gobject.Object00; path: ptr TreePath00) {.
    importc: "gtk_tree_row_reference_inserted", libprag.}

proc inserted*(proxy: gobject.Object; path: TreePath) =
  gtk_tree_row_reference_inserted(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreePath00](path.impl))

type
  TreeSelectionClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    changed*: proc(selection: ptr TreeSelection00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TreeSelectionClass* = ref object
    impl*: ptr TreeSelectionClass00

type
  TreeSelectionForeachFunc* = proc (model: ptr TreeModel00; path: ptr TreePath00; iter: ptr TreeIter00; 
    data: pointer) {.cdecl.}

proc gtk_tree_selection_selected_foreach*(self: ptr TreeSelection00; `func`: TreeSelectionForeachFunc; 
    data: pointer) {.
    importc: "gtk_tree_selection_selected_foreach", libprag.}

proc selectedForeach*(self: TreeSelection; `func`: TreeSelectionForeachFunc; 
    data: pointer) =
  gtk_tree_selection_selected_foreach(cast[ptr TreeSelection00](self.impl), `func`, data)

type
  TreeSelectionFunc* = proc (selection: ptr TreeSelection00; model: ptr TreeModel00; 
    path: ptr TreePath00; pathCurrentlySelected: gboolean; data: pointer): gboolean {.cdecl.}

proc gtk_tree_selection_set_select_function*(self: ptr TreeSelection00; `func`: TreeSelectionFunc; 
    data: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_selection_set_select_function", libprag.}

proc setSelectFunction*(self: TreeSelection; `func`: TreeSelectionFunc; data: pointer; 
    destroy: DestroyNotify) =
  gtk_tree_selection_set_select_function(cast[ptr TreeSelection00](self.impl), `func`, data, destroy)

type
  TreeSortable00* {.pure.} = object
  TreeSortable* = ref object
    impl*: ptr TreeSortable00

proc gtk_tree_sortable_get_sort_column_id*(self: ptr TreeSortable00; sortColumnId: var int32; 
    order: var SortType): gboolean {.
    importc: "gtk_tree_sortable_get_sort_column_id", libprag.}

proc getSortColumnId*(self: TreeSortable; sortColumnId: var int; order: var SortType): bool =
  var sortColumnId_00 = int32(sortColumnId)
  result = toBool(gtk_tree_sortable_get_sort_column_id(cast[ptr TreeSortable00](self.impl), sortColumnId_00, order))
  sortColumnId = int(sortColumnId_00)

proc sortColumnId*(self: TreeSortable; sortColumnId: var int; order: var SortType): bool =
  var sortColumnId_00 = int32(sortColumnId)
  result = toBool(gtk_tree_sortable_get_sort_column_id(cast[ptr TreeSortable00](self.impl), sortColumnId_00, order))
  sortColumnId = int(sortColumnId_00)

proc gtk_tree_sortable_has_default_sort_func*(self: ptr TreeSortable00): gboolean {.
    importc: "gtk_tree_sortable_has_default_sort_func", libprag.}

proc hasDefaultSortFunc*(self: TreeSortable): bool =
  toBool(gtk_tree_sortable_has_default_sort_func(cast[ptr TreeSortable00](self.impl)))

proc gtk_tree_sortable_set_default_sort_func*(self: ptr TreeSortable00; sortFunc: TreeIterCompareFunc; 
    userData: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_sortable_set_default_sort_func", libprag.}

proc setDefaultSortFunc*(self: TreeSortable; sortFunc: TreeIterCompareFunc; 
    userData: pointer; destroy: DestroyNotify) =
  gtk_tree_sortable_set_default_sort_func(cast[ptr TreeSortable00](self.impl), sortFunc, userData, destroy)

proc gtk_tree_sortable_set_sort_column_id*(self: ptr TreeSortable00; sortColumnId: int32; order: SortType) {.
    importc: "gtk_tree_sortable_set_sort_column_id", libprag.}

proc setSortColumnId*(self: TreeSortable; sortColumnId: int; order: SortType) =
  gtk_tree_sortable_set_sort_column_id(cast[ptr TreeSortable00](self.impl), int32(sortColumnId), order)

proc gtk_tree_sortable_set_sort_func*(self: ptr TreeSortable00; sortColumnId: int32; sortFunc: TreeIterCompareFunc; 
    userData: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_sortable_set_sort_func", libprag.}

proc setSortFunc*(self: TreeSortable; sortColumnId: int; sortFunc: TreeIterCompareFunc; 
    userData: pointer; destroy: DestroyNotify) =
  gtk_tree_sortable_set_sort_func(cast[ptr TreeSortable00](self.impl), int32(sortColumnId), sortFunc, userData, destroy)

proc gtk_tree_sortable_sort_column_changed*(self: ptr TreeSortable00) {.
    importc: "gtk_tree_sortable_sort_column_changed", libprag.}

proc sortColumnChanged*(self: TreeSortable) =
  gtk_tree_sortable_sort_column_changed(cast[ptr TreeSortable00](self.impl))

type
  TreeSortableIface00* {.pure.} = object
    gIface*: gobject.TypeInterface00
    sortColumnChanged*: proc(sortable: ptr TreeSortable00) {.cdecl.}
    getSortColumnId*: proc(sortable: ptr TreeSortable00; sortColumnId: var int32; 
    order: var SortType): gboolean {.cdecl.}
    setSortColumnId*: proc(sortable: ptr TreeSortable00; sortColumnId: int32; 
    order: SortType) {.cdecl.}
    setSortFunc*: proc(sortable: ptr TreeSortable00; sortColumnId: int32; 
    sortFunc: TreeIterCompareFunc; userData: pointer; destroy: DestroyNotify) {.cdecl.}
    setDefaultSortFunc*: proc(sortable: ptr TreeSortable00; sortFunc: TreeIterCompareFunc; 
    userData: pointer; destroy: DestroyNotify) {.cdecl.}
    hasDefaultSortFunc*: proc(sortable: ptr TreeSortable00): gboolean {.cdecl.}
  TreeSortableIface* = ref object
    impl*: ptr TreeSortableIface00

type
  TreeStorePrivate00* {.pure.} = object
  TreeStorePrivate* = ref object
    impl*: ptr TreeStorePrivate00

type
  TreeStore* = ref object of gobject.Object
  TreeStore00* = object of gobject.Object00
    priv1: ptr TreeStorePrivate00

proc gtk_tree_store_newv*(nColumns: int32; types: GTypeArray): ptr TreeStore00 {.
    importc: "gtk_tree_store_newv", libprag.}

proc newTreeStore*(nColumns: int; types: GTypeArray): TreeStore =
  new(result, finalizeGObject)
  result.impl = gtk_tree_store_newv(int32(nColumns), types)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeStore*[T](result: var T; nColumns: int; types: GTypeArray) =
  assert(result is TreeStore)
  new(result, finalizeGObject)
  result.impl = gtk_tree_store_newv(int32(nColumns), types)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_store_append*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00) {.
    importc: "gtk_tree_store_append", libprag.}

proc append*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00) {.
    importc: "gtk_tree_store_append", libprag.}

proc gtk_tree_store_clear*(self: ptr TreeStore00) {.
    importc: "gtk_tree_store_clear", libprag.}

proc clear*(self: TreeStore) =
  gtk_tree_store_clear(cast[ptr TreeStore00](self.impl))

proc gtk_tree_store_insert*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00; 
    position: int32) {.
    importc: "gtk_tree_store_insert", libprag.}

proc insert*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00; 
    position: int32) {.
    importc: "gtk_tree_store_insert", libprag.}

proc gtk_tree_store_insert_after*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00; 
    sibling: ptr TreeIter00) {.
    importc: "gtk_tree_store_insert_after", libprag.}

proc insertAfter*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00; 
    sibling: ptr TreeIter00) {.
    importc: "gtk_tree_store_insert_after", libprag.}

proc gtk_tree_store_insert_before*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00; 
    sibling: ptr TreeIter00) {.
    importc: "gtk_tree_store_insert_before", libprag.}

proc insertBefore*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00; 
    sibling: ptr TreeIter00) {.
    importc: "gtk_tree_store_insert_before", libprag.}

proc gtk_tree_store_insert_with_valuesv*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00; 
    position: int32; columns: int32Array; values: gobject.Value00Array; nValues: int32) {.
    importc: "gtk_tree_store_insert_with_valuesv", libprag.}

proc insertWithValues*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00; 
    position: int32; columns: int32Array; values: gobject.Value00Array; nValues: int32) {.
    importc: "gtk_tree_store_insert_with_valuesv", libprag.}

proc gtk_tree_store_is_ancestor*(self: ptr TreeStore00; iter: ptr TreeIter00; descendant: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_store_is_ancestor", libprag.}

proc isAncestor*(self: TreeStore; iter: TreeIter; descendant: TreeIter): bool =
  toBool(gtk_tree_store_is_ancestor(cast[ptr TreeStore00](self.impl), cast[ptr TreeIter00](iter.impl), cast[ptr TreeIter00](descendant.impl)))

proc gtk_tree_store_iter_depth*(self: ptr TreeStore00; iter: ptr TreeIter00): int32 {.
    importc: "gtk_tree_store_iter_depth", libprag.}

proc iterDepth*(self: TreeStore; iter: TreeIter): int =
  int(gtk_tree_store_iter_depth(cast[ptr TreeStore00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_tree_store_iter_is_valid*(self: ptr TreeStore00; iter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_store_iter_is_valid", libprag.}

proc iterIsValid*(self: TreeStore; iter: TreeIter): bool =
  toBool(gtk_tree_store_iter_is_valid(cast[ptr TreeStore00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_tree_store_move_after*(self: ptr TreeStore00; iter: ptr TreeIter00; position: ptr TreeIter00) {.
    importc: "gtk_tree_store_move_after", libprag.}

proc moveAfter*(self: TreeStore; iter: TreeIter; position: TreeIter) =
  gtk_tree_store_move_after(cast[ptr TreeStore00](self.impl), cast[ptr TreeIter00](iter.impl), cast[ptr TreeIter00](position.impl))

proc gtk_tree_store_move_before*(self: ptr TreeStore00; iter: ptr TreeIter00; position: ptr TreeIter00) {.
    importc: "gtk_tree_store_move_before", libprag.}

proc moveBefore*(self: TreeStore; iter: TreeIter; position: TreeIter) =
  gtk_tree_store_move_before(cast[ptr TreeStore00](self.impl), cast[ptr TreeIter00](iter.impl), cast[ptr TreeIter00](position.impl))

proc gtk_tree_store_prepend*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00) {.
    importc: "gtk_tree_store_prepend", libprag.}

proc prepend*(self: ptr TreeStore00; iter: var TreeIter00; parent: ptr TreeIter00) {.
    importc: "gtk_tree_store_prepend", libprag.}

proc gtk_tree_store_remove*(self: ptr TreeStore00; iter: ptr TreeIter00): gboolean {.
    importc: "gtk_tree_store_remove", libprag.}

proc remove*(self: TreeStore; iter: TreeIter): bool =
  toBool(gtk_tree_store_remove(cast[ptr TreeStore00](self.impl), cast[ptr TreeIter00](iter.impl)))

proc gtk_tree_store_set_column_types*(self: ptr TreeStore00; nColumns: int32; types: GTypeArray) {.
    importc: "gtk_tree_store_set_column_types", libprag.}

proc setColumnTypes*(self: TreeStore; nColumns: int; types: GTypeArray) =
  gtk_tree_store_set_column_types(cast[ptr TreeStore00](self.impl), int32(nColumns), types)

proc gtk_tree_store_set_value*(self: ptr TreeStore00; iter: ptr TreeIter00; column: int32; 
    value: ptr gobject.Value00) {.
    importc: "gtk_tree_store_set_value", libprag.}

proc setValue*(self: TreeStore; iter: TreeIter; column: int; value: gobject.Value) =
  gtk_tree_store_set_value(cast[ptr TreeStore00](self.impl), cast[ptr TreeIter00](iter.impl), int32(column), cast[ptr gobject.Value00](value.impl))

proc gtk_tree_store_set_valuesv*(self: ptr TreeStore00; iter: ptr TreeIter00; columns: int32Array; 
    values: gobject.Value00Array; nValues: int32) {.
    importc: "gtk_tree_store_set_valuesv", libprag.}

proc set*(self: TreeStore; iter: TreeIter; columns: int32Array; 
    values: gobject.Value00Array; nValues: int) =
  gtk_tree_store_set_valuesv(cast[ptr TreeStore00](self.impl), cast[ptr TreeIter00](iter.impl), columns, values, int32(nValues))

proc gtk_tree_store_swap*(self: ptr TreeStore00; a: ptr TreeIter00; b: ptr TreeIter00) {.
    importc: "gtk_tree_store_swap", libprag.}

proc swap*(self: TreeStore; a: TreeIter; b: TreeIter) =
  gtk_tree_store_swap(cast[ptr TreeStore00](self.impl), cast[ptr TreeIter00](a.impl), cast[ptr TreeIter00](b.impl))

type
  TreeStoreClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TreeStoreClass* = ref object
    impl*: ptr TreeStoreClass00

type
  TreeViewAccessiblePrivate00* {.pure.} = object
  TreeViewAccessiblePrivate* = ref object
    impl*: ptr TreeViewAccessiblePrivate00

type
  TreeViewAccessible* = ref object of ContainerAccessible
  TreeViewAccessible00* = object of ContainerAccessible00
    priv4: ptr TreeViewAccessiblePrivate00

type
  TreeViewAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  TreeViewAccessibleClass* = ref object
    impl*: ptr TreeViewAccessibleClass00

type
  TreeViewClass00* {.pure.} = object
    parentClass*: ContainerClass00
    rowActivated*: proc(treeView: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00) {.cdecl.}
    testExpandRow*: proc(treeView: ptr TreeView00; iter: ptr TreeIter00; path: ptr TreePath00): gboolean {.cdecl.}
    testCollapseRow*: proc(treeView: ptr TreeView00; iter: ptr TreeIter00; path: ptr TreePath00): gboolean {.cdecl.}
    rowExpanded*: proc(treeView: ptr TreeView00; iter: ptr TreeIter00; path: ptr TreePath00) {.cdecl.}
    rowCollapsed*: proc(treeView: ptr TreeView00; iter: ptr TreeIter00; path: ptr TreePath00) {.cdecl.}
    columnsChanged*: proc(treeView: ptr TreeView00) {.cdecl.}
    cursorChanged*: proc(treeView: ptr TreeView00) {.cdecl.}
    moveCursor*: proc(treeView: ptr TreeView00; step: MovementStep; count: int32): gboolean {.cdecl.}
    selectAll*: proc(treeView: ptr TreeView00): gboolean {.cdecl.}
    unselectAll*: proc(treeView: ptr TreeView00): gboolean {.cdecl.}
    selectCursorRow*: proc(treeView: ptr TreeView00; startEditing: gboolean): gboolean {.cdecl.}
    toggleCursorRow*: proc(treeView: ptr TreeView00): gboolean {.cdecl.}
    expandCollapseCursorRow*: proc(treeView: ptr TreeView00; logical: gboolean; expand: gboolean; 
    openAll: gboolean): gboolean {.cdecl.}
    selectCursorParent*: proc(treeView: ptr TreeView00): gboolean {.cdecl.}
    startInteractiveSearch*: proc(treeView: ptr TreeView00): gboolean {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
    gtkReserved5*: pointer
    gtkReserved6*: pointer
    gtkReserved7*: pointer
    gtkReserved8*: pointer
  TreeViewClass* = ref object
    impl*: ptr TreeViewClass00

type
  TreeViewColumnClass00* {.pure.} = object
    parentClass*: gobject.InitiallyUnownedClass00
    clicked*: proc(treeColumn: ptr TreeViewColumn00) {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  TreeViewColumnClass* = ref object
    impl*: ptr TreeViewColumnClass00

type
  TreeViewColumnDropFunc* = proc (treeView: ptr TreeView00; column: ptr TreeViewColumn00; 
    prevColumn: ptr TreeViewColumn00; nextColumn: ptr TreeViewColumn00; data: pointer): gboolean {.cdecl.}

proc gtk_tree_view_set_column_drag_function*(self: ptr TreeView00; `func`: TreeViewColumnDropFunc; 
    userData: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_view_set_column_drag_function", libprag.}

proc setColumnDragFunction*(self: TreeView; `func`: TreeViewColumnDropFunc; userData: pointer; 
    destroy: DestroyNotify) =
  gtk_tree_view_set_column_drag_function(cast[ptr TreeView00](self.impl), `func`, userData, destroy)

type
  TreeViewMappingFunc* = proc (treeView: ptr TreeView00; path: ptr TreePath00; userData: pointer) {.cdecl.}

proc gtk_tree_view_map_expanded_rows*(self: ptr TreeView00; `func`: TreeViewMappingFunc; 
    data: pointer) {.
    importc: "gtk_tree_view_map_expanded_rows", libprag.}

proc mapExpandedRows*(self: TreeView; `func`: TreeViewMappingFunc; data: pointer) =
  gtk_tree_view_map_expanded_rows(cast[ptr TreeView00](self.impl), `func`, data)

type
  TreeViewRowSeparatorFunc* = proc (model: ptr TreeModel00; iter: ptr TreeIter00; data: pointer): gboolean {.cdecl.}

proc gtk_combo_box_set_row_separator_func*(self: ptr ComboBox00; `func`: TreeViewRowSeparatorFunc; 
    data: pointer; destroy: DestroyNotify) {.
    importc: "gtk_combo_box_set_row_separator_func", libprag.}

proc setRowSeparatorFunc*(self: ComboBox; `func`: TreeViewRowSeparatorFunc; 
    data: pointer; destroy: DestroyNotify) =
  gtk_combo_box_set_row_separator_func(cast[ptr ComboBox00](self.impl), `func`, data, destroy)

proc gtk_tree_view_set_row_separator_func*(self: ptr TreeView00; `func`: TreeViewRowSeparatorFunc; 
    data: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_view_set_row_separator_func", libprag.}

proc setRowSeparatorFunc*(self: TreeView; `func`: TreeViewRowSeparatorFunc; 
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_view_set_row_separator_func(cast[ptr TreeView00](self.impl), `func`, data, destroy)

type
  TreeViewSearchEqualFunc* = proc (model: ptr TreeModel00; column: int32; key: cstring; 
    iter: ptr TreeIter00; searchData: pointer): gboolean {.cdecl.}

proc gtk_tree_view_set_search_equal_func*(self: ptr TreeView00; searchEqualFunc: TreeViewSearchEqualFunc; 
    searchUserData: pointer; searchDestroy: DestroyNotify) {.
    importc: "gtk_tree_view_set_search_equal_func", libprag.}

proc setSearchEqualFunc*(self: TreeView; searchEqualFunc: TreeViewSearchEqualFunc; 
    searchUserData: pointer; searchDestroy: DestroyNotify) =
  gtk_tree_view_set_search_equal_func(cast[ptr TreeView00](self.impl), searchEqualFunc, searchUserData, searchDestroy)

type
  TreeViewSearchPositionFunc* = proc (treeView: ptr TreeView00; searchDialog: ptr Widget00; 
    userData: pointer) {.cdecl.}

proc gtk_tree_view_set_search_position_func*(self: ptr TreeView00; `func`: TreeViewSearchPositionFunc; 
    data: pointer; destroy: DestroyNotify) {.
    importc: "gtk_tree_view_set_search_position_func", libprag.}

proc setSearchPositionFunc*(self: TreeView; `func`: TreeViewSearchPositionFunc; 
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_view_set_search_position_func(cast[ptr TreeView00](self.impl), `func`, data, destroy)

type
  UIManagerPrivate00* {.pure.} = object
  UIManagerPrivate* = ref object
    impl*: ptr UIManagerPrivate00

type
  UIManager* = ref object of gobject.Object
  UIManager00* = object of gobject.Object00
    privateData1: ptr UIManagerPrivate00

proc scActionsChanged*(self: UIManager;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "actions-changed", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scAddWidget*(self: UIManager;  p: proc (self: ptr gobject.Object00; widget: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "add-widget", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scConnectProxy*(self: UIManager;  p: proc (self: ptr gobject.Object00; action: Action00; proxy: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "connect-proxy", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scDisconnectProxy*(self: UIManager;  p: proc (self: ptr gobject.Object00; action: Action00; proxy: Widget00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "disconnect-proxy", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPostActivate*(self: UIManager;  p: proc (self: ptr gobject.Object00; action: Action00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "post-activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))
proc scPreActivate*(self: UIManager;  p: proc (self: ptr gobject.Object00; action: Action00; xdata: pointer) {.cdecl.}, xdata: pointer = nil) =
  discard g_signal_connect_data(self.impl, "pre-activate", cast[GCallback](p), xdata, nil, cast[ConnectFlags](0))

proc gtk_ui_manager_new*(): ptr UIManager00 {.
    importc: "gtk_ui_manager_new", libprag.}

proc newUIManager*(): UIManager =
  new(result, finalizeGObject)
  result.impl = gtk_ui_manager_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initUIManager*[T](result: var T) =
  assert(result is UIManager)
  new(result, finalizeGObject)
  result.impl = gtk_ui_manager_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_ui_manager_add_ui_from_file*(self: ptr UIManager00; filename: ucstring): uint32 {.
    importc: "gtk_ui_manager_add_ui_from_file", libprag.}

proc addUiFromFile*(self: UIManager; filename: ucstring): int =
  int(gtk_ui_manager_add_ui_from_file(cast[ptr UIManager00](self.impl), filename))

proc gtk_ui_manager_add_ui_from_resource*(self: ptr UIManager00; resourcePath: cstring): uint32 {.
    importc: "gtk_ui_manager_add_ui_from_resource", libprag.}

proc addUiFromResource*(self: UIManager; resourcePath: string): int =
  int(gtk_ui_manager_add_ui_from_resource(cast[ptr UIManager00](self.impl), cstring(resourcePath)))

proc gtk_ui_manager_add_ui_from_string*(self: ptr UIManager00; buffer: cstring; length: int64): uint32 {.
    importc: "gtk_ui_manager_add_ui_from_string", libprag.}

proc addUiFromString*(self: UIManager; buffer: string; length: int64): int =
  int(gtk_ui_manager_add_ui_from_string(cast[ptr UIManager00](self.impl), cstring(buffer), length))

proc gtk_ui_manager_ensure_update*(self: ptr UIManager00) {.
    importc: "gtk_ui_manager_ensure_update", libprag.}

proc ensureUpdate*(self: UIManager) =
  gtk_ui_manager_ensure_update(cast[ptr UIManager00](self.impl))

proc gtk_ui_manager_get_accel_group*(self: ptr UIManager00): ptr AccelGroup00 {.
    importc: "gtk_ui_manager_get_accel_group", libprag.}

proc getAccelGroup*(self: UIManager): AccelGroup =
  let gobj = gtk_ui_manager_get_accel_group(cast[ptr UIManager00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[AccelGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accelGroup*(self: UIManager): AccelGroup =
  let gobj = gtk_ui_manager_get_accel_group(cast[ptr UIManager00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[AccelGroup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_ui_manager_get_action*(self: ptr UIManager00; path: cstring): ptr Action00 {.
    importc: "gtk_ui_manager_get_action", libprag.}

proc getAction*(self: UIManager; path: string): Action =
  let gobj = gtk_ui_manager_get_action(cast[ptr UIManager00](self.impl), cstring(path))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Action](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc action*(self: UIManager; path: string): Action =
  let gobj = gtk_ui_manager_get_action(cast[ptr UIManager00](self.impl), cstring(path))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Action](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_ui_manager_get_action_groups*(self: ptr UIManager00): ptr pointer {.
    importc: "gtk_ui_manager_get_action_groups", libprag.}

proc getActionGroups*(self: UIManager): ptr pointer =
  gtk_ui_manager_get_action_groups(cast[ptr UIManager00](self.impl))

proc actionGroups*(self: UIManager): ptr pointer =
  gtk_ui_manager_get_action_groups(cast[ptr UIManager00](self.impl))

proc gtk_ui_manager_get_add_tearoffs*(self: ptr UIManager00): gboolean {.
    importc: "gtk_ui_manager_get_add_tearoffs", libprag.}

proc getAddTearoffs*(self: UIManager): bool =
  toBool(gtk_ui_manager_get_add_tearoffs(cast[ptr UIManager00](self.impl)))

proc addTearoffs*(self: UIManager): bool =
  toBool(gtk_ui_manager_get_add_tearoffs(cast[ptr UIManager00](self.impl)))

proc gtk_ui_manager_get_ui*(self: ptr UIManager00): cstring {.
    importc: "gtk_ui_manager_get_ui", libprag.}

proc getUi*(self: UIManager): string =
  let resul0 = gtk_ui_manager_get_ui(cast[ptr UIManager00](self.impl))
  result = $resul0
  cogfree(resul0)

proc ui*(self: UIManager): string =
  let resul0 = gtk_ui_manager_get_ui(cast[ptr UIManager00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_ui_manager_get_widget*(self: ptr UIManager00; path: cstring): ptr Widget00 {.
    importc: "gtk_ui_manager_get_widget", libprag.}

proc getWidget*(self: UIManager; path: string): Widget =
  let gobj = gtk_ui_manager_get_widget(cast[ptr UIManager00](self.impl), cstring(path))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: UIManager; path: string): Widget =
  let gobj = gtk_ui_manager_get_widget(cast[ptr UIManager00](self.impl), cstring(path))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_ui_manager_insert_action_group*(self: ptr UIManager00; actionGroup: ptr ActionGroup00; 
    pos: int32) {.
    importc: "gtk_ui_manager_insert_action_group", libprag.}

proc insertActionGroup*(self: UIManager; actionGroup: ActionGroup; pos: int) =
  gtk_ui_manager_insert_action_group(cast[ptr UIManager00](self.impl), cast[ptr ActionGroup00](actionGroup.impl), int32(pos))

proc gtk_ui_manager_new_merge_id*(self: ptr UIManager00): uint32 {.
    importc: "gtk_ui_manager_new_merge_id", libprag.}

proc newMergeId*(self: UIManager): int =
  int(gtk_ui_manager_new_merge_id(cast[ptr UIManager00](self.impl)))

proc gtk_ui_manager_remove_action_group*(self: ptr UIManager00; actionGroup: ptr ActionGroup00) {.
    importc: "gtk_ui_manager_remove_action_group", libprag.}

proc removeActionGroup*(self: UIManager; actionGroup: ActionGroup) =
  gtk_ui_manager_remove_action_group(cast[ptr UIManager00](self.impl), cast[ptr ActionGroup00](actionGroup.impl))

proc gtk_ui_manager_remove_ui*(self: ptr UIManager00; mergeId: uint32) {.
    importc: "gtk_ui_manager_remove_ui", libprag.}

proc removeUi*(self: UIManager; mergeId: int) =
  gtk_ui_manager_remove_ui(cast[ptr UIManager00](self.impl), uint32(mergeId))

proc gtk_ui_manager_set_add_tearoffs*(self: ptr UIManager00; addTearoffs: gboolean) {.
    importc: "gtk_ui_manager_set_add_tearoffs", libprag.}

proc setAddTearoffs*(self: UIManager; addTearoffs: bool) =
  gtk_ui_manager_set_add_tearoffs(cast[ptr UIManager00](self.impl), gboolean(addTearoffs))

proc `addTearoffs=`*(self: UIManager; addTearoffs: bool) =
  gtk_ui_manager_set_add_tearoffs(cast[ptr UIManager00](self.impl), gboolean(addTearoffs))

type
  UIManagerItemType* {.size: sizeof(cint), pure.} = enum
    auto = 0
    menubar = 1
    menu = 2
    toolbar = 4
    placeholder = 8
    popup = 16
    menuitem = 32
    toolitem = 64
    separator = 128
    accelerator = 256
    popupWithAccels = 512

proc gtk_ui_manager_add_ui*(self: ptr UIManager00; mergeId: uint32; path: cstring; 
    name: cstring; action: cstring; `type`: UIManagerItemType; top: gboolean) {.
    importc: "gtk_ui_manager_add_ui", libprag.}

proc addUi*(self: UIManager; mergeId: int; path: string; name: string; 
    action: string; `type`: UIManagerItemType; top: bool) =
  gtk_ui_manager_add_ui(cast[ptr UIManager00](self.impl), uint32(mergeId), cstring(path), cstring(name), cstring(action), `type`, gboolean(top))

proc gtk_ui_manager_get_toplevels*(self: ptr UIManager00; types: UIManagerItemType): ptr pointer {.
    importc: "gtk_ui_manager_get_toplevels", libprag.}

proc getToplevels*(self: UIManager; types: UIManagerItemType): ptr pointer =
  gtk_ui_manager_get_toplevels(cast[ptr UIManager00](self.impl), types)

proc toplevels*(self: UIManager; types: UIManagerItemType): ptr pointer =
  gtk_ui_manager_get_toplevels(cast[ptr UIManager00](self.impl), types)

type
  UIManagerClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    addWidget*: proc(manager: ptr UIManager00; widget: ptr Widget00) {.cdecl.}
    actionsChanged*: proc(manager: ptr UIManager00) {.cdecl.}
    connectProxy*: proc(manager: ptr UIManager00; action: ptr Action00; proxy: ptr Widget00) {.cdecl.}
    disconnectProxy*: proc(manager: ptr UIManager00; action: ptr Action00; proxy: ptr Widget00) {.cdecl.}
    preActivate*: proc(manager: ptr UIManager00; action: ptr Action00) {.cdecl.}
    postActivate*: proc(manager: ptr UIManager00; action: ptr Action00) {.cdecl.}
    getWidget*: proc(manager: ptr UIManager00; path: cstring): ptr Widget00 {.cdecl.}
    getAction*: proc(manager: ptr UIManager00; path: cstring): ptr Action00 {.cdecl.}
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  UIManagerClass* = ref object
    impl*: ptr UIManagerClass00

type
  VBox* = ref object of Box
  VBox00* = object of Box00

proc gtk_vbox_new*(homogeneous: gboolean; spacing: int32): ptr VBox00 {.
    importc: "gtk_vbox_new", libprag.}

proc newVBox*(homogeneous: bool; spacing: int): VBox =
  new(result, finalizeGObject)
  result.impl = gtk_vbox_new(gboolean(homogeneous), int32(spacing))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVBox*[T](result: var T; homogeneous: bool; spacing: int) =
  assert(result is VBox)
  new(result, finalizeGObject)
  result.impl = gtk_vbox_new(gboolean(homogeneous), int32(spacing))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VBoxClass00* {.pure.} = object
    parentClass*: BoxClass00
  VBoxClass* = ref object
    impl*: ptr VBoxClass00

type
  VButtonBox* = ref object of ButtonBox
  VButtonBox00* = object of ButtonBox00

proc gtk_vbutton_box_new*(): ptr VButtonBox00 {.
    importc: "gtk_vbutton_box_new", libprag.}

proc newVButtonBox*(): VButtonBox =
  new(result, finalizeGObject)
  result.impl = gtk_vbutton_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVButtonBox*[T](result: var T) =
  assert(result is VButtonBox)
  new(result, finalizeGObject)
  result.impl = gtk_vbutton_box_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VButtonBoxClass00* {.pure.} = object
    parentClass*: ButtonBoxClass00
  VButtonBoxClass* = ref object
    impl*: ptr VButtonBoxClass00

type
  VPaned* = ref object of Paned
  VPaned00* = object of Paned00

proc gtk_vpaned_new*(): ptr VPaned00 {.
    importc: "gtk_vpaned_new", libprag.}

proc newVPaned*(): VPaned =
  new(result, finalizeGObject)
  result.impl = gtk_vpaned_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVPaned*[T](result: var T) =
  assert(result is VPaned)
  new(result, finalizeGObject)
  result.impl = gtk_vpaned_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VPanedClass00* {.pure.} = object
    parentClass*: PanedClass00
  VPanedClass* = ref object
    impl*: ptr VPanedClass00

type
  VScale* = ref object of Scale
  VScale00* = object of Scale00

proc gtk_vscale_new*(adjustment: ptr Adjustment00): ptr VScale00 {.
    importc: "gtk_vscale_new", libprag.}

proc newVScale*(adjustment: Adjustment): VScale =
  new(result, finalizeGObject)
  result.impl = gtk_vscale_new(cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVScale*[T](result: var T; adjustment: Adjustment) =
  assert(result is VScale)
  new(result, finalizeGObject)
  result.impl = gtk_vscale_new(cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_vscale_new_with_range*(min: cdouble; max: cdouble; step: cdouble): ptr VScale00 {.
    importc: "gtk_vscale_new_with_range", libprag.}

proc newVScaleWithRange*(min: cdouble; max: cdouble; step: cdouble): VScale =
  new(result, finalizeGObject)
  result.impl = gtk_vscale_new_with_range(min, max, step)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVScaleWithRange*[T](result: var T; min: cdouble; max: cdouble; step: cdouble) =
  assert(result is VScale)
  new(result, finalizeGObject)
  result.impl = gtk_vscale_new_with_range(min, max, step)
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VScaleClass00* {.pure.} = object
    parentClass*: ScaleClass00
  VScaleClass* = ref object
    impl*: ptr VScaleClass00

type
  VScrollbar* = ref object of Scrollbar
  VScrollbar00* = object of Scrollbar00

proc gtk_vscrollbar_new*(adjustment: ptr Adjustment00): ptr VScrollbar00 {.
    importc: "gtk_vscrollbar_new", libprag.}

proc newVScrollbar*(adjustment: Adjustment): VScrollbar =
  new(result, finalizeGObject)
  result.impl = gtk_vscrollbar_new(cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVScrollbar*[T](result: var T; adjustment: Adjustment) =
  assert(result is VScrollbar)
  new(result, finalizeGObject)
  result.impl = gtk_vscrollbar_new(cast[ptr Adjustment00](adjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VScrollbarClass00* {.pure.} = object
    parentClass*: ScrollbarClass00
  VScrollbarClass* = ref object
    impl*: ptr VScrollbarClass00

type
  VSeparator* = ref object of Separator
  VSeparator00* = object of Separator00

proc gtk_vseparator_new*(): ptr VSeparator00 {.
    importc: "gtk_vseparator_new", libprag.}

proc newVSeparator*(): VSeparator =
  new(result, finalizeGObject)
  result.impl = gtk_vseparator_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVSeparator*[T](result: var T) =
  assert(result is VSeparator)
  new(result, finalizeGObject)
  result.impl = gtk_vseparator_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VSeparatorClass00* {.pure.} = object
    parentClass*: SeparatorClass00
  VSeparatorClass* = ref object
    impl*: ptr VSeparatorClass00

type
  ViewportPrivate00* {.pure.} = object
  ViewportPrivate* = ref object
    impl*: ptr ViewportPrivate00

type
  Viewport* = ref object of Bin
  Viewport00* = object of Bin00
    priv4: ptr ViewportPrivate00

proc gtk_viewport_new*(hadjustment: ptr Adjustment00; vadjustment: ptr Adjustment00): ptr Viewport00 {.
    importc: "gtk_viewport_new", libprag.}

proc newViewport*(hadjustment: Adjustment; vadjustment: Adjustment): Viewport =
  new(result, finalizeGObject)
  result.impl = gtk_viewport_new(cast[ptr Adjustment00](hadjustment.impl), cast[ptr Adjustment00](vadjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initViewport*[T](result: var T; hadjustment: Adjustment; vadjustment: Adjustment) =
  assert(result is Viewport)
  new(result, finalizeGObject)
  result.impl = gtk_viewport_new(cast[ptr Adjustment00](hadjustment.impl), cast[ptr Adjustment00](vadjustment.impl))
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_get_bin_window*(self: ptr Viewport00): ptr gdk.Window00 {.
    importc: "gtk_viewport_get_bin_window", libprag.}

proc getBinWindow*(self: Viewport): gdk.Window =
  let gobj = gtk_viewport_get_bin_window(cast[ptr Viewport00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc binWindow*(self: Viewport): gdk.Window =
  let gobj = gtk_viewport_get_bin_window(cast[ptr Viewport00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_get_hadjustment*(self: ptr Viewport00): ptr Adjustment00 {.
    importc: "gtk_viewport_get_hadjustment", libprag.}

proc getHadjustment*(self: Viewport): Adjustment =
  let gobj = gtk_viewport_get_hadjustment(cast[ptr Viewport00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: Viewport): Adjustment =
  let gobj = gtk_viewport_get_hadjustment(cast[ptr Viewport00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_get_shadow_type*(self: ptr Viewport00): ShadowType {.
    importc: "gtk_viewport_get_shadow_type", libprag.}

proc getShadowType*(self: Viewport): ShadowType =
  gtk_viewport_get_shadow_type(cast[ptr Viewport00](self.impl))

proc shadowType*(self: Viewport): ShadowType =
  gtk_viewport_get_shadow_type(cast[ptr Viewport00](self.impl))

proc gtk_viewport_get_vadjustment*(self: ptr Viewport00): ptr Adjustment00 {.
    importc: "gtk_viewport_get_vadjustment", libprag.}

proc getVadjustment*(self: Viewport): Adjustment =
  let gobj = gtk_viewport_get_vadjustment(cast[ptr Viewport00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: Viewport): Adjustment =
  let gobj = gtk_viewport_get_vadjustment(cast[ptr Viewport00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Adjustment](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_get_view_window*(self: ptr Viewport00): ptr gdk.Window00 {.
    importc: "gtk_viewport_get_view_window", libprag.}

proc getViewWindow*(self: Viewport): gdk.Window =
  let gobj = gtk_viewport_get_view_window(cast[ptr Viewport00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc viewWindow*(self: Viewport): gdk.Window =
  let gobj = gtk_viewport_get_view_window(cast[ptr Viewport00](self.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Window](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_set_hadjustment*(self: ptr Viewport00; adjustment: ptr Adjustment00) {.
    importc: "gtk_viewport_set_hadjustment", libprag.}

proc setHadjustment*(self: Viewport; adjustment: Adjustment) =
  gtk_viewport_set_hadjustment(cast[ptr Viewport00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `hadjustment=`*(self: Viewport; adjustment: Adjustment) =
  gtk_viewport_set_hadjustment(cast[ptr Viewport00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_viewport_set_shadow_type*(self: ptr Viewport00; `type`: ShadowType) {.
    importc: "gtk_viewport_set_shadow_type", libprag.}

proc setShadowType*(self: Viewport; `type`: ShadowType) =
  gtk_viewport_set_shadow_type(cast[ptr Viewport00](self.impl), `type`)

proc `shadowType=`*(self: Viewport; `type`: ShadowType) =
  gtk_viewport_set_shadow_type(cast[ptr Viewport00](self.impl), `type`)

proc gtk_viewport_set_vadjustment*(self: ptr Viewport00; adjustment: ptr Adjustment00) {.
    importc: "gtk_viewport_set_vadjustment", libprag.}

proc setVadjustment*(self: Viewport; adjustment: Adjustment) =
  gtk_viewport_set_vadjustment(cast[ptr Viewport00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `vadjustment=`*(self: Viewport; adjustment: Adjustment) =
  gtk_viewport_set_vadjustment(cast[ptr Viewport00](self.impl), cast[ptr Adjustment00](adjustment.impl))

type
  ViewportClass00* {.pure.} = object
    parentClass*: BinClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  ViewportClass* = ref object
    impl*: ptr ViewportClass00

type
  VolumeButton* = ref object of ScaleButton
  VolumeButton00* = object of ScaleButton00

proc gtk_volume_button_new*(): ptr VolumeButton00 {.
    importc: "gtk_volume_button_new", libprag.}

proc newVolumeButton*(): VolumeButton =
  new(result, finalizeGObject)
  result.impl = gtk_volume_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVolumeButton*[T](result: var T) =
  assert(result is VolumeButton)
  new(result, finalizeGObject)
  result.impl = gtk_volume_button_new()
  GC_ref(result)
  discard g_object_ref_sink(result.impl)
  g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
  g_object_unref(result.impl)
  assert(g_object_get_qdata(result.impl, Quark) == nil)
  g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VolumeButtonClass00* {.pure.} = object
    parentClass*: ScaleButtonClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  VolumeButtonClass* = ref object
    impl*: ptr VolumeButtonClass00

type
  WindowAccessiblePrivate00* {.pure.} = object
  WindowAccessiblePrivate* = ref object
    impl*: ptr WindowAccessiblePrivate00

type
  WindowAccessible* = ref object of ContainerAccessible
  WindowAccessible00* = object of ContainerAccessible00
    priv4: ptr WindowAccessiblePrivate00

type
  WindowAccessibleClass00* {.pure.} = object
    parentClass*: ContainerAccessibleClass00
  WindowAccessibleClass* = ref object
    impl*: ptr WindowAccessibleClass00

type
  WindowGeometryInfo00* {.pure.} = object
  WindowGeometryInfo* = ref object
    impl*: ptr WindowGeometryInfo00

type
  WindowGroupClass00* {.pure.} = object
    parentClass*: gobject.ObjectClass00
    gtkReserved1*: pointer
    gtkReserved2*: pointer
    gtkReserved3*: pointer
    gtkReserved4*: pointer
  WindowGroupClass* = ref object
    impl*: ptr WindowGroupClass00

proc gtk_accel_groups_activate*(`object`: ptr gobject.Object00; accelKey: uint32; 
    accelMods: gdk.ModifierType): gboolean {.
    importc: "gtk_accel_groups_activate", libprag.}

proc accelGroupsActivate*(`object`: gobject.Object; accelKey: int; accelMods: gdk.ModifierType): bool =
  toBool(gtk_accel_groups_activate(cast[ptr gobject.Object00](`object`.impl), uint32(accelKey), accelMods))

proc gtk_accel_groups_from_object*(`object`: ptr gobject.Object00): ptr pointer {.
    importc: "gtk_accel_groups_from_object", libprag.}

proc accelGroupsFromObject*(`object`: gobject.Object): ptr pointer =
  gtk_accel_groups_from_object(cast[ptr gobject.Object00](`object`.impl))

proc gtk_accelerator_get_default_mod_mask*(): gdk.ModifierType {.
    importc: "gtk_accelerator_get_default_mod_mask", libprag.}

proc acceleratorGetDefaultModMask*(): gdk.ModifierType {.
    importc: "gtk_accelerator_get_default_mod_mask", libprag.}

proc gtk_accelerator_get_label*(acceleratorKey: uint32; acceleratorMods: gdk.ModifierType): cstring {.
    importc: "gtk_accelerator_get_label", libprag.}

proc acceleratorGetLabel*(acceleratorKey: int; acceleratorMods: gdk.ModifierType): string =
  let resul0 = gtk_accelerator_get_label(uint32(acceleratorKey), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_get_label_with_keycode*(display: ptr gdk.Display00; acceleratorKey: uint32; 
    keycode: uint32; acceleratorMods: gdk.ModifierType): cstring {.
    importc: "gtk_accelerator_get_label_with_keycode", libprag.}

proc acceleratorGetLabelWithKeycode*(display: gdk.Display; acceleratorKey: int; keycode: int; 
    acceleratorMods: gdk.ModifierType): string =
  let resul0 = gtk_accelerator_get_label_with_keycode(cast[ptr gdk.Display00](display.impl), uint32(acceleratorKey), uint32(keycode), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_name*(acceleratorKey: uint32; acceleratorMods: gdk.ModifierType): cstring {.
    importc: "gtk_accelerator_name", libprag.}

proc acceleratorName*(acceleratorKey: int; acceleratorMods: gdk.ModifierType): string =
  let resul0 = gtk_accelerator_name(uint32(acceleratorKey), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_name_with_keycode*(display: ptr gdk.Display00; acceleratorKey: uint32; 
    keycode: uint32; acceleratorMods: gdk.ModifierType): cstring {.
    importc: "gtk_accelerator_name_with_keycode", libprag.}

proc acceleratorNameWithKeycode*(display: gdk.Display; acceleratorKey: int; keycode: int; 
    acceleratorMods: gdk.ModifierType): string =
  let resul0 = gtk_accelerator_name_with_keycode(cast[ptr gdk.Display00](display.impl), uint32(acceleratorKey), uint32(keycode), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_parse*(accelerator: cstring; acceleratorKey: var uint32; 
    acceleratorMods: var gdk.ModifierType) {.
    importc: "gtk_accelerator_parse", libprag.}

proc acceleratorParse*(accelerator: cstring; acceleratorKey: var uint32; 
    acceleratorMods: var gdk.ModifierType) {.
    importc: "gtk_accelerator_parse", libprag.}

proc gtk_accelerator_parse_with_keycode*(accelerator: cstring; acceleratorKey: var uint32; 
    acceleratorCodes: var uint32Array; acceleratorMods: var gdk.ModifierType) {.
    importc: "gtk_accelerator_parse_with_keycode", libprag.}

proc acceleratorParseWithKeycode*(accelerator: cstring; acceleratorKey: var uint32; 
    acceleratorCodes: var uint32Array; acceleratorMods: var gdk.ModifierType) {.
    importc: "gtk_accelerator_parse_with_keycode", libprag.}

proc gtk_accelerator_set_default_mod_mask*(defaultModMask: gdk.ModifierType) {.
    importc: "gtk_accelerator_set_default_mod_mask", libprag.}

proc acceleratorSetDefaultModMask*(defaultModMask: gdk.ModifierType) {.
    importc: "gtk_accelerator_set_default_mod_mask", libprag.}

proc gtk_accelerator_valid*(keyval: uint32; modifiers: gdk.ModifierType): gboolean {.
    importc: "gtk_accelerator_valid", libprag.}

proc acceleratorValid*(keyval: uint32; modifiers: gdk.ModifierType): gboolean {.
    importc: "gtk_accelerator_valid", libprag.}

proc gtk_alternative_dialog_button_order*(screen: ptr gdk.Screen00): gboolean {.
    importc: "gtk_alternative_dialog_button_order", libprag.}

proc alternativeDialogButtonOrder*(screen: gdk.Screen): bool =
  toBool(gtk_alternative_dialog_button_order(cast[ptr gdk.Screen00](screen.impl)))

proc gtk_bindings_activate*(`object`: ptr gobject.Object00; keyval: uint32; modifiers: gdk.ModifierType): gboolean {.
    importc: "gtk_bindings_activate", libprag.}

proc bindingsActivate*(`object`: gobject.Object; keyval: int; modifiers: gdk.ModifierType): bool =
  toBool(gtk_bindings_activate(cast[ptr gobject.Object00](`object`.impl), uint32(keyval), modifiers))

proc gtk_bindings_activate_event*(`object`: ptr gobject.Object00; event: ptr gdk.EventKey00): gboolean {.
    importc: "gtk_bindings_activate_event", libprag.}

proc bindingsActivateEvent*(`object`: gobject.Object; event: gdk.EventKey): bool =
  toBool(gtk_bindings_activate_event(cast[ptr gobject.Object00](`object`.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_cairo_should_draw_window*(cr: ptr cairo.Context00; window: ptr gdk.Window00): gboolean {.
    importc: "gtk_cairo_should_draw_window", libprag.}

proc cairoShouldDrawWindow*(cr: cairo.Context; window: gdk.Window): bool =
  toBool(gtk_cairo_should_draw_window(cast[ptr cairo.Context00](cr.impl), cast[ptr gdk.Window00](window.impl)))

proc gtk_cairo_transform_to_window*(cr: ptr cairo.Context00; widget: ptr Widget00; window: ptr gdk.Window00) {.
    importc: "gtk_cairo_transform_to_window", libprag.}

proc cairoTransformToWindow*(cr: cairo.Context; widget: Widget; window: gdk.Window) =
  gtk_cairo_transform_to_window(cast[ptr cairo.Context00](cr.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_check_version*(requiredMajor: uint32; requiredMinor: uint32; requiredMicro: uint32): cstring {.
    importc: "gtk_check_version", libprag.}

proc checkVersion*(requiredMajor: int; requiredMinor: int; requiredMicro: int): string =
  let resul0 = gtk_check_version(uint32(requiredMajor), uint32(requiredMinor), uint32(requiredMicro))
  result = $resul0

proc gtk_device_grab_add*(widget: ptr Widget00; device: ptr gdk.Device00; blockOthers: gboolean) {.
    importc: "gtk_device_grab_add", libprag.}

proc deviceGrabAdd*(widget: Widget; device: gdk.Device; blockOthers: bool) =
  gtk_device_grab_add(cast[ptr Widget00](widget.impl), cast[ptr gdk.Device00](device.impl), gboolean(blockOthers))

proc gtk_device_grab_remove*(widget: ptr Widget00; device: ptr gdk.Device00) {.
    importc: "gtk_device_grab_remove", libprag.}

proc deviceGrabRemove*(widget: Widget; device: gdk.Device) =
  gtk_device_grab_remove(cast[ptr Widget00](widget.impl), cast[ptr gdk.Device00](device.impl))

proc gtk_disable_setlocale*() {.
    importc: "gtk_disable_setlocale", libprag.}

proc disableSetlocale*() {.
    importc: "gtk_disable_setlocale", libprag.}

proc gtk_distribute_natural_allocation*(extraSpace: int32; nRequestedSizes: uint32; sizes: ptr RequestedSize00): int32 {.
    importc: "gtk_distribute_natural_allocation", libprag.}

proc distributeNaturalAllocation*(extraSpace: int; nRequestedSizes: int; sizes: RequestedSize): int =
  int(gtk_distribute_natural_allocation(int32(extraSpace), uint32(nRequestedSizes), cast[ptr RequestedSize00](sizes.impl)))

proc gtk_drag_cancel*(context: ptr gdk.DragContext00) {.
    importc: "gtk_drag_cancel", libprag.}

proc dragCancel*(context: gdk.DragContext) =
  gtk_drag_cancel(cast[ptr gdk.DragContext00](context.impl))

proc gtk_drag_finish*(context: ptr gdk.DragContext00; success: gboolean; 
    del: gboolean; time: uint32) {.
    importc: "gtk_drag_finish", libprag.}

proc dragFinish*(context: gdk.DragContext; success: bool; del: bool; 
    time: int) =
  gtk_drag_finish(cast[ptr gdk.DragContext00](context.impl), gboolean(success), gboolean(del), uint32(time))

proc gtk_drag_get_source_widget*(context: ptr gdk.DragContext00): ptr Widget00 {.
    importc: "gtk_drag_get_source_widget", libprag.}

proc dragGetSourceWidget*(context: gdk.DragContext): Widget =
  let gobj = gtk_drag_get_source_widget(cast[ptr gdk.DragContext00](context.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_set_icon_default*(context: ptr gdk.DragContext00) {.
    importc: "gtk_drag_set_icon_default", libprag.}

proc dragSetIconDefault*(context: gdk.DragContext) =
  gtk_drag_set_icon_default(cast[ptr gdk.DragContext00](context.impl))

proc gtk_drag_set_icon_gicon*(context: ptr gdk.DragContext00; icon: ptr gio.Icon00; 
    hotX: int32; hotY: int32) {.
    importc: "gtk_drag_set_icon_gicon", libprag.}

proc dragSetIconGicon*(context: gdk.DragContext; icon: gio.Icon; hotX: int; 
    hotY: int) =
  gtk_drag_set_icon_gicon(cast[ptr gdk.DragContext00](context.impl), cast[ptr gio.Icon00](icon.impl), int32(hotX), int32(hotY))

proc gtk_drag_set_icon_name*(context: ptr gdk.DragContext00; iconName: cstring; 
    hotX: int32; hotY: int32) {.
    importc: "gtk_drag_set_icon_name", libprag.}

proc dragSetIconName*(context: gdk.DragContext; iconName: string; hotX: int; 
    hotY: int) =
  gtk_drag_set_icon_name(cast[ptr gdk.DragContext00](context.impl), cstring(iconName), int32(hotX), int32(hotY))

proc gtk_drag_set_icon_pixbuf*(context: ptr gdk.DragContext00; pixbuf: ptr gdkpixbuf.Pixbuf00; 
    hotX: int32; hotY: int32) {.
    importc: "gtk_drag_set_icon_pixbuf", libprag.}

proc dragSetIconPixbuf*(context: gdk.DragContext; pixbuf: gdkpixbuf.Pixbuf; 
    hotX: int; hotY: int) =
  gtk_drag_set_icon_pixbuf(cast[ptr gdk.DragContext00](context.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl), int32(hotX), int32(hotY))

proc gtk_drag_set_icon_stock*(context: ptr gdk.DragContext00; stockId: cstring; 
    hotX: int32; hotY: int32) {.
    importc: "gtk_drag_set_icon_stock", libprag.}

proc dragSetIconStock*(context: gdk.DragContext; stockId: string; hotX: int; 
    hotY: int) =
  gtk_drag_set_icon_stock(cast[ptr gdk.DragContext00](context.impl), cstring(stockId), int32(hotX), int32(hotY))

proc gtk_drag_set_icon_surface*(context: ptr gdk.DragContext00; surface: ptr cairo.Surface00) {.
    importc: "gtk_drag_set_icon_surface", libprag.}

proc dragSetIconSurface*(context: gdk.DragContext; surface: cairo.Surface) =
  gtk_drag_set_icon_surface(cast[ptr gdk.DragContext00](context.impl), cast[ptr cairo.Surface00](surface.impl))

proc gtk_drag_set_icon_widget*(context: ptr gdk.DragContext00; widget: ptr Widget00; 
    hotX: int32; hotY: int32) {.
    importc: "gtk_drag_set_icon_widget", libprag.}

proc dragSetIconWidget*(context: gdk.DragContext; widget: Widget; hotX: int; 
    hotY: int) =
  gtk_drag_set_icon_widget(cast[ptr gdk.DragContext00](context.impl), cast[ptr Widget00](widget.impl), int32(hotX), int32(hotY))

proc gtk_draw_insertion_cursor*(widget: ptr Widget00; cr: ptr cairo.Context00; location: ptr gdk.Rectangle00; 
    isPrimary: gboolean; direction: TextDirection; drawArrow: gboolean) {.
    importc: "gtk_draw_insertion_cursor", libprag.}

proc drawInsertionCursor*(widget: Widget; cr: cairo.Context; location: gdk.Rectangle; 
    isPrimary: bool; direction: TextDirection; drawArrow: bool) =
  gtk_draw_insertion_cursor(cast[ptr Widget00](widget.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr gdk.Rectangle00](location.impl), gboolean(isPrimary), direction, gboolean(drawArrow))

proc gtk_events_pending*(): gboolean {.
    importc: "gtk_events_pending", libprag.}

proc eventsPending*(): gboolean {.
    importc: "gtk_events_pending", libprag.}

proc gtk_false*(): gboolean {.
    importc: "gtk_false", libprag.}

proc false*(): gboolean {.
    importc: "gtk_false", libprag.}

proc gtk_get_binary_age*(): uint32 {.
    importc: "gtk_get_binary_age", libprag.}

proc getBinaryAge*(): uint32 {.
    importc: "gtk_get_binary_age", libprag.}

proc binaryAge*(): uint32 {.
    importc: "gtk_get_binary_age", libprag.}

proc gtk_get_current_event*(): ptr gdk.Event00 {.
    importc: "gtk_get_current_event", libprag.}

proc getCurrentEvent*(): gdk.Event =
  new(result)
  result.impl = gtk_get_current_event()

proc currentEvent*(): gdk.Event =
  new(result)
  result.impl = gtk_get_current_event()

proc gtk_get_current_event_device*(): ptr gdk.Device00 {.
    importc: "gtk_get_current_event_device", libprag.}

proc getCurrentEventDevice*(): gdk.Device =
  let gobj = gtk_get_current_event_device()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Device](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc currentEventDevice*(): gdk.Device =
  let gobj = gtk_get_current_event_device()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdk.Device](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_get_current_event_state*(state: var gdk.ModifierType): gboolean {.
    importc: "gtk_get_current_event_state", libprag.}

proc getCurrentEventState*(state: var gdk.ModifierType): gboolean {.
    importc: "gtk_get_current_event_state", libprag.}

proc currentEventState*(state: var gdk.ModifierType): gboolean {.
    importc: "gtk_get_current_event_state", libprag.}

proc gtk_get_current_event_time*(): uint32 {.
    importc: "gtk_get_current_event_time", libprag.}

proc getCurrentEventTime*(): uint32 {.
    importc: "gtk_get_current_event_time", libprag.}

proc currentEventTime*(): uint32 {.
    importc: "gtk_get_current_event_time", libprag.}

proc gtk_get_debug_flags*(): uint32 {.
    importc: "gtk_get_debug_flags", libprag.}

proc getDebugFlags*(): uint32 {.
    importc: "gtk_get_debug_flags", libprag.}

proc debugFlags*(): uint32 {.
    importc: "gtk_get_debug_flags", libprag.}

proc gtk_get_default_language*(): ptr pango.Language00 {.
    importc: "gtk_get_default_language", libprag.}

proc getDefaultLanguage*(): pango.Language =
  new(result)
  result.impl = gtk_get_default_language()

proc defaultLanguage*(): pango.Language =
  new(result)
  result.impl = gtk_get_default_language()

proc gtk_get_event_widget*(event: ptr gdk.Event00): ptr Widget00 {.
    importc: "gtk_get_event_widget", libprag.}

proc getEventWidget*(event: gdk.Event): Widget =
  let gobj = gtk_get_event_widget(cast[ptr gdk.Event00](event.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc eventWidget*(event: gdk.Event): Widget =
  let gobj = gtk_get_event_widget(cast[ptr gdk.Event00](event.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_get_interface_age*(): uint32 {.
    importc: "gtk_get_interface_age", libprag.}

proc getInterfaceAge*(): uint32 {.
    importc: "gtk_get_interface_age", libprag.}

proc interfaceAge*(): uint32 {.
    importc: "gtk_get_interface_age", libprag.}

proc gtk_get_locale_direction*(): TextDirection {.
    importc: "gtk_get_locale_direction", libprag.}

proc getLocaleDirection*(): TextDirection {.
    importc: "gtk_get_locale_direction", libprag.}

proc localeDirection*(): TextDirection {.
    importc: "gtk_get_locale_direction", libprag.}

proc gtk_get_major_version*(): uint32 {.
    importc: "gtk_get_major_version", libprag.}

proc getMajorVersion*(): uint32 {.
    importc: "gtk_get_major_version", libprag.}

proc majorVersion*(): uint32 {.
    importc: "gtk_get_major_version", libprag.}

proc gtk_get_micro_version*(): uint32 {.
    importc: "gtk_get_micro_version", libprag.}

proc getMicroVersion*(): uint32 {.
    importc: "gtk_get_micro_version", libprag.}

proc microVersion*(): uint32 {.
    importc: "gtk_get_micro_version", libprag.}

proc gtk_get_minor_version*(): uint32 {.
    importc: "gtk_get_minor_version", libprag.}

proc getMinorVersion*(): uint32 {.
    importc: "gtk_get_minor_version", libprag.}

proc minorVersion*(): uint32 {.
    importc: "gtk_get_minor_version", libprag.}

proc gtk_get_option_group*(openDefaultDisplay: gboolean): ptr glib.OptionGroup00 {.
    importc: "gtk_get_option_group", libprag.}

proc getOptionGroup*(openDefaultDisplay: bool): glib.OptionGroup =
  new(result)
  result.impl = gtk_get_option_group(gboolean(openDefaultDisplay))

proc optionGroup*(openDefaultDisplay: bool): glib.OptionGroup =
  new(result)
  result.impl = gtk_get_option_group(gboolean(openDefaultDisplay))

proc gtk_grab_get_current*(): ptr Widget00 {.
    importc: "gtk_grab_get_current", libprag.}

proc grabGetCurrent*(): Widget =
  let gobj = gtk_grab_get_current()
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_init*(argc: int32; argv: cstringArray) {.
    importc: "gtk_init", libprag.}

proc init*(argc: int32; argv: cstringArray) {.
    importc: "gtk_init", libprag.}

proc gtk_init_check*(argc: int32; argv: cstringArray): gboolean {.
    importc: "gtk_init_check", libprag.}

proc initCheck*(argc: int32; argv: cstringArray): gboolean {.
    importc: "gtk_init_check", libprag.}

proc gtk_init_with_args*(argc: int32; argv: cstringArray; parameterString: cstring; 
    entries: glib.OptionEntry00Array; translationDomain: cstring): gboolean {.
    importc: "gtk_init_with_args", libprag.}

proc initWithArgs*(argc: int32; argv: cstringArray; parameterString: cstring; 
    entries: glib.OptionEntry00Array; translationDomain: cstring): gboolean {.
    importc: "gtk_init_with_args", libprag.}

proc gtk_key_snooper_remove*(snooperHandlerId: uint32) {.
    importc: "gtk_key_snooper_remove", libprag.}

proc keySnooperRemove*(snooperHandlerId: uint32) {.
    importc: "gtk_key_snooper_remove", libprag.}

proc gtk_main*() {.
    importc: "gtk_main", libprag.}

proc main*() {.
    importc: "gtk_main", libprag.}

proc gtk_main_do_event*(event: ptr gdk.Event00) {.
    importc: "gtk_main_do_event", libprag.}

proc mainDoEvent*(event: gdk.Event) =
  gtk_main_do_event(cast[ptr gdk.Event00](event.impl))

proc gtk_main_iteration*(): gboolean {.
    importc: "gtk_main_iteration", libprag.}

proc mainIteration*(): gboolean {.
    importc: "gtk_main_iteration", libprag.}

proc gtk_main_iteration_do*(blocking: gboolean): gboolean {.
    importc: "gtk_main_iteration_do", libprag.}

proc mainIterationDo*(blocking: gboolean): gboolean {.
    importc: "gtk_main_iteration_do", libprag.}

proc gtk_main_level*(): uint32 {.
    importc: "gtk_main_level", libprag.}

proc mainLevel*(): uint32 {.
    importc: "gtk_main_level", libprag.}

proc gtk_main_quit*() {.
    importc: "gtk_main_quit", libprag.}

proc mainQuit*() {.
    importc: "gtk_main_quit", libprag.}

proc gtk_paint_arrow*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; arrowType: ArrowType; 
    fill: gboolean; x: int32; y: int32; width: int32; height: int32) {.
    importc: "gtk_paint_arrow", libprag.}

proc paintArrow*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; arrowType: ArrowType; fill: bool; 
    x: int; y: int; width: int; height: int) =
  gtk_paint_arrow(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), arrowType, gboolean(fill), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_box*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.
    importc: "gtk_paint_box", libprag.}

proc paintBox*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int) =
  gtk_paint_box(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_box_gap*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; gapSide: PositionType; gapX: int32; gapWidth: int32) {.
    importc: "gtk_paint_box_gap", libprag.}

proc paintBoxGap*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int; 
    gapSide: PositionType; gapX: int; gapWidth: int) =
  gtk_paint_box_gap(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height), gapSide, int32(gapX), int32(gapWidth))

proc gtk_paint_check*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.
    importc: "gtk_paint_check", libprag.}

proc paintCheck*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int) =
  gtk_paint_check(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_diamond*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.
    importc: "gtk_paint_diamond", libprag.}

proc paintDiamond*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int) =
  gtk_paint_diamond(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_expander*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; x: int32; y: int32; expanderStyle: ExpanderStyle) {.
    importc: "gtk_paint_expander", libprag.}

proc paintExpander*(style: Style; cr: cairo.Context; stateType: StateType; 
    widget: Widget; detail: string; x: int; y: int; expanderStyle: ExpanderStyle) =
  gtk_paint_expander(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), expanderStyle)

proc gtk_paint_extension*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; gapSide: PositionType) {.
    importc: "gtk_paint_extension", libprag.}

proc paintExtension*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int; 
    gapSide: PositionType) =
  gtk_paint_extension(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height), gapSide)

proc gtk_paint_flat_box*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.
    importc: "gtk_paint_flat_box", libprag.}

proc paintFlatBox*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int) =
  gtk_paint_flat_box(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_focus*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; x: int32; y: int32; width: int32; height: int32) {.
    importc: "gtk_paint_focus", libprag.}

proc paintFocus*(style: Style; cr: cairo.Context; stateType: StateType; 
    widget: Widget; detail: string; x: int; y: int; width: int; height: int) =
  gtk_paint_focus(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_handle*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; orientation: Orientation) {.
    importc: "gtk_paint_handle", libprag.}

proc paintHandle*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int; 
    orientation: Orientation) =
  gtk_paint_handle(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height), orientation)

proc gtk_paint_hline*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; x1: int32; x2: int32; y: int32) {.
    importc: "gtk_paint_hline", libprag.}

proc paintHline*(style: Style; cr: cairo.Context; stateType: StateType; 
    widget: Widget; detail: string; x1: int; x2: int; y: int) =
  gtk_paint_hline(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x1), int32(x2), int32(y))

proc gtk_paint_layout*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    useText: gboolean; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    layout: ptr pango.Layout00) {.
    importc: "gtk_paint_layout", libprag.}

proc paintLayout*(style: Style; cr: cairo.Context; stateType: StateType; 
    useText: bool; widget: Widget; detail: string; x: int; y: int; layout: pango.Layout) =
  gtk_paint_layout(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, gboolean(useText), cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), cast[ptr pango.Layout00](layout.impl))

proc gtk_paint_option*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.
    importc: "gtk_paint_option", libprag.}

proc paintOption*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int) =
  gtk_paint_option(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_resize_grip*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; edge: gdk.WindowEdge; x: int32; y: int32; 
    width: int32; height: int32) {.
    importc: "gtk_paint_resize_grip", libprag.}

proc paintResizeGrip*(style: Style; cr: cairo.Context; stateType: StateType; 
    widget: Widget; detail: string; edge: gdk.WindowEdge; x: int; y: int; width: int; height: int) =
  gtk_paint_resize_grip(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, cast[ptr Widget00](widget.impl), cstring(detail), edge, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_shadow*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.
    importc: "gtk_paint_shadow", libprag.}

proc paintShadow*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int) =
  gtk_paint_shadow(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_shadow_gap*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; gapSide: PositionType; gapX: int32; gapWidth: int32) {.
    importc: "gtk_paint_shadow_gap", libprag.}

proc paintShadowGap*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int; 
    gapSide: PositionType; gapX: int; gapWidth: int) =
  gtk_paint_shadow_gap(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height), gapSide, int32(gapX), int32(gapWidth))

proc gtk_paint_slider*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32; orientation: Orientation) {.
    importc: "gtk_paint_slider", libprag.}

proc paintSlider*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int; 
    orientation: Orientation) =
  gtk_paint_slider(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height), orientation)

proc gtk_paint_spinner*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; step: uint32; x: int32; y: int32; width: int32; 
    height: int32) {.
    importc: "gtk_paint_spinner", libprag.}

proc paintSpinner*(style: Style; cr: cairo.Context; stateType: StateType; 
    widget: Widget; detail: string; step: int; x: int; y: int; width: int; height: int) =
  gtk_paint_spinner(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, cast[ptr Widget00](widget.impl), cstring(detail), uint32(step), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_tab*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32; y: int32; 
    width: int32; height: int32) {.
    importc: "gtk_paint_tab", libprag.}

proc paintTab*(style: Style; cr: cairo.Context; stateType: StateType; 
    shadowType: ShadowType; widget: Widget; detail: string; x: int; y: int; width: int; height: int) =
  gtk_paint_tab(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, cast[ptr Widget00](widget.impl), cstring(detail), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_vline*(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType; 
    widget: ptr Widget00; detail: cstring; y1: int32; y2: int32; x: int32) {.
    importc: "gtk_paint_vline", libprag.}

proc paintVline*(style: Style; cr: cairo.Context; stateType: StateType; 
    widget: Widget; detail: string; y1: int; y2: int; x: int) =
  gtk_paint_vline(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, cast[ptr Widget00](widget.impl), cstring(detail), int32(y1), int32(y2), int32(x))

proc gtk_parse_args*(argc: int32; argv: cstringArray): gboolean {.
    importc: "gtk_parse_args", libprag.}

proc parseArgs*(argc: int32; argv: cstringArray): gboolean {.
    importc: "gtk_parse_args", libprag.}

proc gtk_print_run_page_setup_dialog*(parent: ptr Window00; pageSetup: ptr PageSetup00; 
    settings: ptr PrintSettings00): ptr PageSetup00 {.
    importc: "gtk_print_run_page_setup_dialog", libprag.}

proc printRunPageSetupDialog*(parent: Window; pageSetup: PageSetup; settings: PrintSettings): PageSetup =
  let gobj = gtk_print_run_page_setup_dialog(cast[ptr Window00](parent.impl), cast[ptr PageSetup00](pageSetup.impl), cast[ptr PrintSettings00](settings.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[PageSetup](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_run_page_setup_dialog_async*(parent: ptr Window00; pageSetup: ptr PageSetup00; 
    settings: ptr PrintSettings00; doneCb: PageSetupDoneFunc; data: pointer) {.
    importc: "gtk_print_run_page_setup_dialog_async", libprag.}

proc printRunPageSetupDialogAsync*(parent: Window; pageSetup: PageSetup; settings: PrintSettings; 
    doneCb: PageSetupDoneFunc; data: pointer) =
  gtk_print_run_page_setup_dialog_async(cast[ptr Window00](parent.impl), cast[ptr PageSetup00](pageSetup.impl), cast[ptr PrintSettings00](settings.impl), doneCb, data)

proc gtk_propagate_event*(widget: ptr Widget00; event: ptr gdk.Event00) {.
    importc: "gtk_propagate_event", libprag.}

proc propagateEvent*(widget: Widget; event: gdk.Event) =
  gtk_propagate_event(cast[ptr Widget00](widget.impl), cast[ptr gdk.Event00](event.impl))

proc gtk_rc_add_default_file*(filename: ucstring) {.
    importc: "gtk_rc_add_default_file", libprag.}

proc rcAddDefaultFile*(filename: ucstring) {.
    importc: "gtk_rc_add_default_file", libprag.}

proc gtk_rc_find_module_in_path*(moduleFile: cstring): ucstring {.
    importc: "gtk_rc_find_module_in_path", libprag.}

proc rcFindModuleInPath*(moduleFile: cstring): ucstring {.
    importc: "gtk_rc_find_module_in_path", libprag.}

proc gtk_rc_find_pixmap_in_path*(settings: ptr Settings00; scanner: ptr glib.Scanner00; 
    pixmapFile: cstring): ucstring {.
    importc: "gtk_rc_find_pixmap_in_path", libprag.}

proc rcFindPixmapInPath*(settings: Settings; scanner: glib.Scanner; pixmapFile: string): ucstring =
  gtk_rc_find_pixmap_in_path(cast[ptr Settings00](settings.impl), cast[ptr glib.Scanner00](scanner.impl), cstring(pixmapFile))

proc gtk_rc_get_default_files*(): ucstringArray {.
    importc: "gtk_rc_get_default_files", libprag.}

proc rcGetDefaultFiles*(): ucstringArray {.
    importc: "gtk_rc_get_default_files", libprag.}

proc gtk_rc_get_im_module_file*(): ucstring {.
    importc: "gtk_rc_get_im_module_file", libprag.}

proc rcGetImModuleFile*(): ucstring {.
    importc: "gtk_rc_get_im_module_file", libprag.}

proc gtk_rc_get_im_module_path*(): ucstring {.
    importc: "gtk_rc_get_im_module_path", libprag.}

proc rcGetImModulePath*(): ucstring {.
    importc: "gtk_rc_get_im_module_path", libprag.}

proc gtk_rc_get_module_dir*(): ucstring {.
    importc: "gtk_rc_get_module_dir", libprag.}

proc rcGetModuleDir*(): ucstring {.
    importc: "gtk_rc_get_module_dir", libprag.}

proc gtk_rc_get_style*(widget: ptr Widget00): ptr Style00 {.
    importc: "gtk_rc_get_style", libprag.}

proc rcGetStyle*(widget: Widget): Style =
  let gobj = gtk_rc_get_style(cast[ptr Widget00](widget.impl))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Style](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_rc_get_style_by_paths*(settings: ptr Settings00; widgetPath: cstring; classPath: cstring; 
    `type`: GType): ptr Style00 {.
    importc: "gtk_rc_get_style_by_paths", libprag.}

proc rcGetStyleByPaths*(settings: Settings; widgetPath: string; classPath: string; 
    `type`: GType): Style =
  let gobj = gtk_rc_get_style_by_paths(cast[ptr Settings00](settings.impl), cstring(widgetPath), cstring(classPath), `type`)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Style](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_rc_get_theme_dir*(): cstring {.
    importc: "gtk_rc_get_theme_dir", libprag.}

proc rcGetThemeDir*(): string =
  let resul0 = gtk_rc_get_theme_dir()
  result = $resul0
  cogfree(resul0)

proc gtk_rc_parse*(filename: cstring) {.
    importc: "gtk_rc_parse", libprag.}

proc rcParse*(filename: cstring) {.
    importc: "gtk_rc_parse", libprag.}

proc gtk_rc_parse_color*(scanner: ptr glib.Scanner00; color: var gdk.Color00): uint32 {.
    importc: "gtk_rc_parse_color", libprag.}

proc rcParseColor*(scanner: ptr glib.Scanner00; color: var gdk.Color00): uint32 {.
    importc: "gtk_rc_parse_color", libprag.}

proc gtk_rc_parse_color_full*(scanner: ptr glib.Scanner00; style: ptr RcStyle00; 
    color: var gdk.Color00): uint32 {.
    importc: "gtk_rc_parse_color_full", libprag.}

proc rcParseColorFull*(scanner: ptr glib.Scanner00; style: ptr RcStyle00; 
    color: var gdk.Color00): uint32 {.
    importc: "gtk_rc_parse_color_full", libprag.}

proc gtk_rc_parse_priority*(scanner: ptr glib.Scanner00; priority: ptr PathPriorityType): uint32 {.
    importc: "gtk_rc_parse_priority", libprag.}

proc rcParsePriority*(scanner: glib.Scanner; priority: ptr PathPriorityType): int =
  int(gtk_rc_parse_priority(cast[ptr glib.Scanner00](scanner.impl), priority))

proc gtk_rc_parse_state*(scanner: ptr glib.Scanner00; state: var StateType): uint32 {.
    importc: "gtk_rc_parse_state", libprag.}

proc rcParseState*(scanner: glib.Scanner; state: var StateType): int =
  int(gtk_rc_parse_state(cast[ptr glib.Scanner00](scanner.impl), state))

proc gtk_rc_parse_string*(rcString: cstring) {.
    importc: "gtk_rc_parse_string", libprag.}

proc rcParseString*(rcString: cstring) {.
    importc: "gtk_rc_parse_string", libprag.}

proc gtk_rc_reparse_all*(): gboolean {.
    importc: "gtk_rc_reparse_all", libprag.}

proc rcReparseAll*(): gboolean {.
    importc: "gtk_rc_reparse_all", libprag.}

proc gtk_rc_reparse_all_for_settings*(settings: ptr Settings00; forceLoad: gboolean): gboolean {.
    importc: "gtk_rc_reparse_all_for_settings", libprag.}

proc rcReparseAllForSettings*(settings: Settings; forceLoad: bool): bool =
  toBool(gtk_rc_reparse_all_for_settings(cast[ptr Settings00](settings.impl), gboolean(forceLoad)))

proc gtk_rc_reset_styles*(settings: ptr Settings00) {.
    importc: "gtk_rc_reset_styles", libprag.}

proc rcResetStyles*(settings: Settings) =
  gtk_rc_reset_styles(cast[ptr Settings00](settings.impl))

proc gtk_rc_set_default_files*(filenames: ucstringArray) {.
    importc: "gtk_rc_set_default_files", libprag.}

proc rcSetDefaultFiles*(filenames: ucstringArray) {.
    importc: "gtk_rc_set_default_files", libprag.}

proc gtk_render_activity*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc: "gtk_render_activity", libprag.}

proc renderActivity*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_activity(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_arrow*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    angle: cdouble; x: cdouble; y: cdouble; size: cdouble) {.
    importc: "gtk_render_arrow", libprag.}

proc renderArrow*(context: StyleContext; cr: cairo.Context; angle: cdouble; 
    x: cdouble; y: cdouble; size: cdouble) =
  gtk_render_arrow(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), angle, x, y, size)

proc gtk_render_background*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc: "gtk_render_background", libprag.}

proc renderBackground*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_background(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_background_get_clip*(context: ptr StyleContext00; x: cdouble; y: cdouble; 
    width: cdouble; height: cdouble; outClip: var gdk.Rectangle00) {.
    importc: "gtk_render_background_get_clip", libprag.}

proc renderBackgroundGetClip*(context: ptr StyleContext00; x: cdouble; y: cdouble; 
    width: cdouble; height: cdouble; outClip: var gdk.Rectangle00) {.
    importc: "gtk_render_background_get_clip", libprag.}

proc gtk_render_check*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc: "gtk_render_check", libprag.}

proc renderCheck*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_check(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_expander*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc: "gtk_render_expander", libprag.}

proc renderExpander*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_expander(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_extension*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType) {.
    importc: "gtk_render_extension", libprag.}

proc renderExtension*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType) =
  gtk_render_extension(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height, gapSide)

proc gtk_render_focus*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc: "gtk_render_focus", libprag.}

proc renderFocus*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_focus(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_frame*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc: "gtk_render_frame", libprag.}

proc renderFrame*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_frame(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_frame_gap*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType; xy0Gap: cdouble; 
    xy1Gap: cdouble) {.
    importc: "gtk_render_frame_gap", libprag.}

proc renderFrameGap*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType; xy0Gap: cdouble; xy1Gap: cdouble) =
  gtk_render_frame_gap(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height, gapSide, xy0Gap, xy1Gap)

proc gtk_render_handle*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc: "gtk_render_handle", libprag.}

proc renderHandle*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_handle(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_icon*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    pixbuf: ptr gdkpixbuf.Pixbuf00; x: cdouble; y: cdouble) {.
    importc: "gtk_render_icon", libprag.}

proc renderIcon*(context: StyleContext; cr: cairo.Context; pixbuf: gdkpixbuf.Pixbuf; 
    x: cdouble; y: cdouble) =
  gtk_render_icon(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl), x, y)

proc gtk_render_icon_pixbuf*(context: ptr StyleContext00; source: ptr IconSource00; 
    size: int32): ptr gdkpixbuf.Pixbuf00 {.
    importc: "gtk_render_icon_pixbuf", libprag.}

proc renderIconPixbuf*(context: StyleContext; source: IconSource; size: int): gdkpixbuf.Pixbuf =
  let gobj = gtk_render_icon_pixbuf(cast[ptr StyleContext00](context.impl), cast[ptr IconSource00](source.impl), int32(size))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[gdkpixbuf.Pixbuf](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_render_icon_surface*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    surface: ptr cairo.Surface00; x: cdouble; y: cdouble) {.
    importc: "gtk_render_icon_surface", libprag.}

proc renderIconSurface*(context: StyleContext; cr: cairo.Context; surface: cairo.Surface; 
    x: cdouble; y: cdouble) =
  gtk_render_icon_surface(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr cairo.Surface00](surface.impl), x, y)

proc gtk_render_insertion_cursor*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; layout: ptr pango.Layout00; index: int32; direction: pango.Direction) {.
    importc: "gtk_render_insertion_cursor", libprag.}

proc renderInsertionCursor*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; layout: pango.Layout; index: int; direction: pango.Direction) =
  gtk_render_insertion_cursor(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, cast[ptr pango.Layout00](layout.impl), int32(index), direction)

proc gtk_render_layout*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; layout: ptr pango.Layout00) {.
    importc: "gtk_render_layout", libprag.}

proc renderLayout*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; layout: pango.Layout) =
  gtk_render_layout(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, cast[ptr pango.Layout00](layout.impl))

proc gtk_render_line*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble) {.
    importc: "gtk_render_line", libprag.}

proc renderLine*(context: StyleContext; cr: cairo.Context; x0: cdouble; 
    y0: cdouble; x1: cdouble; y1: cdouble) =
  gtk_render_line(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x0, y0, x1, y1)

proc gtk_render_option*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc: "gtk_render_option", libprag.}

proc renderOption*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_option(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_slider*(context: ptr StyleContext00; cr: ptr cairo.Context00; 
    x: cdouble; y: cdouble; width: cdouble; height: cdouble; orientation: Orientation) {.
    importc: "gtk_render_slider", libprag.}

proc renderSlider*(context: StyleContext; cr: cairo.Context; x: cdouble; 
    y: cdouble; width: cdouble; height: cdouble; orientation: Orientation) =
  gtk_render_slider(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height, orientation)

proc gtk_rgb_to_hsv*(r: cdouble; g: cdouble; b: cdouble; h: var cdouble; 
    s: var cdouble; v: var cdouble) {.
    importc: "gtk_rgb_to_hsv", libprag.}

proc rgbToHsv*(r: cdouble; g: cdouble; b: cdouble; h: var cdouble; 
    s: var cdouble; v: var cdouble) {.
    importc: "gtk_rgb_to_hsv", libprag.}

proc gtk_selection_add_target*(widget: ptr Widget00; selection: ptr gdk.Atom00; target: ptr gdk.Atom00; 
    info: uint32) {.
    importc: "gtk_selection_add_target", libprag.}

proc selectionAddTarget*(widget: Widget; selection: gdk.Atom; target: gdk.Atom; 
    info: int) =
  gtk_selection_add_target(cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), cast[ptr gdk.Atom00](target.impl), uint32(info))

proc gtk_selection_add_targets*(widget: ptr Widget00; selection: ptr gdk.Atom00; targets: TargetEntry00Array; 
    ntargets: uint32) {.
    importc: "gtk_selection_add_targets", libprag.}

proc selectionAddTargets*(widget: Widget; selection: gdk.Atom; targets: TargetEntry00Array; 
    ntargets: int) =
  gtk_selection_add_targets(cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), targets, uint32(ntargets))

proc gtk_selection_clear_targets*(widget: ptr Widget00; selection: ptr gdk.Atom00) {.
    importc: "gtk_selection_clear_targets", libprag.}

proc selectionClearTargets*(widget: Widget; selection: gdk.Atom) =
  gtk_selection_clear_targets(cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl))

proc gtk_selection_convert*(widget: ptr Widget00; selection: ptr gdk.Atom00; target: ptr gdk.Atom00; 
    time: uint32): gboolean {.
    importc: "gtk_selection_convert", libprag.}

proc selectionConvert*(widget: Widget; selection: gdk.Atom; target: gdk.Atom; 
    time: int): bool =
  toBool(gtk_selection_convert(cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), cast[ptr gdk.Atom00](target.impl), uint32(time)))

proc gtk_selection_owner_set*(widget: ptr Widget00; selection: ptr gdk.Atom00; time: uint32): gboolean {.
    importc: "gtk_selection_owner_set", libprag.}

proc selectionOwnerSet*(widget: Widget; selection: gdk.Atom; time: int): bool =
  toBool(gtk_selection_owner_set(cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), uint32(time)))

proc gtk_selection_owner_set_for_display*(display: ptr gdk.Display00; widget: ptr Widget00; 
    selection: ptr gdk.Atom00; time: uint32): gboolean {.
    importc: "gtk_selection_owner_set_for_display", libprag.}

proc selectionOwnerSetForDisplay*(display: gdk.Display; widget: Widget; selection: gdk.Atom; 
    time: int): bool =
  toBool(gtk_selection_owner_set_for_display(cast[ptr gdk.Display00](display.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), uint32(time)))

proc gtk_selection_remove_all*(widget: ptr Widget00) {.
    importc: "gtk_selection_remove_all", libprag.}

proc selectionRemoveAll*(widget: Widget) =
  gtk_selection_remove_all(cast[ptr Widget00](widget.impl))

proc gtk_set_debug_flags*(flags: uint32) {.
    importc: "gtk_set_debug_flags", libprag.}

proc setDebugFlags*(flags: uint32) {.
    importc: "gtk_set_debug_flags", libprag.}

proc `debugFlags=`*(flags: uint32) {.
    importc: "gtk_set_debug_flags", libprag.}

proc gtk_show_uri*(screen: ptr gdk.Screen00; uri: cstring; timestamp: uint32): gboolean {.
    importc: "gtk_show_uri", libprag.}

proc showUri*(screen: gdk.Screen; uri: string; timestamp: int): bool =
  toBool(gtk_show_uri(cast[ptr gdk.Screen00](screen.impl), cstring(uri), uint32(timestamp)))

proc gtk_show_uri_on_window*(parent: ptr Window00; uri: cstring; timestamp: uint32): gboolean {.
    importc: "gtk_show_uri_on_window", libprag.}

proc showUriOnWindow*(parent: Window; uri: string; timestamp: int): bool =
  toBool(gtk_show_uri_on_window(cast[ptr Window00](parent.impl), cstring(uri), uint32(timestamp)))

proc gtk_stock_add*(items: StockItem00Array; nItems: uint32) {.
    importc: "gtk_stock_add", libprag.}

proc stockAdd*(items: StockItem00Array; nItems: uint32) {.
    importc: "gtk_stock_add", libprag.}

proc gtk_stock_add_static*(items: StockItem00Array; nItems: uint32) {.
    importc: "gtk_stock_add_static", libprag.}

proc stockAddStatic*(items: StockItem00Array; nItems: uint32) {.
    importc: "gtk_stock_add_static", libprag.}

proc gtk_stock_list_ids*(): ptr pointer {.
    importc: "gtk_stock_list_ids", libprag.}

proc stockListIds*(): ptr pointer {.
    importc: "gtk_stock_list_ids", libprag.}

proc gtk_stock_lookup*(stockId: cstring; item: var StockItem00): gboolean {.
    importc: "gtk_stock_lookup", libprag.}

proc stockLookup*(stockId: cstring; item: var StockItem00): gboolean {.
    importc: "gtk_stock_lookup", libprag.}

proc gtk_stock_set_translate_func*(domain: cstring; `func`: TranslateFunc; data: pointer; 
    notify: DestroyNotify) {.
    importc: "gtk_stock_set_translate_func", libprag.}

proc stockSetTranslateFunc*(domain: cstring; `func`: TranslateFunc; data: pointer; 
    notify: DestroyNotify) {.
    importc: "gtk_stock_set_translate_func", libprag.}

proc gtk_target_table_free*(targets: TargetEntry00Array; nTargets: int32) {.
    importc: "gtk_target_table_free", libprag.}

proc targetTableFree*(targets: TargetEntry00Array; nTargets: int32) {.
    importc: "gtk_target_table_free", libprag.}

proc gtk_target_table_new_from_list*(list: ptr TargetList00; nTargets: var int32): TargetEntry00Array {.
    importc: "gtk_target_table_new_from_list", libprag.}

proc targetTableNewFromList*(list: TargetList; nTargets: var int): TargetEntry00Array =
  var nTargets_00 = int32(nTargets)
  result = gtk_target_table_new_from_list(cast[ptr TargetList00](list.impl), nTargets_00)
  nTargets = int(nTargets_00)

proc gtk_targets_include_image*(targets: ptr gdk.Atom00Array; nTargets: int32; writable: gboolean): gboolean {.
    importc: "gtk_targets_include_image", libprag.}

proc targetsIncludeImage*(targets: ptr gdk.Atom00Array; nTargets: int32; writable: gboolean): gboolean {.
    importc: "gtk_targets_include_image", libprag.}

proc gtk_targets_include_rich_text*(targets: ptr gdk.Atom00Array; nTargets: int32; buffer: ptr TextBuffer00): gboolean {.
    importc: "gtk_targets_include_rich_text", libprag.}

proc targetsIncludeRichText*(targets: ptr gdk.Atom00Array; nTargets: int; buffer: TextBuffer): bool =
  toBool(gtk_targets_include_rich_text(targets, int32(nTargets), cast[ptr TextBuffer00](buffer.impl)))

proc gtk_targets_include_text*(targets: ptr gdk.Atom00Array; nTargets: int32): gboolean {.
    importc: "gtk_targets_include_text", libprag.}

proc targetsIncludeText*(targets: ptr gdk.Atom00Array; nTargets: int32): gboolean {.
    importc: "gtk_targets_include_text", libprag.}

proc gtk_targets_include_uri*(targets: ptr gdk.Atom00Array; nTargets: int32): gboolean {.
    importc: "gtk_targets_include_uri", libprag.}

proc targetsIncludeUri*(targets: ptr gdk.Atom00Array; nTargets: int32): gboolean {.
    importc: "gtk_targets_include_uri", libprag.}

proc gtk_test_create_simple_window*(windowTitle: cstring; dialogText: cstring): ptr Widget00 {.
    importc: "gtk_test_create_simple_window", libprag.}

proc testCreateSimpleWindow*(windowTitle: string; dialogText: string): Widget =
  let gobj = gtk_test_create_simple_window(cstring(windowTitle), cstring(dialogText))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_test_find_label*(widget: ptr Widget00; labelPattern: cstring): ptr Widget00 {.
    importc: "gtk_test_find_label", libprag.}

proc testFindLabel*(widget: Widget; labelPattern: string): Widget =
  let gobj = gtk_test_find_label(cast[ptr Widget00](widget.impl), cstring(labelPattern))
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_test_find_sibling*(baseWidget: ptr Widget00; widgetType: GType): ptr Widget00 {.
    importc: "gtk_test_find_sibling", libprag.}

proc testFindSibling*(baseWidget: Widget; widgetType: GType): Widget =
  let gobj = gtk_test_find_sibling(cast[ptr Widget00](baseWidget.impl), widgetType)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_test_find_widget*(widget: ptr Widget00; labelPattern: cstring; widgetType: GType): ptr Widget00 {.
    importc: "gtk_test_find_widget", libprag.}

proc testFindWidget*(widget: Widget; labelPattern: string; widgetType: GType): Widget =
  let gobj = gtk_test_find_widget(cast[ptr Widget00](widget.impl), cstring(labelPattern), widgetType)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[Widget](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    new(result, finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_test_list_all_types*(nTypes: var uint32): GTypeArray {.
    importc: "gtk_test_list_all_types", libprag.}

proc testListAllTypes*(nTypes: var uint32): GTypeArray {.
    importc: "gtk_test_list_all_types", libprag.}

proc gtk_test_register_all_types*() {.
    importc: "gtk_test_register_all_types", libprag.}

proc testRegisterAllTypes*() {.
    importc: "gtk_test_register_all_types", libprag.}

proc gtk_test_slider_get_value*(widget: ptr Widget00): cdouble {.
    importc: "gtk_test_slider_get_value", libprag.}

proc testSliderGetValue*(widget: Widget): cdouble =
  gtk_test_slider_get_value(cast[ptr Widget00](widget.impl))

proc gtk_test_slider_set_perc*(widget: ptr Widget00; percentage: cdouble) {.
    importc: "gtk_test_slider_set_perc", libprag.}

proc testSliderSetPerc*(widget: Widget; percentage: cdouble) =
  gtk_test_slider_set_perc(cast[ptr Widget00](widget.impl), percentage)

proc gtk_test_spin_button_click*(spinner: ptr SpinButton00; button: uint32; upwards: gboolean): gboolean {.
    importc: "gtk_test_spin_button_click", libprag.}

proc testSpinButtonClick*(spinner: SpinButton; button: int; upwards: bool): bool =
  toBool(gtk_test_spin_button_click(cast[ptr SpinButton00](spinner.impl), uint32(button), gboolean(upwards)))

proc gtk_test_text_get*(widget: ptr Widget00): cstring {.
    importc: "gtk_test_text_get", libprag.}

proc testTextGet*(widget: Widget): string =
  let resul0 = gtk_test_text_get(cast[ptr Widget00](widget.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_test_text_set*(widget: ptr Widget00; string: cstring) {.
    importc: "gtk_test_text_set", libprag.}

proc testTextSet*(widget: Widget; string: string) =
  gtk_test_text_set(cast[ptr Widget00](widget.impl), cstring(string))

proc gtk_test_widget_click*(widget: ptr Widget00; button: uint32; modifiers: gdk.ModifierType): gboolean {.
    importc: "gtk_test_widget_click", libprag.}

proc testWidgetClick*(widget: Widget; button: int; modifiers: gdk.ModifierType): bool =
  toBool(gtk_test_widget_click(cast[ptr Widget00](widget.impl), uint32(button), modifiers))

proc gtk_test_widget_send_key*(widget: ptr Widget00; keyval: uint32; modifiers: gdk.ModifierType): gboolean {.
    importc: "gtk_test_widget_send_key", libprag.}

proc testWidgetSendKey*(widget: Widget; keyval: int; modifiers: gdk.ModifierType): bool =
  toBool(gtk_test_widget_send_key(cast[ptr Widget00](widget.impl), uint32(keyval), modifiers))

proc gtk_test_widget_wait_for_draw*(widget: ptr Widget00) {.
    importc: "gtk_test_widget_wait_for_draw", libprag.}

proc testWidgetWaitForDraw*(widget: Widget) =
  gtk_test_widget_wait_for_draw(cast[ptr Widget00](widget.impl))

proc gtk_tree_get_row_drag_data*(selectionData: ptr SelectionData00; treeModel: var ptr TreeModel00; 
    path: var ptr TreePath00): gboolean {.
    importc: "gtk_tree_get_row_drag_data", libprag.}

proc treeGetRowDragData*(selectionData: ptr SelectionData00; treeModel: var ptr TreeModel00; 
    path: var ptr TreePath00): gboolean {.
    importc: "gtk_tree_get_row_drag_data", libprag.}

proc gtk_tree_set_row_drag_data*(selectionData: ptr SelectionData00; treeModel: ptr TreeModel00; 
    path: ptr TreePath00): gboolean {.
    importc: "gtk_tree_set_row_drag_data", libprag.}

proc treeSetRowDragData*(selectionData: SelectionData; treeModel: TreeModel; 
    path: TreePath): bool =
  toBool(gtk_tree_set_row_drag_data(cast[ptr SelectionData00](selectionData.impl), cast[ptr TreeModel00](treeModel.impl), cast[ptr TreePath00](path.impl)))

proc gtk_true*(): gboolean {.
    importc: "gtk_true", libprag.}

proc true*(): gboolean {.
    importc: "gtk_true", libprag.}
# === remaining symbols:

proc init* = 
  init(0, nil)

import macros, strutils

var ProcID: int

macro mconnect(widget: gobject.Object; signal: string; p: untyped; arg: typed; widgett: typedesc; argt: typedesc): typed =
  inc(ProcID)
  let wt = getType(widgett)[1] # widget type
  let at = getType(argt)[1] # argument type
  let signalName = ($signal).replace("-", "_") # maybe we should just use plain proc names
  let procNameCdecl = newIdentNode("connect_for_signal_cdecl_" & signalName & $ProcID)
  let procName = newIdentNode("connect_for_signal_" & signalName & $ProcID)
  let scName = newIdentNode("sc" & signalName)
  result = quote do:
    proc `procNameCdecl`(w: ptr gobject.Object00 , data: pointer) {.cdecl.} =
      var h: pointer = g_object_get_qdata(w, Quark)
      `p`(cast[`wt`](h), cast[`at`](data))

    proc `procName`(self:  `wt`;  p: proc (self: `wt`, arg: `at`); a: `at`) =
      var ar: ref `at`
      new(ar)
      deepCopy(ar[], a)
      GC_ref(ar)
      `scName`(self, `procNameCdecl`, cast[pointer](ar[]))
    `procName`(`widget`, `p`, `arg`)

template connect*(widget: gobject.Object; signal: string; p: untyped; arg: typed) =
  mconnect(widget, signal, p, arg, type(widget), type(arg))

macro mconnect(widget: gobject.Object; signal: string; p: untyped; widgett: typedesc): typed =
  inc(ProcID)
  let wt = getType(widgett)[1]
  let signalName = ($signal).replace("-", "_") 
  let procNameCdecl = newIdentNode("connect_for_signal_cdecl_" & signalName & $ProcID)
  let procName = newIdentNode("connect_for_signal_" & signalName & $ProcID)
  let scName = newIdentNode("sc" & signalName)
  result = quote do:
    proc `procNameCdecl`(w: ptr gobject.Object00 , data: pointer) {.cdecl.} =
      var h: pointer = g_object_get_qdata(w, Quark)
      `p`(cast[`wt`](h))

    proc `procName`(self:  `wt`;  p: proc (self: `wt`)) =
      `scName`(self, `procNameCdecl`, nil)
    `procName`(`widget`, `p`)

template connect*(widget: gobject.Object; signal: string; p: untyped) =
  mconnect(widget, signal, p, type(widget))

